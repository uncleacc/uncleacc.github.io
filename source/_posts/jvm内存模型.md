---
title: jvm内存模型
cover: 'https://cdn.jsdelivr.net/gh/uncleacc/Img2/129.webp'
mathjax: true
tags: JVM内存模型
categories: 记录
abbrlink: 340c83dd
keywords: JVM内存模型
description: JVM内存模型笔记
date: 2024-09-19 21:36:28
updated:
comments:
highlight_shrink:
---

> 原文链接：https://blog.csdn.net/m0_71777195/article/details/126247090

jvm内存模型如下图所示：

**线程共有**：堆和方法区

**线程私有**：虚拟机栈、本地方法栈和程序计数器

![jvm内存模型](https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240919213836852.png)

# 堆

在 Java 中，堆被划分成两个不同的区域：新生代 ( Young )、老年代 ( Old )，新生代 ( Young ) 又被划分为三个区域：Eden、From Survivor、To Survivor。

下图中的Perm代表的是永久代，但是注意永久代并不属于堆内存中的一部分，同时jdk1.8之后永久代也将被移除。

> 注意：虽然永久代不是堆内存的一部分，但这是从逻辑上讲的，永久代使用的内存空间依旧是堆提供的，只是我们通常讲的堆是用来存放新生对象的区域，而永久代是方法区的实现方式，方法区中存放的有类的元数据信息、常量池、静态变量等。

![堆空间](https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/b8e5f06c68cf5efcebfdcb4806f9a963.png)

堆是java虚拟机所管理的内存中最大的一块内存区域，也是被各个线程共享的内存区域，该内存区域存放了对象实例及数组（但不是所有的对象实例都在堆中）。

其大小通过-Xms(最小值)和-Xmx(最大值)参数设置（最大最小值都要小于1G），前者为启动时申请的最小内存，默认为操作系统物理内存的1/64，后者为JVM可申请的最大内存,默认为物理内存的1/4，默认当空余堆内存小于40%时，JVM会增大堆内存到-Xmx指定的大小，可通过-XX:MinHeapFreeRation=来指定这个比列。

当空余堆内存大于70%时，JVM会减小堆内存的大小到-Xms指定的大小，可通过XX:MaxHeapFreeRation=来指定这个比列，当然为了避免在运行时频繁调整Heap的大小，通常-Xms与-Xmx的值设成一样。堆内存 = 新生代+老生代+持久代。

在我们垃圾回收的时候，我们往往将堆内存分成新生代和老生代（大小比例1：2），新生代中由Eden和Survivor0，Survivor1组成，三者的比例是8：1：1，新生代的回收机制采用复制算法，在Minor GC的时候，我们都留一个存活区用来存放存活的对象，真正进行的区域是Eden+其中一个存活区，当我们的对象时长超过一定年龄时（默认15，可以通过参数设置），将会把对象放入老生代，当然大的对象会直接进入老生代，老生代采用的回收算法是标记整理算法。

# 方法区

其实方法区是在JDK1.8以前的版本里存在的一块内存区域，主要就是存放从class文件里加载进来的类的，而且常量池也是在这块区域内的。

但是在JDK1.8之后，这块区域摇身一变，换了名字，叫做“Metaspace”，翻译过来就是“元数据空间”的意思，当然它只是改了个名，实现的功能是没变的。

方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。

![方法区域存放内容集合](https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/7b5bd84a08eac6ae19c85f0c981ef3aa.png)

1. 类型信息

   对每个加载的类型（类class、接口interface、枚举enum、注解annotation),JVM必须在方法区中存储以下类型信息:

   1. 这个类型的完整有效名称（全名=包名.类名)

   1. 这个类型直接父类的完整有效名(对于interface或是java.lang.0bject，都没有父类)

   1. 这个类型的修饰符(public, abstract,final的某个子集)


   1. 这个类型直接接口的一个有序列表


2. 域信息(Field)成员变量

JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。

域的相关信息包括:域名称、域类型、域修饰符(public, private,protected,static,final, volatile, transient的某个子集)

3. 方法(Method)信息

JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序:

- 方法名称
- 方法的返回类型(或void)·方法参数的数量和类型(按顺序)
- 方法的修饰符(public, private,protected,static, final,synchronized,native,abstract的一个子集)
- 方法的字节码(bytecodes)、操作数栈、局部变量表及大小(abstract和native方法除外)

# 虚拟机栈(JVM Stack)

虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈，每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用。

虚拟机栈的作用：主管Java程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。

每个方法被执行的时候都会创建一个”栈帧”,用于存储局部变量表(包括参数)、操作栈、方法出口等信息。

每个方法被调用到执行完的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

栈帧（Stack Frame） 是用于虚拟机执行时方法调用和方法执行时的数据结构，它是虚拟栈的基本元素，栈帧由局部变量区、操作数栈等组成，如下图所示：

![虚拟机栈](https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/e7a851f1896ea19949fb7b1bd136614a.png)

每一个方法从调用到方法返回都对应着一个栈帧入栈出栈的过程。最顶部的栈帧称为当前栈帧，栈帧所关联的方法称为当前方法，定义这个方法的类称为当前类，该线程中，虚拟机有且也只会对当前栈帧进行操作。

栈帧的作用有存储数据，部分过程结果，处理动态链接，方法返回值和异常分派。

每一个栈帧包含的内容有局部变量表、操作数栈、动态链接、方法返回地址和一些额外的附加信息。在编译代码时，栈帧需要多大的局部变量表，多深的操作数栈都可以完全确定的，并写入到方法表的code属性中。

# 本地方法栈(Native Stack)

本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java 方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native 方法服务。

虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。

甚至有的虚拟机（譬如Sun HotSpot 虚拟机）直接就把本地方法栈和虚拟机栈合二为一。

与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError 和OutOfMemoryError异常。

# 程序计数器（PC Register）

在JVM的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。

分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。

JVM的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，为了各条线程之间的切换后计数器能恢复到正确的执行位置，所以每条线程都会有一个独立的程序计数器。

当线程正在执行一个Java方法，程序计数器记录的是正在执行的JVM字节码指令的地址；如果正在执行的是一个Natvie（本地方法），那么这个计数器的值则为空（Underfined）。

程序计数器占用的内存空间很少，也是唯一一个在JVM规范中没有规定任何OutOfMemoryError（内存不足错误）的区域。

