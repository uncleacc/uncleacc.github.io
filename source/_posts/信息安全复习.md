---
title: 信息安全复习
cover: 'https://cdn.jsdelivr.net/gh/uncleacc/Img2/110.webp'
mathjax: true
tags: 信息安全
categories: 记录
abbrlink: 662ab05b
keywords: 信息安全
description: 信息安全课程复习记录
comments: true
date: 2024-07-07 15:19:22
updated:
highlight_shrink:
---



> 本文记录了博主复习信息安全课程的一些资料，抛出了一些问题，并给出回答



# Q1：三种安全目标的定义及其对应的攻击类型？

**保密性：**确保信息仅对授权用户可见和访问，防止未经授权的访问和泄露。

**完整性：**确保信息在传输、存储和处理过程中不被未经授权的修改或破坏。

**可用性：**确保信息和系统在需要时可以被合法用户访问和使用。



![image-20240707152354261](https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707152354261.png)

**攻击类型：**

**窃听**：窥探是指未经授权访问或拦截数据。

**流量分析**：通过监测在线流量获得一些其他类型的信息

 

**篡改：**篡改是指未经授权的修改数据。

**伪装：**指攻击者假冒合法用户的身份，以进行未经授权的操作。

**重放**：攻击者截获信息并再次发送。尽管数据本身是合法的，但重复使用会导致未授权的操作。

**否认**：由通信双方中的一方执行：发送方或接收方。 信息的发送者后来可能会否认她发送了该信息；信息的接收者后来可能会否认他收到了该信息。

 

**拒绝服务（DoS）**：它可能减慢或完全中断系统的服务。攻击者可以使用几种策略来实现这一目标。她可能会向一个服务器发送大量的虚假请求，以至于服务器因负载过重而崩溃。

# Q2：如何辨别主动攻击和被动攻击，并列举出几种具体的例子？

**被动攻击**：攻击者的目标只是为了获取信息，威胁机密性目标，但不修改信息，因此这种攻击的检查比较困难，可通过信息加密防止被动攻击。

**主动攻击：**可能改变数据或损害系统。主动攻击可能会改变信息或损害系统，威胁完整性和可用性目标，但比较容易检测和防护。

 ![image-20240707152603258](https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707152603258.png)                              



# Q3：解释现代加密系统的基本原则-Kerckhoff原理

基于**Kerckhoff**的原则**，我们应该始终假设对手知道加密/解密算法。 密码对攻击的抵抗力必须**只基于密钥的保密性。换句话说，猜测钥匙应该是非常困难的，以至于没有必要隐藏加密/解密算法。 



# Q4：解释四种密码分析类型

### 仅限密码文本

假设夏娃知道该算法并能截获密码文本。

 ![image-20240707152737032](https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707152737032.png)

**类型：**

**蛮力攻击：**试图使用所有可能的密钥

**统计攻击：**利用语言的特点，即e是最常见的字母。

**模式攻击：**在密码文本中寻找模式

 

### 已知明文攻击

明文/密文对已在前面收集。 

**例如**，爱丽丝向鲍勃发送了一条秘密信息，但她后来公开了信息的内容。夏娃同时保留了密码文本和明文，以使用它们来破解爱丽丝发给鲍勃的下一个秘密信息，**假设爱丽丝没有改变她的密钥**。夏娃**利用前一对之间的关系来分析当前的密码文本。**在这里可以应用在仅有密码文本的攻击中使用的相同方法。

这种攻击更容易实现，因为Eve**有更多的信息**可用于分析。然而，它不太可能发生，因为爱丽丝可能已经改变了她的密钥或可能没有披露任何以前的信息内容。

 ![image-20240707152751457](https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707152751457.png)

 

### 选择明文攻击（chosen-plaintext attack）

选择的明文攻击与已知明文攻击类似，但明文/密码文本对是由攻击者自己选择的。 

 ![image-20240707152812598](https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707152812598.png)

例如，如果**Eve**能够进入Alice的电脑，**这就可能发生。**她可以选择一些明文并截获创建的密码文本。当然，她没有钥匙，因为钥匙通常被嵌入发件人使用的软件中。这种类型的攻击更容易实现，但发生的可能性更小。

### 选定密文攻击

 选择的密文攻击与选择的明文攻击类似，只是夏娃选择一些密文并解密，形成一对密文明文。如果夏娃能够访问鲍勃的计算机，这就可能发生。 

![image-20240707152819900](https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707152819900.png)

# Q5：经典代换密码算法的基本原理

**替换式密码是用一个符号替换另一个符号。**

替换密码可分为**单字母**密码和**多字母**密码。

### 单字母替代

在单字母替换中，明文中的一个符号与密码文中的一个符号之间的关系总是一对一的。

![image-20240707153135529](https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707153135529.png)

#### 加法密码

为每个字母分配数值（小写或大写）。

 ![image-20240707153147718](https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707153147718.png)

密码分析：加法密码容易受到使用详尽密钥的仅有密码文本的攻击。搜索（暴力攻击）。加法密码的密钥域非常小；只有26把钥匙。然而，其中的一个密钥，即零，是无用的（密码文本是  与明文相同）。这就只剩下25个可能的密钥。

#### 乘法密码

![image-20240707153301933](https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707153301933.png)

 

#### Affine Cipher（仿射密码）

我们可以将加法密码和乘法密码结合起来，得到所谓的 "阿凡提密码"，这是两种密码与一对钥匙的结合。**第一把钥匙用于乘法密码；第二把钥匙用于加法密码。**

 ![image-20240707153322572](https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707153322572.png)

### 多字母密码器

在多字母替换中，一个字符的每一次出现都可能有不同的替换。明文中的一个字符与密文中的一个字符之间的关系是**一对多的。** 

为了创建一个多字母密码，我们需要使每个密码文本字符同时依赖于**相应的明文字符**和**明文字符**在信息中的**位置。** 因此，关键在**关键流的形式。**

#### Autokey Cipher

 ![image-20240707153329014](https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707153329014.png)

#### Vigenere Cipher（维吉尼亚）

 ![image-20240707153406911](https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707153406911.png)

![image-20240707153417054](https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707153417054.png)

 Vigenere密码使用一种不同的策略来创建密钥流。**密钥流**是一个长度为m的初始秘密密钥流的重复，其中我们有1≤m≤26**。**该密码可以描述如下 其中(k1, k 2, ..., km)是Alice和Bob同意的初始秘钥。  

 Vigenere密钥流不依赖于明文字符

#### Hill Cipher（希尔密码）

明文被划分为同等大小的块。这些区块以这样一种方式被逐一加密，即**区块中的每个字符都有助于对区块中的其他字符进行加密。**

![image-20240707153440386](https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707153440386.png)

#  Q6：关于P盒、S盒的计算问题

**P盒**是一个换位单元(transposition unit)。三种类型的P盒：**直P盒、扩展P盒和压缩P盒**。

**Straight P-boxes**：n位输入映射n位输出，输出结果共有n！中可能性，最终根据P-boxes的设定规则输出其中一种。

**压缩P-boxes**：n位输入映射m位输出，其中m﹤n。m位的输出指n位输入(1~n)中有若干位丢失的结果。压缩P-boxes用于我们需要排列n位结果并且在下一阶段减少位数的情况中。

**expansion P-boxes**：n位输入映射m位输出，其中m＞n。m位的输出指n位输入(1~n)中有若干位重复出现的结果。expansion P-boxes 用于我们需要排列n位结果并且在下一阶段增加位数的情况中。

**S盒**是一个换字单元(substitution unit)。两种类型的S-boxes：**linear S-box**和**nonlinear S-box**。S-box有n位输入(X0,X1,...,Xn)映射m位输出(Y1,Y2,...,Ym)，n和m的值不需要相同。

linear S-box中输入与输出的关系：

Y1 = a1,1x1⊕a1,2x2⊕...⊕a1,nxn

Y2 = a2,1x1⊕a2,2x2⊕...⊕a2,nxn

Yn = an,1x1⊕an,2x2⊕...⊕an,nxn

其中ai,j属于矩阵Amxn

nonlinear S-box中输入的n位与m位输出之间通过非线性函数计算得到。

#  Q7：混淆和扩散

扩散和混乱是由Shannon提出的设计密码系统的两个基本方法，目的是抵抗攻击者对密码的统计分析。

**扩散：**扩散(diffusion)是为了隐藏明文和密文之间的联系，将明文的统计特性散布到密文中去。

**混淆：**混淆(Confusion)是为了隐藏密文和密钥之间的联系，使密文和密钥之间的统计关系变得尽可能复杂。

![image-20240707153651661](https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707153651661.png)        

# Q8：简单的差分分析原理

![image-20240707153723330](https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707153723330.png)

# Q9：关于LFSR的计算问题

![image-20240707153801795](https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707153801795.png)

![image-20240707153807215](https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707153807215.png)

# Q10：DES算法每轮由哪几部分组成

1.首先把明文分成若干个64-bit的分组，算法以一个分组作为输入，通过一个初始置换（IP）将明文分组分成左半部分（L0）和右半部分（R0），各为32-bit。

2.然后进行16轮完全相同的运算，这些运算我们称为函数f，在运算过程中数据与密钥相结合。

3.经过16轮运算后，左、右两部分合在一起经过一个末转换（初始转换的逆置换IP-1），输出一个64-bit的密文分组。

**Feistel**密码：

![image-20240707153835398](https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707153835398.png)

DES的每一轮都是一个Feistel密码，如图6.4所示。

![image-20240707153846103](https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707153846103.png)

![image-20240707153855056](https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707153855056.png)

# Q11：双重DES和中途相遇攻击

**双重DES**：使用两个加密秘钥，用第一个加密秘钥加密后，再用另一个秘钥进行二次加密，解密则先用第二次加密的秘钥解密，然后再用第一次加密的秘钥进行解密。密钥复杂度由2^56 增加到2^112

**中途相遇攻击：**尝试密钥一个加密一个解密，结果相同即为正确密钥，强度降为2^57。

# Q12：电子密码本（Electronic Codebook, ECB）模式

![image-20240707154000342](https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707154000342.png)

# Q13：CBC（密码块链（CBC）模式）

在CBC模式下，每个明文块在被加密前都会与前一个密码块进行排他性交换。

当一个区块被加密后，该区块被发送，但它的一个副本被保存在内存中，用于下一个区块的加密。

![image-20240707154021385](https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707154021385.png)

**误差传播**：在CBC模式下，传输过程中密码文本块Cj的一个比特错误可能会在解密过程中在**明文块**Pj的大多数比特中产生错误。然而，这个单一的错误只在明文块Pj+1中切换一个位（同一位置的位）。这一事实的证明留作练习。明文块Pj+2至PN不受这个单一比特错误的影响。密码文本中的单比特错误是可以自我恢复的。

# Q14：为什么需要操作模式

DES加密的分组大小为64，而在实际应用中要加密的文本大小是可变的，通常都要远远大于由现代分组密码确定的分组大小。操作模式就是设计用来对现代分组密码的任意大小的文本进行加密。

# Q15：CFB和OFB模式的定义式，它们分别创建的是一个同步还是非同步流密码

同步流密码（Synchronous Stream Cipher）是指在加密和解密过程中，密钥流的生成仅依赖于密钥和初始化向量（IV），与明文和密文无关。加密和解密双方独立生成相同的密钥流，并将其与明文或密文进行异或操作。

**非同步**流密码，其中的密钥流取决于密码文本。 

## 密码反馈CFB

![image-20240707154205639](https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707154205639.png)

## 输出反馈OFB

![image-20240707154228251](https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707154228251.png)

# Q16：cfb和ofb模式的基本原理，并分析它们各自的错误传播性能

在CFB中，传输过程中密文块Cj的一个比特错误会在明文块Pj中产生一个比特错误（在同一位置）。然而，只要Cj的一些位仍在移位寄存器中，下面的明文块中的大多数位都有错误。 

在OFB中，**密码文本中的一个错误只影响到明文中的相应位。** 

# Q17：CTR模式的基本原理

在计数器（CTR）模式下，没有反馈。密钥流中的伪随机性是通过一个计数器实现的。

![image-20240707154341557](https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707154341557.png)

# Q18：RSA的原理和证明

![image-20240707154504381](https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707154504381.png)

![image-20240707154512783](https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707154512783.png)

![image-20240707154523627](https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707154523627.png)

# Q19：Hash函数的三个标准

一个加密哈希函数必须满足三个标准：**抗预象性、抗第二预象性**和**抗碰撞性**

**抗预象性：**加密哈希函数必须具有抗预像性。给定一个哈希函数h和y=h(M)，对于Eve来说，要找到任何消息M′，使y=h(M′)，一定是非常困难的。 

**第二个预像阻力**：如果Alice创建了一个信息和一个摘要，并将两者都发送给Bob，这个标准确保Eve不能轻易地创建另一个信息，而这个信息的摘要是完全相同的。换句话说，给定一个特定的信息和它的摘要，不可能（或至少非常困难）创造另一个具有相同摘要的信息。

**抗碰撞性：**确保Eve不能找到两个散列到相同摘要的信息。 

# Q20：RSA数字签名方案的原理

![image-20240707154741308](https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707154741308.png)

# Q21：分别用于数字签名和用于保障机密性时，私钥和公钥的区别

公钥是公开的，私钥是私有的，所以Alice给Bob发消息，就要用Bob公开的公钥来做加密，Bob再用自己的私钥进行解密即可。简单来说，公钥加密，私钥解密。

数字签名：数字签名刚好相反，比如大家想对Alice的签名进行验证，那么大家能获取的就是Alice公开的公钥，而签名则由Alice用自己的私钥进行签名。 简单来说，私钥签名，公钥验证。



## Q22：用数字签名提供不可否认性服务。

如何通过使用可信中心和签名来提供不可抵赖服务？

可以**使用受信任的一方**提供不可抵赖性。

人们可以在他们之间建立一个既定的可信方。在未来的章节中，我们将看到受信方可以解决许多其他有关安全服务和密钥交换的问题。图13.4显示了受信方如何防止Alice否认她发送了信息。

爱丽丝从她的信息中创建一个签名并将信息、她的身份、Bob的身份和签名发送到中心。中心在检查了Alice的公钥是否有效后，通过Alice的公钥验证了该消息来自Alice。然后，中心在其档案中保存了一份带有发件人身份、收件人身份和时间戳的信息副本。中心使用它的私钥从信息中创建另一个签名。然后中心将信息、新签名、Alice的身份和Bob的身份发送给Bob。Bob使用受信任的中心的公钥验证该消息。

![image-20240707154857307](https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707154857307.png)

如果将来Alice否认是她发送的信息，中心可以出示保存的信息的副本。如果鲍勃的信息与中心保存的信息是重复的，那么爱丽丝将失去争议。

# Q23：固定口令的一种方法--盐化口令方法

第三种方法被称为对密码加盐。**当密码字符串被创建时，一个随机字符串，称为盐，被连接到密码**。然后对加盐的密码进行哈希。然后，ID、盐和哈希值被存储在文件中。现在，当用户要求访问时，系统提取盐，将其与收到的密码连接起来，对结果进行哈希，并将其与存储在文件中的哈希进行比较。如果有匹配的，就允许访问；否则，就拒绝访问。

![image-20240707155005505](https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707155005505.png)

加盐使字典攻击更加困难。如果原始密码是6位数，盐是4位数，那么哈希就在10位数的数值上进行。这意味着，Eve现在需要做一个1000万个项目的列表，并为每个项目创建一个哈希值。哈希值的列表有1000万个条目，比较的时间要长得多。如果盐是一个很长的随机数，盐化是非常有效的。UNIX操作系统使用这种方法的一个变种。

# Q24：解释用Hash链实现一次性口令

![image-20240707155041742](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20240707155041742.png)

当系统收到用户在第三条信息中的响应时，它将哈希函数应用于收到的值，看它是否与存储在条目中的值相匹配。如果匹配，则允许访问；否则，拒绝访问。然后，系统将条目中的n值递减，并将密码的旧值替换为$h^{n-1}(P_0)$  . 

当用户试图第二次访问系统时，它收到的计数器的值是n-1，现在，该用户的第三条信息是$h^{n-2}(P_0)$ 。当系统收到这个消息时，它应用哈希函数得到$h^{n-1}(P_0)$，可以与更新的条目进行比较。

条目中n的值在每次访问时都会被递减。当该值变为0时，用户就不能再访问系统；一切都必须重新设置。由于这个原因，n的值通常被选为一个大数字，如1000。

# Q25：用对称密钥密码技术实现挑战-应答认证

第一种：在第一种方法中，验证者发送一个**nonce**，一个只使用一次的随机数，来质疑索赔者。一个nonce必须是时间变化的；每次它被创建时都是不同的。声明者使用声明者和验证者之间共享的秘密密钥对挑战作出回应。

![image-20240707155344383](https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707155344383.png)

第二种：在第二种方法中，时间变化的值是一个时间戳，它显然是随时间变化的。在这种方法中，挑战信息是由验证人向申请人发送的当前时间。然而，这假定客户端和服务器的时钟是同步的；申请人知道当前的时间。这意味着不需要挑战信息。三条信息可以合并。其结果是，可以使用一个消息进行认证，即对隐含挑战的响应，即当前时间。图14.6显示了这种方法。

![image-20240707155353089](https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707155353089.png)

第三种方法：第一种和第二种方法是用于单向认证。Alice对Bob进行了认证，但不是反过来。如果Alice也需要确定Bob的身份，我们需要双向认证。

![image-20240707155432397](https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707155432397.png)

# Q26：基于KDC实现对称密钥分配的协议过程

![image-20240707155502556](https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707155502556.png)

# Q27：Kerberos的操作过程

![image-20240707155537882](https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707155537882.png)

# Q28：Diffie-Hellman密钥协商协议的基本原理

![image-20240707155602124](https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707155602124.png)

# Q29：认证结构的基本原理

![image-20240707155633990](https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707155633990.png)

![image-20240707155640391](https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707155640391.png)



