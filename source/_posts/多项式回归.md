---
title: 回归问题
cover: 'https://cdn.jsdelivr.net/gh/uncleacc/Img2/108.webp'
mathjax: true
tags: 线性回归
categories: 算法
abbrlink: edb5b5ea
keywords: 线性回归、梯度下降、机器学习
description: 利用多项式拟合非线性函数：sin和cos
date: 2024-02-02 12:40:53
updated:
comments:
highlight_shrink:
---

> 线性回归就是多项式回归的一种特殊情况，在线性回归中只存在一次项，所以只能拟合直线，而多项式回归则存在高次项，可以拟合曲线。本文代码都是基于多项式回归的，所以w是一个向量，并且没有考虑多元函数的情况，只存在x和y两个变量

# 前言

机器学习中的线性回归是一种简单但强大的技术，其作用包括但不限于以下几个方面：

1. **预测：** 最常见的用途是用来预测目标变量的数值。通过学习输入特征和目标变量之间的线性关系，线性回归模型可以用来预测未知数据点的目标变量值。例如，根据房屋的面积、卧室数量等特征，预测房屋的售价。
2. **关联分析：** 可以用线性回归来分析输入特征与目标变量之间的关联程度。通过观察特征与目标变量之间的线性关系，可以识别出哪些特征对目标变量有显著影响，进而深入了解数据之间的关系。
3. **异常检测：** 通过观察模型的预测残差（实际值与预测值之间的差异），可以识别出可能是异常的数据点。这些异常点可能是数据采集或处理过程中的错误，或者是真实世界中的特殊情况，值得进一步调查。
4. **特征工程：** 线性回归可以用来评估特征的重要性和影响程度。基于模型的系数（权重），可以识别出哪些特征对目标变量的影响最大，从而指导特征选择和特征工程的过程。
5. **解释性：** 线性回归模型具有很强的解释性，模型的系数可以直观地解释特征对目标变量的影响程度。这使得线性回归在决策支持系统和业务解释性要求较高的场景中非常有用。

总的来说，线性回归在机器学习中扮演着重要的角色，是许多其他复杂模型的基础。它提供了一种简单而有效的方法来建模和预测数据，同时具有很强的解释性，使得其在实际应用中得到了广泛的应用。

# 成本函数

成本函数在回归问题中的作用是衡量模型预测值与真实值之间的差异，或者说衡量模型的预测误差。它是优化算法的核心，用于指导模型参数的更新，使得模型能够更好地拟合训练数据并得到更准确的预测结果。

具体来说，成本函数在回归问题中的作用包括以下几个方面：

1. **评估模型性能：** 成本函数提供了一个度量模型预测性能的指标。通过计算成本函数的值，可以了解模型对训练数据的拟合程度，以及模型的预测误差大小。成本函数的值越小，表示模型的预测结果与真实值越接近，模型性能越好。

2. **优化模型参数：** 成本函数是优化算法的目标函数，优化算法的目标是最小化成本函数的值。通过最小化成本函数，可以找到使模型预测误差最小化的参数值，从而得到更准确的模型。常见的优化算法包括梯度下降、随机梯度下降等，它们通过计算成本函数的梯度来指导参数的更新。

3. **调整模型复杂度：** 成本函数可以帮助调整模型的复杂度，以避免过拟合或欠拟合的问题。通过引入正则化项或调整模型的超参数，可以改变成本函数的形式，从而影响模型的学习过程和预测性能。

在回归问题中，常用的成本函数包括均方误差（Mean Squared Error，MSE）、均方根误差（Root Mean Squared Error，RMSE）、平均绝对误差（Mean Absolute Error，MAE）等。这些成本函数可以根据具体的问题和需求进行选择，用于评估模型的性能并指导模型的优化。

```python
def compute_cost(x, y, w, b):
    m = x.shape[0]

    cost_sum = 0
    for i in range(m):
        f_wb = sum(w * x[i]) + b
        cost = (f_wb - y[i]) ** 2
        cost_sum = cost_sum + cost
    total_cost = (1 / (2 * m)) * cost_sum

    return total_cost
```

# 计算梯度

![image-20240202133656183](https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/image-20240202133656183.png)

```python
def compute_gradient(x, y, w, b):
    m = x.shape[0]
    dj_dw = 0
    dj_db = 0

    for i in range(m):
        f_wb = sum(w * x[i]) + b
        dj_dw_i = (f_wb - y[i]) * x[i]
        dj_db_i = f_wb - y[i]
        dj_db += dj_db_i
        dj_dw += dj_dw_i
    dj_dw = dj_dw / m
    dj_db = dj_db / m

    return dj_dw, dj_db
```

# 标准化和归一化

标准化（Normalization）和归一化（Standardization）是数据预处理中常用的两种技术，它们的作用不同，适用于不同的情况：

1. **标准化（Standardization）：**
   - **作用：** 标准化的主要作用是使数据的分布符合标准正态分布（均值为0，标准差为1）。通过减去特征的均值，然后除以特征的标准差，可以将数据的均值调整为0，标准差调整为1。
   - **优点：** 标准化不会改变数据的原始分布形状，适用于大部分机器学习算法，特别是那些对数据分布敏感的算法，如支持向量机（SVM）和k近邻（KNN）等。
   - **适用情况：** 当特征的数值范围差异较大，或者特征的分布不符合标准正态分布时，可以考虑使用标准化。

2. **归一化（Normalization）：**
   - **作用：** 归一化的主要作用是将特征缩放到一个指定的范围内，通常是[0, 1]或[-1, 1]。通过对每个特征的数值进行线性变换，使其落在指定的范围内。
   - **优点：** 归一化可以消除特征之间的量纲差异，使得不同特征具有相同的重要性。它也有助于加速模型的收敛速度，并提高模型的性能。
   - **适用情况：** 当特征的数值范围差异较大，或者特征的数值范围不重要，但需要保证特征具有相同的重要性时，可以考虑使用归一化。

总的来说，标准化和归一化是常用的数据预处理技术，可以帮助提高模型的性能和稳定性。选择使用哪种技术取决于数据的特点和机器学习算法的需求，需要根据具体情况进行选择。

```python
def zscore_normalize_features(X):
    mu = np.mean(X, axis=0)  # mu will have shape (n,)
    sigma = np.std(X, axis=0)  # sigma will have shape (n,)
    X_norm = (X - mu) / sigma
    return X_norm
```

# 代码

```python
import numpy as np
import math
import matplotlib.pyplot as plt


def zscore_normalize_features(X):
    mu = np.mean(X, axis=0)  # 平均值
    sigma = np.std(X, axis=0)  # 标准差
    X_norm = (X - mu) / sigma
    return X_norm


def compute_cost(x, y, w, b):
    m = x.shape[0]

    cost_sum = 0
    for i in range(m):
        f_wb = sum(w * x[i]) + b
        cost = (f_wb - y[i]) ** 2
        cost_sum = cost_sum + cost
    total_cost = (1 / (2 * m)) * cost_sum

    return total_cost


def compute_gradient(x, y, w, b):
    m = x.shape[0] # x 是二维向量，一维表示数量，二维表示特征数量（高次项数量）
    dj_dw = 0
    dj_db = 0

    for i in range(m):
        f_wb = sum(w * x[i]) + b
        dj_dw_i = (f_wb - y[i]) * x[i]
        dj_db_i = f_wb - y[i]
        dj_db += dj_db_i
        dj_dw += dj_dw_i
    dj_dw = dj_dw / m
    dj_db = dj_db / m

    return dj_dw, dj_db

def gradient_descent(X, y, num_iters, alpha):
    J_history = []	# 调试，打印每次的成本
    w = np.zeros(X.shape[1]) # 随便初始化 w 和 b
    b = 0
    for i in range(num_iters):

        # Calculate the gradient and update the parameters
        dj_dw, dj_db = compute_gradient(X, y, w, b)


        # Update Parameters using w, b, alpha and gradient
        w = w - alpha * dj_dw  ##更新 w 和 b
        b = b - alpha * dj_db  

        # Save cost J at each iteration
        J_history.append(compute_cost(X, y, w, b))

        # Print cost every at intervals 10 times or as many iterations if < 10
        if i % math.ceil(num_iters / 10) == 0:
            print(f"Iteration {i: 4d}: Cost {J_history[-1]:8.10f}   ")

    return w, b


x = np.arange(0,20,1)
y = np.sin(x/2)

# 多项式高次项，自己根据情况指定
X = np.c_[x, x**2, x**3,x**4, x**5, x**6, x**7, x**8, x**9, x**10, x**11, x**12, x**13]
X = zscore_normalize_features(X) # 标准化


model_w, model_b = gradient_descent(X, y, 1000000, 1e-1)

plt.scatter(x, y, marker='x', c='r', label="Actual Value")
plt.title("Normalized x x**2, x**3 feature")
plt.plot(x, X@model_w + model_b, label="Predicted Value") # x @ model_w 就是矩阵乘法
plt.xlabel("x")
plt.ylabel("y")
plt.legend()
plt.show()
```

#  运行结果

![image-20240202134136841](https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/image-20240202134136841.png)

# 逻辑回归

[文章链接](https://blog.csdn.net/qq_40582172/article/details/111527286)