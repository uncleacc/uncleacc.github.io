<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>01字典树</title>
    <url>/posts/cc730d32.html</url>
    <content><![CDATA[<h1 id="01字典树"><a href="#01字典树" class="headerlink" title="01字典树"></a>01字典树</h1><blockquote>
<p>01字典树: 解决最大异或问题</p>
</blockquote>
<p>和字典树一样，只不过每一个节点的值不再是字符而是01，一个数从高位到低位对应于字典树从根到叶子，一个数二进制有多少位，就应该建几层树，包含根节点的那个编号0</p>
<p>树上的每一个点都有各自的编号，节点有两条边，分别是0和1，开空间时应该多开40倍左右</p>
<h2 id="HDU4825-Xor-Sum"><a href="#HDU4825-Xor-Sum" class="headerlink" title="HDU4825 Xor Sum"></a>HDU4825 Xor Sum</h2><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4825">题目链接</a></p>
<p>这道题数据有点水，说是不超过2^32^，其实连int都没有爆，应该开33层(包含根节点)，但是实际上32层就可以，代码是开了33层</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#pragma G++ optimize(2)</span></span><br><span class="line"><span class="comment">//#pragma G++ optimize(3,&quot;Ofast&quot;,&quot;inline&quot;)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="type">const</span> ll MAXN=<span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> ll MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll SUB=<span class="number">-0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-4</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> E=<span class="built_in">exp</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">int</span> ch[<span class="number">30</span>*MAXN][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> val[<span class="number">30</span>*MAXN];</span><br><span class="line"><span class="type">int</span> tot,t,n,m;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(val,<span class="number">0</span>,<span class="keyword">sizeof</span> val);</span><br><span class="line">    <span class="built_in">memset</span>(ch,<span class="number">0</span>,<span class="keyword">sizeof</span> ch);</span><br><span class="line">    tot=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> v)</span>&#123;</span><br><span class="line">    <span class="type">int</span> u=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">31</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="type">int</span> now=(v&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!ch[u][now]) ch[u][now]=++tot;</span><br><span class="line">        u=ch[u][now];</span><br><span class="line">    &#125;</span><br><span class="line">    val[u]=v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="type">int</span> u=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">31</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="type">int</span> now=(x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(ch[u][now^<span class="number">1</span>]) u=ch[u][now^<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span> u=ch[u][now];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> val[u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="type">int</span> js=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> tmp;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;tmp;</span><br><span class="line">            insert(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Case #&quot;</span>&lt;&lt;++js&lt;&lt;<span class="string">&quot;:\n&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">            <span class="type">int</span> tmp;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;tmp;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;query(tmp)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="Chip-Factory"><a href="#Chip-Factory" class="headerlink" title="Chip Factory"></a>Chip Factory</h2><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=5536">题目链接</a></p>
<p>在一个数组中找出 (s[i]+s[j])^s[k] 最大的值，其中 i、j、k 各不相同。</p>
<p>可以找出任意两个数的和，然后把这两个数从字典树中删除，之后查询最大异或，再添加上，再找，如此往复，输出最大值即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> t,n,tot;</span><br><span class="line"><span class="type">int</span> ch[MAXN*<span class="number">40</span>][<span class="number">2</span>],arr[MAXN],val[MAXN*<span class="number">40</span>];</span><br><span class="line"><span class="type">int</span> num[MAXN*<span class="number">40</span>]; </span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="type">int</span> u=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">31</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="type">int</span> now=(x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!ch[u][now]) ch[u][now]=++tot;</span><br><span class="line">        u=ch[u][now];</span><br><span class="line">        num[u]++;</span><br><span class="line">    &#125;</span><br><span class="line">    val[u]=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="type">int</span> u=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">31</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="type">int</span> now=(x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(ch[u][now^<span class="number">1</span>] &amp;&amp; num[ch[u][now^<span class="number">1</span>]]) u=ch[u][now^<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span> u=ch[u][now];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> val[u]^x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> c)</span>&#123;</span><br><span class="line">    <span class="type">int</span> u=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">31</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">    	<span class="type">int</span> now=(x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">    	num[ch[u][now]]+=c;</span><br><span class="line">    	u=ch[u][now];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">	tot=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">memset</span>(val,<span class="number">0</span>,<span class="keyword">sizeof</span> val);</span><br><span class="line">	<span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="keyword">sizeof</span> num);</span><br><span class="line">	<span class="built_in">memset</span>(ch,<span class="number">0</span>,<span class="keyword">sizeof</span> ch);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ios;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">    	init();</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;arr[i];</span><br><span class="line">            insert(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="type">int</span> cur=arr[i]+arr[j];</span><br><span class="line">                update(arr[i],<span class="number">-1</span>);</span><br><span class="line">                update(arr[j],<span class="number">-1</span>);</span><br><span class="line">                ans=max(ans,query(cur));</span><br><span class="line">                update(arr[i],<span class="number">1</span>);</span><br><span class="line">                update(arr[j],<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="The-xor-longest-Path"><a href="#The-xor-longest-Path" class="headerlink" title="The xor-longest Path"></a>The xor-longest Path</h2><p><a href="http://poj.org/problem?id=3764">题目链接</a></p>
<p>在树上找一段路径（连续）使得边权相异或的结果最大。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/20210507212615.png" alt="image-20210507212604651"></p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">110010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> to,w,next;</span><br><span class="line">&#125;e[MAXN*<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> t,n,tot,cnt,root,ans;</span><br><span class="line"><span class="type">int</span> val[MAXN*<span class="number">32</span>];</span><br><span class="line"><span class="type">int</span> ch[MAXN*<span class="number">32</span>][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> head[MAXN];</span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> c)</span>&#123;</span><br><span class="line">	e[cnt]=&#123;v,c,head[u]&#125;;</span><br><span class="line">	head[u]=cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="type">int</span> u=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">31</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="type">int</span> now=(x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!ch[u][now]) ch[u][now]=++tot;</span><br><span class="line">        u=ch[u][now];</span><br><span class="line">    &#125;</span><br><span class="line">    val[u]=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="type">int</span> u=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">31</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="type">int</span> now=(x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(ch[u][now^<span class="number">1</span>]) u=ch[u][now^<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span> u=ch[u][now];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> val[u]^x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> f,<span class="type">int</span> pre)</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[x];~i;i=e[i].next)&#123;</span><br><span class="line">		<span class="type">int</span> v=e[i].to,w=e[i].w;</span><br><span class="line">		<span class="keyword">if</span>(v==f) <span class="keyword">continue</span>;</span><br><span class="line">		ans=max(ans,query(pre^w));</span><br><span class="line">		insert(pre^w);</span><br><span class="line">		dfs(v,x,pre^w);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(val,<span class="number">0</span>,<span class="keyword">sizeof</span> val);</span><br><span class="line">	<span class="built_in">memset</span>(ch,<span class="number">0</span>,<span class="keyword">sizeof</span> ch);</span><br><span class="line">	<span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span> head);</span><br><span class="line">	ans=<span class="number">0</span>; cnt=<span class="number">0</span>; tot=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ios;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n)!=EOF)&#123;</span><br><span class="line">    	init();</span><br><span class="line">    	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">    		<span class="type">int</span> u,v,w;</span><br><span class="line">    		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">    		add(u,v,w);</span><br><span class="line">    		add(v,u,w);</span><br><span class="line">		&#125;</span><br><span class="line">		insert(<span class="number">0</span>);</span><br><span class="line">		dfs(root,<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">0 1 3</span></span><br><span class="line"><span class="comment">1 2 4</span></span><br><span class="line"><span class="comment">1 3 6</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>01字典树</tag>
      </tags>
  </entry>
  <entry>
    <title>2020summary</title>
    <url>/posts/a53cc33d.html</url>
    <content><![CDATA[<h1 id="2020年度总结"><a href="#2020年度总结" class="headerlink" title="2020年度总结"></a>2020年度总结</h1><blockquote>
<p>转眼间已是2021，想一想我的大学生活已经过去将近一半，真是快呀！总结一下我的2020年叭~</p>
</blockquote>
<h2 id="成就"><a href="#成就" class="headerlink" title="成就"></a>成就</h2><ul>
<li><p>ACM</p>
<ol>
<li>天梯赛(铜奖)</li>
<li>CCPC省赛银奖</li>
</ol>
</li>
<li><p>CET</p>
<ul>
<li>成绩还没出，不过感觉是考的不错</li>
</ul>
</li>
<li>体测<ul>
<li>79，已经非常满意了，只要过了75就满足了~</li>
</ul>
</li>
<li>学业<ul>
<li>比较满足了，相比于上学期确实进步了好多，可能是因为新图书馆建好了的缘故叭~</li>
</ul>
</li>
</ul>
<h2 id="想说的话"><a href="#想说的话" class="headerlink" title="想说的话"></a>想说的话</h2><h3 id="寒假"><a href="#寒假" class="headerlink" title="寒假"></a>寒假</h3><p>​    2020年寒假在家，对视频剪辑，PS，特效制作兴趣比较大，就学了十多天吧，当时还去淘宝上买了好几个教学视频呢，现在都还在百度网盘存着，就是做特效的时候才发现AE对电脑的配置需求太大了！5千多的电脑根本带不起来…CPU在燃烧🔥~最后也是做出来了一个爱情公寓版的开头片，个人感觉还是不错的，做了两天呢！遗憾的是最后失误把源文件了导致图片链接不上了，最后也是啥也没做成，现在也忘了软件咋用了。</p>
<h3 id="接触Hexo"><a href="#接触Hexo" class="headerlink" title="接触Hexo"></a>接触Hexo</h3><p>​    从过年开始疫情就开始了，过年的那两天啥也没干，亲戚也不敢串，都窝在家里，当时一整天有半天多都是躺在被窝里玩游戏或者看爱情公寓5，好慵懒😶~然后就是因为疫情一直没有开学，从2月底开始上网课，记得刚听说要上网课时那天早上还贼兴奋，很早就起来在电脑前面等着看慕课，记得第一节看的是高数，华中农业大学老师讲的真不错，新鲜感也就持续了一个星期，一个星期后再上网课就是不停发呆，不断刷抖音，再后来就接触了Hexo博客，那时我是没有博客的，连CSDN都没有，之前也想过用博客来记录算法，但是总是很懒，不愿意动手，直到我看到了龙佬的Sakura博客，当时感觉贼好看，就决心要搞一下，当时查询了超多的资料，什么也不懂，什么git，GitHub，ssh，hexo，什么都不知道，甚至连markdown都不会😂，真是难为我了！</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/Sucai/20210107130349.png" alt="image-20210107130340716"></p>
<p>最后还是在咸鱼上下单了，更离谱的是那个人最后也没给我搞好！他就差最后一步把GitHub仓库的名字加上后缀.github.io，不过他人还挺好的，给我弄了一个下午，最后还没打算给我要钱，我最后还是给了他15块钱，之后就是疯狂美化，虽然啥也不知道，就按照博客教程一步一步傻瓜式操作，到最后自己都不知道博客文件里面哪些是我自己添加的哪些是自带的，甚至有一次还把一个JS的script误删了，最后导致手机看博客打不开菜单~天知道我是怎么一步一步过来的，那几天甚至睡觉都在想着怎么美化，早上6点多自动从床上弹起来，去看教程，上网课都不能好好上，好的是最后终于做成了，做成的时候我真的是激动呐，还发了B站😂</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/Sucai/20210107131326.png" alt="image-20210107131320660"></p>
<p>真的Hexo带给我太多了！</p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>​    Hexo博客折腾的差不多后就是搞算法了，当时在家里算法也没停下，当时一星期要有3天晚上都要比赛，每次比赛之前都特别紧张，到现在都还是这样…当时真的很菜，连模板题都不会，学长们也是挺负责，会给我们出题解，我们私信他们，他们也会认真回我们，现在想一想真的感谢当时的自己，感谢当时没有放弃。</p>
<h3 id="在家期末考试"><a href="#在家期末考试" class="headerlink" title="在家期末考试"></a>在家期末考试</h3><p>​    再后来就是期末考试了，当时到最后交物理实验报告时，我连物理实验群聊都没加…当时急死我了，补了两天，写的手疼✍，由于网课都没有好好听，当时又挺喜欢看B站，就直接去B站上下学习了，感谢高数叔捞我！🙆推荐大家期末复习看高数叔，当然如果帮到了你们可以考虑赞助一下她们呀。</p>
<h3 id="暑期培训"><a href="#暑期培训" class="headerlink" title="暑期培训"></a>暑期培训</h3><p>​    期末考试完就放暑假了，寒暑假连放，真是百年难遇！然后就去报驾照了，3天看了1300多道题目，之后就是约了考试，一星期过了科目一，之后暑假培训就开始了，就没再练过车，天天在家里刷题，从早上9点左右开始到12点，下午又从2点半到6点，晚上从7点多到9点多，日日如此，每天都在做眼保教程，就那眼睛都感觉疲惫，真是难忘，当时晚上还要讲题，自己也提高了很大，一周一次的积分赛，真是害怕的要死，当提交后看到wrong的胆颤心惊，看到TLE的无奈，以及经过了无数次调试运行后的CORRT，感谢学长们暑假培训对我们的栽培，鞠躬🙏</p>
<h3 id="开学了"><a href="#开学了" class="headerlink" title="开学了"></a>开学了</h3><p>​    之后就开学了！终于开学了，开学后终于一睹了潘大佬的真容，打了第一场组队赛，之后就一直组队，次次躺赢🐉，慢慢的我们也熟悉了，后来老牛也来了，”三只菜鸡齐力下厨”人齐了，之后打了第一场比赛，CCPC国赛，过了三个题，打铁人，打铁魂，打铁人都是人上人，然后是CCPC省赛拿了省二，和省一就差了两名~好遗憾好遗憾啊。之后就是天梯赛，被队友带飞，拿了国三💊，之后就是体测了，上学期的奖学金丢的这么亏这学期必须拿到！跑了一星期的步，做了一星期的引体向上，终于最后过了75</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/Sucai/20210107134157.jpg" alt="IMG_20201125_211213"></p>
<p>​    然后英语四级就要开始了，两星期备考四级，当时真的就是天天泡在图书馆，好恐怖啊，你见过晚上10点的图书馆吗？</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/Sucai/20210107133706.jpg" alt="IMG_20201101_220135">{height=”400” width=”300”}</p>
<p>经过了艰难的两个星期，然后离期末考试就只剩下3个星期了，三星期复习5门课，不！不能叫复习，应该是学习。真是一个奇迹呢，天天泡在图书馆，第一次这么喜欢图书馆！</p>
<p>​    最后考完试就到了现在，这个2020过的也是针不戳，还有最重要的，2020年10月25日我也遇到了我的另一半，感谢小茹陪我走过了这两个月，新的一年，我也会陪着你继续走下去。</p>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>放几张照片吧</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/Sucai/20210107134655.jpg" alt="img06" title="CCPC秦皇岛"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/Sucai/20210107134903.jpg" alt="IMG_20201213_135647" title="和小茹在龙源湖"><img src="https://cdn.jsdelivr.net/gh/uncleacc/Sucai/20210107134712.jpg" alt="IMG_20210105_215227" title="晚上在图书馆"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/Sucai/20210107135013.jpg" alt="IMG_20201212_081333" title="四级考试现场"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/Sucai/20210107135032.jpg" alt="IMG_20201128_202329" title="和队友一起出去玩"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/Sucai/20210107135114.jpg" alt="IMG_20210105_151820" title="校园漫步"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/Sucai/20210107135155.jpg" alt="IMG_20201215_161541" title="做物理实验"></p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>2020</tag>
      </tags>
  </entry>
  <entry>
    <title>2021ICPC训练赛</title>
    <url>/posts/25665b78.html</url>
    <content><![CDATA[<h2 id="Early-Orders"><a href="#Early-Orders" class="headerlink" title="Early Orders"></a>Early Orders</h2><p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/20210308172548.png" alt="image-20210308150507708" style="zoom: 67%;" /></p>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>n个数从中找出一个包含1-k的字典序最小子串，注意子串可以断开，但是相对顺序不能变</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>求得是字典序最小的子串，用一个单调栈维护，从栈底到栈顶依次表示子串的从前到后，为什么用栈呢？考虑子串的先后性，必须先把后面的更新了才能更新前面的，如何维护栈呢？对于栈顶元素，从左往右遍历的过程中如果这个数字比栈顶数字小，而且右面还有栈顶数字，那就可以出栈，还有就是当栈内有一个元素了，这时就不能再往里面塞这个元素，搞一个标记数组标记栈中是否有这个元素</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0) </span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="type">int</span>&gt; st;</span><br><span class="line"><span class="type">bool</span> vis[MAXN];</span><br><span class="line"><span class="type">int</span> ans[MAXN],a[MAXN],pos[MAXN];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="type">int</span> n,m;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">		pos[a[i]]=i;  <span class="comment">//记录这个元素在这个序列中出现的最后位置</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(vis[a[i]]) <span class="keyword">continue</span>;  <span class="comment">//已经入栈了</span></span><br><span class="line">		<span class="keyword">while</span>(!st.empty() &amp;&amp; a[i]&lt;st.top() &amp;&amp; pos[st.top()]&gt;i)&#123;</span><br><span class="line">			vis[st.top()]=<span class="number">0</span>;  <span class="comment">//出栈恢复标记</span></span><br><span class="line">			st.pop();</span><br><span class="line">		&#125;</span><br><span class="line">		st.push(a[i]);</span><br><span class="line">		vis[a[i]]=<span class="number">1</span>;  <span class="comment">//标记这个元素入栈了</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> tail=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!st.empty())&#123;</span><br><span class="line">		ans[++tail]=st.top();  <span class="comment">//倒着输出</span></span><br><span class="line">		st.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=tail;i&gt;=<span class="number">1</span>;i--) <span class="built_in">cout</span>&lt;&lt;ans[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这道题和之前我们学校的招新赛一道题很类似，<a href="https://hpuoj.com/contest/34/">河南理工大学19级新生程序设计大赛：C. 星星选字符串</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/20210308155728.png" alt="image-20210308155726637" style="zoom:67%;" /></p>
<p>题意：在S串中找出包含T串所有字符的长度最短的连续子串</p>
<p>题解：用尺取做，当前区间满足条件了就缩小区间，不满足就扩大，这里需要注意的是最好用左闭右开的方式，因为如果左闭右闭的话，尺取的开始不好初始化左右指针的值，假如S=BA，T=B，那第一次就找到了，这时候l=-1,r=0，而你更新长度时条件是len&gt;r-l+1，这时就多计算了一个+1，因为这时候l所在的位置是空的，它没有占有一个字符所以这个+1就是多余的，所以可以刚开始初始化为l=0,r=0，只要在循环外面判断一次第一个字符就可以了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//左闭右闭</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SUB=<span class="number">-0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> eps=<span class="number">1e-4</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> E=<span class="built_in">exp</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">string</span> s,t; </span><br><span class="line"><span class="built_in">map</span>&lt;<span class="type">char</span>,<span class="type">int</span>&gt; mp,mp2;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;s&gt;&gt;t;</span><br><span class="line">	<span class="type">int</span> len=t.size(),k=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!mp[t[i]])&#123;</span><br><span class="line">			mp[t[i]]=<span class="number">1</span>;</span><br><span class="line">			k++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>,ans=INF,len2=s.size(),lp,rp,cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(r&lt;len2 &amp;&amp; mp[s[r]])&#123;</span><br><span class="line">		mp2[s[r]]++;</span><br><span class="line">		cnt++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(r&lt;len2)&#123;</span><br><span class="line">		<span class="keyword">if</span>(cnt==k)&#123;</span><br><span class="line">			<span class="keyword">if</span>(ans&gt;r-l+<span class="number">1</span>)&#123;</span><br><span class="line">				ans=r-l+<span class="number">1</span>;</span><br><span class="line">				lp=l;</span><br><span class="line">				rp=r;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(mp2[s[l]])&#123;</span><br><span class="line">				mp2[s[l]]--;</span><br><span class="line">				<span class="keyword">if</span>(mp2[s[l]]==<span class="number">0</span>) cnt--;</span><br><span class="line">			&#125;</span><br><span class="line">			l++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			r++;</span><br><span class="line">			<span class="keyword">if</span>(mp[s[r]])&#123;</span><br><span class="line">				mp2[s[r]]++;</span><br><span class="line">				<span class="keyword">if</span>(mp2[s[r]]==<span class="number">1</span>) cnt++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(ans!=INF)<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//左闭右开</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SUB=<span class="number">-0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> eps=<span class="number">1e-4</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> E=<span class="built_in">exp</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">string</span> s,t; </span><br><span class="line"><span class="built_in">map</span>&lt;<span class="type">char</span>,<span class="type">int</span>&gt; mp,mp2;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;s&gt;&gt;t;</span><br><span class="line">	<span class="type">int</span> len=t.size(),k=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!mp[t[i]])&#123;</span><br><span class="line">			mp[t[i]]=<span class="number">1</span>;</span><br><span class="line">			k++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>,ans=INF,len2=s.size(),lp,rp,cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(r&lt;=len2)&#123;</span><br><span class="line">		<span class="keyword">if</span>(cnt==k)&#123;</span><br><span class="line">			<span class="keyword">if</span>(ans&gt;r-l)&#123;</span><br><span class="line">				ans=r-l;</span><br><span class="line">				lp=l;</span><br><span class="line">				rp=r;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(mp2[s[l]])&#123;</span><br><span class="line">				mp2[s[l]]--;</span><br><span class="line">				<span class="keyword">if</span>(mp2[s[l]]==<span class="number">0</span>) cnt--;</span><br><span class="line">			&#125;</span><br><span class="line">			l++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(mp[s[r]])&#123;</span><br><span class="line">				mp2[s[r]]++;</span><br><span class="line">				<span class="keyword">if</span>(mp2[s[r]]==<span class="number">1</span>)cnt++;</span><br><span class="line">			&#125;</span><br><span class="line">			r++;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//		cout&lt;&lt;cnt&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(ans!=INF) <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="comment">//	for(int i=lp;i&lt;rp;i++) cout&lt;&lt;s[i];</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>比赛</tag>
      </tags>
  </entry>
  <entry>
    <title>2021牛客寒假算法基础集训营5</title>
    <url>/posts/505dcdf.html</url>
    <content><![CDATA[<h2 id="B-比武招亲（上）"><a href="#B-比武招亲（上）" class="headerlink" title="B 比武招亲（上）"></a>B<a href="https://ac.nowcoder.com/acm/contest/9985/B"> 比武招亲（上）</a></h2><p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/20210306171528.png" alt="image-20210306171517109" style="zoom:67%;" /></p>
<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定n,m，每次从1-n中挑选出m个数，可以重复挑选，挑选出的数的贡献值等于排序后最大值减去最小值，挑选的序列不同当且仅当两个序列排序后不同，求所有可能的序列的总贡献值？</p>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>可以枚举贡献值，差值一共有n-1种，差值固定了，也就是在m-2个空位中随意放置[min,max]的数，这里有一个坑，也不是随便放的，因为要求排过序后序列不同，也就是放置要求是单调不减，于是可以把+1看成一个隔板，就是在m-2+1个隔板中放置d(差值)个隔板，可是隔板可以连续放置，所以放置一个隔板后空位就会增多！所以答案不是C(m-1,d)，雨巨的想法NB，考虑每一个隔板的左面带有一个空位，那么所有的隔板放完后空位就增加到了m-1+d个，在这些空位中放进去d个隔板，这个时候隔板就不能连续放了，因为每一个隔板左面都带有一个空位，所以每一个隔板左面都必须至少有一个空位，那最左面也不能放了，所以空位变成了m-1+d-1，答案就变成了从m-2+d个空位中放置d个隔板，隔板不能连续放，C(m-2+d,d)，到这里题目就做出来一大半了，组合数复杂度为O(n)，这里的n和m都是1e5，所以每次都算一遍组合数时间就是O(n2)级别的，必定超时，考虑优化组合数，先算出差值为1的答案，然后算差值为2的组合数时在差值为1的基础上*分子*分母的逆元可以把组合数的时间去掉，时复O(n)</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SUB=<span class="number">-0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> eps=<span class="number">1e-4</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> E=<span class="built_in">exp</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line">ll <span class="title function_">ksm</span><span class="params">(ll a,ll b)</span>&#123;</span><br><span class="line">	ll ret=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(b)&#123;</span><br><span class="line">		<span class="keyword">if</span>(b&amp;<span class="number">1</span>) ret=ret*a%MOD;</span><br><span class="line">		a=a*a%MOD;</span><br><span class="line">		b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret%MOD;</span><br><span class="line">&#125;</span><br><span class="line">ll <span class="title function_">inv</span><span class="params">(ll x)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ksm(x,MOD<span class="number">-2</span>)%MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">1</span> || m==<span class="number">1</span>)&#123;  <span class="comment">//特判特殊情况</span></span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ll now=m<span class="number">-2</span>+<span class="number">1</span>,ans=now*(n<span class="number">-1</span>)%MOD;<span class="comment">//先算出差值为1的答案</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n<span class="number">-1</span>;i++)&#123;  <span class="comment">//之后在上一个差值的基础上算这个差值的答案</span></span><br><span class="line">		now=now*(m<span class="number">-2</span>+i)%MOD*inv(i)%MOD;  <span class="comment">//乘上分子和分母的逆元</span></span><br><span class="line">		ans=(ans+now*i%MOD*(n-i)%MOD)%MOD;  <span class="comment">//现在now表示这个差值的种类数记得乘上差值和这个差值下可以取到的区间数量</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>比赛</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-2 两数相加</title>
    <url>/posts/cbf78b69.html</url>
    <content><![CDATA[<p>考察了对链表的使用 </p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/f32296771e0e43e7b64b06a748d3b5da.png" alt="img"> 特别注意的是<strong>在一个自己声明的函数</strong>中<strong>直接定义变量</strong>和<strong>使用new声明</strong>内存分配机制是不一样的，<strong>直接定义是由系统管理内存的分配与回收</strong>，而<strong>new则是由程序员自己分配与回收</strong>，所以在自定义函数中直接定义变量，然后把指针指向此变量会导致在函数结束后内存回收指针指向无效地址的错误，而new则避免了此问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123;</span><br><span class="line">        ListNode *head = nullptr, *tail = nullptr;</span><br><span class="line">        <span class="type">int</span> last=<span class="number">0</span>;	<span class="comment">//保存进位</span></span><br><span class="line">        <span class="keyword">while</span>(l1 || l2) &#123;	<span class="comment">//有一个链表非空则继续计算</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;	<span class="comment">//保存当前和</span></span><br><span class="line">            <span class="keyword">if</span>(l1) sum += l1-&gt;val;</span><br><span class="line">            <span class="keyword">if</span>(l2) sum += l2-&gt;val;</span><br><span class="line">            sum += last;</span><br><span class="line">            last=sum/<span class="number">10</span>;	<span class="comment">//更新进位</span></span><br><span class="line">            <span class="keyword">if</span>(!head) head = tail = <span class="keyword">new</span> <span class="title class_">ListNode</span>(sum%<span class="number">10</span>);	<span class="comment">//没有头结点，所以第一个节点就是结构体节点，需要特判一下</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                tail-&gt;next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(sum%<span class="number">10</span>);</span><br><span class="line">                tail = tail-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l1) l1 = l1-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(l2) l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(last) tail-&gt;next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(last);	<span class="comment">//最后特判是否进位</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>01字典树</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-5 最长回文子串</title>
    <url>/posts/b5949c1f.html</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/c4268e9784f84075b08ed979f60d2f7d.png" alt="img"> 动态规划</p>
<p> <img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/8ce61f447b95410ebd98bb7547c8347a.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string <span class="title function_">longestPalindrome</span><span class="params">(string s)</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="type">int</span> <span class="variable">st</span> <span class="operator">=</span> <span class="number">0</span>, L = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.size();</span><br><span class="line">        bool dp[<span class="number">1100</span>][<span class="number">1100</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i ++) dp[i][i] = <span class="number">1</span>;	<span class="comment">//长度为1的子串都是回文串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= len; i ++) &#123;</span><br><span class="line">   	<span class="comment">//枚举长度</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j + i - <span class="number">1</span> &lt; len; j ++) &#123;</span><br><span class="line">   	<span class="comment">//枚举位置</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> j + i - <span class="number">1</span>;	<span class="comment">//结束位置</span></span><br><span class="line">                <span class="keyword">if</span>(s[j] != s[k]) dp[j][k] = <span class="number">0</span>;	<span class="comment">//如果两端字符不一致不回文</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">                    <span class="keyword">if</span>(i &lt;= <span class="number">3</span>) dp[j][k] = <span class="number">1</span>;	<span class="comment">//长度为3或者2的都是回文</span></span><br><span class="line">                    <span class="keyword">else</span> dp[j][k] = dp[j+<span class="number">1</span>][k-<span class="number">1</span>];	<span class="comment">//由之前状态推过来</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(dp[j][k]) st = j, L = i;	<span class="comment">//更新长度和起始位置</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(st, L);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>01字典树</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-80</title>
    <url>/posts/9c90cade.html</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/d1b412323e4d4ad08e5c330fce47d2e4.png" alt="img"></p>
<p>写麻烦了，总之就是双指针，一个快指针一个慢指针</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="type">int</span> len=nums.size();</span><br><span class="line">        <span class="type">int</span> cnt=<span class="number">1</span>,L=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">   </span><br><span class="line">            <span class="keyword">if</span>(nums[i]==nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">   </span><br><span class="line">                <span class="keyword">if</span>(cnt==<span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span> cnt++,L++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">   </span><br><span class="line">                L++;</span><br><span class="line">                cnt=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;L&lt;&lt;endl;</span></span><br><span class="line">        cnt=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">1</span>;i&lt;len &amp;&amp; j&lt;L;i++)&#123;</span><br><span class="line">   </span><br><span class="line">            <span class="keyword">if</span>(nums[i]==nums[i-<span class="number">1</span>] &amp;&amp; cnt==<span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=nums[i-<span class="number">1</span>]) cnt=<span class="number">0</span>;</span><br><span class="line">            nums[j++]=nums[i];</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> L;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>01字典树</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-1027最长等差数列</title>
    <url>/posts/b2c9ee6e.html</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/27ba9d758d86403e884e0ebea8971439.png" alt="img"> 和最长上升子序列类似，这里多加了公差的性质，第一种想法是开一个结构体dp一维数组，dp[i].val表示以i位置结尾的最长长度，dp[i].cha表示以i位置结尾的子序列公差，你会发现无法进行状态转移，假设i&lt;j&lt;k，dp[k]被dp[j]更新了，并且更新后长度最大，但这不代表i这个位置就一定不是最长等差序列之一，因为可能dp[i].val和dp[j].val只相差1甚至相同，但两者公差不一样，如果后面再来几个公差和dp[i].cha一样的，而你又没有把k位置给添加到序列中，这个状态没有被考虑，导致错误。 因此需要dp[i][j]表示第i个位置添加到末尾并且公差是j的最长长度。 之后再仿照最长上升子序列进行更新即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> dp[<span class="number">1100</span>][<span class="number">1100</span>];</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">longestArithSeqLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> &#123;</span><br><span class="line">   </span><br><span class="line">        memset(dp,<span class="number">0</span>,sizeof dp);</span><br><span class="line">        <span class="type">int</span> len=nums.size();</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">   </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">   </span><br><span class="line">                dp[i][nums[i]-nums[j]+<span class="number">500</span>]=max(dp[j][nums[i]-nums[j]+<span class="number">500</span>]+<span class="number">1</span>,dp[i][nums[i]-nums[j]+<span class="number">500</span>]);</span><br><span class="line">                res=max(res,dp[i][nums[i]-nums[j]+<span class="number">500</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>01字典树</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-82 含有重复元素集合的组合</title>
    <url>/posts/ea0f870d.html</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/f1cd32f7ea404c54b57b319e0e2fb4ff.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates,vector&lt;<span class="type">int</span>&gt;&amp; ans,<span class="type">int</span> sum,<span class="type">int</span> pos, <span class="type">int</span> &amp;target)</span>&#123;</span><br><span class="line">   </span><br><span class="line">        ans.push_back(candidates[pos]);</span><br><span class="line">        <span class="keyword">if</span>(sum+candidates[pos]==target) res.push_back(ans);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(sum+candidates[pos]&lt;target)&#123;</span><br><span class="line">   </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=pos+<span class="number">1</span>;i&lt;candidates.size();i++)&#123;</span><br><span class="line">   </span><br><span class="line">                <span class="keyword">if</span>(i&gt;pos+<span class="number">1</span> &amp;&amp; candidates[i]==candidates[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                dfs(candidates,ans,sum+candidates[pos],i,target);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.pop_back();</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="title function_">combinationSum2</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">   </span><br><span class="line">        sort(candidates.begin(),candidates.end());</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;candidates.size();i++)&#123;</span><br><span class="line">   </span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; candidates[i]==candidates[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            dfs(candidates,ans,<span class="number">0</span>,i,target);	<span class="comment">//每一次dfs都把以i这个元素作为第一个元素的组合都找出来了，那么后面再以i这个元素作为第一个元素就是重复的</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>01字典树</tag>
      </tags>
  </entry>
  <entry>
    <title>Git命令</title>
    <url>/posts/b6ef4fe0.html</url>
    <content><![CDATA[<p>.gitnore文件配置忽视规则</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">/文件夹	#忽略此文件夹</span><br><span class="line">!/文件夹  #表示此文件夹不忽略</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git init <span class="comment">//初始化为git仓库</span></span><br><span class="line">git status	<span class="comment">//查看状态</span></span><br><span class="line">git add file1 file2 <span class="comment">//未跟踪或改变文件推送到暂存区</span></span><br><span class="line">git add.	<span class="comment">//添加所有文件到缓存区</span></span><br><span class="line">git commit -m <span class="string">&quot;备注信息&quot;</span>	<span class="comment">//将暂存区的文件提交到本地仓库</span></span><br><span class="line">git remote add origin <span class="string">&quot;https://....git&quot;</span>		<span class="comment">//将本地仓库关联到远程仓库，origin是默认的代表远程仓库在本地的名称</span></span><br><span class="line">git remote -v	<span class="comment">//查看远程仓库在本地的名称及地址</span></span><br><span class="line">git pull --rebase origin master	<span class="comment">//和远程仓库的master分支建立联系</span></span><br><span class="line">git push -u origin master	<span class="comment">//推送到远程仓库，origin代表远程仓库，master代表本地分支</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>01字典树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode162-寻找峰值</title>
    <url>/posts/ac816005.html</url>
    <content><![CDATA[<p> <a href="https://leetcode.cn/problems/find-peak-element/">LeetCode162-寻找峰值</a> 二分找索引，对于mid，如果处于上坡，则答案在右边，如果处于下坡，答案在左边，如果处于低谷，答案任意，如果处于峰顶，即为答案。 注意特判0和nums.szie()-1两个位置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">findPeakElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums.size()-<span class="number">1</span>, mid;</span><br><span class="line">        <span class="type">int</span> res;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">   </span><br><span class="line">            mid = (l + r) / <span class="number">2</span>;</span><br><span class="line"><span class="comment">//            cout &lt;&lt; nums[mid] &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">if</span>((mid == <span class="number">0</span> || nums[mid] &gt; nums[mid - <span class="number">1</span>]) &amp;&amp; (mid == nums.size() - <span class="number">1</span> || nums[mid] &gt; nums[mid + <span class="number">1</span>])) &#123;</span><br><span class="line">   </span><br><span class="line">                res = mid;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((mid == <span class="number">0</span> || nums[mid-<span class="number">1</span>] &lt; nums[mid]) &amp;&amp; (mid &lt; nums.size() - <span class="number">1</span> &amp;&amp; nums[mid] &lt; nums[mid+<span class="number">1</span>])) l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((mid &gt; <span class="number">0</span> &amp;&amp; nums[mid-<span class="number">1</span>] &gt; nums[mid]) &amp;&amp; (mid == nums.size() - <span class="number">1</span> || nums[mid] &gt; nums[mid+<span class="number">1</span>])) r = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>01字典树</tag>
      </tags>
  </entry>
  <entry>
    <title>15. 三数之和</title>
    <url>/posts/e192590d.html</url>
    <content><![CDATA[<p>先排序，两层for循环，二分寻找-(nums[i]+nums[j])，用map去重 时复：O(n2logn) 算上常数差不多9e8左右 刚好超时 寻找能优化的地方 因为排过序了，如果-(nums[i]+nums[j])&lt;nums[j]就没必要找了，加上这句正好卡过去</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">struct node &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">    bool operator&lt;(const node &amp;o) const &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">return</span> a == o.a ? (b == o.b ? (c &lt; o.c) : b &lt; o.b) : a &lt; o.a;</span><br><span class="line">    &#125;</span><br><span class="line">    node(<span class="type">int</span> ta, <span class="type">int</span> tb, <span class="type">int</span> tc):a(ta),b(tb),c(tc)&#123;</span><br><span class="line">   &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">map&lt;node, bool&gt; vis;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="title function_">threeSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> &#123;</span><br><span class="line">   </span><br><span class="line">        vis.clear();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.size(); i ++) &#123;</span><br><span class="line">   </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; nums.size(); j ++) &#123;</span><br><span class="line">   </span><br><span class="line">                <span class="keyword">if</span>(-(nums[i]+nums[j]) &lt; nums[j]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> lower_bound(nums.begin()+j+<span class="number">1</span>, nums.end(), -(nums[i]+nums[j])) - nums.begin();</span><br><span class="line">                <span class="keyword">if</span>(id != nums.size() &amp;&amp; nums[id] == -(nums[i] + nums[j])) &#123;</span><br><span class="line">   </span><br><span class="line">                    <span class="keyword">if</span>(!vis[node(nums[i], nums[j], nums[id])]) &#123;</span><br><span class="line">   </span><br><span class="line">                    	vis[node(nums[i], nums[j], nums[id])] = <span class="number">1</span>;</span><br><span class="line">                        res.push_back(&#123;</span><br><span class="line">   nums[i], nums[j], nums[id]&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>01字典树</tag>
      </tags>
  </entry>
  <entry>
    <title>11. 盛最多水的容器</title>
    <url>/posts/d910afda.html</url>
    <content><![CDATA[<p> <a href="https://leetcode.cn/problems/container-with-most-water/">11. 盛最多水的容器</a> 题目所求即为最大面积，面积=(较短边*两线段距离)，答案即为max{以每一条线段作为较短边的最大面积}，当较短边确定时，两线段距离越长越好，因此考虑双指针从两端向内进行移动 考虑以下状态： 两指针在两端时，对于较短边而言，以此线段为较短边的最大面积就是线段长度乘以两指针位置之差，因此较短边对应的指针就可以向前或向后移动了。 移动后的状态又是以上状态。 因此每次较短边指针移动</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = height.size() - <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">   </span><br><span class="line">            res = max(res, min(height[i], height[j])*(j-i));</span><br><span class="line">            <span class="keyword">if</span>(height[i] &gt; height[j]) j --;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(height[i] &lt; height[j]) i ++;</span><br><span class="line">            <span class="keyword">else</span> i ++,j --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>01字典树</tag>
      </tags>
  </entry>
  <entry>
    <title>117. 填充每个节点的下一个右侧节点指针 II</title>
    <url>/posts/8dbab94f.html</url>
    <content><![CDATA[<p> <a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/">117. 填充每个节点的下一个右侧节点指针 II</a> 题目有点类似于层序线索化，就是在层序遍历的基础上魔改一下，使得可以获得当前遍历到第几层的信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* left;</span></span><br><span class="line"><span class="comment">    Node* right;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() : val(0), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _left, Node* _right, Node* _next)</span></span><br><span class="line"><span class="comment">        : val(_val), left(_left), right(_right), next(_next) &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(Node *root)</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">if</span>(root == NULL) <span class="keyword">return</span> ;</span><br><span class="line">        queue&lt;Node*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="comment">//cnt:当前正在遍历的这一层已经遍历了几个节点</span></span><br><span class="line">        <span class="comment">//tail:当前正在遍历的这一层一共有几个节点</span></span><br><span class="line">        <span class="comment">//num:下一层一共有几个节点</span></span><br><span class="line">        <span class="comment">//pre:这一层上一个遍历到的节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>, tail = <span class="number">1</span>, num = <span class="number">0</span>;</span><br><span class="line">        Node *pre = NULL;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">   </span><br><span class="line">            Node *u = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span>(pre) pre-&gt;next = u;</span><br><span class="line">            pre = u;</span><br><span class="line">            ++ cnt;</span><br><span class="line">            <span class="keyword">if</span>(u-&gt;left) &#123;</span><br><span class="line">   </span><br><span class="line">                q.push(u-&gt;left);</span><br><span class="line">                ++ num;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(u-&gt;right) &#123;</span><br><span class="line">   </span><br><span class="line">                q.push(u-&gt;right);</span><br><span class="line">                ++ num;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cnt == tail) &#123;</span><br><span class="line">   </span><br><span class="line">                cnt = <span class="number">0</span>;</span><br><span class="line">                tail = num;</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">                u-&gt;next = NULL;</span><br><span class="line">                pre = NULL;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Node* connect(Node* root) &#123;</span><br><span class="line">   </span><br><span class="line">        bfs(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>还有一种简单的写法，直接得出当前层节点个数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* left;</span></span><br><span class="line"><span class="comment">    Node* right;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() : val(0), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _left, Node* _right, Node* _next)</span></span><br><span class="line"><span class="comment">        : val(_val), left(_left), right(_right), next(_next) &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(Node *root)</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">if</span>(root == NULL) <span class="keyword">return</span> ;</span><br><span class="line">        queue&lt;Node*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">   </span><br><span class="line">            Node *pre = NULL;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> q.size();	<span class="comment">//为当前层的总节点数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">   	<span class="comment">//遍历当前层节点</span></span><br><span class="line">                Node *u = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">if</span>(pre) pre-&gt;next = u;</span><br><span class="line">                pre = u;</span><br><span class="line">                <span class="keyword">if</span>(u-&gt;left) q.push(u-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(u-&gt;right) q.push(u-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Node* connect(Node* root) &#123;</span><br><span class="line">   </span><br><span class="line">        bfs(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>01字典树</tag>
      </tags>
  </entry>
  <entry>
    <title>572. 另一棵树的子树</title>
    <url>/posts/7ae49056.html</url>
    <content><![CDATA[<p> <a href="https://leetcode.cn/problems/subtree-of-another-tree/">572. 另一棵树的子树</a> 解法一、暴力遍历每一个子树，比较子树是否相同 时复：O(s * t)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    bool <span class="title function_">judge</span><span class="params">(TreeNode *t1, TreeNode *t2)</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">if</span>(t1-&gt;val != t2-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(bool(t1-&gt;left) ^ bool(t2-&gt;left)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(bool(t1-&gt;right) ^ bool(t2-&gt;right)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(t1-&gt;left &amp;&amp; !judge(t1-&gt;left, t2-&gt;left)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(t1-&gt;right &amp;&amp; !judge(t1-&gt;right, t2-&gt;right)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bool <span class="title function_">isSubtree</span><span class="params">(TreeNode* root, TreeNode* subRoot)</span> &#123;</span><br><span class="line">   </span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">   </span><br><span class="line">            TreeNode *u = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span>(judge(u, subRoot)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(u-&gt;left) q.push(u-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(u-&gt;right) q.push(u-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>解法二、 解出两颗子树的所有前序序列，若t2是t1的子树，则t2的前序序列应为t1的前序序列的子串，利用kmp算法匹配即可，代码中lNull为左子树空的标志，rNull为右子树空的标志 时复：O(s + t)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> lNull, rNull;</span><br><span class="line">    <span class="type">int</span> ne[<span class="number">4100</span>];</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt; &amp;ve)</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> ;</span><br><span class="line">        ve.push_back(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left) dfs(root-&gt;left, ve);</span><br><span class="line">        <span class="keyword">else</span> ve.push_back(lNull);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right) dfs(root-&gt;right, ve);</span><br><span class="line">        <span class="keyword">else</span> ve.push_back(rNull);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">get_next</span><span class="params">(vector&lt;<span class="type">int</span>&gt; v1)</span>&#123;</span><br><span class="line">   </span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = -<span class="number">1</span>;  <span class="comment">//这里j是初始化为-1！</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> v1.size();</span><br><span class="line">        ne[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; len)&#123;</span><br><span class="line">   </span><br><span class="line">            <span class="keyword">if</span>(j == -<span class="number">1</span> || v1[i] == v1[j])&#123;</span><br><span class="line">   </span><br><span class="line">                ++ i; ++ j;</span><br><span class="line">                ne[i] = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> j = ne[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    bool <span class="title function_">kmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;v1, vector&lt;<span class="type">int</span>&gt; &amp;v2)</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> v1.size(), len2 = v2.size();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; len2)&#123;</span><br><span class="line">   </span><br><span class="line">            <span class="keyword">if</span>(j == -<span class="number">1</span> || v1[j] == v2[i])&#123;</span><br><span class="line">   </span><br><span class="line">                ++ i; ++ j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> j = ne[j];</span><br><span class="line">            <span class="keyword">if</span>(j == len1) &#123;</span><br><span class="line">   </span><br><span class="line">                cnt ++;  <span class="comment">// 匹配到</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    bool <span class="title function_">isSubtree</span><span class="params">(TreeNode* root, TreeNode* subRoot)</span> &#123;</span><br><span class="line">   </span><br><span class="line">        lNull = <span class="number">10001</span>, rNull = <span class="number">10002</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; v1, v2;</span><br><span class="line">        dfs(root, v2);</span><br><span class="line">        dfs(subRoot, v1);</span><br><span class="line">        get_next(v1);</span><br><span class="line">        <span class="keyword">return</span> kmp(v1, v2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>解法三、 官方题解给出的哈希做法，感觉很秒</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>01字典树</tag>
      </tags>
  </entry>
  <entry>
    <title>Typora使用配置</title>
    <url>/posts/5655ac3f.html</url>
    <content><![CDATA[<h3 id="取消拼写检查"><a href="#取消拼写检查" class="headerlink" title="取消拼写检查"></a>取消拼写检查</h3><p>默认会检查拼写错误，并在下方给予红线提示。 偏好设置-&gt;拼写检查-&gt;不使用拼写检查</p>
<h3 id="取消自动保存"><a href="#取消自动保存" class="headerlink" title="取消自动保存"></a>取消自动保存</h3><p>偏好设置-&gt;自动保存</p>
<h3 id="取消自动检查更新"><a href="#取消自动检查更新" class="headerlink" title="取消自动检查更新"></a>取消自动检查更新</h3><h3 id="图像上传路径"><a href="#图像上传路径" class="headerlink" title="图像上传路径"></a>图像上传路径</h3><p>偏好设置-&gt;图像-&gt;插入图像时-&gt;复制到指定路径-&gt;设置图片保存路径</p>
<h3 id="开启markdown扩展语法"><a href="#开启markdown扩展语法" class="headerlink" title="开启markdown扩展语法"></a>开启markdown扩展语法</h3><p>偏好设置-&gt;markdown-&gt;markdown扩展语法</p>
<h3 id="代码块显示行号"><a href="#代码块显示行号" class="headerlink" title="代码块显示行号"></a>代码块显示行号</h3><p>偏好设置-&gt;markdown-&gt;代码块</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>01字典树</tag>
      </tags>
  </entry>
  <entry>
    <title>56. 合并区间</title>
    <url>/posts/2e0786fe.html</url>
    <content><![CDATA[<h2 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a>56. 合并区间</h2><p>双指针，先按照左端点升序排序，对于一个区间，如果可以和后面的合并，则其右端点一定大于后面区间的左端点，且合并后的区间右端点要取两个区间大的右端点，取max，注意边界即可 vector&lt;vector&lt;int&gt;&gt;默认按照第一列的元素从小到大排序，注意如果这里加cmp函数，必须是静态函数，因为sort是全局函数，全局函数不能调用类的成员函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="title function_">merge</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals)</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> intervals.size();</span><br><span class="line">        sort(intervals.begin(), intervals.end());</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">1</span>, mx = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span>(j &lt; n) &#123;</span><br><span class="line">   </span><br><span class="line">            <span class="keyword">if</span>(intervals[j][<span class="number">0</span>] &lt;= mx) &#123;</span><br><span class="line">   </span><br><span class="line">                mx = max(mx, intervals[j][<span class="number">1</span>]);</span><br><span class="line">                j ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">                res.push_back(&#123;</span><br><span class="line">   intervals[i][<span class="number">0</span>], mx&#125;);</span><br><span class="line">                i = j;</span><br><span class="line">                j = i + <span class="number">1</span>;</span><br><span class="line">                mx = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(&#123;</span><br><span class="line">   intervals[i][<span class="number">0</span>], mx&#125;);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>01字典树</tag>
      </tags>
  </entry>
  <entry>
    <title>706. 设计哈希映射</title>
    <url>/posts/35f83738.html</url>
    <content><![CDATA[<h2 id="706-设计哈希映射"><a href="#706-设计哈希映射" class="headerlink" title="706. 设计哈希映射"></a>706. 设计哈希映射</h2><p>处理冲突方法采用链表法，利用list</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyHashMap</span> &#123;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;list&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; data;</span><br><span class="line">    <span class="keyword">static</span> const <span class="type">int</span> <span class="variable">base</span> <span class="operator">=</span> <span class="number">769</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">return</span> x % base;</span><br><span class="line">    &#125;</span><br><span class="line">    MyHashMap(): data(base) &#123;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">auto</span> <span class="variable">it</span> <span class="operator">=</span> data[hash(key)].begin(); it != data[hash(key)].end(); it ++) &#123;</span><br><span class="line">   </span><br><span class="line">            <span class="keyword">if</span>((*it).first == key) &#123;</span><br><span class="line">   </span><br><span class="line">                (*it).second = value;</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        data[hash(key)].push_back(make_pair(key, value));</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> hash(key);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">auto</span> <span class="variable">it</span> <span class="operator">=</span> data[h].begin(); it != data[h].end(); it ++) &#123;</span><br><span class="line">   </span><br><span class="line">            <span class="keyword">if</span>((*it).first == key) &#123;</span><br><span class="line">   </span><br><span class="line">                <span class="keyword">return</span> (*it).second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> hash(key);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">auto</span> <span class="variable">it</span> <span class="operator">=</span> data[h].begin(); it != data[h].end(); it ++) &#123;</span><br><span class="line">   </span><br><span class="line">            <span class="keyword">if</span>((*it).first == key) &#123;</span><br><span class="line">   </span><br><span class="line">                data[h].erase(it);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyHashMap object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyHashMap* obj = new MyHashMap();</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;remove(key);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>01字典树</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 48. 旋转图像</title>
    <url>/posts/33a3ea80.html</url>
    <content><![CDATA[<h2 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48. 旋转图像"></a>48. 旋转图像</h2><p>矩阵从外到内，是一圈一圈的，只要能把一圈旋转90度，内层圈找好数据关系，for循环就可以搞定每一圈 对于一圈：对于第一行（除了最后一个元素）而言，只要把这些元素旋转四次就回到了原来位置，所以只要循环四次，把中间遍历到的元素都移到下一次即将遍历的位置即可 如何把当前元素放到下一个即将访问的位置？如果只是简单的覆盖，下一个元素将丢失，容易想到的是用temp存储即将丢失的元素，但这样实现起来有许多细节很难写，用交换实现则特别简单，找一个临时变量，每次都把当前位置和临时变量进行交换，则实现了旋转操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> struct node &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        node(<span class="type">int</span> x, <span class="type">int</span> y) &#123;</span><br><span class="line">   </span><br><span class="line">            <span class="built_in">this</span>-&gt;x = x;</span><br><span class="line">            <span class="built_in">this</span>-&gt;y = y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">static</span> node <span class="title function_">nextP</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">   <span class="comment">// 计算旋转后位置</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">   y, n - x - <span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">work</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> &#123;</span><br><span class="line">    <span class="comment">// 旋转一个元素对应的四个位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix.size(), bx = x, by = y;</span><br><span class="line">        <span class="type">node</span> <span class="variable">np</span> <span class="operator">=</span> nextP(x, y, n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++) &#123;</span><br><span class="line">   </span><br><span class="line">            swap(matrix[np.x][np.y], matrix[bx][by]); <span class="comment">// 交换</span></span><br><span class="line">            x = np.x; y = np.y;</span><br><span class="line">            np = nextP(np.x, np.y, n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n/<span class="number">2</span>; i ++) &#123;</span><br><span class="line">    <span class="comment">// 行</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; n-<span class="number">1</span>-i; j ++) &#123;</span><br><span class="line">    <span class="comment">// 列</span></span><br><span class="line">                work(i, j, matrix);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>01字典树</tag>
      </tags>
  </entry>
  <entry>
    <title>operator的两种用法（重载和隐式类型转换）</title>
    <url>/posts/64415dbc.html</url>
    <content><![CDATA[<h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><p>略</p>
<h2 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h2><h3 id="构造函数的隐式类型转换"><a href="#构造函数的隐式类型转换" class="headerlink" title="构造函数的隐式类型转换"></a>构造函数的隐式类型转换</h3><p>利用operator进行的隐式类型转换成为<strong>operator算子的隐式类型转换</strong>，讲这个之前先了解<strong>构造函数的隐式类型转换</strong>，请看以下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>&#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="type">int</span> val;</span><br><span class="line">		X(<span class="type">int</span> _val) &#123;</span><br><span class="line">   	<span class="comment">//隐式类型转换</span></span><br><span class="line">			val = _val;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">	<span class="type">X</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">2</span>;	<span class="comment">//等价于X m(2);</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>传入<strong>一个参数</strong>初始化类的构造函数就是构造函数的隐式类型转换，可以理解为将int类型转换为X(class)类型</p>
<h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p>如果不想出现这种隐式类型转换，就可以用explict修饰 具体详解请看： <a href="https://blog.csdn.net/weixin_45525272/article/details/105996548">explict详解</a></p>
<h3 id="operator算子的隐式类型转换"><a href="#operator算子的隐式类型转换" class="headerlink" title="operator算子的隐式类型转换"></a>operator算子的隐式类型转换</h3><p>而operator算子的隐式类型转换则是相反的，例如以下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test1</span>&#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">	    Test1(<span class="type">int</span> value):_value(value)&#123;</span><br><span class="line">   </span><br><span class="line">	        cout&lt;&lt;<span class="string">&quot;constructor&quot;</span>&lt;&lt;endl;</span><br><span class="line">	    &#125;</span><br><span class="line">	    ~Test1()&#123;</span><br><span class="line">   </span><br><span class="line">	        cout&lt;&lt;<span class="string">&quot;destructor&quot;</span>&lt;&lt;endl;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span>&#123;</span><br><span class="line">   </span><br><span class="line">	        <span class="keyword">return</span> _value;</span><br><span class="line">	    &#125;</span><br><span class="line">	    bool <span class="title function_">operator</span><span class="params">()</span> (<span class="type">int</span> x) const&#123;</span><br><span class="line">   	<span class="comment">//重载括号</span></span><br><span class="line">	        cout&lt;&lt;<span class="string">&quot;() is overload&quot;</span>&lt;&lt;endl;</span><br><span class="line">	        <span class="keyword">return</span> x &gt; _value;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="comment">//operator在返回类型前面（区分重载），string是返回类型</span></span><br><span class="line">	    operator <span class="title function_">string</span><span class="params">()</span>&#123;</span><br><span class="line">   	<span class="comment">//operator算子隐式类型转换</span></span><br><span class="line">	        cout&lt;&lt;<span class="string">&quot;type convert&quot;</span>&lt;&lt;endl;</span><br><span class="line">	        stringstream sstr;</span><br><span class="line">	        sstr&lt;&lt;_value;</span><br><span class="line">	        <span class="keyword">return</span> sstr.str();</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">	    <span class="type">int</span> _value;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">   </span><br><span class="line">    Test1 <span class="title function_">t</span><span class="params">(<span class="number">10</span>)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">if</span>(t(<span class="number">5</span>))</span><br><span class="line">        cout&lt;&lt;i&lt;&lt;<span class="string">&quot; is greater than &quot;</span>&lt;&lt;t.getValue()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;i&lt;&lt;<span class="string">&quot; is less than &quot;</span>&lt;&lt;t.getValue()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    string <span class="title function_">str</span><span class="params">(t)</span>; <span class="comment">// 将Test1类型转换为string类型</span></span><br><span class="line">    cout&lt;&lt;str&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Test1类型的对象传入string的构造函数，是用了c++构造函数的隐式类型转换特性，虽然string类并没有显式定义参数为Test1的构造函数，但因为其可以隐式转换为string，所以语法上都是合法的。</p>
<p>构造函数的隐式类型转换，是使用一个其他的类型构造当前类的临时对象并用此临时对象来构造当前对象，这种转换必须有构造函数的支持；</p>
<p>operator算子的隐式类型转换，使用当前对象去生成另一个类型的对象（正好与构造函数隐式转换相反），这种转换必须有operator算子的支持。</p>
<p>当然了，构造函数的隐式类型转换有利有弊，类的设计者就起决定性作用了，如果你不想让构造函数发生隐式的类型转换，请在构造函数前加explicit关键字；同时，operator算子声明的隐式类型转换也可以通过一些相应的返回值函数替代，用户的掌控性更好。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>01字典树</tag>
      </tags>
  </entry>
  <entry>
    <title>缓冲区浅析</title>
    <url>/posts/aed25912.html</url>
    <content><![CDATA[<h2 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h2><p>程序运行输入数据时，从键盘的输入先存储到缓冲区，只有当缓冲区满或者输入回车时程序才会真正地从缓冲区读入数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">	<span class="type">int</span> a, b;</span><br><span class="line">	cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>in: 1 2\n 例如这里输入空格时程序没有输出，而是将空格也放入了缓冲区，只有输入回车时，程序才从缓冲区中拿出数据，而<strong>cin遇到回车、空格、tab时会停止读入</strong>，首先拿出1，遇到空格，停止读入，但<strong>空格并未被处理，依旧在缓冲区</strong>，所以下次读入时，先碰到空格，cin会舍弃 <em>刚开始碰到的</em> <strong>空白字符（空格、tab、回车）</strong>，读入2，遇到回车，停止读入，但回车依旧在缓冲区 对于上面话的理解可以看下面代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	cin &gt;&gt; a;</span><br><span class="line">	<span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> getchar();</span><br><span class="line">	cout &lt;&lt; c;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>in_1:1空格回车 in_2:1回车 两种输入方式输出内容不一样，第二种多输出了一个空白行</p>
<p>这篇文章只是浅析缓冲区，缓冲区具体分为三种，全缓冲、行缓冲、不带缓冲，深入理解自行查阅资料</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>01字典树</tag>
      </tags>
  </entry>
  <entry>
    <title>指针笔记（指针数组和指向数组的指针，数组中a和&amp;a的区别等）</title>
    <url>/posts/23a3191d.html</url>
    <content><![CDATA[<h2 id="指针数组和指向数组的指针"><a href="#指针数组和指向数组的指针" class="headerlink" title="指针数组和指向数组的指针"></a>指针数组和指向数组的指针</h2><p>int <em>p[4]和int (</em>p)[4]有何区别？ 前者是一个指针数组，数组大小为4，每一个元素都是一个指向int的指针 后者是指向int[4]类型数组的指针 <img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/43a71c451b20467fac3fc113d84a02e1.png" alt="img"> 以上代码若运行会报如下错误 <img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/05e85d7085f640cfa68b4e2d5794719e.png" alt="img"> main函数中定义的a数组本质是一个指向int[2]的指针，而函数形参则是一个指针数组，即形参的a是一个二维指针，所以会报错类型不匹配 若将形参改为int (*a)[2]则编译通过</p>
<h2 id="数组中a和-amp-a的区别"><a href="#数组中a和-amp-a的区别" class="headerlink" title="数组中a和&amp;a的区别"></a>数组中a和&amp;a的区别</h2><p>假如a是一个一维数组，输出a和&amp;a发现结果相同，都是一维数组首元素的地址，但两者虽然值相同，却是不同的 <img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/9057c28b1d0d4acdbfaa1d2ccb9b0b0b.png" alt="img"> 这段代码是没问题的，但若将第二行的&amp;a改为a，则会报错 <img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/3667b35f35634f0db37c9078454c7fcf.png" alt="img"> 即编译器认为a是int <em>类型的，而&amp;a则是int (</em> )[4]类型的，用大白话讲就是&amp;a编译器可以认出a是一个数组，a则不行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#include <span class="string">&quot;stdio.h&quot;</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line"> <span class="type">int</span> a[<span class="number">5</span>] = &#123;</span><br><span class="line">    <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line"> <span class="type">int</span> *ptr = (<span class="type">int</span> *)(&amp;a + <span class="number">1</span>);</span><br><span class="line"> printf(<span class="string">&quot;%d,%d&quot;</span>, *(a + <span class="number">1</span>), *(ptr - <span class="number">1</span>));</span><br><span class="line"> <span class="comment">/*getchar是用VS编写方便查看输出*/</span></span><br><span class="line"> getchar();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请思考一下上面的输出结果，如果你非常自信了，可以不用往下看 这个题目主要考察&amp;a 和 a</p>
<ul>
<li>a 在这里代表是的数组首元素的地址即 a[0]的首地址，其值为 0x005efda0。 </li>
<li>&amp;a 代表的是数组的首地址，其值为 0x005efda0。 </li>
<li>a+1 的值是 0x005efda0+1*sizeof（int），等于 0x005efda4。 </li>
<li>&amp;a+1 的值是（0x005efda0 +（sizeof（a）= 5*sizeof(int)）= 0x005efdb4 {0xcccccccc, 0xcb626a90, 0x005efdd0, 0x0029200e, 0x00000001}</li>
</ul>
<h2 id="二级指针"><a href="#二级指针" class="headerlink" title="二级指针"></a>二级指针</h2><blockquote>
<p>指向指针的指针</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一些常用的头文件</span></span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">通过引用直接去修改数组里的元素</span></span><br><span class="line"><span class="comment">小技巧：函数写在主函数（main）前面，就不用写函数声明了</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">SetArray</span><span class="params">(<span class="type">int</span> row,<span class="type">int</span> col,<span class="type">int</span>** &amp;Array)</span>&#123;</span><br><span class="line">   <span class="comment">//&amp;是引用符号，得到的是指针地址</span></span><br><span class="line"><span class="comment">//二维指针需要通过一维指针去指向数组</span></span><br><span class="line">	Array = <span class="keyword">new</span> <span class="title class_">int</span>*[row]; <span class="comment">//开辟行空间</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; row;i++)&#123;</span><br><span class="line">   </span><br><span class="line">		Array[i] = <span class="keyword">new</span> <span class="title class_">int</span>[col]; <span class="comment">//开辟列空间</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; col;j++)&#123;</span><br><span class="line">   </span><br><span class="line">			Array[i][j]  = <span class="number">0</span>;<span class="comment">//初始化，也可以将其他数组或是值存进去</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印数组里的内容</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">PrintArray</span><span class="params">(<span class="type">int</span>** Array,<span class="type">int</span> row,<span class="type">int</span> col)</span>&#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; row;i++)&#123;</span><br><span class="line">   </span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; col;j++)&#123;</span><br><span class="line">   </span><br><span class="line">			cout &lt;&lt; Array[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//内存释放：开辟的数组空间用完必须要手动释放，不然会爆内存</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">DeleteArray</span><span class="params">(<span class="type">int</span>** Array,<span class="type">int</span> row)</span>&#123;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; row;i++)&#123;</span><br><span class="line">   </span><br><span class="line">		delete[] Array[i];</span><br><span class="line">	&#125;</span><br><span class="line">	delete Array;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">   </span><br><span class="line">	<span class="type">int</span>** Array = NULL;</span><br><span class="line">	<span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> col = <span class="number">3</span>;</span><br><span class="line">	SetArray(row,col,Array);</span><br><span class="line">	PrintArray( Array,row,col);</span><br><span class="line">	DeleteArray(Array,row);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>01字典树</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客练习赛-C-梦迹</title>
    <url>/posts/82361365.html</url>
    <content><![CDATA[<h2 id="题目：梦迹"><a href="#题目：梦迹" class="headerlink" title="题目：梦迹"></a>题目：梦迹</h2><p>这道题和用树状数组求逆序对那道题目类似，都是把数组值作为树状数组下标，效果等价于权值线段树，本质上是一道树状数组的简单题。 每一个数字为答案的贡献等于getsum(W-num) 因此修改数字时就可以先减去修改前的贡献，加上修改后的贡献，树状数组的维护上，如果数字从a变为b，就把a位置加上-1，b位置加上1即可 考虑答案是否爆int，最差情况是n*(n-1)/2，到1e10，开longlong，其次注意树状数组下标从1开始，而题目a[i]从0开始，因此加上值为1的偏移量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">#define ios ios::sync_with_stdio(<span class="number">0</span>);cin.tie(<span class="number">0</span>);cout.tie(<span class="number">0</span>)</span><br><span class="line">#define endl <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">#define <span class="type">int</span> <span class="type">long</span> <span class="type">long</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">const <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N], tr[N];</span><br><span class="line"><span class="type">int</span> n, q, W;</span><br><span class="line"><span class="type">int</span> <span class="title function_">lowbit</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">modify</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">   </span><br><span class="line">	i ++;</span><br><span class="line">	<span class="keyword">while</span>(i &lt; N) &#123;</span><br><span class="line">   </span><br><span class="line">		tr[i] += val;</span><br><span class="line">		i += lowbit(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getsum</span><span class="params">(<span class="type">int</span> pos)</span> &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	pos ++;</span><br><span class="line">	<span class="keyword">while</span>(pos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">   </span><br><span class="line">		res += tr[pos];</span><br><span class="line">		pos -= lowbit(pos);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">solve</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">	cin &gt;&gt; n &gt;&gt; q &gt;&gt; W;</span><br><span class="line">	<span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">   </span><br><span class="line">		cin &gt;&gt; a[i];</span><br><span class="line">		modify(a[i], <span class="number">1</span>);</span><br><span class="line">		ans += getsum(W - a[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(q --) &#123;</span><br><span class="line">   </span><br><span class="line">		<span class="type">int</span> p, x;</span><br><span class="line">		cin &gt;&gt; p &gt;&gt; x;</span><br><span class="line">		ans -= getsum(W - a[p]);</span><br><span class="line">		modify(a[p], -<span class="number">1</span>);</span><br><span class="line">		modify(x, <span class="number">1</span>);</span><br><span class="line">		ans += getsum(W - x);</span><br><span class="line">		a[p] = x;</span><br><span class="line">		cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125; </span><br><span class="line">signed <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">   </span><br><span class="line">	ios;</span><br><span class="line">	<span class="type">int</span> T;</span><br><span class="line">	T = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(T --) &#123;</span><br><span class="line">   </span><br><span class="line">	    solve();</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>01字典树</tag>
      </tags>
  </entry>
  <entry>
    <title>C++转载的文章</title>
    <url>/posts/d0810907.html</url>
    <content><![CDATA[<p> <a href="https://coolshell.cn/articles/12176.html">C++对象的内存布局</a>  <a href="https://coolshell.cn/articles/12165.html#%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8">C++虚函数表解析</a>  <a href="https://blog.csdn.net/weixin_50866517/article/details/113247374">C++函数指针</a>  <a href="https://www.shuzhiduo.com/A/RnJWOgMvJq/">C++动态绑定和静态绑定</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>01字典树</tag>
      </tags>
  </entry>
  <entry>
    <title>环境配置-转载的文章</title>
    <url>/posts/f4a92650.html</url>
    <content><![CDATA[<h2 id="1-opencv-qt-MinGW"><a href="#1-opencv-qt-MinGW" class="headerlink" title="1. opencv+qt+MinGW"></a>1. opencv+qt+MinGW</h2><p> <a href="https://cxymm.net/article/f9547064141/112427355">click here</a></p>
<h2 id="2-CLion-opencv"><a href="#2-CLion-opencv" class="headerlink" title="2. CLion+opencv"></a>2. CLion+opencv</h2><p> <a href="https://www.jianshu.com/p/cf56d771a934">click here</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM冷知识</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序-防止退化O(n2)(三路排序)</title>
    <url>/posts/be43ae97.html</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p> <a href="https://leetcode.cn/problems/sort-an-array/">click here</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="传统快速排序"><a href="#传统快速排序" class="headerlink" title="传统快速排序"></a>传统快速排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span> ;</span><br><span class="line">	<span class="type">int</span> <span class="variable">bas</span> <span class="operator">=</span> a[l];</span><br><span class="line">	<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l, j = r;</span><br><span class="line">	<span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">   </span><br><span class="line">		<span class="keyword">while</span>(i &lt; j &amp;&amp; a[j] &gt;= bas) j --;</span><br><span class="line">		a[i] = a[j];</span><br><span class="line">		<span class="keyword">while</span>(i &lt; j &amp;&amp; a[i] &lt;= bas) i ++;</span><br><span class="line">		a[j] = a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	a[i] = bas;</span><br><span class="line">	quickSort(a, l, i-<span class="number">1</span>);</span><br><span class="line">	quickSort(a, i+<span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Hack数据1"><a href="#Hack数据1" class="headerlink" title="Hack数据1"></a>Hack数据1</h3><p>严格单调有序的数组 时间复杂度会退化为O(n2) 解决方案：随机化数组或者随机取基准值（而非第一个）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> l + rand() % (r - l + <span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">bas</span> <span class="operator">=</span> a[id];</span><br></pre></td></tr></table></figure>
<h3 id="Hack数据2"><a href="#Hack数据2" class="headerlink" title="Hack数据2"></a>Hack数据2</h3><p>所有数据都相等的数组 时间复杂度会退化为O(n2) 解决方案： <a href="https://blog.csdn.net/Tanyongyin/article/details/114841898">三路排序（详解点击）</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> l + rand()%(r - l + <span class="number">1</span>);</span><br><span class="line">    swap(&amp;a[l], &amp;a[index]);</span><br><span class="line">	<span class="type">int</span> <span class="variable">bas</span> <span class="operator">=</span> a[l];</span><br><span class="line">	<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l, j = r, k = l + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(k &lt;= j) &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">if</span>(a[k] == bas) k ++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[k] &lt; bas) &#123;</span><br><span class="line">   </span><br><span class="line">            swap(&amp;a[k], &amp;a[i]);</span><br><span class="line">            i ++;</span><br><span class="line">            k ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">            swap(&amp;a[k], &amp;a[j]);</span><br><span class="line">            j --;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	quickSort(a, l, i-<span class="number">1</span>);</span><br><span class="line">	quickSort(a, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>* sortArray(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span>* returnSize)&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    quickSort(nums, <span class="number">0</span>, numsSize-<span class="number">1</span>);</span><br><span class="line">    *returnSize = numsSize;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM冷知识</tag>
      </tags>
  </entry>
  <entry>
    <title>高并发浅析</title>
    <url>/posts/565b1d4d.html</url>
    <content><![CDATA[<h2 id="什么是高并发"><a href="#什么是高并发" class="headerlink" title="什么是高并发"></a>什么是高并发</h2><p>高并发指通过设计保证系统能够同时并行处理很多请求，是分布式系统非常重要的概念 评价分布式系统性能的指标有：</p>
<ol>
<li>响应时间：系统对请求做出响应的时间。 </li>
<li>吞吐量：单位时间内处理的请求数量。 </li>
<li>QPS（和吞吐量基本没啥区别）：每秒响应请求数。 </li>
<li>并发用户数：同时承载正常使用系统功能的用户数量。</li>
</ol>
<h2 id="水平扩容和垂直扩容"><a href="#水平扩容和垂直扩容" class="headerlink" title="水平扩容和垂直扩容"></a>水平扩容和垂直扩容</h2><p>那么如何实现高并发呢？ <img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/d6b7cf1a63604dc78036ceeb79fd1d34.png" alt="img"> 上图都是实现高并发的方法，而这里只介绍水平扩容和垂直扩容</p>
<h3 id="垂直扩容"><a href="#垂直扩容" class="headerlink" title="垂直扩容"></a>垂直扩容</h3><p>这是过去一直在使用并且可以马上见效的方法，但是缺点也很致命，垂直扩容有两种方案</p>
<ol>
<li>提升单机硬件配置 例如：增加CPU核数如32核，升级更好的网卡如万兆，升级更好的硬盘如SSD，扩充硬盘容量如2T，扩充系统内存如128G； <li>改善单机架构 例如：使用Cache来减少IO次数，使用异步来增加单服务吞吐量，使用无锁数据结构来减少响应时间； 但是这种方式势必会受到科技的限制，性能有极限，如果想突破这种极限，实现线性上升，就需要水平扩容</li>

</li>
</ol>
<h3 id="水平扩容"><a href="#水平扩容" class="headerlink" title="水平扩容"></a>水平扩容</h3><p>增加服务器数量，把请求尽量均匀地分配到各个服务器上，这也是分布式系统的目标。 举个例子，通常一个域名绑定一个IP，而一个IP对应一个服务器，当很多用户访问，响应速度会变慢，而采用nginx反向代理，把域名绑定到多个IP，利用dns轮询技术实现均衡负载，可以显著提高响应速度，而且没有极限</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM冷知识</tag>
      </tags>
  </entry>
  <entry>
    <title>Git如何推送当前代码到远程仓库</title>
    <url>/posts/d98274c.html</url>
    <content><![CDATA[<h2 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h2><p>（建立在已经配置好用户变量和ssh基础上） 在本地创建git仓库</p>
<blockquote>
<p>git init</p>
</blockquote>
<p>绑定远程仓库，origin是给远程仓库起的别名，也可以起其他名字，但是如果用origin，git push时可以不指出名字，如果用其他名字需要指出名字，git push 名字</p>
<blockquote>
<p>git remote add origin git@github.com:<strong><em>*</em></strong>/test.git</p>
</blockquote>
<p>提交到暂存区，提交所有文件</p>
<blockquote>
<p>git add .</p>
</blockquote>
<p>从暂存区提交到本地仓库</p>
<blockquote>
<p>git commit -m “time”</p>
</blockquote>
<p>从本地仓库推送到远程仓库</p>
<blockquote>
<p>git push</p>
</blockquote>
<h2 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h2><p>与第一种方法不同的只有绑定远程仓库的方法不同</p>
<blockquote>
<p>git clone [远程仓库地址]</p>
</blockquote>
<p>之后的步骤一样，git add. git commit git push</p>
<h2 id="工作区、暂存区、版本库、远程仓库"><a href="#工作区、暂存区、版本库、远程仓库" class="headerlink" title="工作区、暂存区、版本库、远程仓库"></a>工作区、暂存区、版本库、远程仓库</h2><p><img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/587813a177974bbcb166f2fa91cd3b39.png" alt="img"> workspace: 工作区 staging：暂存区 local repository：本地仓库（版本库） remote repository：远程仓库</p>
<h2 id="本地分支名字必须和远程分支名字一样"><a href="#本地分支名字必须和远程分支名字一样" class="headerlink" title="本地分支名字必须和远程分支名字一样"></a>本地分支名字必须和远程分支名字一样</h2><p>本地分支名字必须和远程分支名字一样才能push成功，现在GitHub默认分支为main，而git默认分支为master，这样push上去后GitHub就有两个分支，可以去GitHub把默认分支修改为master</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="查看本地分支"><a href="#查看本地分支" class="headerlink" title="查看本地分支"></a>查看本地分支</h3><p>git branch</p>
<h3 id="创建本地分支"><a href="#创建本地分支" class="headerlink" title="创建本地分支"></a>创建本地分支</h3><p>git branch [name]</p>
<h3 id="修改本地分支名字"><a href="#修改本地分支名字" class="headerlink" title="修改本地分支名字"></a>修改本地分支名字</h3><p>git branch -m [src] [dst]</p>
<h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><p>git checkout [分支名]</p>
<h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><p>git branch -d [分支名]</p>
<h3 id="查看当前状态"><a href="#查看当前状态" class="headerlink" title="查看当前状态"></a>查看当前状态</h3><p>git status</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM冷知识</tag>
      </tags>
  </entry>
  <entry>
    <title>select、poll、epoll（IO多路复用）</title>
    <url>/posts/bc5cfa75.html</url>
    <content><![CDATA[<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>三个模型都是用来判断是否有被监听的socket状态发生改变（读写和异常）</p>
<h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p>首先介绍一下fd_set这个数组，这其实是一个类图，其中每一位表示一个socketfd，哪一位是1表示这一位对应的socket就是被监听的，有三种需要监听的状态，所以就有三个数组，分别是readset，writeset、exceptset，分别监听读写和异常 select原型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> maxfd, fd_set* readset, fd_set* writeset, fd_set* exceptset, </span></span><br><span class="line"><span class="params">const struct timeval* timeout)</span>;&gt;</span><br></pre></td></tr></table></figure>
<ol>
<li>maxfd表示监听的最大fd（给定了范围） </li>
<li>三种状态的数组 </li>
<li>timeout表示超时时间，当timeout是NULL表示select只有监听到状态发生变化才会结束否则被阻塞，timeout是0表示select非阻塞，立刻返回，timeout&gt;0（数据结构内部有int）表示过一定时间后若还未检测到状态变化就结束 </li>
<li>返回值为状态变化的fd数量，若返回-1表示错误</li>
</ol>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>select采用轮询的方法，遍历fd_set的每一位，检查此socket是否有状态变化，若有变化就把这一位置为1，否则置为0，这样操作之后fd_set表示的意义也从“所有socket的列表”变为了“发生状态变化的socket列表”，接下来只需要遍历这个列表即可处理每一种状态，例如有一个socket有读的需求，则遍历到列表中这个fd时就可以调用read函数，当然由于socketfd意义发生变化，每次select前都需要提前备份一下fd_set，之后每次select后再次select，恢复到备份，这样才能保证每一个监听的fd都被遍历到，还需要注意的时timeout每次也需要重置，当select提前结束，此时timeout会变成剩余的时间，下次select需要重新指定</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>由于select采用轮询的方式，而每次发生状态变化的fd只有几个，更多是非活跃状态的fd，遍历全部花费了太多时间 </li>
<li>fd_set内部有最大限制，32位OS最大1024，62位最大2048</li>
</ol>
<h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><p>poll只优化了select的几个点</p>
<ol>
<li>poll采用了新的数据结构代替了fd_set，是一个链表，所以最大限制的说法就不复存在了 </li>
<li>poll返回值为活跃状态的fd链表，而没有修改监听链表，这样就不需要每次恢复到备份了 但是poll还是采用轮询的方式，效果依旧很差</li>
</ol>
<h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>epoll内部采用了红黑树和链表的方式彻底解决了以上问题</p>
<ol>
<li>红黑树保存所有带监听的fd，不需要像轮询那样遍历许多非监听的fd </li>
<li>突破了最大限制 epoll会把发生事件的fd放到链表中，只需遍历链表即可处理每一个事件</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM冷知识</tag>
      </tags>
  </entry>
  <entry>
    <title>红黑树介绍</title>
    <url>/posts/c9f4dad.html</url>
    <content><![CDATA[<p>红黑树就是满足以下特性的二叉树</p>
<ol>
<li>所有节点只有红色和黑色 </li>
<li>红色节点的孩子都是黑色（红色节点不能相邻） </li>
<li>黑色节点到任意叶子节点的简单路径上经过的黑色节点数量相同 </li>
<li>叶子节点不存储值，而且叶子节点都是黑色的 满足这样特性的二叉树高度一定不超过2log(n+1) 下面是证明 如果把红色节点全部删掉，把下面的剩下的所有节点都连接在一起，那么新产生的树就是一颗每个节点最多有四个子节点的树，计算高度可以采用满四叉树的高度来近似计算，即log(n)，而把删除的红色节点加上就是2倍</li>
</ol>
<p>红黑树相较于AVL，其查找效率略低一点，而插入删除效率高出AVL很多，所以当插入删除操作很多时可以使用红黑树</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM冷知识</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt 桌面闹钟提示小程序</title>
    <url>/posts/b3acc6d2.html</url>
    <content><![CDATA[<h2 id="程序运行截图"><a href="#程序运行截图" class="headerlink" title="程序运行截图"></a>程序运行截图</h2><p>倒计时 <img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/5859b6f410aa4b63a2f0c6ebbaf30ea1.png" alt="img"> 闹钟设置界面 <img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/8bdbe197d525459c921f1591001348d9.png" alt="img"> 闹钟弹窗提示+提示音 <img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/d987e900e87345ac9e5a1d62b3dee75c.png" alt="img"></p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p> <a href="https://gitee.com/uncleacc/clock">gitee源码链接</a>  <a href="https://gitee.com/uncleacc/clock-program/releases/tag/1.0">软件打包</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM冷知识</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-寻找两个正序数组的中位数</title>
    <url>/posts/ab7be2e3.html</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p> <a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/">click here</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>此题目是寻找两个数组组合为一个数组后的中位数，我们知道两个数组的长度，中位数是组合后的数组第几个数字我们是知道的，问题就转化为了寻找组合后数组的第k个数字，要求时间复杂度在<strong>log(n)</strong>，明显是二分，但是二分什么呢？一般都是二分两个数组，但这道题不同，需要二分的是k，对于两个数组而言，比较两个数组的第k/2个数字，小的一方前k/2个数字都不会是中位数，可以直接排除，从而快速缩小范围</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> nums1.size(), n = nums2.size();</span><br><span class="line">        <span class="type">int</span> <span class="variable">id1</span> <span class="operator">=</span> <span class="number">0</span>, id2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">   </span><br><span class="line">            <span class="keyword">if</span>(id1 == m) <span class="keyword">return</span> nums2[id2 + k - <span class="number">1</span>];<span class="comment">//边界</span></span><br><span class="line">            <span class="keyword">if</span>(id2 == n) <span class="keyword">return</span> nums1[id1 + k - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(k == <span class="number">1</span>) <span class="keyword">return</span> min(nums1[id1], nums2[id2]);</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> k / <span class="number">2</span>;<span class="comment">//二分</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">newid1</span> <span class="operator">=</span> min(id1 + len - <span class="number">1</span>, m - <span class="number">1</span>), newid2 = min(id2 + len - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(nums1[newid1] &lt; nums2[newid2]) &#123;</span><br><span class="line">   <span class="comment">//缩小范围</span></span><br><span class="line">                k -= newid1 - id1 + <span class="number">1</span>;</span><br><span class="line">                id1 = newid1 + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">                k -= newid2 - id2 + <span class="number">1</span>;</span><br><span class="line">                id2 = newid2 + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">findMedianSortedArrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> nums1.size(), len2 = nums2.size();</span><br><span class="line">        <span class="keyword">if</span>((len1 + len2) &amp; <span class="number">1</span>) <span class="keyword">return</span> find((len1 + len2) / <span class="number">2</span> + <span class="number">1</span>, nums1, nums2);</span><br><span class="line">        <span class="keyword">return</span> (find((len1 + len2) / <span class="number">2</span>, nums1, nums2) + find((len1 + len2)/<span class="number">2</span> + <span class="number">1</span>, nums1, nums2)) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM冷知识</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt 类似vscode和matlab的分屏显示效果</title>
    <url>/posts/4e9af57f.html</url>
    <content><![CDATA[<h2 id="运行截图"><a href="#运行截图" class="headerlink" title="运行截图"></a>运行截图</h2><p>向右分屏 <img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/d12ee987ffbe45ffb733304de299cdbf.png" alt="img"> 多分屏 <img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/744aa251f91a4112a2e6c5cf80d82adf.png" alt="img"> 全屏显示 <img src="C:\Users\60116\Desktop\img\68b7863013584ed097e8932f31b01566.png" alt="img"></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>实现了一个类似vscode和matlab的标签页显示分屏效果，支持鼠标拖拽分屏、全屏显示，可自适应调整大小，程序把要显示的Widget独立出来，可随时替换为其他的用户自定义Widget，例如3d模型、二维画图等</p>
<h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><ol>
<li>加载图片会非常卡，猜测是paintEvent频繁调用而每次绘制图片复杂度高导致 </li>
<li>分屏不能等分分屏，应该不难实现</li>
</ol>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p> <a href="https://gitee.com/uncleacc/qt-tab-page">gitee源码</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM冷知识</tag>
      </tags>
  </entry>
  <entry>
    <title>docker容器使用初体验</title>
    <url>/posts/de5ab824.html</url>
    <content><![CDATA[<p>我们写程序时，都会搭建相关的环境，比如写了一个web，使用了tomcat、nginx等，现在想要把程序部署到云服务器或者在其他电脑上运行，就需要重新部署一遍环境，尤其是项目开源后，上手成本大。</p>
<h2 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。 Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。 容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。 （来源于菜鸟教程）</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>docker依赖于linux内核，因此在windows系统中需要安装Hyper-V（类似于 VMWare 或 VirtualBox）或者WSL，然后进入docker desktop官网下载安装程序，双击运行即可。安装完成后可以在虚拟机中运行命令docker —version检查是否成功安装。</p>
<h3 id="镜像和容器的区别"><a href="#镜像和容器的区别" class="headerlink" title="镜像和容器的区别"></a>镜像和容器的区别</h3><p>Docker 中镜像（Image）和容器（Container）是两个核心概念，它们有以下主要区别：</p>
<ol>
<li>定义和用途： <ul> 
1. 镜像（Image）：镜像是一个只读的文件系统快照，它包含了一个应用程序及其运行环境所需的所有内容，包括代码、库、依赖项、配置等。镜像是用于创建容器的模板，可以看作是一个静态的、不可更改的应用程序打包。 
1. 容器（Container）：容器是一个运行时实例，它是基于镜像创建的，包含了应用程序及其所有依赖项的运行环境。容器可以被启动、停止、删除等，它提供了一个隔离的运行环境，使应用程序能够在不同的容器中运行，而不受主机环境的影响。 
</ul>  </li>
<li>可变性： <ul> 
4. 镜像是不可更改的，一旦创建就不能修改。如果需要对应用程序或环境进行更改，必须创建一个新的镜像。 
4. 容器是可变的，可以在运行时进行修改。你可以进入容器、安装软件、修改配置等，然后保存为新的镜像，以便将更改保存下来。 
</ul>  </li>
<li>生命周期： <ul> 
7. 镜像的生命周期是静态的，它存在于磁盘上并可以被多个容器实例使用。 
7. 容器的生命周期是动态的，它可以被创建、启动、停止和销毁。容器是临时的运行实体。 
</ul>  </li>
<li>资源消耗： <ul> 
10. 镜像通常占用磁盘空间，并且资源消耗较低，因为它们是静态的。 
10. 容器占用系统资源（CPU、内存等），因为它们正在运行应用程序和服务。 
</ul> 

</li>
</ol>
<p>总之，镜像是容器的模板，用于创建容器实例。容器是在镜像基础上运行的可执行实体，具有自己的运行时状态。Docker 的强大之处在于它允许你使用镜像来轻松创建、分发和管理容器，从而实现应用程序的隔离和可移植性。</p>
<h3 id="dockerhub"><a href="#dockerhub" class="headerlink" title="dockerhub"></a>dockerhub</h3><p>Docker Hub 是一个在线的 Docker 镜像仓库和容器注册表服务。它是 Docker 公司提供的官方服务，用于帮助开发人员和运维团队存储、分享和获取 Docker 镜像。Docker Hub 允许用户上传、存储和管理 Docker 镜像。这些镜像可以包含操作系统、应用程序、服务和其他容器化的组件，供其他用户下载和使用，类似于Github仓库。</p>
<p>如果要上传一个镜像，就需要编写dockerfile脚本文件，在这个文件中写入环境配置的命令行。</p>
<h3 id="docker和虚拟机区别"><a href="#docker和虚拟机区别" class="headerlink" title="docker和虚拟机区别"></a>docker和虚拟机区别</h3><p>Docker 和虚拟机是两种不同的虚拟化技术，它们在应用、资源消耗、启动时间和隔离等方面有一些重要区别。以下是 Docker 和虚拟机之间的主要区别： <strong>架构和隔离：</strong> Docker：Docker 使用容器技术，容器共享主机操作系统的内核，但在容器内部提供隔离的用户空间。这意味着容器之间共享操作系统内核，使其轻量且启动迅速。容器之间的隔离通过 Linux 内核的命名空间和控制组技术实现。 虚拟机：虚拟机是完全虚拟化的技术，每个虚拟机都运行自己的操作系统内核。这意味着虚拟机需要更多的资源，并且启动速度较慢，因为它们需要模拟整个操作系统。 <strong>资源消耗：</strong> Docker：由于容器共享主机操作系统的内核，所以 Docker 容器通常比虚拟机更轻量，需要较少的内存和存储资源。 虚拟机：虚拟机通常需要更多的资源，因为每个虚拟机都包含自己的操作系统内核和系统文件。 <strong>启动时间：</strong> Docker：Docker 容器可以在几秒内启动，因为它们不需要启动整个操作系统内核。 虚拟机：虚拟机通常需要更长的时间来启动，因为它们需要模拟和启动整个操作系统。 <strong>应用部署和管理：</strong> Docker：Docker 容器的部署和管理相对简单，可以使用 Docker Compose 和 Kubernetes 等工具来自动化管理多个容器。 虚拟机：虚拟机的部署和管理相对复杂，需要使用虚拟化管理工具来创建、配置和监视虚拟机。 <strong>跨平台支持：</strong> Docker：Docker 容器可以在不同的操作系统上运行，前提是它们都支持 Docker。 虚拟机：虚拟机通常需要适用于特定虚拟化平台的映像，并且不太容易跨平台移植。 <strong>隔离性：</strong> Docker：容器提供了一定程度的隔离，但不如虚拟机隔离得严格。容器之间可以共享操作系统内核，这意味着一些攻击可能会影响多个容器。 虚拟机：虚拟机提供了更强的隔离性，每个虚拟机都有独立的内核和资源，攻击一个虚拟机不会影响其他虚拟机。 根据你的需求和用例，你可以选择使用 Docker 或虚拟机来虚拟化和隔离应用程序。Docker 更适合轻量级、可扩展的应用程序，而虚拟机通常更适合需要更严格隔离或运行不同操作系统的应用程序。在实际应用中，有时也会同时使用 Docker 和虚拟机，以充分利用它们各自的优势。</p>
<h3 id="更改镜像源"><a href="#更改镜像源" class="headerlink" title="更改镜像源"></a>更改镜像源</h3><p>docker默认镜像源速度很慢，可以更改为以下镜像源：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;registry-mirrors&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;https://registry.hub.docker.com&quot;</span>,</span><br><span class="line">        <span class="string">&quot;http://hub-mirror.c.163.com&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://registry.docker-cn.com&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>可以将代码拉取到虚拟机本地，然后把代码上传到docker，进入容器，执行代码，参考以下命令</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">拉取代码</span><br><span class="line">git clone https:<span class="comment">//github.com/oceanbase/miniob.git </span></span><br><span class="line">挂载方式新建一个新容器，-v表示挂载，：前面表示本地文件目录，：后面表示你要在docker 容器中挂载的位置（随意，没有该目录也会新建）</span><br><span class="line">docker run -it -v /usr/lyjps/miniob:/lyjps oceanbase/miniob </span><br><span class="line">执行下面的命令进入容器，并创建bash终端，此时就可以使用Linux终端方式进行一些开发工作</span><br><span class="line">docker exec -it miniob bash</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM冷知识</tag>
      </tags>
  </entry>
  <entry>
    <title>函数对象以及labbda表达式浅析</title>
    <url>/posts/fc600b6.html</url>
    <content><![CDATA[<h2 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h2><p>函数对象就是仿函数，之所以叫仿函数，是因为使用起来书写形式和调用函数的代码形式很像，之所以叫函数对象，是因为本shi质还是个对象，只不过写这个类是为了使用类似函数的功能。 仿函数就是重载了括号，例如以下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span>&#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="type">int</span> cnt;</span><br><span class="line">		<span class="keyword">void</span> <span class="title function_">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">   </span><br><span class="line">			cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">			++ cnt;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">	myPrint func;</span><br><span class="line">    func(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//    myPrint()(2);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>myPrint类声明的对象就是函数对象，func()本质上是调用成员函数func.operator()(2)，但是由于经过运算符重载后也可以写成func(2)，形式就像是调用函数一样，所以称为函数对象 和普通的函数相比，有很多好处</p>
<ol>
<li>可以在内部保存状态，例如这里cnt记录了函数调用次数 </li>
<li>可以作为参数传递到其他函数（因为其内部有状态），类似函数指针</li>
</ol>
<h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><p>形式如下 其中返回类型可写可不写，编译器可以自动推断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[捕获变量](形参)-&gt;返回类型 &#123;</span><br><span class="line">   </span><br><span class="line">	函数体内容</span><br><span class="line">	<span class="keyword">return</span> 变量;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">	<span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">3</span>, n = <span class="number">4</span>;</span><br><span class="line">	<span class="type">auto</span> <span class="variable">func</span> <span class="operator">=</span> [&amp;m](<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b) &#123;</span><br><span class="line">   </span><br><span class="line">		<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a;</span><br><span class="line">		a = b;</span><br><span class="line">		b = temp;</span><br><span class="line">		m = <span class="number">10</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">	func(a, b);</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; m &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>捕获变量有几种形式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">lambda表达式，从闭包作用域捕获变量而获得状态，分为传值和传引用。</span><br><span class="line">捕获变量登记与函数对象中的示例数据成员。</span><br><span class="line"> [=] 值捕获所有变量</span><br><span class="line"> [&amp;] 引用捕获所有变量</span><br><span class="line"> [&amp;x] 引用捕获x变量</span><br><span class="line"> [x]  值捕获x</span><br><span class="line"> [=,&amp;x] 默认值捕获，x变量通过引用捕获</span><br><span class="line"> [&amp;,x] 默认引用捕获，x通过值捕获</span><br><span class="line"> [<span class="built_in">this</span>] 捕获当前对象，可访问所有共有成员，C++<span class="number">20</span>中不允许隐式捕获<span class="built_in">this</span></span><br><span class="line"> [=,x],[&amp;,&amp;x] 错误，重复指定</span><br><span class="line"> 注意：即便默认要值捕获，全局变量总是使用引用捕获</span><br><span class="line"> 使用初始化捕获表达式表达move捕获</span><br></pre></td></tr></table></figure>
<p>值捕获的变量默认是const不可修改的，如果需要修改，则需要将lambda匿名函数对象用mutable修饰</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">	<span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">	<span class="type">auto</span> <span class="variable">func</span> <span class="operator">=</span> [m]() mutable&#123;</span><br><span class="line">   </span><br><span class="line">		m = <span class="number">2</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM冷知识</tag>
      </tags>
  </entry>
  <entry>
    <title>explicit关键字</title>
    <url>/posts/58412853.html</url>
    <content><![CDATA[<h2 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a>explicit</h2><blockquote>
<p>作用: 防止隐式类型转换</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span> &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">double</span> real, imag;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		Complex()&#123;</span><br><span class="line">   </span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		Complex(<span class="type">double</span> _r, <span class="type">double</span> _i): real(_r), imag(_i) &#123;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">   </span><br><span class="line">	<span class="type">Complex</span> <span class="variable">t</span> <span class="operator">=</span> &#123;</span><br><span class="line">   <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码不会报错，因为t = {1, 2}这里发生了隐式类型转换，将{1, 2}转化为了Complex(1, 2)，产生了一个匿名对象，然后把匿名对象赋值给t(这种赋值只是简单的值拷贝操作，假如存在指针，这种操作有浅拷贝的隐患) 但如果在构造函数前面加上explicit关键字，以上代码无法通过编译，因为explicit不允许隐式类型转换，等号右边的类型与左边的类型不符，则编译失败</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM冷知识</tag>
      </tags>
  </entry>
  <entry>
    <title>每日一题-动态规划(从不同类型的物品中各挑选一个，使得最后花费总和等于1000)</title>
    <url>/posts/a6596b9.html</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/189fa5e92dcf4e3482717f3905171ca3.jpeg" alt="img"> 四种类型的物品，每一种类型物品数量都是n，先要从每种类型的物品中挑选一件，使得最后花费总和等于1000 暴力做法10000^4 看到花费总和是1000，很小且固定的数字，肯定有玄机，从这里想应该是用dp，不难想到用dp[i][j]表示前i种类型的物品花费为j的方案数量，思考转移方程： dp[i][j] = dp[i-1][j-A] * js[i][A]，js[i][A]表示i类型的物件花销为A的方案数量，如此只需要枚举j和A，它们的范围就是1000以内</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#define ios ios::sync_with_stdio(<span class="number">0</span>);cin.tie(<span class="number">0</span>);cout.tie(<span class="number">0</span>)</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[<span class="number">5</span>][<span class="number">1100</span>], js[<span class="number">5</span>][<span class="number">11000</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ve[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">    ios;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">   </span><br><span class="line">    	<span class="type">int</span> a, b , c, d;</span><br><span class="line">    	cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;</span><br><span class="line">    	ve[<span class="number">1</span>].push_back(a);</span><br><span class="line">    	ve[<span class="number">2</span>].push_back(b);</span><br><span class="line">    	ve[<span class="number">3</span>].push_back(c);</span><br><span class="line">    	ve[<span class="number">4</span>].push_back(d);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++) &#123;</span><br><span class="line">   </span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; ve[i].size(); j++) &#123;</span><br><span class="line">   </span><br><span class="line">			js[i][ve[i][j]] ++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(auto p : ve[<span class="number">1</span>]) &#123;</span><br><span class="line">   </span><br><span class="line">		dp[<span class="number">1</span>][p] ++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= <span class="number">4</span>; i++) &#123;</span><br><span class="line">   </span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= <span class="number">1000</span>; j++) &#123;</span><br><span class="line">   </span><br><span class="line">			<span class="keyword">if</span>(js[i][j]) &#123;</span><br><span class="line">   </span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> j; k &lt;= <span class="number">1000</span>; k++) &#123;</span><br><span class="line">   </span><br><span class="line">					dp[i][k] += dp[i-<span class="number">1</span>][k-j] * js[i][j];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; dp[<span class="number">4</span>][<span class="number">1000</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">250 250 250 250</span></span><br><span class="line"><span class="comment">156 201 205 400</span></span><br><span class="line"><span class="comment">205 190 100 250</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM冷知识</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 笔记</title>
    <url>/posts/2da2039a.html</url>
    <content><![CDATA[<h3 id="四区"><a href="#四区" class="headerlink" title="四区"></a>四区</h3><ol>
<li>全局区 静态变量、全局变量、常量 <li>代码区 存储编写的代码，本质就是把代码编译形成的二进制文件放在内存的代码区</li> 
<li>栈区 形参、临时变量（由操作系统负责分配与回收）</li> 
<li>堆区 new的变量（由程序员负责分配与回收）</li>

</li>
</ol>
<h3 id="argc和argv"><a href="#argc和argv" class="headerlink" title="argc和argv"></a>argc和argv</h3><p>如果在命令行中编译运行C或C++文件，可能会传入某些参数，argc为参数的个数，argv为每一个参数的名称 main(int argc, char *argv[]) argv[0]为运行文件的目录地址（第一个参数） argv[1]为传入的第二个参数 … argv[argc-1]为传入的argc个参数 argv[argc]为NULL <img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/5eab799b38fd46d0b0edfca3ccf60cce.png" alt="img"> 图片中hello即为传入的第二个参数</p>
<h3 id="函数的分文件编写"><a href="#函数的分文件编写" class="headerlink" title="函数的分文件编写"></a>函数的分文件编写</h3><ol>
<li>把函数声明放在.h的头文件中 </li>
<li>把函数定义写在.cpp的函数文件中 </li>
<li>在main.cpp中包含了函数声明头文件即可直接使用此函数</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">swap.h</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span>;</span><br><span class="line"></span><br><span class="line">swap.cpp</span><br><span class="line">#include <span class="string">&quot;swap.h&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span> &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> *a;</span><br><span class="line">	*a = *b;</span><br><span class="line">	*b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main.cpp</span><br><span class="line">#include <span class="string">&quot;swap.h&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">	<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">	swap(&amp;a, &amp;b);</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数默认参数"><a href="#函数默认参数" class="headerlink" title="函数默认参数"></a>函数默认参数</h3><blockquote>
<p>若一个形参有默认参数，则此形参的右边所有参数都必须有默认参数，这是防止二义性的出现</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getRadius</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">2</span>, <span class="type">int</span> c = <span class="number">3</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//valid</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getRadius</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">2</span>, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="comment">//invalid</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="class结构"><a href="#class结构" class="headerlink" title="class结构"></a>class结构</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">class 类名 &#123;</span><br><span class="line">   </span><br><span class="line">	访问权限:</span><br><span class="line">		变量</span><br><span class="line">	访问权限:</span><br><span class="line">		方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>访问权限（默认是私有）:</p>
<ol>
<li>public 类内类外都可以访问 <li>protected 类内可以访问，类外不可以访问 派生类可以访问基类的protected，但是不可以访问private</li> 
<li>private 类内可以访问，类外不可以访问</li>

</li>
</ol>
<h3 id="class和struct的区别"><a href="#class和struct的区别" class="headerlink" title="class和struct的区别"></a>class和struct的区别</h3><p>c++的struct除了保留c的所有特性外，还增加了class的所有特性，两者只有一点不同，struct里面的属性默认是public，而class默认是private</p>
<h3 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h3><blockquote>
<p>构造函数：创建对象时会自动调用构造函数，构造函数（与函数名一致）若不定义则系统会默认创建一个空实现的构造函数<br> 析构函数：释放对象内存时会自动调用析构函数，在构造函数前面加上“~”即成为析构函数，若不定义则系统会默认创建一个空实现的析构函数</p>
</blockquote>
<p>析构函数通常用来释放类对象在堆区开辟的空间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">cicle</span> &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		cicle() &#123;</span><br><span class="line">   </span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;这里调用了构造函数&quot;</span> &lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//析构函数</span></span><br><span class="line">		~cicle() &#123;</span><br><span class="line">   </span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;这里调用了析构函数&quot;</span> &lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="拷贝函数"><a href="#拷贝函数" class="headerlink" title="拷贝函数"></a>拷贝函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">circle</span> &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="type">int</span> radius;</span><br><span class="line">		circle(const circle &amp;c) &#123;</span><br><span class="line">   	<span class="comment">//参数形式是固定的，只能这样写const类名 &amp;变量名</span></span><br><span class="line">			radius = c.radius;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;这里调用了拷贝函数&quot;</span> &lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建对象的三种方法"><a href="#创建对象的三种方法" class="headerlink" title="创建对象的三种方法"></a>创建对象的三种方法</h3><blockquote>
<p>如果创建了有参构造函数则不提供默认构造函数<br> 如果创建了拷贝构造函数则不提供其他构造函数</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">circle <span class="title function_">c</span><span class="params">(<span class="number">2</span>)</span>;	<span class="comment">//括号法 </span></span><br><span class="line"><span class="type">circle</span> <span class="variable">c</span> <span class="operator">=</span> circle(<span class="number">2</span>);	<span class="comment">//显示法（circle(2)创建了一个匿名对象），匿名对象会立刻被系统回收掉</span></span><br><span class="line"><span class="type">circle</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">2</span>;	<span class="comment">//隐式转化法（编译器将此语句变成circle c = circle(2)）</span></span><br></pre></td></tr></table></figure>
<h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h3><p>浅拷贝： 简单的变量赋值操作 深拷贝： 在堆区重新申请内存，用指针接受地址</p>
<p>浅拷贝存在的问题：如果在类中函数有申请堆区内存操作，假设创建了类c1，类中指针p接收了new出来的内存地址，又调用拷贝函数创建了c2，c2的p指针内容是由c1的p指针内容拷贝过来的，因此两者指针指向同一块内存区域，若此时c2调用了析构函数，将p指针指向的区域delete掉了，由于c1的p也指向此区域，所以当c1调用析构函数时，就会因为p1指针指向区域已经被释放掉而进行非法操作。解决办法是自定义拷贝函数，重新申请一块新区域，用p指针指向此区域，即深拷贝</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">circle</span> &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="type">int</span> *p;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		circle(<span class="type">int</span> a) &#123;</span><br><span class="line">   </span><br><span class="line">			p = <span class="keyword">new</span> <span class="title class_">int</span>(a);</span><br><span class="line">		&#125;</span><br><span class="line">		circle(const circle &amp;c) &#123;</span><br><span class="line">   	<span class="comment">//拷贝函数如果有new操作特别注意要深拷贝，浅拷贝会出问题</span></span><br><span class="line">			p = <span class="keyword">new</span> <span class="title class_">int</span>(*c.p);</span><br><span class="line">		&#125;</span><br><span class="line">		~circle() &#123;</span><br><span class="line">   		<span class="comment">//释放掉类中new的内存</span></span><br><span class="line">			<span class="keyword">if</span>(p) &#123;</span><br><span class="line">   </span><br><span class="line">				delete p;</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;调用成功&quot;</span> &lt;&lt; endl;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">circle</span> &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="type">int</span> aa, bb, cc;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		circle(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c): aa(a), bb(b), cc(c) &#123;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h3><p>静态成员变量</p>
<ol>
<li>所有对象共享同一份数据 </li>
<li>在编译阶段分配内存 </li>
<li>类内声明，类外初始化（必须）</li>
</ol>
<p>静态成员函数 4. 所有对象共享同一个函数 5. 静态成员函数只能访问静态成员变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">circle</span> &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">static</span> <span class="type">int</span> a;	<span class="comment">//类内声明</span></span><br><span class="line">		<span class="type">int</span> b;</span><br><span class="line">		<span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getB</span><span class="params">()</span> &#123;</span><br><span class="line">   	<span class="comment">//invalid，因为b是非静态变量</span></span><br><span class="line">			<span class="keyword">return</span> b;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> circle::a = <span class="number">1</span>; 	<span class="comment">//类外初始化</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">	circle c;</span><br><span class="line">	circle c2;</span><br><span class="line">	c2.a = <span class="number">3</span>;	<span class="comment">//c2和c共享一份a静态变量</span></span><br><span class="line">	cout &lt;&lt; c.a &lt;&lt; endl; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h3><p>this指针指向被调用的成员函数所指向的对象 this指针不需要定义，直接使用即可 this指针的用途</p>
<ol>
<li>当形参和成员变量同名时，可用this指针来区分 </li>
<li>在类的非静态成员函数中返回对象本身，可使用return *this（链式编程）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span> &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="type">int</span> age;</span><br><span class="line">		person(<span class="type">int</span> age) &#123;</span><br><span class="line">   </span><br><span class="line">			<span class="built_in">this</span>-&gt;age = age;	<span class="comment">//区分形参和成员变量</span></span><br><span class="line">			<span class="comment">//person::age = age;//这种形式也可以</span></span><br><span class="line">		&#125;</span><br><span class="line">		person&amp; addAge(<span class="type">int</span> age) &#123;</span><br><span class="line">   	<span class="comment">//注意返回引用才可以链式编程</span></span><br><span class="line">			<span class="built_in">this</span>-&gt;age += age;</span><br><span class="line">			<span class="keyword">return</span> *<span class="built_in">this</span>;	<span class="comment">//返回调用该函数的对象c</span></span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">	person c;</span><br><span class="line">	c.age = <span class="number">10</span>;</span><br><span class="line">	c.addAge(<span class="number">10</span>).addAge(<span class="number">10</span>).addAge(<span class="number">10</span>);	<span class="comment">//链式编程</span></span><br><span class="line">	cout &lt;&lt; c.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="常成员函数和常对象"><a href="#常成员函数和常对象" class="headerlink" title="常成员函数和常对象"></a>常成员函数和常对象</h3><blockquote>
<p>特例：<strong>mutable</strong>修饰的变量可以被常函数和常对象修改</p>
</blockquote>
<p>在普通成员函数后面括号后面加上const修饰就变成了常成员函数，常成员函数无法修改成员变量，通过两个规则保证</p>
<ol>
<li><strong>常成员函数不能更新对象的数据成员，也不能调用该类中没有用const修饰的成员函数</strong>。这保证了在常成员函数中绝对不会更新数据成员的值。 </li>
<li>如果将一个对象说明为常对象（const对象），<strong>则通过该常对象只能调用它的常成员函数</strong>，而不能调用其他成员函数。这是C++从语法机制上对 const对象 的保护，也是 const对象 唯一的对外接口方式。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span> &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="type">int</span> age;</span><br><span class="line">		<span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> const &#123;</span><br><span class="line">   	<span class="comment">//常成员函数 ，const本质上是在修饰this指针，更改成员变量本质上就是通过对this指针解引用实现 </span></span><br><span class="line"><span class="comment">//			this-&gt;age = age //invalid，不允许修改成员变量 </span></span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>定义对象语句前面加上const修饰即为常对象。 常对象只能调用常函数，无法修改常对象的成员变量和调用常对象的普通成员函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">const person <span class="title function_">p</span><span class="params">()</span>;	<span class="comment">//const修饰要初始化加上一个括号</span></span><br></pre></td></tr></table></figure>
<h3 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h3><blockquote>
<p>作用：让全局函数可以访问到类对象的私有变量和函数<br> 用法：在类中加上一条全局函数声明，再在前面加上friend修饰</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span> &#123;</span><br><span class="line">   </span><br><span class="line">	friend <span class="keyword">void</span> <span class="title function_">func</span><span class="params">(person &amp;p)</span>;	<span class="comment">//友元函数声明</span></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">int</span> age;</span><br><span class="line">		string name;</span><br><span class="line">		string <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">			<span class="keyword">return</span> name;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		person(string name, <span class="type">int</span> age) &#123;</span><br><span class="line">   </span><br><span class="line">			<span class="built_in">this</span>-&gt;name = name;</span><br><span class="line">			<span class="built_in">this</span>-&gt;age = age;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">func</span><span class="params">(person &amp;p)</span> &#123;</span><br><span class="line">   	<span class="comment">//友元函数可以访问私有成员</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;正在访问&quot;</span> &lt;&lt; p.name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p.age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; p.getName() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	cin &gt;&gt; name &gt;&gt; age;</span><br><span class="line">	<span class="type">person</span> <span class="variable">p1</span> <span class="operator">=</span> person(name, age);</span><br><span class="line">	func(p1);	</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">	test();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h3><blockquote>
<p>作用：和友元函数一样，都是让好朋友可以访问自己的私有成员<br> 用法：在类中加上友元类声明，再在前面加上friend修饰</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">rooms</span>;	<span class="comment">//事先声明rooms类，防止location报错找不到rooms类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span> &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">int</span> age;</span><br><span class="line">		string name;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		person(string name, <span class="type">int</span> age) &#123;</span><br><span class="line">   </span><br><span class="line">			<span class="built_in">this</span>-&gt;name = name;</span><br><span class="line">			<span class="built_in">this</span>-&gt;age = age;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">void</span> <span class="title function_">location</span><span class="params">(rooms &amp;r)</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">rooms</span> &#123;</span><br><span class="line">   </span><br><span class="line">	friend <span class="keyword">class</span> <span class="title class_">person</span>;	<span class="comment">//友元类</span></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		string bedRoom;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		string sittingRoom;</span><br><span class="line">		rooms(string a, string b) &#123;</span><br><span class="line">   </span><br><span class="line">			bedRoom = a;</span><br><span class="line">			sittingRoom = b;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> person::location(rooms &amp;r) &#123;</span><br><span class="line">   	<span class="comment">//在类外实现成员函数的定义，这是因为location用到了rooms的成员变量，而person类定义在rooms之前，所以如果location在类内定义的话，编译器不认识bedRoom这个变量，因为此时rooms只是声明了一下，并没有定义内部变量（如果不想这么写，可以直接把rooms定义写在person类定义前面）</span></span><br><span class="line">	cout &lt;&lt; name &lt;&lt; <span class="string">&quot;现在正在&quot;</span> &lt;&lt; r.bedRoom &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">	person <span class="title function_">p</span><span class="params">(<span class="string">&quot;李四&quot;</span>, <span class="number">21</span>)</span>;</span><br><span class="line">	rooms <span class="title function_">r</span><span class="params">(<span class="string">&quot;卧室&quot;</span>, <span class="string">&quot;客厅&quot;</span>)</span>;</span><br><span class="line">	p.location(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="友元成员函数"><a href="#友元成员函数" class="headerlink" title="友元成员函数"></a>友元成员函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">rooms</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span> &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		string name;</span><br><span class="line">		rooms *p; </span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		person(string name);</span><br><span class="line">		<span class="keyword">void</span> <span class="title function_">location</span><span class="params">()</span>;</span><br><span class="line">		</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">rooms</span> &#123;</span><br><span class="line">   </span><br><span class="line">	friend <span class="keyword">void</span> person::location();	<span class="comment">//变得只有这里</span></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		string bedRoom;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		string sittingRoom;</span><br><span class="line">		rooms() &#123;</span><br><span class="line">   </span><br><span class="line">			bedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">			sittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person::person(string name) &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="built_in">this</span>-&gt;name = name;</span><br><span class="line">	p = <span class="keyword">new</span> <span class="title class_">rooms</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> person::location() &#123;</span><br><span class="line">   </span><br><span class="line">	cout &lt;&lt; name &lt;&lt; <span class="string">&quot;现在正在&quot;</span> &lt;&lt; p-&gt;bedRoom &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">	person <span class="title function_">p</span><span class="params">(<span class="string">&quot;李四&quot;</span>)</span>;</span><br><span class="line">	p.location();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>重载依据：</p>
<ol>
<li>形参类型； </li>
<li>参数个数； </li>
<li>形参的顺序； </li>
<li>const，有const 只读，无const可读写 重点说一下const修饰的函数，const只能修饰成员函数，const修饰的函数不能修改成员变量，const修饰的常对象只能调用const修饰的常函数，而非常对象只能调用<strong>重载</strong>的非常函数（但非常函数可以调用没有重载的常函数，也就是只有一个函数名字的常函数）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">T</span> &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="type">int</span> <span class="title function_">disp</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">			cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">char</span> <span class="title function_">disp</span><span class="params">()</span> const&#123;</span><br><span class="line">   </span><br><span class="line">			cout &lt;&lt; <span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">	T t;</span><br><span class="line">	t.disp();</span><br><span class="line">	const T t2;</span><br><span class="line">	t2.disp(); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p>将成员函数名字换成operator”运算符”，即为运算符重载，本质还是编写函数</p>
<h4 id="重载-（加号运算符）"><a href="#重载-（加号运算符）" class="headerlink" title="重载+（加号运算符）"></a>重载+（加号运算符）</h4><p>让两个同类对象对应属性相加</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span> &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="type">int</span> age;</span><br><span class="line">		person(<span class="type">int</span> age) &#123;</span><br><span class="line">   </span><br><span class="line">			<span class="built_in">this</span>-&gt;age = age;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//		person operator+(person p) &#123;	//成员函数重载</span></span><br><span class="line"><span class="comment">//			person temp(0);</span></span><br><span class="line"><span class="comment">//			temp.age = age + p.age;</span></span><br><span class="line"><span class="comment">//			return temp;</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">person operator+(person a, person b) &#123;</span><br><span class="line">   	<span class="comment">//全局函数重载</span></span><br><span class="line">	person <span class="title function_">temp</span><span class="params">(<span class="number">0</span>)</span>;</span><br><span class="line">	temp.age = a.age + b.age;</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">	person <span class="title function_">p1</span><span class="params">(<span class="number">10</span>)</span>;</span><br><span class="line">	person <span class="title function_">p2</span><span class="params">(<span class="number">20</span>)</span>;</span><br><span class="line"><span class="comment">//	person p3 = p1.person(p2);	//成员函数重载，第一种写法</span></span><br><span class="line"><span class="comment">//	person p3 = operator+(p1, p2);	//全局函数重载，第二种写法</span></span><br><span class="line">	<span class="type">person</span> <span class="variable">p3</span> <span class="operator">=</span> p1 + p2;	<span class="comment">//以上两种写法的简化，等价于上面两种</span></span><br><span class="line">	cout &lt;&lt; p3.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="重载-lt-lt-（左移运算符）"><a href="#重载-lt-lt-（左移运算符）" class="headerlink" title="重载&lt;&lt;（左移运算符）"></a>重载&lt;&lt;（左移运算符）</h4><p>输出对象的所有属性值，由于cout在左移运算符左边，所以无法通过成员函数实现，成员函数cout只能在右边</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span> &#123;</span><br><span class="line">   </span><br><span class="line">	friend ostream&amp; operator&lt;&lt;(ostream &amp;out, person &amp;p);	<span class="comment">//友元</span></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">int</span> a, b;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		person(<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">   </span><br><span class="line">			<span class="built_in">this</span>-&gt;a = a;</span><br><span class="line">			<span class="built_in">this</span>-&gt;b = b;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line">ostream&amp; operator&lt;&lt;(ostream &amp;out, person &amp;p) &#123;</span><br><span class="line">   	<span class="comment">//链式编程，只有这样cout&lt;&lt;p之后才可以继续追加输出，cout本质就是一个ostream的对象</span></span><br><span class="line">	out &lt;&lt; p.a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p.b;</span><br><span class="line">	<span class="keyword">return</span> out; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">	person <span class="title function_">p</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span>;</span><br><span class="line">	cout &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="重载自增运算符（递增运算符）"><a href="#重载自增运算符（递增运算符）" class="headerlink" title="重载自增运算符（递增运算符）"></a>重载自增运算符（递增运算符）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">myInteger</span> &#123;</span><br><span class="line">   </span><br><span class="line">	friend ostream&amp; operator&lt;&lt;(ostream &amp;cout, myInteger &amp;o);</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">int</span> num;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		myInteger() &#123;</span><br><span class="line">   </span><br><span class="line">			num = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		myInteger&amp; operator++() &#123;</span><br><span class="line">   </span><br><span class="line">			++ num;</span><br><span class="line">			<span class="keyword">return</span> *<span class="built_in">this</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		myInteger&amp; operator++(<span class="type">int</span>) &#123;</span><br><span class="line">   	<span class="comment">//占位区分前置和后置</span></span><br><span class="line">			<span class="type">myInteger</span> <span class="variable">temp</span> <span class="operator">=</span> *<span class="built_in">this</span>;</span><br><span class="line">			num ++;</span><br><span class="line">			<span class="keyword">return</span> temp;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line">ostream&amp; operator&lt;&lt;(ostream &amp;cout, myInteger &amp;o) &#123;</span><br><span class="line">   </span><br><span class="line">	cout &lt;&lt; o.num;</span><br><span class="line">	<span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">	myInteger a;</span><br><span class="line">	cout &lt;&lt; ++a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; a++ &lt;&lt;endl;</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="重载-（赋值运算符）"><a href="#重载-（赋值运算符）" class="headerlink" title="重载=（赋值运算符）"></a>重载=（赋值运算符）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span> &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="type">int</span> *p;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		person(<span class="type">int</span> t) &#123;</span><br><span class="line">   </span><br><span class="line">			p = <span class="keyword">new</span> <span class="title class_">int</span>(t);</span><br><span class="line">		&#125;</span><br><span class="line">		person(const person &amp;o) &#123;</span><br><span class="line">   	<span class="comment">//重写拷贝函数</span></span><br><span class="line">			p = <span class="keyword">new</span> <span class="title class_">int</span>(*o.p);</span><br><span class="line">		&#125;</span><br><span class="line">		~person() &#123;</span><br><span class="line">   	<span class="comment">//析构函数释放申请空间</span></span><br><span class="line">			<span class="keyword">if</span>(p) &#123;</span><br><span class="line">   </span><br><span class="line">				delete p;</span><br><span class="line">				p = NULL;</span><br><span class="line">			&#125;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;success&quot;</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		person&amp; operator=(person &amp;o) &#123;</span><br><span class="line">   	<span class="comment">//重载=，注意返回当前对象，链式法则</span></span><br><span class="line">			<span class="keyword">if</span>(p) &#123;</span><br><span class="line">   </span><br><span class="line">				delete p;</span><br><span class="line">				p = NULL;</span><br><span class="line">			&#125;</span><br><span class="line">			p = <span class="keyword">new</span> <span class="title class_">int</span>(*o.p);</span><br><span class="line">			<span class="keyword">return</span> *<span class="built_in">this</span>;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">	person <span class="title function_">p1</span><span class="params">(<span class="number">10</span>)</span>;</span><br><span class="line">	person <span class="title function_">p2</span><span class="params">(<span class="number">0</span>)</span>;</span><br><span class="line">	person <span class="title function_">p3</span><span class="params">(<span class="number">0</span>)</span>;</span><br><span class="line">	<span class="type">person</span> <span class="variable">p4</span> <span class="operator">=</span> p3;	<span class="comment">//这里不是=运算符重载，而是调用拷贝函数，因此依旧是浅拷贝，需要自定义拷贝函数，改成深拷贝 </span></span><br><span class="line">	p3 = p2 = p1;</span><br><span class="line">	cout &lt;&lt; p1.p &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p2.p &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p3.p &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p4.p &lt;&lt; endl;	<span class="comment">//查看申请的内存地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="重载关系运算符"><a href="#重载关系运算符" class="headerlink" title="重载关系运算符"></a>重载关系运算符</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span> &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		string name;</span><br><span class="line">		<span class="type">int</span> age;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		person(string name, <span class="type">int</span> age) &#123;</span><br><span class="line">   </span><br><span class="line">			<span class="built_in">this</span>-&gt;name = name;</span><br><span class="line">			<span class="built_in">this</span>-&gt;age = age;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//		bool operator==(person o) &#123;</span></span><br><span class="line">   </span><br><span class="line"><span class="comment">//			if(name == o.name &amp;&amp; age == o.age) return true;</span></span><br><span class="line"><span class="comment">//			return false;</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line">		bool operator&lt;(person o) &#123;</span><br><span class="line">   </span><br><span class="line">			<span class="keyword">if</span>(age &lt; o.age) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		bool operator&gt;(person o) &#123;</span><br><span class="line">   </span><br><span class="line">			<span class="keyword">if</span>(age &gt; o.age) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line">bool operator==(person a, person b) &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">if</span>(a.name == b.name &amp;&amp; a.age == b.age) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">	person <span class="title function_">p1</span><span class="params">(<span class="string">&quot;tom&quot;</span>, <span class="number">16</span>)</span>;</span><br><span class="line">	person <span class="title function_">p2</span><span class="params">(<span class="string">&quot;tom&quot;</span>, <span class="number">15</span>)</span>;</span><br><span class="line">	<span class="keyword">if</span>(p1 == p2) cout &lt;&lt; <span class="string">&quot;same&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(p1 &gt; p2) cout &lt;&lt; <span class="string">&quot;bigger&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;smaller&quot;</span> &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="重载括号运算符"><a href="#重载括号运算符" class="headerlink" title="重载括号运算符"></a>重载括号运算符</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span> &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		string name;</span><br><span class="line">		<span class="type">int</span> age;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		person(string name, <span class="type">int</span> age) &#123;</span><br><span class="line">   </span><br><span class="line">			<span class="built_in">this</span>-&gt;name = name;</span><br><span class="line">			<span class="built_in">this</span>-&gt;age = age;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">void</span> <span class="title function_">operator</span><span class="params">()</span><span class="params">()</span> &#123;</span><br><span class="line">   	<span class="comment">//重载（）运算符</span></span><br><span class="line">			cout &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">	person <span class="title function_">p1</span><span class="params">(<span class="string">&quot;tom&quot;</span>, <span class="number">16</span>)</span>;	</span><br><span class="line">	p1();	<span class="comment">//由于写法类似函数，又名仿函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h4><p>考虑以下情况： 狗是一个类，但狗又可以细分为很多品种，例如边牧、二哈、柯基等，这些细分的品种有狗的共性，但也有自己的特性，这时就体现出继承。 继承方式有三种：(子类会继承所有父类属性，但父类private的属性子类无法访问) public： 不改变从父类继承过来的属性访问权限 protected： 把所有父类非private的属性访问权限设为protected private： 把所有父类非private的属性访问权限设为private <strong>派生类不可以访问基类的私有成员，只能通过函数接口来访问；但是可以访问基类的公共成员和保护成员</strong> 派生类应当使用初始化列表的方式将值传递给基类的构造函数，否则将使用默认的基类构造函数 derived:derived(type1 x, type2 y):base(x, y) {} 首先创建基类对象。 派生类构造函数应通过成员初始化列表将基类信息传递给基类的构造函数。 派生类构造函数应当初始化派生类新增的初始化成员。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">basicClass</span> &#123;</span><br><span class="line">   	<span class="comment">//父类，公共内容</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">void</span> <span class="title function_">header</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;公共头部&quot;</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">void</span> <span class="title function_">footer</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;公共底部&quot;</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">void</span> <span class="title function_">left</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;公共左部&quot;</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JAVA</span> : <span class="keyword">public</span> basicClass &#123;</span><br><span class="line">   	<span class="comment">//继承父类的子类</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">void</span> <span class="title function_">content</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;JAVA课程&quot;</span> &lt;&lt; endl; </span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPP</span> : <span class="keyword">public</span> basicClass &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">void</span> <span class="title function_">content</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;CPP课程&quot;</span> &lt;&lt; endl; </span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Python</span> : <span class="keyword">public</span> basicClass &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">void</span> <span class="title function_">content</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;Python课程&quot;</span> &lt;&lt; endl; </span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">	JAVA a;</span><br><span class="line">	Python b;</span><br><span class="line">	CPP c;</span><br><span class="line">	a.header(); a.content(); a.footer(); a.left(); </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;----------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	b.header(); b.content(); b.footer(); b.left();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;----------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	c.header(); c.content(); c.footer(); c.left();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="同名变量函数"><a href="#同名变量函数" class="headerlink" title="同名变量函数"></a>同名变量函数</h4><p>如果子类和父类有同名变量或者同名函数，则子类会隐藏父类的同名变量和同名函数，想要访问到父类的同名变量或者函数，则必须加上父类的作用域，另外，即使子类和父类的同名函数参数不同，但是子类仍然会隐藏父类的函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">basicClass</span> &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="type">int</span> a;</span><br><span class="line">		<span class="keyword">void</span> <span class="title function_">out</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;basicClass&quot;</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">void</span> <span class="title function_">out</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">   </span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;basicClass &quot;</span> &lt;&lt; k &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JAVA</span> : <span class="keyword">public</span> basicClass &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		JAVA() &#123;</span><br><span class="line">   </span><br><span class="line">			a = <span class="number">100</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> a;</span><br><span class="line">		<span class="keyword">void</span> <span class="title function_">out</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;JAVA&quot;</span> &lt;&lt; endl; </span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">	JAVA a;</span><br><span class="line">	cout &lt;&lt; a.a &lt;&lt; endl;</span><br><span class="line">	a.out();</span><br><span class="line">	cout &lt;&lt; a.basicClass::a &lt;&lt; endl;</span><br><span class="line">	a.basicClass::out();</span><br><span class="line">	a.basicClass::out(<span class="number">2</span>);	<span class="comment">//即使子类同名函数和父类同名函数参数不同，仍然会隐藏父类同名函数 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="多个父类拥有同名变量函数"><a href="#多个父类拥有同名变量函数" class="headerlink" title="多个父类拥有同名变量函数"></a>多个父类拥有同名变量函数</h4><p>子类可以继承多个父类，如果多个父类拥有同名变量或者函数，也需要通过作用域来区分</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">basicClass</span> &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="type">int</span> a;</span><br><span class="line">		basicClass() &#123;</span><br><span class="line">   </span><br><span class="line">			a = <span class="number">100</span>;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">basicClass2</span> &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="type">int</span> a;</span><br><span class="line">		basicClass2() &#123;</span><br><span class="line">   </span><br><span class="line">			a = <span class="number">200</span>;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JAVA</span> : <span class="keyword">public</span> basicClass, <span class="keyword">public</span> basicClass2 &#123;</span><br><span class="line">   </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">	JAVA a;</span><br><span class="line">	cout &lt;&lt; a.basicClass::a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a.basicClass2::a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h4><p>考虑下面情况： 有基类A，B继承于A，C继承于A，D继承于B和C，A中有一份数据，此时D就会同时继承两份一样的数据，要访问这份数据，还要加上作用域。如何解决呢？ 虚继承可以解决此问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">annimal</span> &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="type">int</span> age;</span><br><span class="line">		annimal() &#123;</span><br><span class="line">   </span><br><span class="line">			age = <span class="number">18</span>;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">sleep</span> : virtual <span class="keyword">public</span> annimal &#123;</span><br><span class="line">   </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">tuo</span> : virtual <span class="keyword">public</span> annimal &#123;</span><br><span class="line">   </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">sleepTuo</span> : <span class="keyword">public</span> sleep, <span class="keyword">public</span> tuo &#123;</span><br><span class="line">   </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">	sleepTuo a;</span><br><span class="line">	cout &lt;&lt; sizeof a &lt;&lt; endl;	<span class="comment">//8-&gt;24消耗了内存</span></span><br><span class="line">	cout &lt;&lt; a.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虚继承本质是存储一个指向虚基类的指针，指针指向虚基类表，表中存储一个偏移量，指针地址加上偏移量就是数据存放地址，因此此操作实质上增加了内存消耗，换来的是不用区分作用域。</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p> <a href="https://blog.csdn.net/zhang_si_hang/article/details/126173598">详解</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">annimal</span> &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		virtual <span class="keyword">void</span> <span class="title function_">speak</span><span class="params">()</span> &#123;</span><br><span class="line">   	<span class="comment">//定义为虚函数</span></span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;动物在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">cat</span> : <span class="keyword">public</span> annimal &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">void</span> <span class="title function_">speak</span><span class="params">()</span> &#123;</span><br><span class="line">   	<span class="comment">//重写虚函数</span></span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;猫在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">	cat c;</span><br><span class="line">	annimal &amp;a = c;	<span class="comment">//多态</span></span><br><span class="line">	a.speak();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h4><p>开发项目时最忌讳代码一整个一口气写完，一是可读性差，二是扩展性差 开闭原则即为 扩展开放，修改封闭 多态即可实现这样的目标，下面计算器是一个实例，如果把计算器实现的所有操作都封装在一个类里面，会显得代码都集中在一块，没有体现模块化编程思想，以后想添加新的操作，就要修改计算器类的代码。 如果使用多态，就可以创造一个空实现的基类，要添加操作时，就可以创造一个新类继承此基类，重写虚函数，实现新功能，不需要更改旧代码，只需要添加新代码即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">calculator</span> &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="type">int</span> num1, num2;</span><br><span class="line">		virtual <span class="type">int</span> <span class="title function_">calc</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">subCalculator</span> : <span class="keyword">public</span> calculator &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="type">int</span> <span class="title function_">calc</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">			<span class="keyword">return</span> num1 + num2;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">	calculator *c = <span class="keyword">new</span> <span class="title class_">subCalculator</span>;	<span class="comment">//加法器 </span></span><br><span class="line">	c-&gt;num1 = <span class="number">1</span>;</span><br><span class="line">	c-&gt;num2 = <span class="number">2</span>;</span><br><span class="line">	cout &lt;&lt; c-&gt;calc() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h4><p>以上案例中基类的虚函数函数体其实根本不会用到，写它只是为了过编译，这种情况就可以使用纯虚函数，纯虚函数可以不写函数体，拥有纯虚函数的类称为虚类，而让子类重写此函数，且子类必须重写纯虚函数，否则子类就也为虚类。</p>
<p>虚类无法实例化，即无法创建对象。</p>
<p>只能创建指针或者引用来实现多态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">calculator</span> &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="type">int</span> num1, num2;</span><br><span class="line">		virtual <span class="type">int</span> <span class="title function_">calc</span><span class="params">()</span> = <span class="number">0</span>;	<span class="comment">//纯虚函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><blockquote>
<p>template&lt;class T&gt;：括号里面的就是模板形参，调用模板时没有歧义时可以省略实参，否则需要指明实参类型</p>
</blockquote>
<h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">template&lt;typename T&gt;	<span class="comment">//将T作为一种数据类型</span></span><br><span class="line"><span class="comment">//template&lt;class T&gt;	效果等价于上一句</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">out</span><span class="params">(T &amp;a)</span> &#123;</span><br><span class="line">   </span><br><span class="line">	cout &lt;&lt; a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码调用out函数时会根据传入的参数判断出T的类型，我们也可以在调用时直接指定出类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">out&lt;string&gt;(s);	<span class="comment">//直接指定T为string类型</span></span><br></pre></td></tr></table></figure>
<p>以下是快速排序自写的一个模板</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">template&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(T a[], <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span> ;</span><br><span class="line">	<span class="type">T</span> <span class="variable">bas</span> <span class="operator">=</span> a[l];</span><br><span class="line">	<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l, j = r;</span><br><span class="line">	<span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">   </span><br><span class="line">		<span class="keyword">while</span>(i &lt; j &amp;&amp; a[j] &gt;= bas) j --;</span><br><span class="line">		<span class="keyword">while</span>(i &lt; j &amp;&amp; a[i] &lt;= bas) i ++;</span><br><span class="line">		swap(a[i], a[j]);</span><br><span class="line">	&#125;</span><br><span class="line">	swap(a[l], a[i]);</span><br><span class="line">	sort(a, l, i-<span class="number">1</span>);</span><br><span class="line">	sort(a, i+<span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="调用规则"><a href="#调用规则" class="headerlink" title="调用规则"></a>调用规则</h4><p>调用规则如下:</p>
<ol>
<li>如果函数模板和普通函数都可以实现，优先调用普通函数 </li>
<li>可以通过空模板参数列表来强制调用函数模板 </li>
<li>函数模板也可以发生重载 </li>
<li>如果函数模板可以产性更好的匹配,优先调用函数模板</li>
</ol>
<h4 id="利用具体化模板解决自定义类型的比较问题"><a href="#利用具体化模板解决自定义类型的比较问题" class="headerlink" title="利用具体化模板解决自定义类型的比较问题"></a>利用具体化模板解决自定义类型的比较问题</h4><blockquote>
<p><code>template&lt;&gt;</code>打头，且参数类型具体指名即为具体化模板</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span> &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="type">int</span> age;</span><br><span class="line">		string name;</span><br><span class="line">		person(<span class="type">int</span> age, string name) &#123;</span><br><span class="line">   </span><br><span class="line">			<span class="built_in">this</span>-&gt;age = age;</span><br><span class="line">			<span class="built_in">this</span>-&gt;name = name;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">bool <span class="title function_">compare</span><span class="params">(T &amp;a, T &amp;b)</span> &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">if</span>(a == b) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;&gt;bool <span class="title function_">compare</span><span class="params">(person &amp;a, person &amp;b)</span> &#123;</span><br><span class="line">   	<span class="comment">//具体化模板</span></span><br><span class="line">	<span class="keyword">if</span>(a.age == b.age &amp;&amp; a.name == b.name) <span class="keyword">return</span> <span class="literal">true</span>;	<span class="comment">//如果函数参数和具体化模板参数相同，则会优先调用具体化模板</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">	person <span class="title function_">p1</span><span class="params">(<span class="number">16</span>, <span class="string">&quot;tom&quot;</span>)</span>;</span><br><span class="line">	person <span class="title function_">p2</span><span class="params">(<span class="number">16</span>, <span class="string">&quot;tom&quot;</span>)</span>;</span><br><span class="line">	cout &lt;&lt; compare(p1, p2) &lt;&lt; endl;	<span class="comment">//person类型编译器无法比较</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>try、catch、throw throw(x)：x的类型决定抛出异常的类型，x可以是表达式，也可以是常数或变量，其他类型异常自行百度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="type">double</span> <span class="title function_">fuc</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span> &#123;</span><br><span class="line">       </span><br><span class="line">	<span class="keyword">if</span>(y==<span class="number">0</span>) <span class="keyword">throw</span> <span class="number">0</span>;	<span class="comment">//如果除数为0抛出int类型异常</span></span><br><span class="line">	<span class="keyword">return</span> x/y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">	<span class="type">double</span> res;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">   	<span class="comment">//尝试执行try，出现异常后执行对应catch块中内容</span></span><br><span class="line">		res=fuc(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;The result of x/y is : &quot;</span>&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">		res=fuc(<span class="number">4</span>,<span class="number">0</span>);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">catch</span>(<span class="type">int</span>) &#123;</span><br><span class="line">   </span><br><span class="line">		cerr&lt;&lt;<span class="string">&quot;error of dividing zero.\n&quot;</span>;</span><br><span class="line">		res=fuc(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">		exit(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span>(...) &#123;</span><br><span class="line">   	<span class="comment">//默认异常处理</span></span><br><span class="line">		cerr &lt;&lt; <span class="string">&quot;error&quot;</span> &lt;&lt; endl;	<span class="comment">//与cout无异，只是规范</span></span><br><span class="line">		exit(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="const引用"><a href="#const引用" class="headerlink" title="const引用"></a>const引用</h3><p> <a href="https://blog.csdn.net/holybin/article/details/17558183?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~OPENSEARCH~Rate-1-17558183-blog-115046837.pc_relevant_multi_platform_whitelistv3&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~OPENSEARCH~Rate-1-17558183-blog-115046837.pc_relevant_multi_platform_whitelistv3&amp;utm_relevant_index=1">讲解博客</a></p>
<h3 id="指针常量和常量指针"><a href="#指针常量和常量指针" class="headerlink" title="指针常量和常量指针"></a>指针常量和常量指针</h3><p>指针<strong>常量</strong>int *const p 指针的值不能改变，即指向的地址无法改变，但可以修改该地址的值 常量<strong>指针</strong>const int *p | int const *p 指针的值可以改变，但指针指向的内容不可以改变，即指向常量的指针</p>
<h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><p>通过inline关键字修饰的函数就是内联函数，分为显式和隐式，<strong>类内定义的成员函数默认为内联函数</strong>，这被称为隐式内联，而在函数头前面加上inline就是显式。 调用函数时，操作系统需要执行转移指令，并把当前地址压栈，还需要把形参赋值给实参，这些操作虽然开销不大，但是若一个函数经常被调用，开销也需要考虑在内，内联函数可以在编译时将该函数的目标代码插入每个调用该函数的地方，和#include有些类似，不需要再执行转移指令了，减少了开销</p>
<h3 id="静态变量和全局变量的区别"><a href="#静态变量和全局变量的区别" class="headerlink" title="静态变量和全局变量的区别"></a>静态变量和全局变量的区别</h3><ol>
<li>单文件时+静态局部变量：在函数内定义静态变量，静态变量定义在全局区而非栈区，所以生命周期不同于局部变量，静态变量一直存在直到程序结束，而局部变量当程序执行过其作用域后，局部变量会被回收，生命也就结束了，静态变量相当于结合了局部变量和全局变量的特点，作用域等于局部变量，生命周期等于全局变量。 </li>
<li>单文件+静态全局变量：等价于全局变量。 </li>
<li>多文件+静态局部变量：静态局部变量和单文件没区别 </li>
<li>多文件+静态全局变量：此时静态全局变量作用域为此文件，不同于全局变量的作用域为所有文件。</li>
</ol>
<p><strong>总结：</strong> 全局变量、局部变量、全局静态变量、局部静态变量的区别。要从分配内存的位置和作用域入手来解释。</p>
<p>全局变量，分配的内存在静态存储区内存上面，其作用域是全局作用域，也就是整个程序的生命周期内都可以使用，同时，有些程序并不是由一个源文件构成的，可能有许多个源文件构成，全局变量只要在一个文件中定义，就可以在其他所有的文件中使用，当然，必须在其他文件使用extern关键字声明该变量。</p>
<p>局部变量，分配内存是分配在栈存储区上的，其作用域也只是在局部函数内，在定义该变量的函数内，只要出了该函数，该局部变量就不再起作用，该变量的生命周期也只是和该函数同在。</p>
<p>全局静态变量，分配的内存与全局变量一样，也是在静态存储内存上，其生命周期也是与整个程序同在的，从程序开始到结束一直起作用，但是与全局变量不同的是，全局静态变量作用域只在定义它的一个源文件内，其他源文件不能使用它。</p>
<p>局部静态变量，分配的内存也是在静态存储内存上的，其第一次初始化后就一直存在直到程序结束，该变量的特点是其作用域只在定义它的函数内可见，出了该函数就不可见了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//	static int a = 0; //同一作用域 不能重复定义</span></span><br><span class="line">	cout &lt;&lt; ++ a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">f2</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> a;</span><br><span class="line">	cout &lt;&lt; ++ a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">	f2();</span><br><span class="line">	f2();</span><br><span class="line">	f1();</span><br><span class="line">	f1();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">输出</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>不同作用域的变量是互不干扰的，即使是静态变量也是如此，上面代码f1和f2函数的a变量存储在不同内存，互不干扰，而且a有记忆（类似全局变量），在之前基础上自增</p>
<h3 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h3><p>extern放在变量或者函数之前，表示变量或者函数的定义在<strong>别的文件</strong>中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。 比如在a文件中有一个全局变量或者全局函数，在b文件中想要使用这个全局变量或者函数，就可以在前面加上extern关键字声明它。 一般应用于以下场景： a.h， a.cpp 在a.cpp中定义了全局变量，a.h中声明此变量，在前面加上extern，其他文件想使用此变量，就可以包含a.h</p>
<h3 id="delete"><a href="#delete" class="headerlink" title="= delete"></a>= delete</h3><p>防止函数被调用，例如需要禁止一个类调用拷贝函数或者赋值函数，可以</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MyClass is neither copyable nor movable.</span></span><br><span class="line">MyClass(const MyClass&amp;) = delete;</span><br><span class="line">MyClass&amp; operator=(const MyClass&amp;) = delete;</span><br></pre></td></tr></table></figure>
<p>更进一步来说，可能是为了： （1）防止隐式转换 （2）希望类不能被拷贝（之前的做法是把类的构造函数定义为private） 关于（1）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestClass</span></span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">    printf(<span class="string">&quot;data: %d\n&quot;</span>, data); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">    TestClass obj;</span><br><span class="line">    obj.func(<span class="number">100</span>);</span><br><span class="line">    obj.func(<span class="number">100.0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是因为隐式转换，把100.0转换为int类型的100导致的。如何防止：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestClass</span></span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">    printf(<span class="string">&quot;data: %d\n&quot;</span>, data); &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">func</span><span class="params">(<span class="type">double</span> data)</span>=delete;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">    TestClass obj;</span><br><span class="line">    obj.func(<span class="number">100</span>);</span><br><span class="line">    obj.func(<span class="number">100.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="左值（引用）和右值（引用）"><a href="#左值（引用）和右值（引用）" class="headerlink" title="左值（引用）和右值（引用）"></a>左值（引用）和右值（引用）</h3><p>左值指在内存中有实体，可以取地址的变量，而右值通常是一个式子，例如 a = b + c a是左值，b+c是右值 而左右值引用就是分别引用左值和右值 int &amp;d = a; int &amp;&amp;e = b + c;</p>
<h3 id="override"><a href="#override" class="headerlink" title="override"></a>override</h3><p>用来提醒编译器这是一个重写基类纯虚函数的函数，编译器会检查基类中是否存在相应的基函数，如果不存在就会报错。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">annimal</span> &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		virtual <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span> = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">dog</span>:<span class="keyword">public</span> annimal &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span> override;</span><br><span class="line"><span class="comment">//		void cry(int) override;	//报错，编译器检测到在基类不存在这种类型的函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> dog::cry() &#123;</span><br><span class="line">   </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;wangwang&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">	dog *d = <span class="keyword">new</span> <span class="title class_">dog</span>;</span><br><span class="line">	d-&gt;cry();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="为什么父类的析构函数需要写成虚函数"><a href="#为什么父类的析构函数需要写成虚函数" class="headerlink" title="为什么父类的析构函数需要写成虚函数"></a>为什么父类的析构函数需要写成虚函数</h3><p>C++的类中，构造函数用于初始化对象及相关操作，构造函数是不能声明为虚函数的，因为在执行构造函数前对象尚未完成创建，虚函数表指针还不存在。 析构函数则用于销毁对象完成时相应的资源释放工作，析构函数可以被声明为虚函数。在继承层次中，基类的析构函数一般建议声明为虚函数。 通过一个例子来说明下基类析构函数声明为虚函数的必要性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">base</span> &#123;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    base() &#123;</span><br><span class="line">   </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;base constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="type">int</span> *b = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    ~base() &#123;</span><br><span class="line">   </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;base destructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">        delete[] b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> *b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">derived</span> : <span class="keyword">public</span> base &#123;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    derived() &#123;</span><br><span class="line">   </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;derived constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="type">int</span> *d = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">8</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    ~derived() &#123;</span><br><span class="line">   </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;derived destructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">        delete[] d;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> *d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">    base *pBase = <span class="keyword">new</span> <span class="title class_">derived</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;---&quot;</span> &lt;&lt; endl;</span><br><span class="line">    delete pBase;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">base constructor</span><br><span class="line">derived constructor</span><br><span class="line">---</span><br><span class="line">base destructor</span><br></pre></td></tr></table></figure>
<p>上面定义了两个类：一个基类base，一个派生类derived。</p>
<p>基类和派生类都分别定义了各自的构造函数和析构函数。</p>
<p>基类和派生类中各有一个int型指针成员变量：</p>
<p>在基类的构造函数中，给指针变量b分配了5个int型空间；基类的析构函数用于将b所指的空间释放掉； 在派生类的构造函数中，指针成员变量d被分配了8个int型空间；派生类的析构函数是为了释放掉d指针所指向的存储空间。 在主函数中创建一个基类类型的指针pBase，指向一个派生类对象，之后释放掉pBase指针所指向的对象的存储空间。</p>
<p>观察程序的运行结果，说明：</p>
<p>首先，基类的构造函数被调用（base constructor）； 其次，派生类的构造函数也被调用（derived constructor）； 最后，基类的析构函数被调用（base destructor）。 但是却没有调用派生类的析构函数，这样会导致d指针所指向的整型存储空间不会被释放，从而造成内存泄漏。</p>
<p>为了解决这个问题，需要将基类的析构函数声明为虚函数。修改如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">virtual ~base() &#123;</span><br><span class="line">   </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;base destructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    delete[] b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">base constructor</span><br><span class="line">derived constructor</span><br><span class="line">---</span><br><span class="line">derived destructor</span><br><span class="line">base destructor</span><br></pre></td></tr></table></figure>
<p>将基类的析构函数声明为虚函数之后，派生类的析构函数也自动成为虚析构函数，在主函数中基类指针pBase指向的是派生类对象，当delete释放pBase指针所指向的存储空间时，</p>
<p>首先执行派生类的析构函数（derived destructor）； 然后执行基类的析构函数（base destructor）。 综上所述，将基类的析构函数设为虚函数，可以保证派生类被正确地释放。</p>
<h3 id="enum-class"><a href="#enum-class" class="headerlink" title="enum class"></a>enum class</h3><p> <a href="https://zhuanlan.zhihu.com/p/501309032">文章链接</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>01字典树</tag>
      </tags>
  </entry>
  <entry>
    <title>A*算法</title>
    <url>/posts/edfb9eba.html</url>
    <content><![CDATA[<blockquote>
<p>A*算法在求一个点到目标点的最短距离时，可以加快速度，如果使用dijstla是nlogn的时复，但是A*更快，当节点足够多，边足够大时，可能不能求起点到所有点的最短距离，空间不够或者时复顶不住，这个时候A*<strong>或许</strong>能做，A<em>使用了一个启发式函数f()，其含义是节点到终点的估计距离，这个距离可以是曼哈顿距离，可以是实际到终点的最短距离等等，只要满足<em>*估计距离小于等于实际距离</em></em>即可，只要满足了这个，那么用f(u)+dis(u)当作优先队列的排序规则，每次取出最小值，这个点的最短距离就确定了，证明我找不到，<code>画个图可以想一下是有道理的</code></p>
</blockquote>
<h2 id="ACWing-178-第K短路"><a href="#ACWing-178-第K短路" class="headerlink" title="ACWing.178.第K短路"></a><a href="https://www.acwing.com/problem/content/description/180/">ACWing.178.第K短路</a></h2><p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/image-20210907170044220.png" alt="image-20210907170044220"></p>
<p>我看到这道题，不会A<em>之前，我只能想到Knlogn的时复，跑K次dijstla…太菜了，其实更好的是使用BFS，给每一个状态加上一个距离，使用优先队列，每次取出距离最小的点，其实就是dijstla，只不过少了dis数组，这样子做如果不加优化空间和时间都顶不住，所以开一个cnt[]数组记录每一个点被更新了几次，如果一个点已经被更新K次了，之后这个点就没必要再入队了，加上这个优化后，时复和空间复杂度最坏就是Knlogn，<del>但是这道题还是过不去</del>，所以使用A\</em>优化，加上f()函数，表示从终点到节点的最短距离作为近似值，估计值=节点距离起点的距离+距离终点的距离近似值，以估计值作为排序标准，每次取出最小，当终点被第K次取出时返回答案。</p>
<p>需要说明的时这个题目是可能存在重边的，所以必须等一个点把能到的状态都走完，才能判断返回条件。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=h[u.to];~i;i=e[i].next)&#123;</span><br><span class="line">    <span class="type">int</span> v=e[i].to,w=e[i].w;</span><br><span class="line">    <span class="keyword">if</span>(v==ed)&#123;</span><br><span class="line">        K--;</span><br><span class="line">        <span class="keyword">if</span>(K==<span class="number">0</span>) <span class="keyword">return</span> u.d+w;</span><br><span class="line">    &#125;</span><br><span class="line">    pq.push(&#123;v,u.d+w&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个写法是错误的，假如1-&gt;2有很多边权，存边的时候是按照来的顺序存的，所以可能是乱的，除非用vector存边而且边权排序，否则答案不对，还有这道题每条最短路中至少要包含一条边，所以如果终点和起点相同，找的是第K+1条边。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0) </span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">110000</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> to,next,w;</span><br><span class="line">&#125;e[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> to,d;</span><br><span class="line">	<span class="type">bool</span> operator&lt;(<span class="type">const</span> node &amp;o)<span class="type">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> d&gt;o.d;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nb</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> to,d,c;</span><br><span class="line">	<span class="type">bool</span> operator&lt;(<span class="type">const</span> nb &amp;o)<span class="type">const</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(c==o.c) <span class="keyword">return</span> d&gt;o.d;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> c&gt;o.c;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> h[N],rh[N],f[N],cnt[N];</span><br><span class="line"><span class="type">int</span> tot,n,m,st,ed,K;</span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> *h,<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> c)</span>&#123;</span><br><span class="line">	e[tot]=&#123;v,h[u],c&#125;;</span><br><span class="line">	h[u]=tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dij</span><span class="params">(<span class="type">int</span> st)</span>&#123;</span><br><span class="line">	<span class="built_in">priority_queue</span>&lt;node&gt; pq;</span><br><span class="line">	<span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line">	f[st]=<span class="number">0</span>;</span><br><span class="line">	pq.push(&#123;st,<span class="number">0</span>&#125;);</span><br><span class="line">	<span class="keyword">while</span>(!pq.empty())&#123;</span><br><span class="line">		<span class="keyword">auto</span> u=pq.top().to;</span><br><span class="line">		pq.pop();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=rh[u];~i;i=e[i].next)&#123;</span><br><span class="line">			<span class="type">int</span> v=e[i].to,w=e[i].w;</span><br><span class="line">			<span class="keyword">if</span>(f[v]&gt;f[u]+w)&#123;</span><br><span class="line">				f[v]=f[u]+w;</span><br><span class="line">				pq.push(&#123;v,f[v]&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span> st)</span>&#123;</span><br><span class="line">	<span class="built_in">priority_queue</span>&lt;nb&gt; pq;</span><br><span class="line">	pq.push(&#123;st,<span class="number">0</span>,f[st]&#125;);</span><br><span class="line">	<span class="keyword">while</span>(!pq.empty())&#123;</span><br><span class="line">		<span class="keyword">auto</span> u=pq.top();</span><br><span class="line">		pq.pop();</span><br><span class="line">		<span class="keyword">if</span>(cnt[u.to]&gt;=K) <span class="keyword">continue</span>;</span><br><span class="line">		cnt[u.to]++;</span><br><span class="line">		<span class="keyword">if</span>(cnt[u.to]==K &amp;&amp; u.to==ed) <span class="keyword">return</span> u.d;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=h[u.to];~i;i=e[i].next)&#123;</span><br><span class="line">			<span class="type">int</span> v=e[i].to,w=e[i].w;</span><br><span class="line">			<span class="keyword">if</span>(cnt[v]&gt;=K) <span class="keyword">continue</span>;</span><br><span class="line">			pq.push(&#123;v,u.d+w,u.d+w+f[v]&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">	<span class="built_in">memset</span>(rh,<span class="number">-1</span>,<span class="keyword">sizeof</span> rh);</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="type">int</span> u,v,w;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">		add(h,u,v,w);</span><br><span class="line">		add(rh,v,u,w);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;st&gt;&gt;ed&gt;&gt;K;</span><br><span class="line">	<span class="keyword">if</span>(st==ed) K++;</span><br><span class="line">	dij(ed);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;bfs(st);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>A*算法</tag>
      </tags>
  </entry>
  <entry>
    <title>ACM冷知识</title>
    <url>/posts/5ccd823e.html</url>
    <content><![CDATA[<h2 id="int128"><a href="#int128" class="headerlink" title="__int128"></a>__int128</h2><p>C++支持的最大数据类型就是longlong，再大就会爆掉，所以出现了<em>_int128类型，默认gcc是不支持编译的，但是在各大OJ上是可以运行的，\</em>_int128不支持cin、cout，所以需要自己写读入打印函数，也就是传统的快读快写</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ll;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(__int128 &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> y=<span class="number">1</span>;x=<span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(c&lt;<span class="string">&#x27;0&#x27;</span> || c&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>) y=<span class="number">-1</span>;</span><br><span class="line">		c=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(c&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; c&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">		x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		c=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	x*=y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(__int128 x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">		x*=<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;=<span class="number">10</span>) <span class="built_in">print</span>(x/<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __int128 x;</span><br><span class="line">	<span class="built_in">read</span>(x);</span><br><span class="line">	<span class="built_in">print</span>(x); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h2 id="atan2"><a href="#atan2" class="headerlink" title="atan2"></a>atan2</h2><p>函数原型：<code>double atan2(double y,double x)</code></p>
<p>传进去一个向量，返回这个向量相对于x轴正方向的角度值，当向量朝向是y轴以上返回值为正，当向量朝向为y轴以下，返回值为负，所以值域为(-pi,pi]</p>
<h2 id="stoi函数-amp-amp-atoi函数"><a href="#stoi函数-amp-amp-atoi函数" class="headerlink" title="stoi函数 &amp;&amp; atoi函数"></a>stoi函数 &amp;&amp; atoi函数</h2><blockquote>
<p>头文件 cstring</p>
<p>作用：将一个字符串转化为int类型，如果输入小数会省略小数点后面的，负数也可以输入</p>
</blockquote>
<p>atoi: 接受const char *，所以string类型需要调用c_str()转化一下，超过上界返回上界，超出下界返回下界</p>
<p>stoi: 接受const string *，直接传入string即可，超出int范围会报错runerror</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;stoi(s)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&gt;&gt;123</span></span><br><span class="line"><span class="comment">&lt;&lt;123</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="isalpha-islower-isupper-isdigit"><a href="#isalpha-islower-isupper-isdigit" class="headerlink" title="isalpha || islower || isupper || isdigit"></a>isalpha || islower || isupper || isdigit</h2><p>传入字符判断</p>
<p>isalpha： 判断是否为字母</p>
<p>islower:  判断是否为小写字母</p>
<p>isupper： 判断是否为大写字母</p>
<p>isdigit： 判断是否为数字</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM冷知识</tag>
      </tags>
  </entry>
  <entry>
    <title>AC自动机</title>
    <url>/posts/5c28c80e.html</url>
    <content><![CDATA[<blockquote>
<p> AC自动机以trie为基础，结合了kmp的next数组思想而创造出来的一种数据结构，用来解决多模式串匹配问题</p>
</blockquote>
<h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p><a href="https://www.luogu.com.cn/problem/P3808">P3808 【模板】AC自动机（简单版）</a></p>
<p>给定n个模式串（$n&lt;=1e6$），一个主串s（$s&lt;=1e6$），问主串中包含多少个这些之中的模式串？</p>
<h2 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h2><p>传统做法，利用KMP，O(n)遍历每一个模式串，O(n)匹配是否包含此模式串，复杂度O(n2)</p>
<p>利用AC自动机，先把所有的模式串插入到trie中，接下来预处理一个fail数组，fail[i]表示i节点失配后该去找哪个节点（类似next数组），fail数组的真正含义是<code>当前正在匹配的模式串的后缀和其他所有模式串的前缀可以匹配最大长度的那个模式串</code>，有点绕。<img src="https://oi-wiki.org/string/images/ac-automaton1.png" style="zoom:67%;" /></p>
<p>这张图中的6号节点的fail指针指向7号节点，因为6号节点的后缀s和7号节点的前缀s相同，且匹配长度最大，所以fail[6]=7。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="type">void</span> <span class="title function_">build</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//这里把根节点的儿子节点入队，因为如果只把根节点入队的话会导致根节点失配指针指向自己，那么第一次bfs求儿子节点的fail指针时，儿子的fail也会指向自己</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tr[<span class="number">0</span>][i]) q.push(tr[<span class="number">0</span>][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//利用bfs进行构建</span></span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="type">int</span> u=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tr[u][i])&#123;</span><br><span class="line">                fail[tr[u][i]]=tr[fail[u]][i];</span><br><span class="line">                q.push(tr[u][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> tr[u][i]=tr[fail[u]][i];	<span class="comment">//压缩路径</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/08/20/Rbm5doiqH9hXZKz.png" alt="image-20210820104813489"></p>
<p>预处理出fail数组后即可进行主串匹配，需要注意的是每一个字符都要当作失配字符进行一次不断向fail数组跳跃的过程，过程中记录出现的模式串。</p>
<p>例如</p>
<p>t1: ash</p>
<p>t2: sh</p>
<p>S: ash</p>
<p>匹配时可以直接匹配到ash，但是sh是藏在ash中的，所以在匹配ash的过程中时刻需要看看有没有其他的模式串的前缀和当前字符串的后缀匹配成功的，sh的前缀就和ash的后缀匹配上了，然后发现这正是fail数组的意义，所以每次跳跃到fail[i]即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="built_in">string</span> s)</span>&#123;</span><br><span class="line">    <span class="type">int</span> len=s.size(),u=<span class="number">0</span>,ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        u=tr[u][s[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=u;j &amp;&amp; num[j]!=<span class="number">-1</span>;j=fail[j])&#123;	</span><br><span class="line">            <span class="comment">//每一个字符都当成失配字符算一遍匹配模式串数量</span></span><br><span class="line">            ret+=num[j];</span><br><span class="line">            num[j]=<span class="number">-1</span>;	<span class="comment">//一个模式串被计算过了就要标记一下</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#pragma G++ optimize(2)</span></span><br><span class="line"><span class="comment">//#pragma G++ optimize(3,&quot;Ofast&quot;,&quot;inline&quot;)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span><span class="number">-100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SUB=<span class="number">-0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-4</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> E=<span class="built_in">exp</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AC</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> tr[MAXN][<span class="number">27</span>],num[MAXN],fail[MAXN];	<span class="comment">//tr: 字典树数组、num:记录模式串数量、失配跳转指针</span></span><br><span class="line">	<span class="type">int</span> tot;	<span class="comment">//点编号</span></span><br><span class="line">	<span class="type">void</span> <span class="title function_">insert</span><span class="params">(<span class="built_in">string</span> s)</span>&#123;	<span class="comment">//插入模式串，构建字典树</span></span><br><span class="line">		<span class="type">int</span> p=<span class="number">0</span>,len=s.size();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(!tr[p][s[i]-<span class="string">&#x27;a&#x27;</span>]) tr[p][s[i]-<span class="string">&#x27;a&#x27;</span>]=++tot;</span><br><span class="line">			p=tr[p][s[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		num[p]++;	<span class="comment">//数量加一</span></span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	<span class="type">void</span> <span class="title function_">build</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(tr[<span class="number">0</span>][i]) q.push(tr[<span class="number">0</span>][i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">			<span class="type">int</span> u=q.front();</span><br><span class="line">			q.pop();</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(tr[u][i])&#123;</span><br><span class="line">					fail[tr[u][i]]=tr[fail[u]][i];</span><br><span class="line">					q.push(tr[u][i]);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> tr[u][i]=tr[fail[u]][i];	<span class="comment">//压缩路径</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="built_in">string</span> s)</span>&#123;</span><br><span class="line">		<span class="type">int</span> len=s.size(),u=<span class="number">0</span>,ret=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">			u=tr[u][s[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=u;j &amp;&amp; num[j]!=<span class="number">-1</span>;j=fail[j])&#123;	</span><br><span class="line">			<span class="comment">//每一个字符都当成失配字符算一遍匹配模式串数量</span></span><br><span class="line">				ret+=num[j];</span><br><span class="line">				num[j]=<span class="number">-1</span>;	<span class="comment">//一个模式串被计算过了就要标记一下</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">AC tree;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="comment">// debug;</span></span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">		tree.insert(s);</span><br><span class="line">	&#125;</span><br><span class="line">	tree.build();</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;tree.query(s)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>Shoka主题配置Algolia搜索</title>
    <url>/posts/6a52303e.html</url>
    <content><![CDATA[<blockquote>
<p>原来使用的Sakura主题已经没人维护了，写作时因为没有集成插件很多标签都没有，因此写出来的文章就比较丑，最重要的原因还是shoka这个主题太好看了，个人实在是喜欢(❤ ω ❤)，忍不住就咕哝了两天，在这里记录一下迁移过程遇到最棘手的问题Algolia的配置吧。</p>
</blockquote>
<p>:::success</p>
<p><code>主题优点</code></p>
<p>先给新主题shoka打个广告，继承了许多优秀插件，尤其是写作标签非常多，<a href="https://shoka.lostyu.me/computer-science/note/theme-shoka-doc/special/">写作标签介绍</a>，就光这一点就足够吸引我了，其次就是好看，贼好看，这个布局确实是让人看着赏心悦目，而且配置简单，因为很多东西都集成了，就方便了很多操作。</p>
<p>:::</p>
<p>回归主题，由于以前没用过algolia，导致我还得去网上查资料一点一点学，好在最后弄好了。</p>
<h2 id="Algolia配置"><a href="#Algolia配置" class="headerlink" title="Algolia配置"></a>Algolia配置</h2><ol>
<li><p>首先第一步就是安装hexo-algolia，右击博客根目录输入<code>npm i hexo-algolia</code></p>
</li>
<li><p>打开网页<a href="https://www.algolia.com/">algolia</a>，注册账户，新建一个Indice，名字随便起，然后根据提示完成后续工作，大致就是让你选择根据什么来搜索</p>
</li>
<li><p>之后在左侧导航栏中找到<code>Api Keys</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/Sucai/20201225213848.png" alt="" title="Algolia"></p>
</li>
<li><p>点击All API Keys，然后点击右上角New API Key，新建一个API Key，因为默认给的Only search权限不够只能搜索却不能通过这个API向服务器传输数据，indice选择刚才新建的那个</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/Sucai/20201225214129.png" alt="" title="API"></p>
</li>
<li><p>之后在博客根目录<code>config.yml</code>中，找到<code>algolia</code>的相关配置，然后添加<code>applicationID</code>属性，<code>appID</code>不要删(主题JS需要)，这两个虽然是一样的，但是因为hexo-algolia会自动去config.yml文件中寻找applicationID字眼而不是appID，因此不加上applicationID会报错，之后填上相应的值，这里注意<code>apiKey</code>可以填刚新添加的APIKEY，也可以填这里<code>Search-Only APIKEY</code>，刚才创建的用处不在这里</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/Sucai/20201225220935.png" alt="" title="algolia"></p>
</li>
<li><p>之后在博客根目录右击<code>git bash</code>，输入<code>export HEXO_ALGOLIA_INDEXING_KEY=&quot;你刚才新创建的APIKEY&quot;</code>，这里一定要是你新创建的不能是Search-Only APIKEY，否则权限不够无法上传索引，之后输入<code>hexo algolia</code>，即可成功上传，并在algolia后台中看到上传的索引</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/Sucai/20201225222422.png" alt="" title="algolia"><img src="https://cdn.jsdelivr.net/gh/uncleacc/Sucai/20201225224116.png" alt="" title="索引"></p>
</li>
<li><p>在搜索框中输入即可看到结果了</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/Sucai/20201225223941.png" alt="" title="algolia"></p>
</li>
</ol>
<p>[:heavy_check_mark:完美解决]{.label .success}</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>Algolia是一款很强大的搜索服务，打开<code>Indices</code>，点击<code>configuration</code>，找到<code>Searchable attributes</code>，在里面可以定制搜索凭借，例如你添加了<code>content</code>，之后输入的内容就会去和文章内容进行匹配之后出来结果，还是很强大的，不过如果你添加了content默认hexo-algolia插件是不上传文章内容的，也就是说你必须修改hexo-algolia插件Js内容来上传content，具体操作是打开目录:<code>shoka\node_modules\hexo-algolia\lib</code>，修改<code>command.js</code>，输入关键词var INDEXED_PROPERTIES = [查找，然后在[]中添加要上传的内容，不要删除里面的内容，因为可能会报错！</p>
<p>:::warning</p>
<p>[一定认真阅读主题官方文档！一定认真阅读主题官方文档！一定认真阅读主题官方文档！]{.rainbow}</p>
<p>:::</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>BFS模板题</title>
    <url>/posts/7247b6a5.html</url>
    <content><![CDATA[<p>上一篇文章讲了dfs的记忆化搜索，来看看上一道题 “仙岛求药” </p>
<h2 id="仙岛求药"><a href="#仙岛求药" class="headerlink" title="仙岛求药"></a>仙岛求药</h2><p>少年李逍遥的婶婶病了，王小虎介绍他去一趟仙灵岛，向仙女姐姐要仙丹救婶婶。叛逆但孝顺的李逍遥闯进了仙灵岛，克服了千险万难来到岛的中心，发现仙药摆在了迷阵的深处。迷阵由 M×NM \times NM×N 个方格组成，有的方格内有可以瞬秒李逍遥的怪物，而有的方格内则是安全。现在李逍遥想尽快找到仙药，显然他应避开有怪物的方格，并经过最少的方格，而且那里会有神秘人物等待着他。现在要求你来帮助他实现这个目标。</p>
<p>输入格式</p>
<p>第一行输入两个非零整数 MMM 和 NNN，两者均不大于 202020。MMM 表示迷阵行数, NNN 表示迷阵列数。</p>
<p>接下来有 MMM 行, 每行包含 NNN 个字符,不同字符分别代表不同含义:</p>
<p>1) ‘@’：少年李逍遥所在的位置；2) ‘.’：可以安全通行的方格；3) ‘#’：有怪物的方格；4) ‘*’：仙药所在位置。</p>
<p>输出格式</p>
<p>输出一行，该行包含李逍遥找到仙药需要穿过的最少的方格数目(计数包括初始位置的方块)。如果他不可能找到仙药, 则输出 −1-1−1。</p>
<p>输出时每行末尾的多余空格，不影响答案正确性</p>
<p>样例输入1</p>
<p>8 8<br>.@##…#</p>
<h1 id="…"><a href="#…" class="headerlink" title="….#."></a>….#.</h1><h1 id=""><a href="#" class="headerlink" title=".#.##.."></a>.#.##..</h1><p>..#.###.</p>
<h1 id="…-1"><a href="#…-1" class="headerlink" title=".#…#."></a>.#…#.</h1><p>..###.#.<br>…#.*..<br>.#…###</p>
<p>样例输出1</p>
<p>10</p>
<p>样例输入2</p>
<p>6 5</p>
<p>.*.#.</p>
<p>.#…</p>
<p>..##.</p>
<p>…..</p>
<p>.#…</p>
<p>….@</p>
<p>样例输出2</p>
<p>8</p>
<p>样例输入3</p>
<p>9 6</p>
<p>.#..#. </p>
<p>.#.*.# </p>
<p>.####. </p>
<p>..#… </p>
<p>..#… </p>
<p>..#… </p>
<p>..#… </p>
<h1 id="-1"><a href="#-1" class="headerlink" title=".@."></a>.@.</h1><p>.#..#.</p>
<p>样例输出3</p>
<p>-1</p>
<p>ok，如果直接用dfs做而不加任何优化会TLE，现在我们来用BFS做，BFS和DFS比较，它的优点就是时间快，但相应的空间上也耗损的更多，个人感觉如果仅仅是打ACM，这个特点比较好，毕竟大多数题还是卡时间而不是卡空间，来 see yi see BFS吧</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/20200416093927119.png" alt=""></p>
<p><img src="" alt="https://img-blog.csdnimg.cn/20200416093935363.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FHTklORw==,size_16,color_FFFFFF,t_70"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/20200416093942750.png" alt="https://img-blog.csdnimg.cn/20200416093942750.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FHTklORw==,size_16,color_FFFFFF,t_70"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/20200416093935363.png" alt="https://img-blog.csdnimg.cn/20200416093956703.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FHTklORw==,size_16,color_FFFFFF,t_70"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/20200416094004328.png" alt=""></p>
<p>还是比较容易理解的吧，毕竟只是一个模板没有加任何优化</p>
<p>现在回到上一道题，贴代码：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct node&#123;</span><br><span class="line">	int x,y;</span><br><span class="line">	int step;</span><br><span class="line">	int f;</span><br><span class="line">&#125;que[500];</span><br><span class="line">int vis[30][30];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int m,n,stx,sty,tgx,tgy,head=1,tail=1;  //定义了地图大小，起始坐标，目标坐标，队列的头和尾 </span><br><span class="line">	int Next[4][2]=&#123;&#123;1,0&#125;,&#123;0,1&#125;,&#123;-1,0&#125;,&#123;0,-1&#125;&#125;;//定义了下一步的操作 </span><br><span class="line">	char map[30][30];//定义了地图 </span><br><span class="line">	cin&gt;&gt;m&gt;&gt;n;//输入地图大小 </span><br><span class="line">	for(int i=0;i&lt;m;i++)&#123;</span><br><span class="line">		for(int j=0;j&lt;n;j++)&#123;</span><br><span class="line">			scanf(&quot; %c&quot;,&amp;map[i][j]);//输入地图 </span><br><span class="line">			if(map[i][j]==&#x27;@&#x27;)&#123;//找到起始位置 </span><br><span class="line">				stx=i; sty=j;</span><br><span class="line">			&#125;</span><br><span class="line">			if(map[i][j]==&#x27;*&#x27;)&#123;//找到目标位置 </span><br><span class="line">				tgx=i; tgy=j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	vis[stx][sty]=1;//标记起始位置 </span><br><span class="line">	que[tail].x=stx;//初始化队列 </span><br><span class="line">	que[tail].y=sty; </span><br><span class="line">	que[tail].step=0;//开始位置步数为零 </span><br><span class="line">	que[tail].f=0; </span><br><span class="line">	tail++;       //tail指向队列最后一个元素的下一个位置 </span><br><span class="line">	int tx,ty,flag=0; //定义一个临时坐标和flag判断是否到达目标位置 </span><br><span class="line">	while(head&lt;tail)&#123;</span><br><span class="line">		for(int i=0;i&lt;4;i++)&#123;  //移动坐标 </span><br><span class="line">			tx=que[head].x+Next[i][0];</span><br><span class="line">			ty=que[head].y+Next[i][1];</span><br><span class="line">			if(tx&lt;0||tx&gt;=m||ty&lt;0||ty&gt;=n) continue;//判断边界 </span><br><span class="line">			if(!vis[tx][ty]&amp;&amp;map[tx][ty]!=&#x27;#&#x27;)&#123; //判断当前位置是否走过，当前位置能不能走 </span><br><span class="line">				vis[tx][ty]=1;  //标记此位置已走过 				 </span><br><span class="line">				que[tail].x=tx;  //入队 </span><br><span class="line">				que[tail].y=ty;</span><br><span class="line">				que[tail].f=head;  //新入队的父亲节点是队列的头 </span><br><span class="line">				que[tail].step=que[que[tail].f].step+1; //当前步数等于父亲的步数加一 </span><br><span class="line">				tail++;  //tail后移 </span><br><span class="line">			&#125;</span><br><span class="line">			if(tx==tgx&amp;&amp;ty==tgy)&#123;  //判断是否到到达目标点 </span><br><span class="line">				flag=1;  //更新flag </span><br><span class="line">				break;   //到达目标break </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if(flag==1) break;  //到达目标break </span><br><span class="line">		head++;  //出队，让后面的点进行扩展 </span><br><span class="line">	&#125;</span><br><span class="line">	if(flag==1) cout&lt;&lt;que[tail-1].step&lt;&lt;endl;</span><br><span class="line">	else cout&lt;&lt;&quot;-1&quot;&lt;&lt;endl;	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果您精通STL的容器，可以直接使用STL自带的queue，这里只是模板，自己写一个队列并不难</p>
<blockquote>
<p>制作不易，可否赞助一下我这只小可怜两毛钱呢，小可怜已经连饭都吃不上了（owo）</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>win10美化</title>
    <url>/posts/6c8ada9b.html</url>
    <content><![CDATA[<blockquote>
<p>你是否还在为这丑陋的window10界面而叹气(<del>win10界面其实还可以</del>)，你是否还在为怎么美化界面而烦恼？不用叹气，不用烦恼！这篇博客可以解决你的问题</p>
</blockquote>
<p>众所周知，一个简单漂亮的界面对人的心情也是有很大影响的，假如一个人不整理文件，桌面上乱七八糟，什么都往桌面上放，那迟早是受不了的，将来一定有一天你都不想开电脑</p>
<p>先来放一张美化过后的图片吧</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/Sucai/20201210215744.png" alt=""></p>
<p>效果还不错吧</p>
<p>强烈推荐 <a href="https://zhutix.com/">致美化</a>（里面什么都有）</p>
<h2 id="Mydock"><a href="#Mydock" class="headerlink" title="Mydock"></a>Mydock</h2><p>仿MAC-dock栏，<a href="https://www.mydockfinder.com/">官网</a>，随便选择一个下载渠道，下载后安装</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/Sucai/20201210225441.png" alt=""></p>
<p>找到一个空白地方右击可以设置大小，图标，开机启动等等，还可以设置最小化动画</p>
<h2 id="Translucent-汉化版"><a href="#Translucent-汉化版" class="headerlink" title="Translucent(汉化版)"></a>Translucent(汉化版)</h2><p>任务栏透明化，在桌面时可以使任务栏变得透明，点击左下角windows图标，选择所有应用，找到M开头的应用，找到Micrsoft Store，打开后搜索Translucent(汉化版)一定要是汉化版<del>除非您是英语大佬</del></p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/Sucai/20201210225839.png" alt="image-20201210225837762"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/Sucai/20201211080515.png" alt=""></p>
<p>下载就可以了</p>
<h2 id="雨滴皮肤"><a href="#雨滴皮肤" class="headerlink" title="雨滴皮肤"></a>雨滴皮肤</h2><p>雨滴是一款占内存非常小的软件，里面有桌面时钟效果，可以添加到桌面动态时钟</p>
<p>皮肤下载地址: <a href="https://zhutix.com/tag/rainmeter/">Here</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/Sucai/20201211081513.png" alt=""></p>
<p>自行设置效果吧</p>
<p>本人还是觉得简约效果最好:</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/Sucai/20201211081020.png" alt="alt" title="这里是 title"></p>
<h2 id="任务栏图标居中"><a href="#任务栏图标居中" class="headerlink" title="任务栏图标居中"></a>任务栏图标居中</h2><p><img src="https://cdn.jsdelivr.net/gh/uncleacc/Sucai/20201211081650.png" alt=""></p>
<p>找一个安全位置新建一个文件夹，命名为“任务栏”，右击任务栏，选择工具栏&gt;新建工具栏，打开刚才新建的文件夹，之后点击两条竖线可以拖动图标（如果你不能拖动右击看看你是不是把任务栏锁定住了），将新建的工具栏拖动到最左面，然后把图标拖动到中间即可，“任务栏”文件夹中的文件会被展示到任务栏上，可以利用这点添加我的电脑快捷方式和关机.bat，可以更加方便你的操作，其次右击任务栏还可以隐藏图标名字，把任务栏变小，最后锁定住任务栏即可</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/Sucai/20201211081921.png" alt=""></p>
<h2 id="uTools"><a href="#uTools" class="headerlink" title="uTools"></a>uTools</h2><p>百度<code>uTools</code>，下载，按住Alt+Space可以弹出搜索框，可以搜索到电脑里面的各种软件，关键在于里面有很多插件，和Everything搭配使用可以直接代替Everything。如果你是一个有过Linux经历，能敲键盘就绝不动鼠标，那这个就是你的绝佳选择。    </p>
<h2 id="WindowBlinds10"><a href="#WindowBlinds10" class="headerlink" title="WindowBlinds10"></a>WindowBlinds10</h2><p>一款可以更换主题风格的软件，而且其内存占用非常小，而且没有什么Bug，非常稳定，所以推荐这款软件，它可以把你的电脑风格换成Mac的样式，这个自行探索吧，下载链接<code>致美化</code>里面有</p>
<font color="red" size=6>最后不推荐大家使用"Startdocks"，个人就被它折磨的恢复过系统，系统还原点非常重要!</font>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>win10</tag>
      </tags>
  </entry>
  <entry>
    <title>Bellman-ford</title>
    <url>/posts/9012ae67.html</url>
    <content><![CDATA[<h1 id="Bellman-ford"><a href="#Bellman-ford" class="headerlink" title="Bellman-ford"></a>Bellman-ford</h1><blockquote>
<p>用途：</p>
<ol>
<li>判负环</li>
<li>计算含有负权边的最短路径</li>
</ol>
<p>重边不会影响答案，因为Bellman-ford会遍历所有的边</p>
</blockquote>
<h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><p>先存边，Bellman-ford的存边十分随意，什么储存方式都可以，只有一个要求，就是每次都要遍历到所有的边！</p>
<p>既然如此就用一个结构体去存，一个for循环就可以遍历到所有的边了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> u,v,w</span><br><span class="line">&#125;e[MAXN];</span><br></pre></td></tr></table></figure>
<p>算法十分简单，每次只要让所有的边进行一次更新即可，如果不存在负环，那么一个点最多被n-1个点更新(除了自己)，所以外层循环遍历n-1次，内层循环遍历每一条边</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">        <span class="type">int</span> u=e[j].u,v=e[j].v,w=e[j].w;</span><br><span class="line">		dis[v]=min(dis[v],dis[u]+w);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果存在负环，那么经过上面的松弛操作后，一定还有点还可以被松弛，负环可以把环上点能到的所有点的权值都松弛到无限小，遍历所有点，检查是否还有点可以被松弛，如果有，则存在负环，否则不存在。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(dis[e[i].v]&gt;dis[e[i].u]+e[i].w)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="输出路径"><a href="#输出路径" class="headerlink" title="输出路径"></a>输出路径</h3><p>用pre数组保存该节点由谁更新的，初始化时把所有的pre初始化为起点，最后从终点开始往回走，直到走到起点，输出路径。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>BFS练习</title>
    <url>/posts/3522c2e0.html</url>
    <content><![CDATA[<h2 id="A-Red-and-Black"><a href="#A-Red-and-Black" class="headerlink" title="A - Red and Black"></a>A - Red and Black</h2><blockquote>
<p>There is a rectangular room, covered with square tiles. Each tile is colored either red or black. A man is standing on a black tile. From a tile, he can move to one of four adjacent tiles. But he can’t move on red tiles, he can move only on black tiles.</p>
<p>Write a program to count the number of black tiles which he can reach by repeating the moves described above.</p>
<p><strong>Input</strong></p>
<p>The input consists of multiple data sets. A data set starts with a line containing two positive integers W and H; W and H are the numbers of tiles in the x- and y- directions, respectively. W and H are not more than 20.</p>
<p>There are H more lines in the data set, each of which includes W characters. Each character represents the color of a tile as follows.</p>
<p>‘.’ - a black tile<br>‘#’ - a red tile<br>‘@’ - a man on a black tile(appears exactly once in a data set)</p>
<p>The input consists of multiple data sets. A data set starts with a line containing two positive integers W and H; W and H are the numbers of tiles in the x- and y- directions, respectively. W and H are not more than 20.</p>
<p>There are H more lines in the data set, each of which includes W characters. Each character represents the color of a tile as follows.</p>
<p>‘.’ - a black tile<br>‘#’ - a red tile<br>‘@’ - a man on a black tile(appears exactly once in a data set)</p>
<p><strong>Output</strong></p>
<p>For each data set, your program should output a line which contains the number of tiles he can reach from the initial tile (including itself).</p>
<p><strong>Sample Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;6 9</span><br><span class="line">&gt;....#.</span><br><span class="line">&gt;.....#</span><br><span class="line">&gt;......</span><br><span class="line">&gt;......</span><br><span class="line">&gt;......</span><br><span class="line">&gt;......</span><br><span class="line">&gt;......</span><br><span class="line">&gt;#@...#</span><br><span class="line">&gt;.#..#.</span><br><span class="line">&gt;11 9</span><br><span class="line">&gt;.#.........</span><br><span class="line">&gt;.#.#######.</span><br><span class="line">&gt;.#.#.....#.</span><br><span class="line">&gt;.#.#.###.#.</span><br><span class="line">&gt;.#.#..@#.#.</span><br><span class="line">&gt;.#.#####.#.</span><br><span class="line">&gt;.#.......#.</span><br><span class="line">&gt;.#########.</span><br><span class="line">&gt;...........</span><br><span class="line">&gt;11 6</span><br><span class="line">&gt;..#..#..#..</span><br><span class="line">&gt;..#..#..#..</span><br><span class="line">&gt;..#..#..###</span><br><span class="line">&gt;..#..#..#@.</span><br><span class="line">&gt;..#..#..#..</span><br><span class="line">&gt;..#..#..#..</span><br><span class="line">&gt;7 7</span><br><span class="line">&gt;..#.#..</span><br><span class="line">&gt;..#.#..</span><br><span class="line">&gt;###.###</span><br><span class="line">&gt;...@...</span><br><span class="line">&gt;###.###</span><br><span class="line">&gt;..#.#..</span><br><span class="line">&gt;..#.#..</span><br><span class="line">&gt;0 0</span><br></pre></td></tr></table></figure>
<p><strong>Sample Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;45</span><br><span class="line">&gt;59</span><br><span class="line">&gt;6</span><br><span class="line">&gt;13</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>模板题，没有任何需要注意的地方</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI acos(-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">210</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> x,y,step;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">char</span> Map[N][N];</span><br><span class="line"><span class="type">bool</span> vis[N][N];</span><br><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span> sx,<span class="type">int</span> sy)</span>&#123;</span><br><span class="line">	<span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">	node s=&#123;sx,sy,<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="built_in">queue</span>&lt;node&gt; q;</span><br><span class="line">	q.push(s);</span><br><span class="line">	vis[sx][sy]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		node fr=q.front();q.pop();</span><br><span class="line">		cnt++;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">			node next=&#123;fr.x+dir[i][<span class="number">0</span>],fr.y+dir[i][<span class="number">1</span>],fr.step+<span class="number">1</span>&#125;;</span><br><span class="line">			<span class="keyword">if</span>(next.x&lt;<span class="number">1</span>||next.x&gt;n||next.y&gt;m||next.y&lt;<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(vis[next.x][next.y]||Map[next.x][next.y]==<span class="string">&#x27;#&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">			vis[next.x][next.y]=<span class="number">1</span>;</span><br><span class="line">			q.push(next);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;m&gt;&gt;n)&#123;</span><br><span class="line">		<span class="keyword">if</span>(m==<span class="number">0</span>&amp;n==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">		<span class="type">int</span> sx,sy;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">				<span class="built_in">cin</span>&gt;&gt;Map[i][j];</span><br><span class="line">				<span class="keyword">if</span>(Map[i][j]==<span class="string">&#x27;@&#x27;</span>)&#123;</span><br><span class="line">					sx=i;</span><br><span class="line">					sy=j;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> ans=bfs(sx,sy);</span><br><span class="line">		<span class="keyword">if</span>(ans!=<span class="number">-1</span>) <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;oop!&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="B-Rescue"><a href="#B-Rescue" class="headerlink" title="B - Rescue"></a>B - Rescue</h2><blockquote>
<p>Angel was caught by the MOLIGPY! He was put in prison by Moligpy. The prison is described as a N * M (N, M &lt;= 200) matrix. There are WALLs, ROADs, and GUARDs in the prison.</p>
<p>Angel’s friends want to save Angel. Their task is: approach Angel. We assume that “approach Angel” is to get to the position where Angel stays. When there’s a guard in the grid, we must kill him (or her?) to move into the grid. We assume that we moving up, down, right, left takes us 1 unit time, and killing a guard takes 1 unit time, too. And we are strong enough to kill all the guards.</p>
<p>You have to calculate the minimal time to approach Angel. (We can move only UP, DOWN, LEFT and RIGHT, to the neighbor grid within bound, of course.)</p>
<p><strong>Input</strong></p>
<p>First line contains two integers stand for N and M.</p>
<p>Then N lines follows, every line has M characters. “.” stands for road, “a” stands for Angel, and “r” stands for each of Angel’s friend.</p>
<p>Process to the end of the file.</p>
<p><strong>Output</strong></p>
<p>For each test case, your program should output a single integer, standing for the minimal time needed. If such a number does no exist, you should output a line containing “Poor ANGEL has to stay in the prison all his life.”</p>
<p><strong>Sample Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;7 8</span><br><span class="line">&gt;#.#####.</span><br><span class="line">&gt;#.a#..r.</span><br><span class="line">&gt;#..#x...</span><br><span class="line">&gt;..#..#.#</span><br><span class="line">&gt;#...##..</span><br><span class="line">&gt;.#......</span><br><span class="line">&gt;........</span><br></pre></td></tr></table></figure>
<p><strong>Sample Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;13</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>小小的升级，在x处步数加一，问到a处最少步数，用优先队列就行了，把步数靠前的放前面</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI acos(-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">210</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> x,y,time;</span><br><span class="line">	<span class="type">bool</span> operator &lt; (<span class="type">const</span> node &amp;o) <span class="type">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> o.time&lt;time;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">char</span> Map[N][N];</span><br><span class="line"><span class="type">bool</span> vis[N][N];</span><br><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span> sx,<span class="type">int</span> sy)</span>&#123;</span><br><span class="line">	node s=&#123;sx,sy,<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="built_in">priority_queue</span>&lt;node&gt; q;</span><br><span class="line">	q.push(s);</span><br><span class="line">	vis[sx][sy]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		node fr=q.top();q.pop();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">			node next=&#123;fr.x+dir[i][<span class="number">0</span>],fr.y+dir[i][<span class="number">1</span>],fr.time+<span class="number">1</span>&#125;;</span><br><span class="line">			<span class="keyword">if</span>(next.x&lt;<span class="number">1</span>||next.x&gt;n||next.y&gt;m||next.y&lt;<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(vis[next.x][next.y]||Map[next.x][next.y]==<span class="string">&#x27;#&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(Map[next.x][next.y]==<span class="string">&#x27;x&#x27;</span>) next.time++;</span><br><span class="line">			<span class="keyword">if</span>(Map[next.x][next.y]==<span class="string">&#x27;a&#x27;</span>)&#123;</span><br><span class="line">				<span class="keyword">return</span> next.time;</span><br><span class="line">			&#125;</span><br><span class="line">			vis[next.x][next.y]=<span class="number">1</span>;</span><br><span class="line">			q.push(next);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> INF;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">		<span class="type">int</span> sx,sy;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">				<span class="built_in">cin</span>&gt;&gt;Map[i][j];</span><br><span class="line">				<span class="keyword">if</span>(Map[i][j]==<span class="string">&#x27;r&#x27;</span>)&#123;</span><br><span class="line">					sx=i;</span><br><span class="line">					sy=j;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> ans=bfs(sx,sy);</span><br><span class="line">		<span class="keyword">if</span>(ans!=INF) <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Poor ANGEL has to stay in the prison all his life.&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="C-Battle-City"><a href="#C-Battle-City" class="headerlink" title="C - Battle City"></a>C - Battle City</h2><blockquote>
<p>Many of us had played the game “Battle city” in our childhood, and some people (like me) even often play it on computer now.</p>
<p>What we are discussing is a simple edition of this game. Given a map that consists of empty spaces, rivers, steel walls and brick walls only. Your task is to get a bonus as soon as possible suppose that no enemies will disturb you (See the following picture).</p>
<p>Your tank can’t move through rivers or walls, but it can destroy brick walls by shooting. A brick wall will be turned into empty spaces when you hit it, however, if your shot hit a steel wall, there will be no damage to the wall. In each of your turns, you can choose to move to a neighboring (4 directions, not 8) empty space, or shoot in one of the four directions without a move. The shot will go ahead in that direction, until it go out of the map or hit a wall. If the shot hits a brick wall, the wall will disappear (i.e., in this turn). Well, given the description of a map, the positions of your tank and the target, how many turns will you take at least to arrive there?</p>
<p><strong>Input</strong></p>
<p>The input consists of several test cases. The first line of each test case contains two integers M and N (2 &lt;= M, N &lt;= 300). Each of the following M lines contains N uppercase letters, each of which is one of ‘Y’ (you), ‘T’ (target), ‘S’ (steel wall), ‘B’ (brick wall), ‘R’ (river) and ‘E’ (empty space). Both ‘Y’ and ‘T’ appear only once. A test case of M = N = 0 indicates the end of input, and should not be processed.</p>
<p><strong>Output</strong></p>
<p>For each test case, please output the turns you take at least in a separate line. If you can’t arrive at the target, output “-1” instead.</p>
<p><strong>Sample Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 4</span><br><span class="line">YBEB</span><br><span class="line">EERE</span><br><span class="line">SSTE</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure>
<p><strong>Sample Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>经典坦克大战，R(河流)S(钢铁)过不去，B(砖块)可以过去但是需要多花一秒，于是这个和上一道就是一道题了，只不过多了一条河不能过而已</p>
<h3 id="CODE-1"><a href="#CODE-1" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI acos(-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">410</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> x,y,time;</span><br><span class="line">	<span class="type">bool</span> operator &lt; (<span class="type">const</span> node &amp;o) <span class="type">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> o.time&lt;time;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">char</span> Map[N][N];</span><br><span class="line"><span class="type">bool</span> vis[N][N];</span><br><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span> sx,<span class="type">int</span> sy)</span>&#123;</span><br><span class="line">	node s=&#123;sx,sy,<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="built_in">priority_queue</span>&lt;node&gt; q;</span><br><span class="line">	q.push(s);</span><br><span class="line">	vis[sx][sy]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		node fr=q.top();q.pop();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">			node next=&#123;fr.x+dir[i][<span class="number">0</span>],fr.y+dir[i][<span class="number">1</span>],fr.time+<span class="number">1</span>&#125;;</span><br><span class="line">			<span class="keyword">if</span>(next.x&lt;<span class="number">1</span>||next.x&gt;n||next.y&gt;m||next.y&lt;<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(vis[next.x][next.y]||Map[next.x][next.y]==<span class="string">&#x27;S&#x27;</span>||Map[next.x][next.y]==<span class="string">&#x27;R&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(Map[next.x][next.y]==<span class="string">&#x27;B&#x27;</span>) next.time++;</span><br><span class="line">			<span class="keyword">if</span>(Map[next.x][next.y]==<span class="string">&#x27;T&#x27;</span>)&#123;</span><br><span class="line">				<span class="keyword">return</span> next.time;</span><br><span class="line">			&#125;</span><br><span class="line">			vis[next.x][next.y]=<span class="number">1</span>;</span><br><span class="line">			q.push(next);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m)&#123;</span><br><span class="line">		<span class="keyword">if</span>(n==<span class="number">0</span>&amp;&amp;m==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">		<span class="type">int</span> sx,sy;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">				<span class="built_in">cin</span>&gt;&gt;Map[i][j];</span><br><span class="line">				<span class="keyword">if</span>(Map[i][j]==<span class="string">&#x27;Y&#x27;</span>)&#123;</span><br><span class="line">					sx=i;</span><br><span class="line">					sy=j;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> ans=bfs(sx,sy);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Dungeon-Master"><a href="#Dungeon-Master" class="headerlink" title="Dungeon Master"></a>Dungeon Master</h2><blockquote>
<p>You are trapped in a 3D dungeon and need to find the quickest way out! The dungeon is composed of unit cubes which may or may not be filled with rock. It takes one minute to move one unit north, south, east, west, up or down. You cannot move diagonally and the maze is surrounded by solid rock on all sides.</p>
<p>Is an escape possible? If yes, how long will it take?</p>
<p><strong>Input</strong></p>
<p>The input consists of a number of dungeons. Each dungeon description starts with a line containing three integers L, R and C (all limited to 30 in size).<br>L is the number of levels making up the dungeon.<br>R and C are the number of rows and columns making up the plan of each level.<br>Then there will follow L blocks of R lines each containing C characters. Each character describes one cell of the dungeon. A cell full of rock is indicated by a ‘#’ and empty cells are represented by a ‘.’. Your starting position is indicated by ‘S’ and the exit by the letter ‘E’. There’s a single blank line after each level. Input is terminated by three zeroes for L, R and C.</p>
<p><strong>Output</strong></p>
<p>Each maze generates one line of output. If it is possible to reach the exit, print a line of the form</p>
<p>​    Escaped in x minute(s).</p>
<p>where x is replaced by the shortest time it takes to escape.<br>If it is not possible to escape, print the line</p>
<p>​    Trapped!</p>
<p><strong>Sample Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;3 4 5</span><br><span class="line">&gt;S....</span><br><span class="line">&gt;.###.</span><br><span class="line">&gt;.##..</span><br><span class="line">&gt;###.#</span><br><span class="line"></span><br><span class="line">&gt;#####</span><br><span class="line">&gt;#####</span><br><span class="line">&gt;##.##</span><br><span class="line">&gt;##...</span><br><span class="line"></span><br><span class="line">&gt;#####</span><br><span class="line">&gt;#####</span><br><span class="line">&gt;#.###</span><br><span class="line">&gt;####E</span><br><span class="line"></span><br><span class="line">&gt;1 3 3</span><br><span class="line">&gt;S##</span><br><span class="line">&gt;#E#</span><br><span class="line">&gt;###</span><br><span class="line"></span><br><span class="line">&gt;0 0 0</span><br></pre></td></tr></table></figure>
<p><strong>Sample Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;Escaped in 11 minute(s).</span><br><span class="line">&gt;Trapped!</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>这个题有点意思，是一个三维空间的BFS，一维二维都会了，三维自然是手到擒来了，按着模板写，添加一维就行了</p>
<h3 id="CODE-2"><a href="#CODE-2" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI acos(-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">40</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> x,y,z,time;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> l,n,m;</span><br><span class="line"><span class="type">char</span> Map[N][N][N];</span><br><span class="line"><span class="type">bool</span> vis[N][N][N];</span><br><span class="line"><span class="type">int</span> dir[<span class="number">6</span>][<span class="number">3</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">check</span><span class="params">(node next)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(next.x&lt;<span class="number">1</span>||next.x&gt;n||next.y&gt;m||next.y&lt;<span class="number">1</span>||next.z&lt;<span class="number">1</span>||next.z&gt;l) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span> sx,<span class="type">int</span> sy,<span class="type">int</span> sz)</span>&#123;</span><br><span class="line">	node s=&#123;sx,sy,sz,<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="built_in">queue</span>&lt;node&gt; q;</span><br><span class="line">	q.push(s);</span><br><span class="line">	vis[sz][sx][sy]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		node fr=q.front();q.pop();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">			node next=&#123;fr.x+dir[i][<span class="number">0</span>],fr.y+dir[i][<span class="number">1</span>],fr.z+dir[i][<span class="number">2</span>],fr.time+<span class="number">1</span>&#125;;</span><br><span class="line">			<span class="keyword">if</span>(!check(next)) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(vis[next.z][next.x][next.y]||Map[next.z][next.x][next.y]==<span class="string">&#x27;#&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(Map[next.z][next.x][next.y]==<span class="string">&#x27;E&#x27;</span>)&#123;</span><br><span class="line">				<span class="keyword">return</span> next.time;</span><br><span class="line">			&#125;</span><br><span class="line">			vis[next.z][next.x][next.y]=<span class="number">1</span>;</span><br><span class="line">			q.push(next);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//	ios;</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;l&gt;&gt;n&gt;&gt;m)&#123;</span><br><span class="line">		<span class="keyword">if</span>(l==<span class="number">0</span>&amp;&amp;n==<span class="number">0</span>&amp;&amp;m==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">		<span class="type">int</span> sx,sy,sz;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=l;k++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">					<span class="built_in">cin</span>&gt;&gt;Map[k][i][j];</span><br><span class="line">					<span class="keyword">if</span>(Map[k][i][j]==<span class="string">&#x27;S&#x27;</span>)&#123;</span><br><span class="line">						sx=i;</span><br><span class="line">						sy=j;</span><br><span class="line">						sz=k;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> ans=bfs(sx,sy,sz);</span><br><span class="line">		<span class="keyword">if</span>(ans!=<span class="number">-1</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Escaped in &quot;</span>&lt;&lt;ans&lt;&lt;<span class="string">&quot; minute(s).&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Trapped!&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Catch-That-Cow"><a href="#Catch-That-Cow" class="headerlink" title="Catch That Cow"></a>Catch That Cow</h2><blockquote>
<p>Farmer John has been informed of the location of a fugitive cow and wants to catch her immediately. He starts at a point <em>N</em> (0 ≤ <em>N</em> ≤ 100,000) on a number line and the cow is at a point <em>K</em> (0 ≤ <em>K</em> ≤ 100,000) on the same number line. Farmer John has two modes of transportation: walking and teleporting.</p>
<p>* Walking: FJ can move from any point <em>X</em> to the points <em>X</em> - 1 or <em>X</em> + 1 in a single minute<br>* Teleporting: FJ can move from any point <em>X</em> to the point 2 × <em>X</em> in a single minute.</p>
<p>If the cow, unaware of its pursuit, does not move at all, how long does it take for Farmer John to retrieve it?</p>
<p><strong>Input</strong></p>
<p>Line 1: Two space-separated integers: <em>N</em> and <em>K</em></p>
<p><strong>Output</strong></p>
<p>Line 1: The least amount of time, in minutes, it takes for Farmer John to catch the fugitive cow.</p>
<p><strong>Sample Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;5 17</span><br></pre></td></tr></table></figure>
<p><strong>Sample Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;4</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>毒瘤的一道题目，没什么难度，就是感觉评测机器有问题，同样两段代码，放到函数和写在main函数里面不一样的结果。。。不信你可以试试</p>
<h3 id="CODE-3"><a href="#CODE-3" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> vis[<span class="number">1000001</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> wei;</span><br><span class="line">	<span class="type">int</span> time;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n,k;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">	node start=&#123;n,<span class="number">0</span>&#125;;</span><br><span class="line">	vis[n]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">queue</span>&lt;node&gt;q;</span><br><span class="line">	q.push(start);</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		node tmp=q.front(); q.pop(); </span><br><span class="line">		<span class="keyword">if</span>(tmp.wei==k)&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;tmp.time&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">			node nx;</span><br><span class="line">			<span class="keyword">if</span>(i==<span class="number">0</span>) nx=&#123;tmp.wei+<span class="number">1</span>,tmp.time+<span class="number">1</span>&#125;;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">1</span>) nx=&#123;tmp.wei<span class="number">-1</span>,tmp.time+<span class="number">1</span>&#125;;</span><br><span class="line">			<span class="keyword">else</span> nx=&#123;tmp.wei*<span class="number">2</span>,tmp.time+<span class="number">1</span>&#125;;</span><br><span class="line">			<span class="keyword">if</span>(nx.wei&lt;<span class="number">0</span>||nx.wei&gt;<span class="number">100000</span>||vis[nx.wei]) <span class="keyword">continue</span>;</span><br><span class="line">			vis[nx.wei]=<span class="number">1</span>;</span><br><span class="line">			q.push(nx);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Number-Transformation"><a href="#Number-Transformation" class="headerlink" title="Number Transformation"></a>Number Transformation</h2><blockquote>
<p>In this problem, you are given an integer number <strong>s</strong>. You can transform any integer number <strong>A</strong> to another integer number <strong>B</strong> by adding <strong>x</strong> to <strong>A</strong>. This <strong>x</strong> is an integer number which is a prime factor of <strong>A</strong> (please note that 1 and <strong>A</strong> are not being considered as a factor of <strong>A</strong>). Now, your task is to find the minimum number of transformations required to transform <strong>s</strong> to another integer number <strong>t</strong>.</p>
<p><strong>Input</strong></p>
<p>Input starts with an integer <strong>T (**</strong>≤ 500)**, denoting the number of test cases.</p>
<p>Each case contains two integers: <strong>s (1 ≤ s ≤ 100)</strong> and <strong>t (1 ≤ t ≤ 1000)</strong>.</p>
<p><strong>Output</strong></p>
<p>For each case, print the case number and the minimum number of transformations needed. If it’s impossible, then print <strong>-1</strong>.</p>
<p><strong>Sample Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line"></span><br><span class="line">6 12</span><br><span class="line"></span><br><span class="line">6 13</span><br></pre></td></tr></table></figure>
<p><strong>Sample Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Case 1: 2</span><br><span class="line"></span><br><span class="line">Case 2: -1</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><p>有意思的一道题目，给你两个数a和b，让你不断通过加a的质因子直到和b相等，有意思在哪里？这个质因子不是不变的，当a改变后，a的质因子也会发生改变，所以有两种做法，一个是每次增加都进行一次质因子分解，这也是很快的，根本不会超时，1000以内的任何一个数的质因子数量都是不超过10个的，第二种是开一个二维数组，打一个表，因为这里的b是小于1000的，我们可以开这么大的数组，存储某一个数的质因子，这里用了第二种做法，其实题目也不难，就是题目难以理解</p>
<h3 id="CODE-4"><a href="#CODE-4" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> T,t,s;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX=<span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> vis[MAX];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; vt[MAX];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> x,step;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">2</span>||n==<span class="number">3</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">1</span>||n%<span class="number">6</span>!=<span class="number">1</span>&amp;&amp;n%<span class="number">6</span>!=<span class="number">5</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">5</span>;i*i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(n%i==<span class="number">0</span>||n%(i+<span class="number">2</span>)==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">prime</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;MAX;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;i;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(i%j==<span class="number">0</span>&amp;&amp;check(j)) vt[i].push_back(j);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">bfs</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="built_in">queue</span>&lt;node&gt; q;</span><br><span class="line">	vis[s]=<span class="number">1</span>;</span><br><span class="line">	node start;</span><br><span class="line">	start.x=s; start.step=<span class="number">0</span>;</span><br><span class="line">	q.push(start);</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		node tmp=q.front(); q.pop();</span><br><span class="line">		<span class="keyword">if</span>(tmp.x==t) <span class="keyword">return</span> tmp.step;</span><br><span class="line">		<span class="type">int</span> len=vt[tmp.x].size();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">			node nx;</span><br><span class="line">			nx.x=tmp.x+vt[tmp.x][i];</span><br><span class="line">			nx.step=tmp.step+<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(nx.x&gt;t||vis[nx.x]) <span class="keyword">continue</span>;</span><br><span class="line">			vis[nx.x]=<span class="number">1</span>;</span><br><span class="line">			q.push(nx);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	prime();</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line">	<span class="type">int</span> kase=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(T--)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;s,&amp;t);</span><br><span class="line">		<span class="type">int</span> ans=INF;</span><br><span class="line">		ans=bfs();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Case %d: %d\n&quot;</span>,++kase,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="G-Knight-Moves"><a href="#G-Knight-Moves" class="headerlink" title="G - Knight Moves"></a>G - Knight Moves</h2><blockquote>
<p>A friend of you is doing research on the Traveling Knight Problem (TKP) where you are to find the shortest closed tour of knight moves that visits each square of a given set of n squares on a chessboard exactly once. He thinks that the most difficult part of the problem is determining the smallest number of knight moves between two given squares and that, once you have accomplished this, finding the tour would be easy.<br>Of course you know that it is vice versa. So you offer him to write a program that solves the “difficult” part.</p>
<p>Your job is to write a program that takes two squares a and b as input and then determines the number of knight moves on a shortest route from a to b.</p>
<p><strong>Input</strong></p>
<p>The input file will contain one or more test cases. Each test case consists of one line containing two squares separated by one space. A square is a string consisting of a letter (a-h) representing the column and a digit (1-8) representing the row on the chessboard.</p>
<p><strong>Output</strong></p>
<p>For each test case, print one line saying “To get from xx to yy takes n knight moves.”.</p>
<p><strong>Sample Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;e2 e4</span><br><span class="line">&gt;a1 b2</span><br><span class="line">&gt;b2 c3</span><br><span class="line">&gt;a1 h8</span><br><span class="line">&gt;a1 h7</span><br><span class="line">&gt;h8 a1</span><br><span class="line">&gt;b1 c3</span><br><span class="line">&gt;f6 f6</span><br></pre></td></tr></table></figure>
<p><strong>Sample Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;To get from e2 to e4 takes 2 knight moves.</span><br><span class="line">&gt;To get from a1 to b2 takes 4 knight moves.</span><br><span class="line">&gt;To get from b2 to c3 takes 2 knight moves.</span><br><span class="line">&gt;To get from a1 to h8 takes 6 knight moves.</span><br><span class="line">&gt;To get from a1 to h7 takes 5 knight moves.</span><br><span class="line">&gt;To get from h8 to a1 takes 6 knight moves.</span><br><span class="line">&gt;To get from b1 to c3 takes 1 knight moves.</span><br><span class="line">&gt;To get from f6 to f6 takes 0 knight moves.</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h3><p>只是把上下左右换成了马的走法而已</p>
<h3 id="CODE-5"><a href="#CODE-5" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">char</span> ch1[<span class="number">3</span>],ch2[<span class="number">3</span>];</span><br><span class="line"><span class="type">int</span> vis[<span class="number">9</span>][<span class="number">9</span>],ans;</span><br><span class="line"><span class="type">int</span> dir[<span class="number">8</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">2</span>,<span class="number">1</span>&#125;,&#123;<span class="number">-2</span>,<span class="number">1</span>&#125;,&#123;<span class="number">2</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-2</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">1</span>,<span class="number">-2</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">-2</span>&#125;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> row,col,step;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">bfs</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;node&gt; q;</span><br><span class="line">    node s;</span><br><span class="line">    s.row=ch1[<span class="number">1</span>]-<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    s.col=ch1[<span class="number">0</span>]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    s.step=<span class="number">0</span>;</span><br><span class="line">    vis[s.row][s.col]=<span class="number">1</span>;</span><br><span class="line">    q.push(s);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        node tmp=q.front(); q.pop();</span><br><span class="line">        <span class="keyword">if</span>(tmp.row==(ch2[<span class="number">1</span>]-<span class="string">&#x27;1&#x27;</span>)&amp;&amp;tmp.col==(ch2[<span class="number">0</span>]-<span class="string">&#x27;a&#x27;</span>))&#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp.step&lt;ans) ans=tmp.step;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">           	node nx;</span><br><span class="line">    		nx.row=tmp.row+dir[i][<span class="number">0</span>];</span><br><span class="line">    		nx.col=tmp.col+dir[i][<span class="number">1</span>];</span><br><span class="line">        	<span class="keyword">if</span>(!vis[nx.row][nx.col]&amp;&amp;nx.row&gt;=<span class="number">0</span>&amp;&amp;nx.row&lt;<span class="number">8</span>&amp;&amp;nx.col&gt;=<span class="number">0</span>&amp;&amp;nx.col&lt;<span class="number">8</span>)&#123;</span><br><span class="line">	            vis[nx.row][nx.col]=<span class="number">1</span>;</span><br><span class="line">	            nx.step=tmp.step+<span class="number">1</span>;</span><br><span class="line">	            q.push(nx);</span><br><span class="line">        	&#125;  </span><br><span class="line">       	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;ch1&gt;&gt;ch2)&#123;</span><br><span class="line">        ans=<span class="number">1e9</span>;</span><br><span class="line">	    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">	    bfs();</span><br><span class="line">	    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;To get from &quot;</span>&lt;&lt;ch1&lt;&lt;<span class="string">&quot; to &quot;</span>&lt;&lt;ch2&lt;&lt;<span class="string">&quot; takes &quot;</span>&lt;&lt;ans&lt;&lt;<span class="string">&quot; knight moves.&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="噩梦"><a href="#噩梦" class="headerlink" title="噩梦"></a>噩梦</h2><p><a href="https://www.acwing.com/problem/content/description/179/">题目链接</a></p>
<blockquote>
<p>给定一张N*M的地图，地图中有1个男孩，1个女孩和2个鬼。</p>
<p>字符“.”表示道路，字符“X”表示墙，字符“M”表示男孩的位置，字符“G”表示女孩的位置，字符“Z”表示鬼的位置。</p>
<p>男孩每秒可以移动3个单位距离，女孩每秒可以移动1个单位距离，男孩和女孩只能朝上下左右四个方向移动。</p>
<p>每个鬼占据的区域每秒可以向四周扩张2个单位距离，并且无视墙的阻挡，也就是在第k秒后所有与鬼的曼哈顿距离不超过2k的位置都会被鬼占领。</p>
<p><strong>注意：</strong> 每一秒鬼会先扩展，扩展完毕后男孩和女孩才可以移动。</p>
<p>求在不进入鬼的占领区的前提下，男孩和女孩能否会合，若能会合，求出最短会合时间。</p>
<h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数T，表示共有T组测试用例。</p>
<p>每组测试用例第一行包含两个整数N和M，表示地图的尺寸。</p>
<p>接下来N行每行M个字符，用来描绘整张地图的状况。（注意：地图中一定有且仅有1个男孩，1个女孩和2个鬼）</p>
<h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>每个测试用例输出一个整数S，表示最短会合时间。</p>
<p>如果无法会合则输出-1。</p>
<p>每个结果占一行。</p>
<h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1&lt;n,m&lt;8001&lt;n,m&lt;800</p>
<h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;3</span><br><span class="line">&gt;5 6</span><br><span class="line">&gt;XXXXXX</span><br><span class="line">&gt;XZ..ZX</span><br><span class="line">&gt;XXXXXX</span><br><span class="line">&gt;M.G...</span><br><span class="line">&gt;......</span><br><span class="line">&gt;5 6</span><br><span class="line">&gt;XXXXXX</span><br><span class="line">&gt;XZZ..X</span><br><span class="line">&gt;XXXXXX</span><br><span class="line">&gt;M.....</span><br><span class="line">&gt;..G...</span><br><span class="line">&gt;10 10</span><br><span class="line">&gt;..........</span><br><span class="line">&gt;..X.......</span><br><span class="line">&gt;..M.X...X.</span><br><span class="line">&gt;X.........</span><br><span class="line">&gt;.X..X.X.X.</span><br><span class="line">&gt;.........X</span><br><span class="line">&gt;..XX....X.</span><br><span class="line">&gt;X....G...X</span><br><span class="line">&gt;...ZX.X...</span><br><span class="line">&gt;...Z..X..X</span><br></pre></td></tr></table></figure>
<h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;1</span><br><span class="line">&gt;1</span><br><span class="line">&gt;-1</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h3><p>双向BFS，男孩和女孩轮流BFS，直到两者轨迹有交叉</p>
<h3 id="CODE-6"><a href="#CODE-6" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">810</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">pii boy,girl,ghost[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> vis[N][N],dx[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;,dy[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"><span class="type">bool</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">1</span>||x&gt;n||y&lt;<span class="number">1</span>||y&gt;m||g[x][y]==<span class="string">&#x27;X&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;   </span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(x-ghost[i].first)+<span class="built_in">abs</span>(y-ghost[i].second)&lt;=<span class="number">2</span>*k) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">bfs</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;pii&gt; qb,qg;</span><br><span class="line">    qb.push(boy); qg.push(girl);</span><br><span class="line">    <span class="type">int</span> step=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!qb.empty()||!qg.empty())&#123;</span><br><span class="line">    	step++;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">3</span>;k++)&#123;</span><br><span class="line">    		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>,len=qb.size();j&lt;len;j++)&#123;</span><br><span class="line">    			<span class="type">int</span> x=qb.front().first;</span><br><span class="line">    			<span class="type">int</span> y=qb.front().second;</span><br><span class="line">    			qb.pop();</span><br><span class="line">    			<span class="keyword">if</span>(!check(x,y,step)) <span class="keyword">continue</span>;</span><br><span class="line">    			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">    				<span class="type">int</span> nx=x+dx[i];</span><br><span class="line">    				<span class="type">int</span> ny=y+dy[i];</span><br><span class="line">    				<span class="keyword">if</span>(!check(nx,ny,step)) <span class="keyword">continue</span>;</span><br><span class="line">					<span class="keyword">if</span>(vis[nx][ny]==<span class="number">2</span>) <span class="keyword">return</span> step;</span><br><span class="line">    				<span class="keyword">if</span>(!vis[nx][ny])&#123;</span><br><span class="line">    					vis[nx][ny]=<span class="number">1</span>;</span><br><span class="line">    					qb.push(&#123;nx,ny&#125;);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">1</span>;k++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>,len=qg.size();j&lt;len;j++)&#123;</span><br><span class="line">				<span class="type">int</span> x=qg.front().first;</span><br><span class="line">				<span class="type">int</span> y=qg.front().second;</span><br><span class="line">				qg.pop();</span><br><span class="line">				<span class="keyword">if</span>(!check(x,y,step)) <span class="keyword">continue</span>;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">					<span class="type">int</span> nx=x+dx[i];</span><br><span class="line">					<span class="type">int</span> ny=y+dy[i];</span><br><span class="line">					<span class="keyword">if</span>(!check(nx,ny,step)) <span class="keyword">continue</span>;</span><br><span class="line">					<span class="keyword">if</span>(vis[nx][ny]==<span class="number">1</span>) <span class="keyword">return</span> step;</span><br><span class="line">					<span class="keyword">if</span>(!vis[nx][ny])&#123;</span><br><span class="line">						vis[nx][ny]=<span class="number">2</span>;</span><br><span class="line">						qg.push(&#123;nx,ny&#125;);</span><br><span class="line">					&#125;</span><br><span class="line">					</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">		<span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">				<span class="built_in">cin</span>&gt;&gt;g[i][j];</span><br><span class="line">				<span class="keyword">if</span>(g[i][j]==<span class="string">&#x27;M&#x27;</span>) boy=&#123;i,j&#125;;</span><br><span class="line">				<span class="keyword">if</span>(g[i][j]==<span class="string">&#x27;G&#x27;</span>) girl=&#123;i,j&#125;;</span><br><span class="line">				<span class="keyword">if</span>(g[i][j]==<span class="string">&#x27;Z&#x27;</span>) ghost[cnt++]=&#123;i,j&#125;;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;bfs()&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Binary Tree</title>
    <url>/posts/e0e2589a.html</url>
    <content><![CDATA[<blockquote>
<p>实验目标：<br>1、创建二叉树<br>2、用非递归算法先中后序遍历二叉树 (难点)<br>3、分别求出二叉树中度为 0、1、2的结点个数<br>4、求出树的高度</p>
<p>参考博客:<br><a href="https://www.cnblogs.com/dolphin0520/archive/2011/08/25/2153720.html">Article_1</a><br><a href="https://www.cnblogs.com/rain-lei/p/3705680.html">Article_2</a> </p>
</blockquote>
<p>难点在于非递归遍历，用栈来模拟递归的过程</p>
<h2 id="二叉树结构"><a href="#二叉树结构" class="headerlink" title="二叉树结构"></a>二叉树结构</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="type">char</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br></pre></td></tr></table></figure>
<h2 id="创建二叉树"><a href="#创建二叉树" class="headerlink" title="创建二叉树"></a>创建二叉树</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CreateBiTree</span><span class="params">(BiTree &amp;t)</span>&#123;</span><br><span class="line">	<span class="type">char</span> ch; <span class="built_in">cin</span>&gt;&gt;ch;</span><br><span class="line">	<span class="keyword">if</span>(ch==<span class="string">&#x27;#&#x27;</span>) t=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		t=new node;</span><br><span class="line">		t-&gt;data=ch;</span><br><span class="line">		CreateBiTree(t-&gt;lchild);  <span class="comment">//创建左子树 </span></span><br><span class="line">		CreateBiTree(t-&gt;rchild);  <span class="comment">//创建右子树 </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Level</span><span class="params">(BiTree L)</span>&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;层序遍历:\n&quot;</span>;</span><br><span class="line">	<span class="keyword">if</span>(!L) <span class="keyword">return</span> ;</span><br><span class="line">	<span class="built_in">queue</span>&lt;BiTree&gt; q;  <span class="comment">//STL队列定义 </span></span><br><span class="line">	q.push(L);</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		BiTree fr=q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="keyword">if</span>(fr) <span class="built_in">cout</span>&lt;&lt;fr-&gt;data&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">		q.push(fr-&gt;lchild);</span><br><span class="line">		q.push(fr-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">preOrder1</span><span class="params">(BinTree *root)</span>     <span class="comment">//递归前序遍历 </span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(root!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;root-&gt;data&lt;&lt;<span class="string">&quot;&quot;</span>;</span><br><span class="line">        preOrder1(root-&gt;lchild);</span><br><span class="line">        preOrder1(root-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h4><p><code>用栈模拟递归</code> </p>
<p>对比递归算法，当递归调用自己时就<code>把当前状态入栈</code>!</p>
<p>操作： 对于当前子树，1.不空就输出根节点并把当前指针入栈，然后更新指针指向左子树，2. 空就更新指针指向栈顶的右子树</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PreOreder</span><span class="params">(BiTree L)</span>&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;前序遍历:\n&quot;</span>;</span><br><span class="line">	<span class="keyword">if</span>(!L) <span class="keyword">return</span> ;</span><br><span class="line">	<span class="built_in">stack</span>&lt;BiTree&gt; st;</span><br><span class="line">	<span class="keyword">while</span>(L || !st.empty())&#123;</span><br><span class="line">		<span class="keyword">while</span>(L)&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;L-&gt;data&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">			st.push(L);</span><br><span class="line">			L=L-&gt;lchild;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!st.empty())&#123;</span><br><span class="line">			L=st.top();</span><br><span class="line">			st.pop();</span><br><span class="line">			L=L-&gt;rchild;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><h4 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">inOrder1</span><span class="params">(BinTree *root)</span>      <span class="comment">//递归中序遍历</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(root!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        inOrder1(root-&gt;lchild);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;root-&gt;data&lt;&lt;<span class="string">&quot;&quot;</span>;</span><br><span class="line">        inOrder1(root-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h4 id="非递归-1"><a href="#非递归-1" class="headerlink" title="非递归"></a>非递归</h4><p>和前序一样，只不过改成在当前节点没有左子树时输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MidOreder</span><span class="params">(BiTree L)</span>&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;中序遍历:\n&quot;</span>;</span><br><span class="line">	<span class="built_in">stack</span>&lt;BiTree&gt; st;</span><br><span class="line">	<span class="keyword">while</span>(L || !st.empty())&#123;</span><br><span class="line">		<span class="keyword">while</span>(L)&#123;</span><br><span class="line">			st.push(L);</span><br><span class="line">			L = L-&gt;lchild;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!st.empty())&#123;</span><br><span class="line">			L = st.top();</span><br><span class="line">			st.pop();</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;L-&gt;data&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">			L=L-&gt;rchild;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><h4 id="递归-2"><a href="#递归-2" class="headerlink" title="递归"></a>递归</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">postOrder1</span><span class="params">(BinTree *root)</span>    <span class="comment">//递归后序遍历</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(root!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        postOrder1(root-&gt;lchild);</span><br><span class="line">        postOrder1(root-&gt;rchild);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;root-&gt;data&lt;&lt;<span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h4 id="非递归-2"><a href="#非递归-2" class="headerlink" title="非递归"></a>非递归</h4><p>后序遍历的非递归实现是三种遍历方式中最难的一种。因为在后序遍历中，要保证左孩子和右孩子都已被访问并且左孩子在右孩子前访问才能访问根结点，这就为流程的控制带来了难题，解决方案如下。</p>
<p>要保证根结点在左孩子和右孩子访问之后才能访问，因此对于任一结点P，先将其入栈。如果P不存在左孩子和右孩子，则可以直接访问它；或者P存在左孩子或者右孩子，但是其左孩子和右孩子都已被访问过了，则同样可以直接访问该结点。若非上述两种情况，则将P的右孩子和左孩子依次入栈，这样就保证了每次取栈顶元素的时候，左孩子在右孩子前面被访问，左孩子和右孩子都在根结点前面被访问。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">也就是模拟递归</span></span><br><span class="line"><span class="comment">对于当前节点，只有当左子树和右子树都访问过或者为空时才能输出当前节点，有一个存在且没有访问过就需要先访问它，而栈是先进后</span></span><br><span class="line"><span class="comment">出，所以入栈顺序先放右子树在放左子树</span></span><br><span class="line"><span class="comment">如何判断是否访问过？</span></span><br><span class="line"><span class="comment">我们可以保存上一个访问的节点pre，如果满足 (p-&gt;right==NULL &amp;&amp; pre==p-&gt;left) || pre=p-&gt;right，那么显然p的孩子都访问</span></span><br><span class="line"><span class="comment">过了，接下来可以访问p </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="type">void</span> <span class="title function_">PostOrder</span><span class="params">(BiTree L)</span>&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;后序遍历:\n&quot;</span>;</span><br><span class="line">	<span class="keyword">if</span>(!L) <span class="keyword">return</span> ;</span><br><span class="line">	<span class="built_in">stack</span>&lt;BiTree&gt; st; </span><br><span class="line">	st.push(L);</span><br><span class="line">	BiTree pre=L;</span><br><span class="line">	<span class="keyword">while</span>(!st.empty())&#123;</span><br><span class="line">		BiTree temp=st.top();</span><br><span class="line">		<span class="keyword">if</span>((!temp-&gt;lchild &amp;&amp; !temp-&gt;rchild) || (!temp-&gt;rchild &amp;&amp; temp-&gt;lchild==pre) || temp-&gt;rchild==pre)&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;temp-&gt;data&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">			pre=temp;</span><br><span class="line">			st.pop();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(temp-&gt;rchild) st.push(temp-&gt;rchild);</span><br><span class="line">			<span class="keyword">if</span>(temp-&gt;lchild) st.push(temp-&gt;lchild);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>求度数简单这里不单独放代码了</p>
<h2 id="全代码"><a href="#全代码" class="headerlink" title="全代码"></a>全代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">实验目标：</span></span><br><span class="line"><span class="comment">1、创建二叉树</span></span><br><span class="line"><span class="comment">2、用非递归算法先中后序遍历二叉树</span></span><br><span class="line"><span class="comment">3、分别求出二叉树中度为 0、1、2的结点个数</span></span><br><span class="line"><span class="comment">4、求出树的高度</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">难点在于非递归遍历，用栈来模拟递归的过程，这里我用了STL里面的栈，只需要知道栈的操作干什么即可，不需要知道原理 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">代码输入方式: 输入一颗树的先序序列，空节点用&quot;#&quot;代替 </span></span><br><span class="line"><span class="comment">参考博客: </span></span><br><span class="line"><span class="comment">https://www.cnblogs.com/dolphin0520/archive/2011/08/25/2153720.html</span></span><br><span class="line"><span class="comment">https://www.cnblogs.com/rain-lei/p/3705680.html </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="type">char</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"><span class="type">int</span> cnt0,cnt1,cnt2,high;</span><br><span class="line"><span class="comment">//递归利用先序遍历方式创建二叉树，空节点用&quot;#&quot;代替 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateBiTree</span><span class="params">(BiTree &amp;t)</span>&#123;</span><br><span class="line">	<span class="type">char</span> ch; <span class="built_in">cin</span>&gt;&gt;ch;</span><br><span class="line">	<span class="keyword">if</span>(ch==<span class="string">&#x27;#&#x27;</span>) t=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		t=new node;</span><br><span class="line">		t-&gt;data=ch;</span><br><span class="line">		CreateBiTree(t-&gt;lchild);  <span class="comment">//创建左子树 </span></span><br><span class="line">		CreateBiTree(t-&gt;rchild);  <span class="comment">//创建右子树 </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">find</span><span class="params">(BiTree t,<span class="type">int</span> h)</span>&#123;  <span class="comment">//传入高度参数 </span></span><br><span class="line">	<span class="keyword">if</span>(!t) <span class="keyword">return</span> ;</span><br><span class="line">	high=max(high,h);  <span class="comment">//以最大高度节点为准 </span></span><br><span class="line">	<span class="keyword">if</span>(t-&gt;lchild &amp;&amp; t-&gt;rchild) cnt2++;  <span class="comment">//度为2 </span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(!t-&gt;lchild &amp;&amp; !t-&gt;rchild) cnt0++;  <span class="comment">//度为0 </span></span><br><span class="line">	<span class="keyword">else</span> cnt1++;  <span class="comment">//度为1 </span></span><br><span class="line">	find(t-&gt;lchild,h+<span class="number">1</span>);  <span class="comment">//左子树 </span></span><br><span class="line">	find(t-&gt;rchild,h+<span class="number">1</span>);  <span class="comment">//右子树 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//层序遍历利用BFS输出 (实验不做要求)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Level</span><span class="params">(BiTree L)</span>&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;层序遍历:\n&quot;</span>;</span><br><span class="line">	<span class="keyword">if</span>(!L) <span class="keyword">return</span> ;</span><br><span class="line">	<span class="built_in">queue</span>&lt;BiTree&gt; q;  <span class="comment">//STL队列定义 </span></span><br><span class="line">	q.push(L);</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		BiTree fr=q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="keyword">if</span>(fr) <span class="built_in">cout</span>&lt;&lt;fr-&gt;data&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">		q.push(fr-&gt;lchild);</span><br><span class="line">		q.push(fr-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">用栈模拟递归 </span></span><br><span class="line"><span class="comment">操作：</span></span><br><span class="line"><span class="comment">对于当前子树根节点，1.如果当前子树不为空就输出子树根节点并把左子树入栈，指针指向左子树，2.为空则pop出栈顶元素，并</span></span><br><span class="line"><span class="comment">将此时栈顶根节点的右子树入栈 </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOreder</span><span class="params">(BiTree L)</span>&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;前序遍历:\n&quot;</span>;</span><br><span class="line">	<span class="keyword">if</span>(!L) <span class="keyword">return</span> ;</span><br><span class="line">	<span class="built_in">stack</span>&lt;BiTree&gt; st;</span><br><span class="line">	<span class="keyword">while</span>(L || !st.empty())&#123;</span><br><span class="line">		<span class="keyword">while</span>(L)&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;L-&gt;data&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">			st.push(L);</span><br><span class="line">			L=L-&gt;lchild;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!st.empty())&#123;</span><br><span class="line">			L=st.top();</span><br><span class="line">			st.pop();</span><br><span class="line">			L=L-&gt;rchild;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">和先序类似，就是先处理完左子树再输出根节点然后把右子树入栈 </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="type">void</span> <span class="title function_">MidOreder</span><span class="params">(BiTree L)</span>&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;中序遍历:\n&quot;</span>;</span><br><span class="line">	<span class="built_in">stack</span>&lt;BiTree&gt; st;</span><br><span class="line">	<span class="keyword">while</span>(L || !st.empty())&#123;</span><br><span class="line">		<span class="keyword">while</span>(L)&#123;</span><br><span class="line">			st.push(L);</span><br><span class="line">			L = L-&gt;lchild;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!st.empty())&#123;</span><br><span class="line">			L = st.top();</span><br><span class="line">			st.pop();</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;L-&gt;data&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">			L=L-&gt;rchild;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">也就是模拟递归</span></span><br><span class="line"><span class="comment">对于当前节点，只有当左子树和右子树都访问过或者为空时才能输出当前节点，有一个存在且没有访问过就需要先访问它，而栈是先进后</span></span><br><span class="line"><span class="comment">出，所以入栈顺序先放右子树在放左子树</span></span><br><span class="line"><span class="comment">如何判断是否访问过？</span></span><br><span class="line"><span class="comment">我们可以保存上一个访问的节点pre，如果满足 (p-&gt;right==NULL &amp;&amp; pre==p-&gt;left) || pre=p-&gt;right，那么显然p的孩子都访问</span></span><br><span class="line"><span class="comment">过了，接下来可以访问p </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="type">void</span> <span class="title function_">PostOrder</span><span class="params">(BiTree L)</span>&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;后序遍历:\n&quot;</span>;</span><br><span class="line">	<span class="keyword">if</span>(!L) <span class="keyword">return</span> ;</span><br><span class="line">	<span class="built_in">stack</span>&lt;BiTree&gt; st; </span><br><span class="line">	st.push(L);</span><br><span class="line">	BiTree pre=L;</span><br><span class="line">	<span class="keyword">while</span>(!st.empty())&#123;</span><br><span class="line">		BiTree temp=st.top();</span><br><span class="line">		<span class="keyword">if</span>((!temp-&gt;lchild &amp;&amp; !temp-&gt;rchild) || (!temp-&gt;rchild &amp;&amp; temp-&gt;lchild==pre) || temp-&gt;rchild==pre)&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;temp-&gt;data&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">			pre=temp;</span><br><span class="line">			st.pop();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(temp-&gt;rchild) st.push(temp-&gt;rchild);</span><br><span class="line">			<span class="keyword">if</span>(temp-&gt;lchild) st.push(temp-&gt;lchild);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Traverse</span><span class="params">(BiTree L)</span>&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>; </span><br><span class="line">	Level(L);  <span class="comment">//层序遍历 </span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	PreOreder(L);  <span class="comment">//前序遍历 </span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	MidOreder(L);  <span class="comment">//中序遍历 </span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	PostOrder(L);  <span class="comment">//后序遍历 </span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	BiTree L;</span><br><span class="line">	CreateBiTree(L);  <span class="comment">//创建二叉树 </span></span><br><span class="line">	Traverse(L);  <span class="comment">//遍历二叉树 </span></span><br><span class="line">	find(L,<span class="number">1</span>);  <span class="comment">//找到二叉树度数为0、1、2的结点数，并得出深度 </span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;树的高度为: &quot;</span>&lt;&lt;high&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;度数为0的节点数量: &quot;</span>&lt;&lt;cnt0&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;度数为1的节点数量: &quot;</span>&lt;&lt;cnt1&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;度数为2的节点数量: &quot;</span>&lt;&lt;cnt2&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>CCPC打铁记</title>
    <url>/posts/3099d076.html</url>
    <content><![CDATA[<blockquote>
<p>2020年10月18日，这一天是我第一次打比赛的日子，非常有纪念意义，但是时至今日我才补了这篇文章</p>
</blockquote>
<p>2020年注定是不平凡的一年，突如其来的疫情改变很多人的生活轨迹，原本该在这一年大展拳脚的学长们无奈只能在家里打着练习赛，然而对我们而言，有好也有坏吧，好的是我们有更多时间去提升自己(当然全靠自觉)，坏的是少了许多阅历，不管怎样，终于在2020年8月29日我们开学了，开学后经过一个星期的过渡，又回到了算法的训练中去，在下面也打了许多训练赛，每次都紧紧抱着大佬的大腿，每次成绩也都还不错(不错指的是会的都比较快的做出来了)，然而只要是dp只要是新算法我们就止步于此了</p>
<p>又过了一个月，我们迎来的这一年的CCPC邀请赛，首先是出线问题，最终学长们也都打进去了，我们19级的因为时间还多，机会就都留给学长们了，不过一星期后，老师跟我们说可以办外卡，也可以参赛拿奖，高兴了我一天，当时我以为是线下赛，想着终于可以出去涨涨见识了，然而第二天就丧了，因为疫情，这一年几乎所有比赛都是线上举行的！一下子感觉气氛都不对了，不过毕竟是比赛，比赛前我还是有去多刷题的，然而因为好多新算法都没学，有很多题目都是干瞪眼</p>
<p>终于到了比赛的前一天，这一天有热身赛，而且这一天还有蓝桥杯，我被叫去当监考了，报酬是“管饭”，到了才知道上一年19级也有好多人报了蓝桥杯，顿时心理不平衡了。。。也是无聊的看了一上午手机，就到了中午，饭还行，挺好吃的，吃撑了~，吃完没有睡觉直接去打热身赛了，教师布置的有模有样地，开了热身赛，我们瞬间A了签到题，又过了不久A了第二道，然后就没有然后了。。剩下两道做出来的屈指可数，还得到了俩气球，哈哈哈。晚上我们队伍一起去吃饭，吃完后直接去机房打印板子去了，由于热身赛手推了高中的许多公式，我们打印的板子都集中到了高中数学公式上，能用一个都是赚的！终于这一天结束了，我们约定明天要拿铜牌🥉，晚上11点睡觉，然而我还是失眠了。。12点半才睡着</p>
<p>第二天早早起来，拿上该拿的东西，走向了机房，换上队服，拍了照片，进入系统，熟练的打开了DEV。终于比赛开始了，没有人过题，我们仨只能瞎找，过了两分钟，A题有人过了，我们一看是水题，然后他俩写代码，我就去看下一道了，第二道是一个数学题，然而我看错题了，我把向下取整符号看成了绝对值。。导致我们仨浪费了3分钟的时间整理了一个错误的思路，我背锅，发现向下取整后，潘佬爷瞬间有了思路，他给我们手推样例，看了一会，我也懂了，原以为通过这个规律推出一个数学式子，后来发现通过这个规律直接暴力就可以了，潘佬爷txdy，过了不久A了第二题，然后我们看向了E，正解是双指针(尺取)，而我们先是贪心，后来动规，发现解不出来，就看向了G题，是一个判环的题目，由于之前没学过判环，我们仨都没有把握，潘姥爷提出了标记结点的思路，然后我们俩疯狂造数据，疯狂验证，最终证明这个方法是对的，只不过因为题目有一些小坑，wrong了三发，我们一度怀疑算法有问题~A了3题后我们排名还是排到了两百开外，我们也就止步于此了，第四题我们怎么也不知道怎么做，最后2小时多我们划了，哎，打铁了</p>
<p>然而女队却很幸运，只过了两题，竟然混了一个铜牌，太搞了太搞了，晚上我们聚在一起吃了一顿饭，商量了一下以后的训练，希望我们下次不再打铁，毕竟我们的理想不只是拿一个铜牌💪</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>CCPC2021网络赛复赛</title>
    <url>/posts/7a5cad64.html</url>
    <content><![CDATA[<h2 id="Primality-Test"><a href="#Primality-Test" class="headerlink" title="Primality Test"></a><a href="http://acm.hdu.edu.cn/contest/problem?cid=1038&amp;pid=1004">Primality Test</a></h2><p>根据题意可知，求连续两个质数相加除以2向下取整后是否还是质数，因为是连续的两个质数，所以取中位数后一定不会是质数，1除外</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line">LL t , n;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span> , &amp;t);</span><br><span class="line">    <span class="keyword">while</span> (t --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span> , &amp;n);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Nun-Heh-Heh-Aaaaaaaaaaa"><a href="#Nun-Heh-Heh-Aaaaaaaaaaa" class="headerlink" title=" Nun Heh Heh Aaaaaaaaaaa"></a><a href="http://acm.hdu.edu.cn/contest/problem?cid=1038&amp;pid=1006"> Nun Heh Heh Aaaaaaaaaaa</a></h2><p>给定一个字符串，求这个字符串有多少个子序列满足由前缀<strong>nunhehheh</strong>和k个<strong>a</strong>(k&gt;0)组成。</p>
<p>例如nunhehhehaaaaaa就是符合要求的，但是nunhehheh和nunhehhehoooaaa是不符合要求的。</p>
<p>这是一个dp模型，求一个字符串的所有子序列中有多少个s(s是一个字符串)，这里只是多了后缀a，我们先找字符串包含多少个nunhehheh，开一个dp数组，dp[i]表示匹配到匹配到第k个字符出现了前i个字串的数量，例如dp[1]表示出现n的数量，dp[3]表示出现nun的数量，遍历字符串，将对应的字符，dp[i]=(dp[i-1]+dp[i])%mod</p>
<p>最后dp[9]就是出现nunhehheh的数量，用dp[10]表示前缀<strong>nunhehheh</strong>和k个<strong>a</strong>(k&gt;0)组成的字符串数量，考虑给后面加上一个a，那么之前满足条件的字符串可以加a也可以不加，而dp[9]必须加上这个a才能满足条件，所以dp[10]=(dp[10]+dp[9])%mod</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll mod=<span class="number">998244353</span>;</span><br><span class="line">ll dp[<span class="number">20</span>],T;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line">	<span class="keyword">while</span>(T--)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span> dp);</span><br><span class="line">		<span class="built_in">string</span> s;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">		<span class="type">int</span> len=s.size();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(s[i]==<span class="string">&#x27;n&#x27;</span>)&#123;</span><br><span class="line">				dp[<span class="number">1</span>]++;</span><br><span class="line">				dp[<span class="number">3</span>]=(dp[<span class="number">3</span>]+dp[<span class="number">2</span>])%mod;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;u&#x27;</span>) dp[<span class="number">2</span>]=(dp[<span class="number">1</span>]+dp[<span class="number">2</span>])%mod;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;h&#x27;</span>)&#123;	<span class="comment">//这里需要特别注意如果出现连续相同的字符，例如aaaa，那需要先更新最后一个a的答案，因为这里计算出现多少个aaaa，如果当前位置是k，那当前答案是用[1,k-1]出现aaa的数量来更新的，如果先更新前面的a，就会导致使用[1,k]出现的a来更新答案，导致错误</span></span><br><span class="line">				dp[<span class="number">9</span>]=(dp[<span class="number">9</span>]+dp[<span class="number">8</span>])%mod;</span><br><span class="line">				dp[<span class="number">7</span>]=(dp[<span class="number">7</span>]+dp[<span class="number">6</span>])%mod;</span><br><span class="line">				dp[<span class="number">6</span>]=(dp[<span class="number">6</span>]+dp[<span class="number">5</span>])%mod;</span><br><span class="line">				dp[<span class="number">4</span>]=(dp[<span class="number">4</span>]+dp[<span class="number">3</span>])%mod;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;e&#x27;</span>)&#123;</span><br><span class="line">				dp[<span class="number">5</span>]=(dp[<span class="number">4</span>]+dp[<span class="number">5</span>])%mod;</span><br><span class="line">				dp[<span class="number">8</span>]=(dp[<span class="number">8</span>]+dp[<span class="number">7</span>])%mod;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;a&#x27;</span>) dp[<span class="number">10</span>]=(dp[<span class="number">10</span>]*<span class="number">2</span>%mod+dp[<span class="number">9</span>])%mod;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;dp[<span class="number">10</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Kanade-Doesn’t-Want-to-Learn-CG"><a href="#Kanade-Doesn’t-Want-to-Learn-CG" class="headerlink" title=" Kanade Doesn’t Want to Learn CG"></a><a href="http://acm.hdu.edu.cn/contest/problem?cid=1038&amp;pid=1002"> Kanade Doesn’t Want to Learn CG</a></h2><p>分类讨论，数学问题，我用小数写的，但是其实用longlong更好，不会有精度问题</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">int</span> T;</span><br><span class="line"><span class="type">double</span> a,b,c,x0,y0,x1,y1,y2;</span><br><span class="line"><span class="type">double</span> <span class="title function_">f1</span><span class="params">(ll y)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (-b+<span class="built_in">sqrt</span>(b*b<span class="number">-4</span>*a*(c-y0)))/(<span class="number">2</span>*a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> <span class="title function_">f2</span><span class="params">(ll y)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (-b-<span class="built_in">sqrt</span>(b*b<span class="number">-4</span>*a*(c-y0)))/(<span class="number">2</span>*a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> <span class="title function_">work</span><span class="params">(<span class="type">double</span> x)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a*x*x+b*x+c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line">	<span class="keyword">while</span>(T--)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;x0&gt;&gt;x1&gt;&gt;y0&gt;&gt;y1&gt;&gt;y2;</span><br><span class="line">		<span class="keyword">if</span>(work(x0)==y0 || work(x1)==y0) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="type">double</span> p=-b/(<span class="number">2</span>*a);</span><br><span class="line">			<span class="keyword">if</span>(work(p)&lt;=y0 || p&gt;=x1 || (f1(y0)&gt;=x0 &amp;&amp; f1(y0)&lt;=x1)) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(f2(y0)&gt;x0 &amp;&amp; f2(y0)&lt;x1) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">if</span>(work(x1)&lt;=y2 &amp;&amp; f2(y0)&gt;x1 &amp;&amp; f2(y0)&lt;x1+x1-x0) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">				<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更好的代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line">ll a, b, c, xa, xb, ya, yb, yc;</span><br><span class="line"></span><br><span class="line">ll <span class="title function_">changdu</span><span class="params">(ll x)</span>&#123;</span><br><span class="line">    ll res = a * x * x + b * x + c;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    ios;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t --)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; xa &gt;&gt; xb &gt;&gt; ya &gt;&gt; yb &gt;&gt; yc;</span><br><span class="line">        ll lena = changdu(xb), lenb = changdu(<span class="number">0</span> - xa + xb * <span class="number">2</span>), len = changdu(xa);</span><br><span class="line">        <span class="keyword">if</span> (len &lt;= ya) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;No\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (lena == ya || lena &gt; yc) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;No\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (lena &lt; ya) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Yes\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (lenb &gt;= ya) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;No\n&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Yes\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Jumping-Monkey"><a href="#Jumping-Monkey" class="headerlink" title=" Jumping Monkey"></a><a href="http://acm.hdu.edu.cn/contest/problem?cid=1038&amp;pid=1011"> Jumping Monkey</a></h2><p>比赛的时候一直在想从边权大的开始出发，把所有能到达这个点的所有点答案加一，利用线段树去维护，但是到后面块太多了，维护不了，于是就搁置了，正解是从边权小的开始枚举，对于当前点，把和这个点相邻的点都合并到当前点，让当前点作为祖先，循环往复，到最后每一个点距离根节点的距离就是答案，原理就是因为是按照点权从小到大枚举的，因此每一个点都不可能越过根节点到达其他分支的节点，所以一个节点可以到达的节点就是这个点距离和根节点之间的点，也就是距离。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> id,val;</span><br><span class="line">&#125;arr[N];</span><br><span class="line"><span class="type">int</span> T,n,u,v;</span><br><span class="line"><span class="type">int</span> fa[N],ans[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; ve[N];</span><br><span class="line"><span class="type">bool</span> <span class="title function_">cmp</span><span class="params">(node a,node b)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.val&lt;b.val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==fa[x]) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="type">int</span> tmp=fa[x];</span><br><span class="line">		fa[x]=find(fa[x]);</span><br><span class="line">		ans[x]+=ans[tmp];	<span class="comment">//维护距离根节点的距离</span></span><br><span class="line">		<span class="keyword">return</span> fa[x];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		fa[i]=i;</span><br><span class="line">		ans[i]=<span class="number">0</span>;</span><br><span class="line">		ve[i].clear();	</span><br><span class="line">		vis[i]=<span class="number">0</span>;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line">	<span class="keyword">while</span>(T--)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">		init();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">			ve[u].push_back(v);</span><br><span class="line">			ve[v].push_back(u);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;arr[i].val;</span><br><span class="line">			arr[i].id=i;</span><br><span class="line">		&#125;</span><br><span class="line">		sort(arr+<span class="number">1</span>,arr+<span class="number">1</span>+n,cmp);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="type">int</span> now=arr[i].id;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;ve[now].size();j++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(vis[ve[now][j]])&#123;</span><br><span class="line">					<span class="type">int</span> fu=find(ve[now][j]);</span><br><span class="line">					ans[fu]=<span class="number">1</span>;</span><br><span class="line">					fa[fu]=now;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			vis[now]=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			find(i);</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;ans[i]+<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Monopoly"><a href="#Monopoly" class="headerlink" title="Monopoly"></a>Monopoly</h2><p>$a1,a2,a3…an$</p>
<p>首先求一个前缀和，$S=K*pre[n]+pre[i]$，考虑pre[n]大于0的情况，这个时候pre[i]一定小于等于S，对pre[n]取模，发现S和pre[i]同余，也就是求一个pre[i]使得K最小，并且在K相同条件下i尽可能小，考虑维护n个容器，每一个容器对应一个余数，容器中放置所有同余的前缀和，给定一个x就去相对应的容器中二分找到小于等于x的最大前缀，即是答案。</p>
<p>需要特别注意的是，前缀和可能是负数，而给定的x是负数，这个时候x和前缀和是同余的，但是符号相反，这里需要特别处理一下。</p>
<p>如果pre[n]小于0，则所有数字取反即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">ll arr[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;ll&gt; cis[N];</span><br><span class="line"><span class="type">int</span> tot,T;</span><br><span class="line"><span class="built_in">map</span>&lt;ll,<span class="type">int</span>&gt; mp,mp2;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">	mp.clear();</span><br><span class="line">	mp2.clear();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tot;i++) cis[i].clear();</span><br><span class="line">	tot=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line">	<span class="keyword">while</span>(T--)&#123;</span><br><span class="line">		init();</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;arr[i];</span><br><span class="line">			arr[i]+=arr[i<span class="number">-1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		ll sum=arr[n];</span><br><span class="line">		<span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(sum&lt;<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) arr[i]=-arr[i];</span><br><span class="line">			sum=-sum;</span><br><span class="line">			flag=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(!mp2[arr[i]]) mp2[arr[i]]=i;;</span><br><span class="line">		<span class="keyword">if</span>(sum!=<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">				ll now=(arr[i]%sum+sum)%sum;</span><br><span class="line">				<span class="keyword">if</span>(!mp[now]) mp[now]=++tot;</span><br><span class="line">				cis[mp[now]].push_back(arr[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tot;i++) sort(cis[i].begin(),cis[i].end());</span><br><span class="line">		<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">			ll x;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">			<span class="keyword">if</span>(flag) x=-x;</span><br><span class="line">			<span class="keyword">if</span>(x==<span class="number">0</span>)&#123;</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(sum==<span class="number">0</span>)&#123;</span><br><span class="line">				<span class="keyword">if</span>(mp2[x]) <span class="built_in">cout</span>&lt;&lt;mp2[x]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">				<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(!mp[(x%sum+sum)%sum])&#123;</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="type">int</span> now=mp[(x%sum+sum)%sum];</span><br><span class="line">			<span class="keyword">auto</span> it=upper_bound(cis[now].begin(),cis[now].end(),x);</span><br><span class="line">			<span class="keyword">if</span>(it==cis[now].begin()) <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				it--;</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;(x-*it)/sum*n+mp2[*it]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">4 4</span></span><br><span class="line"><span class="comment">1 2 -3 3</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">7</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>比赛</tag>
      </tags>
  </entry>
  <entry>
    <title>CPP文件读写</title>
    <url>/posts/96d45fb1.html</url>
    <content><![CDATA[<h1 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h1><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><p><code>#include &lt;fstream&gt;</code></p>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><ul>
<li><p>声明定义：</p>
<ul>
<li>读取：ifstream inFile</li>
<li>写出：ofstream outFile</li>
</ul>
</li>
<li><p>打开文件：inFile.open(“file name”, ios::in)  (ios::in、ios::out、ios::app)</p>
<ul>
<li>判断是否打开成功：bool inFile.is_open()</li>
</ul>
</li>
<li>读出文件一行内容写入string：getline(inFile, str)</li>
<li>string写出到文件：outFile &lt;&lt; str &lt;&lt; endl;</li>
<li>关闭文件：inFile.close</li>
</ul>
<p><code>示例程序:文件夹下所有文件中csdn图片链接提取出来</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *inFolderPath = <span class="string">&quot;C:\\Users\\60116\\Desktop\\_posts\\&quot;</span>;</span><br><span class="line"><span class="comment">// const char *outFolderPath = &quot;C:\\Users\\60116\\Desktop\\out\\&quot;;</span></span><br><span class="line"></span><br><span class="line">vector&lt;string&gt; res;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dealwith</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str.<span class="built_in">find</span>(<span class="string">&quot;csdn&quot;</span>) == string::npos) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pos = str.<span class="built_in">find</span>(<span class="string">&quot;csdn&quot;</span>), startIndex = <span class="number">-1</span>, endIndex = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(pos--) &#123;</span><br><span class="line">        <span class="keyword">if</span>(str.<span class="built_in">substr</span>(pos, <span class="number">5</span>) == <span class="string">&quot;https&quot;</span>) &#123;</span><br><span class="line">            startIndex = pos;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(pos &lt; str.<span class="built_in">size</span>() &amp;&amp; pos++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(str.<span class="built_in">substr</span>(pos, <span class="number">4</span>) == <span class="string">&quot;.png&quot;</span> || str.<span class="built_in">substr</span>(pos, <span class="number">4</span>) == <span class="string">&quot;.jpg&quot;</span>) &#123;</span><br><span class="line">            endIndex = pos + <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(startIndex != <span class="number">-1</span> &amp;&amp; endIndex != <span class="number">-1</span>) &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(str.<span class="built_in">substr</span>(startIndex, endIndex - startIndex));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">(<span class="type">char</span> *inPrefix, <span class="type">char</span> *fileName)</span> </span>&#123;</span><br><span class="line">    res.<span class="built_in">push_back</span>(fileName);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> inFilePath[<span class="number">500</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(inFilePath, inPrefix);</span><br><span class="line">    <span class="built_in">strcat</span>(inFilePath, fileName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// char outFilePath[500];</span></span><br><span class="line">    <span class="comment">// strcpy(outFilePath, outPrefix);</span></span><br><span class="line">    <span class="comment">// strcat(outFilePath, fileName);</span></span><br><span class="line"></span><br><span class="line">    <span class="function">ifstream <span class="title">inFile</span><span class="params">(inFilePath, ios::in)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!inFile.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;in error&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string line;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取文件每一行数据进行处理</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">getline</span>(inFile, line)) &#123;</span><br><span class="line">        <span class="built_in">dealwith</span>(line);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    inFile.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ofstream <span class="title">outFile</span><span class="params">(<span class="string">&quot;C:\\Users\\60116\\Desktop\\out.txt&quot;</span>, ios::out)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!outFile.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;out error&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DIR *dir;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">dirent</span> *ent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((dir = <span class="built_in">opendir</span>(inFolderPath)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((ent = <span class="built_in">readdir</span>(dir)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 忽略 . 和 .. 条目</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(ent-&gt;d_name, <span class="string">&quot;.&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(ent-&gt;d_name, <span class="string">&quot;..&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">char</span> curInFolderPath[<span class="number">500</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(curInFolderPath, inFolderPath);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// char curOutFolderPath[500];</span></span><br><span class="line">            <span class="comment">// strcpy(curOutFolderPath, outFolderPath);</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">work</span>(curInFolderPath, ent-&gt;d_name);</span><br><span class="line"></span><br><span class="line">            ++cnt;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// break;</span></span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;total: &quot;</span> &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">closedir</span>(dir);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;cannot open this dir&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> p: res) &#123;</span><br><span class="line">        outFile &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    outFile.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="遍历文件夹下所有文件"><a href="#遍历文件夹下所有文件" class="headerlink" title="遍历文件夹下所有文件"></a>遍历文件夹下所有文件</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">DIR *dir;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">dirent</span> *ent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((dir = <span class="built_in">opendir</span>(inFolderPath)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((ent = <span class="built_in">readdir</span>(dir)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 忽略 . 和 .. 条目</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(ent-&gt;d_name, <span class="string">&quot;.&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(ent-&gt;d_name, <span class="string">&quot;..&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ++cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;total: &quot;</span> &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">closedir</span>(dir);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;cannot open this dir&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>文件读写</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round</title>
    <url>/posts/682df6fc.html</url>
    <content><![CDATA[<h2 id="A-Cards-for-Friends"><a href="#A-Cards-for-Friends" class="headerlink" title="A. Cards for Friends"></a>A. Cards for Friends</h2><p>给一个宽度和一个长度的蛋糕，只有为长或宽为偶数时才能切一刀数量乘以2，问给定尺寸的蛋糕能否分够k块。</p>
<p>分别对宽和长除2，只要是偶数就除，看看能除几次，得到两个次数相乘就是能分的最大数量，和k比较一下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SUP=<span class="number">0x800000</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-4</span>;</span><br><span class="line"><span class="type">int</span> num[MAXN];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		<span class="type">int</span> w,h,k;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;w&gt;&gt;h&gt;&gt;k;</span><br><span class="line">		<span class="type">int</span> a=<span class="number">1</span>,b=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(w)&#123;</span><br><span class="line">			<span class="keyword">if</span>(w&amp;<span class="number">1</span>) <span class="keyword">break</span>; </span><br><span class="line">			a*=<span class="number">2</span>;</span><br><span class="line">			w/=<span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(h)&#123;</span><br><span class="line">			<span class="keyword">if</span>(h&amp;<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">			b*=<span class="number">2</span>;</span><br><span class="line">			h/=<span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(k&lt;=a*b)  <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="B-Fair-Division"><a href="#B-Fair-Division" class="headerlink" title="B. Fair Division"></a>B. Fair Division</h2><p>给定n个数，每一个数只能是1或2，问能否把n个数分成相等的两部分</p>
<p>1数量为奇数时不可行，1数量为偶数并且2数量为偶数可行，1数量为偶数2数量为奇数不可行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SUP=<span class="number">0x800000</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-4</span>;</span><br><span class="line"><span class="type">int</span> num[MAXN];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		<span class="type">int</span> n;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">		<span class="type">int</span> cnt1=<span class="number">0</span>,cnt2=<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="type">int</span> tmp;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;tmp;</span><br><span class="line">			<span class="keyword">if</span>(tmp==<span class="number">1</span>) cnt1++;</span><br><span class="line">			<span class="keyword">if</span>(tmp==<span class="number">2</span>) cnt2++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(cnt1&amp;<span class="number">1</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(cnt1==<span class="number">0</span> &amp;&amp; cnt2&amp;<span class="number">1</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="C-Long-Jumps"><a href="#C-Long-Jumps" class="headerlink" title="C. Long Jumps"></a>C. Long Jumps</h2><p>给n个数，初始可以从1-n中任意一个位置作为起始位置，从起始开始，每次往右跳a[i]步，并且得到分数a[i]，当跳过n后结束，问最大分数</p>
<p>排序，从后往前遍历，如果当前位置往右跳后没出界则从这个位置开始的分数就是这个位置的数加上以右跳一步落点为起点的分数，过程中取分数最大值，最后输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SUP=<span class="number">0x800000</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-4</span>;</span><br><span class="line"><span class="type">int</span> num[MAXN],sc[MAXN];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		<span class="type">int</span> n,ans=<span class="number">-1</span>;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;num[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">			sc[i]=num[i];</span><br><span class="line">			<span class="keyword">if</span>(i+num[i]&lt;=n) sc[i]+=sc[i+num[i]];</span><br><span class="line">			ans=max(ans,sc[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="D-Even-Odd-Game"><a href="#D-Even-Odd-Game" class="headerlink" title="D. Even-Odd Game"></a>D. Even-Odd Game</h2><p>n个数，两个人轮流选数，a选到偶数加分，b选到奇数加分，加分为a[i]，求a开始必胜还是必败</p>
<p>排序，从后往前选，能加则加，不能加不加，最后比谁分数大</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll SUP=<span class="number">0x800000</span>;</span><br><span class="line"><span class="type">const</span> ll MAXN=<span class="number">2e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-4</span>;</span><br><span class="line">ll num[MAXN];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	ll t;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		ll n;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">		<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;num[i];</span><br><span class="line">		sort(num+<span class="number">1</span>,num+<span class="number">1</span>+n);</span><br><span class="line">		ll sc1=<span class="number">0</span>,sc2=<span class="number">0</span>,t=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(ll i=n;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">			<span class="keyword">if</span>(t==<span class="number">1</span>)&#123;</span><br><span class="line">				<span class="keyword">if</span>(!(num[i]&amp;<span class="number">1</span>)) sc1+=num[i];</span><br><span class="line">				t=<span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">if</span>(num[i]&amp;<span class="number">1</span>) sc2+=num[i];</span><br><span class="line">				t=<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(sc1==sc2) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Tie\n&quot;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(sc1&gt;sc2) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Alice\n&quot;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Bob\n&quot;</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="E-Correct-Placement"><a href="#E-Correct-Placement" class="headerlink" title="E. Correct Placement"></a>E. Correct Placement</h2><p>n组数，每组数都有一个长宽，一组数可以排在另一组数前面，条件是len(pre)&lt;len(now) and wide(pre)&lt;wide(now)或者len(pre)&lt;wide(now) &amp;&amp; wide(pre)&lt;wide(now)，对于每一个数输出一个可以排在这个数前面的数位置，多解随便输出一个位置即可</p>
<p>这道题我觉得解法很巧妙，首先每一组数保证h&gt;w，按照h大小排一下序，当h相同时按w从大到小排，然后从前往后遍历，这样保证了前面的h小于等于当前h了，只要找前面小于当前w的一个数即可，由于输出任意一个，可以维护前缀最小值，直接判断前面最小的是否小于当前w，小于就输出那个位置，否则就没有输出-1，还有需要按照初始时序列顺序输出，所以需要记录顺序，这里有一个坑就是前面的数h有可能等于当前数的h，所以前面排序规则中才让w从大到小排，这样一来，h相等时就找不到小于当前值的w了，就会记成-1</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll SUP=<span class="number">0x800000</span>;</span><br><span class="line"><span class="type">const</span> ll MAXN=<span class="number">2e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-4</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> h,w,id;</span><br><span class="line">&#125;arr[MAXN],ans[MAXN];</span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(node &amp;x)</span>&#123;</span><br><span class="line">	<span class="type">int</span> tmp=x.h;</span><br><span class="line">	x.h=x.w;</span><br><span class="line">	x.w=tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">cmp</span><span class="params">(node a,node b)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(a.h==b.h) <span class="keyword">return</span> a.w&gt;b.w;</span><br><span class="line">	<span class="keyword">return</span> a.h&lt;b.h;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">cmp2</span><span class="params">(node a,node b)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.id&lt;b.id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mi[MAXN];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	ll t;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		<span class="type">int</span> n;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;arr[i].h&gt;&gt;arr[i].w;</span><br><span class="line">			arr[i].id=i;</span><br><span class="line">			<span class="keyword">if</span>(arr[i].h&lt;arr[i].w) swap(arr[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		sort(arr+<span class="number">1</span>,arr+<span class="number">1</span>+n,cmp);</span><br><span class="line">		<span class="built_in">memset</span>(mi,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> mi);</span><br><span class="line">		<span class="type">int</span> p=<span class="number">-1</span>,tail=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			ans[++tail].id=arr[i].id;</span><br><span class="line">			<span class="keyword">if</span>(arr[i].w&gt;mi[i<span class="number">-1</span>]) ans[tail].h=p;</span><br><span class="line">			<span class="keyword">else</span> ans[tail].h=<span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">if</span>(arr[i].w&lt;mi[i<span class="number">-1</span>])&#123;</span><br><span class="line">				p=arr[i].id;</span><br><span class="line">				mi[i]=arr[i].w;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> mi[i]=mi[i<span class="number">-1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		sort(ans+<span class="number">1</span>,ans+<span class="number">1</span>+tail,cmp2);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tail;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(i!=tail) <span class="built_in">cout</span>&lt;&lt;ans[i].h&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;ans[i].h&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>div3</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS语法笔记</title>
    <url>/posts/efc0e1f0.html</url>
    <content><![CDATA[<blockquote>
<p>对Web有点兴趣，可能它是可视化的，给我带来的成就感更多吧🐷标签不记了，w3school上都有</p>
</blockquote>
<h2 id="文章转载"><a href="#文章转载" class="headerlink" title="文章转载"></a>文章转载</h2><p>原文链接：<a href="https://www.antmoe.com/posts/fd1c8f75/index.html">Click me</a><br>本人也对其做了少些修改</p>
<h2 id="元素"><a href="#元素" class="headerlink" title="元素"></a>元素</h2><p>CSS元素分为<code>块、行、行内块</code>三种元素，块元素会独占一行、行元素会紧凑着排列、而行内块就是综合两者在行内排列着块。</p>
<ul>
  行内元素特征：<br>
  <li>设置宽高无效</li>
  <li>对margin仅设置左右方向有效，上下无效；padding设置上下左右都有效，即会撑大空间,行内元素尺寸，由内含的内容决定，盒模型中 padding, border 与块级元素并无差异，都是标准的盒模型，但是 margin，却只有水平方向的值，垂直方向并没有起作用。行内元素的水平方向的padding-left,padding-right,margin-left,margin-right 都产生边距效果，但是竖直方向的padding-top,padding-bottom,margin-top,margin-bottom都不会产生边距效果。padding设置上下左右都有效，即会撑大空间但是<em>不会产生边距效果</em>。</li>
  <li>不会自动进行换行</li>
  <br><br>
  块状元素特征: <br>
  <li>能够识别宽高</li>
  <li>margin和padding的上下左右均对其有效</li>
  <li>可以自动换行</li>
  <li>多个块状元素标签写在一起，默认排列方式为从上至下</li>
  <br><br>
  行内块状元素特征: <br>
  <li>不自动换行</li>
  <li>能够识别宽高</li>
  <li>默认排列方式为从左到右</li>
</ul>

<p>以上三种元素可以通过<code>display: ???</code>属性切换类型。</p>
<h2 id="选择器分类"><a href="#选择器分类" class="headerlink" title="选择器分类"></a>选择器分类</h2><ul>
<li>基本选择器:  共有 5 个基本选择器，是 CSS 选择器的最为基本的用法。</li>
<li>层级选择器:  共有 4 个层级选择器。</li>
<li>组合选择器：具有交集和并集两种用法，是将之前基本选择器和层级选择器进行组合。</li>
<li>伪类选择器：允许未包含在 HTML 页面中的状态信息选定位 HTML 元素。</li>
<li>伪元素选择器：定位所有未被包含 HTML 的实体。</li>
</ul>
<h2 id="基本选择器"><a href="#基本选择器" class="headerlink" title="基本选择器"></a>基本选择器</h2><ol>
<li>类型选择器（元素选择器）   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">     font: 12px;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li>类（Class）选择器<br>类选择器前面是“ . ”，类名对应HTML中的class类    <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.demo &#123;</span><br><span class="line">   color: lightcoral;</span><br><span class="line">   font-size: 24px;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
<li>ID 选择器<br>id选择器前面是“ # ”，<code>一个 html 文件中 id 只允许出现一次</code>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#Demo &#123;</span><br><span class="line">  color: lightcoral;</span><br><span class="line">  font-size: 24px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>通配符“ * ”，为HTML中所有元素添加样式  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">  color: lightcoral;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>属性选择器</p>
<ul>
<li>[attr] 属性选择器：通过 HTML 元素的 attr 属性名来定位具体 HTML 元素，把所有title属性的元素全部改变。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[title] &#123;</span><br><span class="line">    color=&quot;red&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>[标签][属性]：将所有特定标签加油特定属性的元素添加样式<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a[href] &#123;color:red;&#125; //对所有加有href的a标签添加样式</span><br></pre></td></tr></table></figure></li>
<li>[标签][属性1][属性2][…]：将同时加有属性1、属性2…的特定标签添加样式<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a[href][title]  &#123;color:red;&#125;</span><br></pre></td></tr></table></figure></li>
<li>根据具体属性值选择<br>除了选择拥有某些属性的元素，还可以进一步缩小选择范围，只选择有特定属性值的元素。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a[href=&quot;http://www.w3school.com.cn/about_us.asp&quot;] &#123;color: red;&#125;</span><br></pre></td></tr></table></figure></li>
<li>根据多个具体属性选择<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a[href=&quot;http://www.w3school.com.cn/&quot;][title=&quot;W3School&quot;] &#123;color: red;&#125;</span><br></pre></td></tr></table></figure></li>
<li>选择 titile 属性包含单词 “flower” 的元素，并设置其样式：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[title~=flower]</span><br><span class="line">&#123; </span><br><span class="line">    background-color:yellow;</span><br><span class="line">&#125;</span><br><span class="line">&lt;p title=&quot;flower nb&quot;&gt;添加成功&lt;/p&gt;</span><br><span class="line">&lt;p title=&quot;nb&quot;&gt;添加失败&lt;/p&gt;</span><br></pre></td></tr></table></figure></li>
<li>选择 lang 属性值以 “en” 开头的元素，并设置其样式：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[lang|=en]</span><br><span class="line">&#123; </span><br><span class="line">background-color:yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>设置 class 属性值以 “test” 开头的所有 div 元素的背景色：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">div[class^=&quot;test&quot;]</span><br><span class="line">&#123;</span><br><span class="line">background:#ffff00;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>设置 class 属性值以 “test” 结尾的所有 div 元素的背景色：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">div[class$=&quot;test&quot;]</span><br><span class="line">&#123;</span><br><span class="line">    background:#ffff00;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>设置 class 属性值包含 “test” 的所有 div 元素的背景色：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">div[class*=&quot;test&quot;]</span><br><span class="line">&#123;</span><br><span class="line">    background:#ffff00;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><blockquote>
<p>优先级就是分配给指定的 CSS 声明的一个权重，它由匹配的选择器中的每一种选择器类型的数值决定。</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<p>例如：a.name权重等于a标签权重加上name类名的权重和，其权重大于.name，所以两者同时存在时前者样式生效</p>
<font color="red" size=3>权重相同，<b>后来者居上</b></font>

<font size=4>!important提高到最高优先级</font>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">  color: blue !important;</span><br><span class="line">&#125;</span><br><span class="line">.demo &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;div class=&quot;demo&quot;&gt;这是一个测试内容.&lt;/div&gt; //最终的颜色为 blue</span><br></pre></td></tr></table></figure>
## 层级选择器
### 层级选择器
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;ancestor1&quot;&gt;</span><br><span class="line">  &lt;div id=&quot;parent1&quot;&gt;</span><br><span class="line">    &lt;div id=&quot;child11&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div id=&quot;child12&quot;&gt;&lt;/div&gt; </span><br><span class="line"></span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div id=&quot;parent2&quot;&gt;</span><br><span class="line">    &lt;div id=&quot;child2&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;ancestor2&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
![](https://tva1.sinaimg.cn/large/832afe33ly1gainbqrpuuj21jj0qi763.jpg)
* 兄弟元素：ancestor1 元素和 ancestor2 元素、parent1 元素和 parent2 元素，以及 child11 元素和 child12 元素。
* 父级与子级元素：
    * 如果 `` 元素是父级元素的话，那 ancestor1 元素和 ancestor2 元素就是子级元素。
    * 如果 ancestor1 元素是父级元素的话，那 parent1 元素和 parent2 元素就是子级元素。
    * 如果 parent1 元素是父级元素的话，那 child11 元素和 child12 元素就是子级元素。
* 祖先与后代元素：
    * 如果 `` 元素是祖先元素的话，那其包含的所有元素都是后代元素。
    * 如果 ancestor1 元素是祖先元素的话，那其包含的所有元素都是后代元素。
    * 如果 parent1 元素是祖先元素的话，那其包含的所有元素都是后代元素。
### 层级选择器种类
* 后代选择器
简单来说，该元素的所有后代元素。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">div span &#123;</span><br><span class="line">      background-color: lightcoral;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;span&gt;Span 1.</span><br><span class="line">      &lt;span&gt;Span 2.&lt;/span&gt;</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;span&gt;Span 3.&lt;/span&gt;</span><br><span class="line"></span><br><span class="line">这样只会影响到div里的span标签，而div外的标签则不会受到影响</span><br></pre></td></tr></table></figure>
* 子级选择器
定位该元素的所有子级元素。并不会影响孙子级元素
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">span&#123;</span><br><span class="line">	color: teal;</span><br><span class="line">&#125;</span><br><span class="line">div&gt;span&#123;</span><br><span class="line">	color: violet;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
* 相邻兄弟选择器
定位与该目标元素拥有同一个父级元素的**下一个**指定元素 <font color="red">不包括当前元素，只包括后边的元素</font>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">#a+li&#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li id=&quot;a&quot;&gt;1sadsada&lt;/li&gt; &lt;!-- 不会变色 --&gt;</span><br><span class="line">    &lt;li&gt;555555&lt;/li&gt;&lt;!-- 变色 --&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>
* 普通兄弟选择器
简单来说就是 p~codep 元素之后的元素

定位与该目标元素拥有同一个父级元素的之后任意指定元素
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  span &#123;</span><br><span class="line">    background-color: lightgreen;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  p~code &#123;</span><br><span class="line">    background-color: lightcoral;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;span&gt;This is not red.&lt;/span&gt;</span><br><span class="line">&lt;p&gt;Here is a paragraph.&lt;/p&gt;</span><br><span class="line">&lt;code&gt;Here is some code.&lt;/code&gt; 会变色</span><br><span class="line">&lt;span&gt;And here is a span.&lt;/span&gt;</span><br></pre></td></tr></table></figure>
## 组合选择器
### 组合（并集）选择器
`h1, h2, h3, h4, h5, h6 { color:blue; }` 同时定义多个标签的属性。
### 组合（交集）选择器
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p.cls &#123;</span><br><span class="line">    color: blueviolet;</span><br><span class="line">&#125;</span><br><span class="line">表示把所有class名为cls的p标签都设置成blueviolet颜色</span><br></pre></td></tr></table></figure>
## 伪类选择器
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* 所有用户指针悬停的按钮 */</span><br><span class="line">button:hover &#123;</span><br><span class="line">  color: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
### 否定伪类选择器
>:not(selector) {
    属性 : 属性值;
}
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;否定伪类选择器&lt;/title&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    .fancy &#123;</span><br><span class="line">      text-shadow: 2px 2px 3px gold;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p:not(.fancy) &#123; /*匹配class名不是fancy的p标签*/</span><br><span class="line">      color: green;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    body :not(p) &#123; /*匹配body中不是p标签的标签*/</span><br><span class="line">      text-decoration: underline;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;p&gt;我是一个段落。&lt;/p&gt;</span><br><span class="line">  &lt;p class=&quot;fancy&quot;&gt;我好看极了！&lt;/p&gt;</span><br><span class="line">  &lt;div&gt;我不是一个段落。&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
## 伪元素选择器
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* CSS3 语法 */</span><br><span class="line">选择器::伪元素 &#123;</span><br><span class="line">  属性 : 属性值;</span><br><span class="line">&#125;</span><br><span class="line">/* CSS2 过时语法 (仅用来支持 IE8) */</span><br><span class="line">选择器:伪元素 &#123;</span><br><span class="line">  属性 : 属性值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<b>伪元素选择器</b>的语法格式为 `::伪元素`，一定不要忘记 ::。伪元素选择器只能和基本选择器配合使用，并且一个选择器只能使用一个伪元素选择器，如果要为一个选择器增加多个伪元素选择器需要分别编写。
### before 和 after
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        a::after&#123;</span><br><span class="line">            content: &quot;→&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        a::before&#123;</span><br><span class="line">            content: &quot;♥&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;a href=&quot;https://antmoe.com&quot;&gt;这是一个测试内容&lt;/a&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
![](https://tva1.sinaimg.cn/large/832afe33ly1gaio8klqf7j20k50iadgw.jpg)
### first-letter
<b>::first-letter</b> 伪元素的作用是为匹配元素的文本内容的第一个字母设置样式内容。 如下示例代码展示了 **::first-letter 伪元素 ** 的用法：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p::first-letter &#123;</span><br><span class="line">  font-size: 130%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
### first-line 伪元素
<b>::first-line</b> 伪元素的作用是为匹配 HTML 元素的文本内容的第一行设置样式内容。 如下示例代码展示了 **::first-line 伪元素 ** 的用法：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.line::first-line&#123;</span><br><span class="line">            background-color: tomato;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
### ::selection 伪元素
<b>::selection</b> 伪元素的作用是匹配用户在 HTML 页面选中的文本内容（比如使用鼠标或其他选择设备选中的部分）设置高亮效果。如下示例代码展示了 **::selection 伪元素 ** 的用法：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p::selection &#123;</span><br><span class="line">    color: gold;</span><br><span class="line">    background-color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
![](https://tva1.sinaimg.cn/large/832afe33ly1gaiohh13mbg20ok0950su.gif)
<blockquote>
<p>注意：&nbsp只有一小部分 CSS 属性可以用于::selection 伪元素：</p>
<ul>
<li>color 属性</li>
<li>background-color 属性</li>
<li>cursor 属性</li>
<li>caret-color 属性</li>
<li>outline 属性</li>
<li>text-decoration 属性</li>
<li>text-emphasis-color 属性</li>
<li>text-shadow 属性</li>
</ul>
</blockquote>
<font color="red" size=5>最后感谢原创！！！支持原创</font>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>Cookie技术介绍</title>
    <url>/posts/244d313a.html</url>
    <content><![CDATA[<blockquote>
<p>摘要：</p>
<p>这篇文章围绕Cookie技术，从诞生背景、数据流转、属性、数量限制及客户端操作等方面展开介绍，核心要点如下： </p>
<ol>
<li><strong>诞生背景</strong>：HTTP协议无状态，为解决服务端识别客户端身份问题，Cookie应运而生，它存储在客户端，由服务器发送，下次请求时携带至服务器，且不可跨站，每个Cookie绑定特定域名，同域名不同端口可共享。 </li>
<li><strong>数据流转</strong>：首次访问网站，浏览器请求无Cookie；服务端响应头加Set - Cookie；浏览器保存；再次访问，请求头携带Cookie。 </li>
<li><strong>有效期与作用域</strong>：默认有效期短，随浏览器会话结束消失，与sessionStorage作用域不同。可设max - age延长有效期。作用域由文档源和路径确定，可通过path和domain属性配置。 </li>
<li><p><strong>常见属性</strong>：    </p>
<ul>
<li><p><strong>name = value</strong>：键值对，值为Unicode或二进制数据需编码。    </p>
</li>
<li><p><strong>domain</strong>：决定Cookie生效域名，默认当前域名，设为父域名可在子域名生效。    </p>
</li>
<li><p><strong>path</strong>：限制Cookie生效路径，默认“/”。    </p>
</li>
<li><p><strong>expires</strong>：过期时间（GMT格式），客户端与服务器时间不一致时会有偏差。    </p>
</li>
<li><p><strong>Max - age</strong>：存活时间（秒），正数表示生效秒数，负数为临时Cookie，0表示删除，优先级高于expires。    </p>
</li>
<li><p><strong>HttpOnly</strong>：设此属性，js无法读写Cookie，一定程度防CSRF攻击。    </p>
</li>
<li><p><strong>secure</strong>：指定是否仅用安全协议传输，默认为false。    </p>
</li>
<li><p><strong>SameSite</strong>：确定是否允许跨站请求发送Cookie。    </p>
</li>
<li><p><strong>Priority</strong>：Cookie数量超限时，按此属性定义的优先级清除，有Low、Medium、High三种。 </p>
</li>
</ul>
</li>
<li><strong>个数限制</strong>：Chrome和Safari无硬性限制，Firefox、IE等有不同数量限制，RFC 2965标准规定浏览器最多保存300个Cookie，每个服务器不超20个，单个Cookie不超4KB，部分现代浏览器仍有4KB大小限制。 </li>
<li><strong>客户端存取</strong>：    <ul>
<li><strong>读取</strong>：<code>document.cookie</code>获取，返回字符串，由键值对组成，不含其他属性。    </li>
<li><strong>设置</strong>：用<code>document.cookie</code>添加，值含特殊字符需<code>encodeURIComponent()</code>编码。    </li>
<li><strong>更新</strong>：同名、路径和域，新值和max - age属性可改变Cookie。    </li>
<li><strong>删除</strong>：同名、路径和域，设任意值，<code>max - age</code>为0。 </li>
</ul>
</li>
</ol>
</blockquote>
<h1 id="了解-Cookie"><a href="#了解-Cookie" class="headerlink" title="了解 Cookie"></a>了解 Cookie</h1><ul>
<li>Cookie 最开始被设计出来是为了弥补HTTP在状态管理上的不足。HTTP 协议是一个无状态协议，客户端向服务器发请求，服务器返回响应，故事就这样结束了，但是下次发请求如何让服务端知道客户端是谁呢？这种背景下，就产生了 Cookie。</li>
<li>cookie 存储在客户端： cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。因此，服务端脚本就可以读、写存储在客户端的cookie的值。</li>
<li>cookie 是不可<strong>跨站</strong>的： 每个 cookie 都绑定在特定的域名下（绑定域名下的子域都是有效的），无法在别的域名下获取使用，同域名不同端口也允许共享。（跨域不等于跨站）</li>
</ul>
<h1 id="Cookie-的数据流转"><a href="#Cookie-的数据流转" class="headerlink" title="Cookie 的数据流转"></a>Cookie 的数据流转</h1><ol>
<li>在首次访问网站时，浏览器发送请求中并未携带Cookie。</li>
<li>服务端看到请求中未携带Cookie，在HTTP的响应头中加入Set-Cookie。</li>
<li>浏览器收到Set-Cookie后，会将Cookie保存下来</li>
<li>下次再访问该网站时，HTTP请求头就会携带Cookie。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20250203110352403.png" alt="image-20250203110352403"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20250203110421752.png" alt="image-20250203110421752"></p>
<p>Cookie都是name=value的结构，具体格式如下：</p>
<p><code>Set-Cookie: &quot;name=value;domain=.domain.com;path=/;expires=Sat, 11 Jun 2016 11:29:42 GMT;HttpOnly;secure&quot;</code></p>
<h1 id="cookie属性：有效期和作用域"><a href="#cookie属性：有效期和作用域" class="headerlink" title="cookie属性：有效期和作用域"></a>cookie属性：有效期和作用域</h1><p>cookie默认的有效期很短暂，它只能维持在Web浏览器的会话期间，一旦用户关闭浏览器，cookie保存的数据就丢失了。要注意的是，这与sessionStorage的有效期还是有区别的：cookie的作用域不是局限在浏览器的单个窗口中，它的有效期和整个浏览器进程而不是单个浏览器窗口的有效期一致。如果想要延长cookie的有效期，可以通过设置max-age属性。一旦设置了有效期，浏览器就会将cookie数据存储在一个文件中，并且直到过了指定的有效期才会删除该文件。</p>
<p>cookie的作用域是通过文档源和文档路径来确定的。该作用域通过cookie的path和domain属性可配置。</p>
<h1 id="Cookie常见属性"><a href="#Cookie常见属性" class="headerlink" title="Cookie常见属性"></a>Cookie常见属性</h1><div class="table-container">
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>name=value</td>
<td>键值对，设置 Cookie 的名称及相对应的值，都必须是字符串类型（name 不区分大小写）<br> - 如果值为 Unicode 字符，需要为字符编码。<br> - 如果值为二进制数据，则需要使用 base64 编码。</td>
</tr>
<tr>
<td>domain</td>
<td>Cookie 生效的域名，即 Cookie 在哪个网站生效。默认当前访问域名。<br>例如我们在 a.jzplp.com 下设置的 Cookie，就只在这个域名下生效。但是如果我们设置了 domain=jzplp.com，则该 Cookie 可以在 jzplp.com 下的任何域名内生效。比如：jzplp.com，a.jzplp.com, b.jzplp.com。<br>domain 只能设置为当前服务器的域。</td>
</tr>
<tr>
<td>path</td>
<td>有时候，我们希望 Cookie 仅仅在部分路径下生效，就可以使用 Path 进行限制。这里的路径就是网站的路由。默认的 path=/，即在所有路径下生效。 如果设置了 path=/abc，则只在 /abc 路径下生效。比如：<br> jzplp.com 不生效<br> jzplp.com/abc 生效<br> jzplp.com/abc/def 生效<br> jzplp.com/qaz 不生效<br> jzplp.com/qaz/abc 不生效</td>
</tr>
<tr>
<td>expires</td>
<td>过期时间（GMT 时间格式），当浏览器端本地的当前时间超过这个时间时，Cookie 便会失效。<br>如果客户端和服务器时间不一致，使用 expires 就会存在偏差。<br>一般浏览器的 cookie 都是默认储存的，当关闭浏览器结束这个会话的时候，cookie 会被删除。<br>Expires 格式：Expires=Wed, 21 Oct 2015 07:28:00 GMT。</td>
</tr>
<tr>
<td>Max - age</td>
<td>cookie 存活时间，单位秒。如果为正数，则该 cookie 在 maxAge 秒后失效。如果为负数，该 cookie 为临时 cookie ，关闭浏览器即失效，浏览器也不会以任何形式保存该 cookie。如果为 0，表示删除该 cookie 。默认为 -1。<br>优先级高于 expires</td>
</tr>
<tr>
<td>HttpOnly</td>
<td>如果给某个 cookie 设置了 httpOnly 属性，则无法通过 js 读写该 cookie 的信息，但还是能通过 Application 中手动修改 cookie，所以只是在一定程度上可以防止 CSRF 攻击，不是绝对的安全</td>
</tr>
<tr>
<td>secure</td>
<td>该 cookie 是否仅被使用安全协议传输。安全协议有 HTTPS，SSL 等，在网络上传输数据之前先将数据加密。默认为 false。<br>当 secure 值为 true 时，cookie 在 HTTP 中是无效的。</td>
</tr>
<tr>
<td>SameSite</td>
<td>是否允许跨站请求时发送 Cookie</td>
</tr>
<tr>
<td>Priority</td>
<td>当 Cookie 的数量超过限制时，路蓝旗会清除一部分 Cookie。清除哪些合适呢？Priority 属性用来定义 Cookie 的优先级，低优先级的 Cookie 会优先被清除。<br>Priority 属性有三种： Low, Medium, High。</td>
</tr>
</tbody>
</table>
</div>
<p>cookie集合中的每个cookie都拥有这些属性，而且每个cookie的这些属性都是独立分开的，各自控制各自的cookie。</p>
<h1 id="每个域名下cookie个数限制"><a href="#每个域名下cookie个数限制" class="headerlink" title="每个域名下cookie个数限制"></a>每个域名下cookie个数限制</h1><p>Chrome和Safari没有做硬性限制<br>Firefox最多50个cookie<br>IE7和之后的版本最后可以有50个cookie<br>IE6或更低版本最多20个cookie<br>RFC 2965标准不允许浏览器保存超过300个cookie，为每个Web服务器保存的cookie数不能超过20个（是对整个服务器而言，而不仅仅指服务器上的页面和站点），而且，每个cookie保存的数据不能超过4KB。实际上，现代浏览器允许cookie总数超过300个，但是部分浏览器对单个cookie大小仍然有4KB的限制。</p>
<h1 id="客户端对Cookie的存取"><a href="#客户端对Cookie的存取" class="headerlink" title="客户端对Cookie的存取"></a>客户端对Cookie的存取</h1><ol>
<li>读取cookie：</li>
</ol>
<p>可以用 document.cookie 获取当前页面可用的cookie集合，其返回的值是一个字符串，该字符串都是由一系列键/值对组成，不同键/值对之间通过“分号和空格”分开。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">document.cookie;</span><br><span class="line">// &quot;name1=value1; name2=value2&quot;</span><br></pre></td></tr></table></figure>
<p>这些返回的cookie值并不包含键/值以外的其他cookie属性。</p>
<ol>
<li>设置cookie:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">document.cookie = `name=$&#123;encodeURIComponent(name)&#125;; max-age=1000;`;</span><br></pre></td></tr></table></figure>
<p>name这个cookie会被添加到现有的cookie集合中。</p>
<p>由于cookie的键/值中的值是不允许包含分号、逗号和空白符，因此，在存储前一般可以采用 encodeURIComponent() 函数对值进行编码。相应的，读取cookie值的时候要用 decodeURIComponent() 函数解码。</p>
<ol>
<li>更新cookie</li>
</ol>
<p>要改变cookie的值，需要使用相同的名字、路径和域，但是新的值重新设置cookie的值。同样地，设置新 max-age 属性就可以改变原来的cookie的有效期。</p>
<ol>
<li>删除cookie</li>
</ol>
<p>要删除一个cookie，需要使用相同的名字、路径和域，然后指定一个任意（非空）的值，并且将 max-age 属性指定为0，再次设置cookie。</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://blog.csdn.net/huangpb123/article/details/109107461">Cookie详解：原理、属性与操作-CSDN博客</a></p>
]]></content>
      <categories>
        <category>记录</category>
      </categories>
  </entry>
  <entry>
    <title>(Garbage Collector)GC回收机制</title>
    <url>/posts/cbecc079.html</url>
    <content><![CDATA[<p>Java的垃圾回收机制（Garbage Collection, GC）是其<a href="https://so.csdn.net/so/search?q=内存&amp;spm=1001.2101.3001.7020">内存</a>管理的核心功能之一。通过GC，Java自动管理对象的生命周期，回收不再使用的对象所占的内存空间。本文将详细探讨GC的实现原理、不同算法的细节以及其在JVM中的应用。</p>
<h1 id="垃圾回收的基本原理"><a href="#垃圾回收的基本原理" class="headerlink" title="垃圾回收的基本原理"></a>垃圾回收的基本原理</h1><p>垃圾回收的主要任务是识别和回收不再使用的对象。GC的基本工作过程包括：</p>
<ul>
<li><strong>标记阶段</strong>：标记所有存活的对象。</li>
<li><strong>清除阶段</strong>：回收所有未标记的对象。</li>
<li><strong>压缩阶段（可选）</strong>：整理内存碎片。</li>
</ul>
<h1 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h1><ol>
<li>标记-清理：当一个对象没有被引用时标记它，然后隔一段时间或者立刻清理，会造成内存碎片。</li>
<li>标记-整理：为了解决内存碎片问题每隔一段时间就把内存进行平移紧凑，让内存空间变得连续，但是开销很大。</li>
<li>复制：两块同等大小的内存空间，当左边的空间不够的时候，就把左边有效的空间连续地复制到右边并统一清理左边的空间，下次右边不够再给左边连续复制，交替使用，缺点是内存利用效率低。据网上说复制比标记-整理开销低，具体为什么低我也没搞清楚，如果有大佬知道的话可以告诉我。</li>
<li>分代收集（Generational Collection）算法：</li>
<li><p>分代收集算法基于对象的存活时间，将堆内存分为几代：年轻代（Young Generation）、年老代（Old Generation）和永久代（Permanent Generation）。各代使用不同的收集算法。</p>
<ul>
<li><p>年轻代：对象生命周期短，频繁发生GC，使用复制算法。</p>
</li>
<li><p>年老代：对象生命周期长，使用标记-清除或标记-压缩算法。</p>
</li>
<li>永久代：存储类的元数据（在Java 8及以后版本中被元空间（Metaspace）替代）。</li>
</ul>
</li>
</ol>
<h1 id="JVM中的垃圾收集器"><a href="#JVM中的垃圾收集器" class="headerlink" title="JVM中的垃圾收集器"></a>JVM中的垃圾收集器</h1><p>Java<a href="https://so.csdn.net/so/search?q=虚拟机&amp;spm=1001.2101.3001.7020">虚拟机</a>（JVM）实现了多种垃圾收集器，不同收集器适用于不同的应用场景：</p>
<ul>
<li>Serial 收集器:Serial 收集器是单线程的，适用于单处理器环境和客户端应用。</li>
<li>Parallel 收集器：Parallel 收集器是多线程的，适用于多处理器环境，需要高吞吐量的应用。</li>
<li>CMS（Concurrent Mark-Sweep）收集器：CMS 收集器是低延迟收集器，目标是最小化停顿时间，适合对响应时间要求高的应用。</li>
<li>G1（Garbage-First）收集器：G1 收集器是分区收集器，将堆划分为多个区域，优先收集垃圾最多的区域，适合大内存、多处理器的服务器应用。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/ccd6a93a60874919906d5689e3f13a94.png" alt="JVM垃圾回收机制（GC）-CSDN博客"></p>
<p>如图：GC把内存空间分为<code>新生代</code>和老年代。新生代包括<code>伊甸区（E）、幸存1区（S0）和幸存2区（S1）</code>。各个区的大小不一样，可以调整比例。新生代GC称为minor GC，老年代GC称为Major GC/Full GC。</p>
<p>new出的对象在伊甸区（E区），当空间不够时会触发复制操作复制到幸存1区（S0）并统一回收垃圾空间，下次空间再不够，S0和E区一起往幸存2区（S1）复制，并统一回收垃圾空间，之后S1和E往S0复制，S0和S1反复交替使用，如果一个对象15轮GC都没有淘汰，就会进入老年代。如果幸存区放不下幸存的对象，就会进行分配担保机制，这些多出来的对象会直接进入老年代。</p>
<p>老年代存放<code>存活超过15代</code>、<code>占用内存大</code>的对象，当老年代空间不够时，触发老年代GC采用标记整理方法回收对象，老年代GC的时候通常伴随年轻代GC，也就是Full GC，会引发程序暂停，全力进行垃圾回收。</p>
<h1 id="进入老年代的条件："><a href="#进入老年代的条件：" class="headerlink" title="进入老年代的条件："></a>进入老年代的条件：</h1><p>1、大对象：大对象指需要大量连续内存空间的对象，这部分对象不管是不是“朝生夕死”，都会直接进到老年代。这样做主要是为了避免在 Eden 区及 2 个 Survivor 区之间发生大量的内存复制。当你的系统有非常多“朝生夕死”的大对象时，得注意了。</p>
<p>2、长期存活对象：虚拟机给每个对象定义了一个对象年龄（Age）计数器。正常情况下对象会不断的在 Survivor 的 From 区与 To 区之间移动，对象在 Survivor 区中每经历一次 Minor GC，年龄就增加 1 岁。当年龄增加到 15 岁时，这时候就会被转移到老年代。当然，这里的 15，JVM 也支持进行特殊设置 <code>-XX:MaxTenuringThreshold=10</code>。</p>
<p>可通过 <code>java -XX:+PrintFlagsFinal -version | grep MaxTenuringThreshold</code> 查看默认的阈值。</p>
<p>3、动态对象年龄：JVM 并不强制要求对象年龄必须到 15 岁才会放入老年区，如果 Survivor 空间中某个年龄段的对象总大小超过了 Survivor 空间的一半，那么该年龄段及以上年龄段的所有对象都会在下一次垃圾回收时被晋升到老年代，无需等你“成年”。</p>
<p>有点类似于负载均衡，轮询是负载均衡的一种，保证每台机器都分得同样的请求。看似很均衡，但每台机器的硬件不同，健康状况不同，所以我们可以基于每台机器接收的请求数、响应时间等，来调整负载均衡算法。</p>
<p>这种动态调整机制有助于优化内存使用和减少垃圾收集的频率，特别是在处理大量短生命周期对象的应用程序时。</p>
]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>GC</tag>
      </tags>
  </entry>
  <entry>
    <title>Github突然访问不到解决方案</title>
    <url>/posts/37338f48.html</url>
    <content><![CDATA[<blockquote>
<p>小林下午老老实实的写着博客，当完成后网上提交时突然发现连接不上Github，当时还没有意识到问题严重性，因为以前也经常遇到这类问题，网络不好的原因，多试几次就行了，好的，又试了N次，都说找不到仓库，好家伙！这下我傻了，在浏览器上打开Github打不开！！！我懵了，博客部署不上我的博客不久毁于一旦了？不能！！</p>
</blockquote>
<font color="black" size=5>
我不敢保证此教程能完全解决您的问题，因为网上许多教程解决了一些人的问题对我却不适用，我只是分享出我的解决方案
</font>

<h2 id="解决部署问题"><a href="#解决部署问题" class="headerlink" title="解决部署问题"></a>解决部署问题</h2><p>首先明白本地和Github取得联系是通过ssh的这把钥匙链接的，既然连接不上就说明这把钥匙有问题了，打开ssh所在文件夹，打开config文件(如果没有新建一个)，在里面添加如下内容：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">User 此处为你的github账号绑定的邮箱</span><br><span class="line">Hostname ssh.github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/id_rsa</span><br><span class="line">Port 443</span><br></pre></td></tr></table></figure><br>添加以后，再次部署没问题，问题解决👍</p>
<h2 id="解决浏览器访问不到以及ping不通Github"><a href="#解决浏览器访问不到以及ping不通Github" class="headerlink" title="解决浏览器访问不到以及ping不通Github"></a>解决浏览器访问不到以及ping不通Github</h2><p>这个我真的是尝试了好久！！网上有很多教程，别看那么多，其实他们百分之八十都是同样的内容，让你往hosts文件后面加两句话，但是它们却都没有告诉你这俩句话不是对任何人都适用的，可能只是对他一个人有用！首先我们要明白我们为什么访问不到Github，我们上网时网络有一个DNS服务的东西，它会把你访问的那个域名也就是www.<em>**</em>.com的东西转换成IP地址，然后这个IP地址指向所对应的服务器，然后我们就能成功上网，现在访问不到Github就是因为DNS失效了，他不能帮你转换成IP地址或是它转换错了！那么我们就要自己来转换，如何转换呢？电脑里面都有一个叫hosts的文件，这个文件是干嘛的？就是用来解决DNS失效的问题的，hosts文件默认是一堆说明，#号后面是注释的意思，我们就要在这里面填上对应的IP地址和其域名，当你访问对应的域名时计算机会自动帮你转换成前面的IP，这也就是为什么那么多教程让你改hosts文件加这两行的原因</p>
<h2 id="如何改hosts"><a href="#如何改hosts" class="headerlink" title="如何改hosts"></a>如何改hosts</h2><p>登录网址<a href="https://fastly.net.ipaddress.com/github.global.ssl.fastly.net">点击我</a>，在里面找到对应的IP<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMjI0MTk1MzA0MTAx" alt="">hosts文件的更改需要权限，这个如果不会自行百度<br>然后在hosts文件中加上你查到的IP，在后面加上github.com<br>之后登录网址<a href="https://ip.cha127.com/github.global.ssl.fastly.net.html">点击我</a><br>在里面找到对应IP，然后在hosts文件后面添加上对应IP并在后面加上~github.global.ssl.fastly.net~<br><strong>记得域名与IP之间隔一个空格</strong><br>之后再ping github成功了</p>
<h2 id="解决浏览器访问不到github"><a href="#解决浏览器访问不到github" class="headerlink" title="解决浏览器访问不到github"></a>解决浏览器访问不到github</h2><p>ping通后可是浏览器还是访问不到github，只不过错误变了，原来是网页访问不到，现在是<del>您的连接并不安全</del>如何解决这个问题？我在网上找到的<a href="https://blog.csdn.net/sinat_35811978/article/details/80289219">原文</a><br>删除上面让你添加的github.com的那一行，然后再访问就行了…….但是又ping不通了，这个我也不知道为啥，俩者好像没有关系😳，不过能访问就行</p>
<font color="red" size=6>Ending~ 撒花</font>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>ICPC2021网络赛2</title>
    <url>/posts/c35e724f.html</url>
    <content><![CDATA[<h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><h2 id="L-Euler-Function"><a href="#L-Euler-Function" class="headerlink" title="L Euler Function"></a>L Euler Function</h2><p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/image-20210930092043674.png" alt="image-20210930092043674"></p>
<p>题目大意：</p>
<p>给定n个数字，每一个数字不超过100，m次询问</p>
<ol>
<li>把一个区间的所有数字乘以w(w&lt;=100)</li>
<li>求一个区间所有数的欧拉函数和(mod 998244353)</li>
</ol>
<p>首先明白一个性质：</p>
<p>$phi(n)=n/(p1<em>p2</em>p3…)<em>(p1-1)</em>(p2-1)*(p3-1)…$</p>
<p>而n也可以表示为$p1<em>p2</em>p3…$</p>
<p>所以$phi(n)=(p1-1)<em>(p2-1)</em>(p3-1)…$</p>
<p>那么$phi(w*n)$的值怎么求？</p>
<p>把w质因子分解，可以发现如果n和w有同一个质因子c，那么$phi(c<em>n)=phi(n)</em>c$，如果存在一个质因子w有，n没有，那么$phi(c<em>n)=phi(n)</em>(c-1)$，发现w的质因子在要乘的区间中都有，那么这道题就变成了简单的区间乘法，区间询问，但是区间中不一定包含w的所有质因子，所以就要去找到那些不包含w的某个质因子的位置，把这些位置单独拿出来乘以(c-1)，如何找到这些位置呢？</p>
<p>可以考虑开一个vis数组，vis[x]标记一个区间是否都存在质因子x，那么每次做区间乘法时，就可以把w质因子分解，对于每一个质因子c，都去线段树中找，如果一个区间被vis标记了，那么这个区间都存在这个质因子c，就可以直接进行区间修改，否则如果这个区间没有被标记，就向左右子树都找，直到找到这个位置</p>
<p>这里的vis合并时需要遍历25个质因子，进行与的操作，总时复：(O(mlogn*25))，时间快要超时，所以可以把vis数组改成bitset，除以一个32的常数，稳过</p>
<p><code>注意区间乘法lazy数组初始化为1！！！</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls u&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs u&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> arr[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> l,r;</span><br><span class="line">	ll val;</span><br><span class="line">	<span class="built_in">bitset</span>&lt;<span class="number">100</span>&gt; bit;</span><br><span class="line">&#125;tr[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line">ll lazy[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">getphi</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">	<span class="type">int</span> res=x;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(x);i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(x%i==<span class="number">0</span>)&#123;</span><br><span class="line">			res=res*(i<span class="number">-1</span>)/i;</span><br><span class="line">			<span class="keyword">while</span>(x%i==<span class="number">0</span>) x/=i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;<span class="number">1</span>) res=res*(x<span class="number">-1</span>)/x;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> pr[<span class="number">100</span>],tot;</span><br><span class="line"><span class="built_in">bitset</span>&lt;<span class="number">100</span>&gt; st[N];</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">100</span>;i++)&#123;</span><br><span class="line">		<span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;=<span class="built_in">sqrt</span>(i);j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(i%j==<span class="number">0</span>)&#123;</span><br><span class="line">				flag=<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!flag) pr[++tot]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=tot;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(arr[i]%pr[j]==<span class="number">0</span>)&#123;</span><br><span class="line">				st[i][pr[j]]=<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">pushup</span><span class="params">(<span class="type">int</span> u)</span>&#123;</span><br><span class="line">	tr[u].bit=tr[ls].bit&amp;tr[rs].bit;	<span class="comment">//维护标记</span></span><br><span class="line">	tr[u].val=(tr[ls].val+tr[rs].val)%mod;	<span class="comment">//维护区间欧拉函数和</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">pushdown</span><span class="params">(<span class="type">int</span> u)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(lazy[u]!=<span class="number">1</span>)&#123;</span><br><span class="line">		lazy[ls]=lazy[u]*lazy[ls]%mod;</span><br><span class="line">		lazy[rs]=lazy[u]*lazy[rs]%mod;</span><br><span class="line">		tr[ls].val=tr[ls].val*lazy[u]%mod;</span><br><span class="line">		tr[rs].val=tr[rs].val*lazy[u]%mod;</span><br><span class="line">		lazy[u]=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">	lazy[u]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">		tr[u]=&#123;l,r,getphi(arr[l]),st[l]&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		tr[u]=&#123;l,r&#125;;</span><br><span class="line">		build(ls,l,mid);</span><br><span class="line">		build(rs,mid+<span class="number">1</span>,r);</span><br><span class="line">		pushup(u);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> c)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(tr[u].l&gt;=l &amp;&amp; tr[u].r&lt;=r &amp;&amp; tr[u].bit[c])&#123;</span><br><span class="line">		lazy[u]=lazy[u]*c%mod;</span><br><span class="line">		tr[u].val=tr[u].val*c%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(tr[u].l==tr[u].r)&#123;</span><br><span class="line">		tr[u].val=tr[u].val*(c<span class="number">-1</span>)%mod;</span><br><span class="line">		tr[u].bit[c]=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		pushdown(u);</span><br><span class="line">		<span class="type">int</span> mid=tr[u].l+tr[u].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(l&lt;=mid) update(ls,l,r,c);</span><br><span class="line">		<span class="keyword">if</span>(r&gt;mid) update(rs,l,r,c);</span><br><span class="line">		pushup(u);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">ll <span class="title function_">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=tr[u].l &amp;&amp; tr[u].r&lt;=r) <span class="keyword">return</span> tr[u].val;</span><br><span class="line">	pushdown(u);</span><br><span class="line">	<span class="type">int</span> mid=(tr[u].l+tr[u].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	ll res=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=mid) res=(res+query(ls, l, r))%mod;</span><br><span class="line">	<span class="keyword">if</span>(r&gt;mid) res=(res+query(rs, l, r))%mod;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">signed</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;arr[i];</span><br><span class="line">	init();</span><br><span class="line">	build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="type">int</span> op,l,r,w;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;op;</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r&gt;&gt;w;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">25</span>;i++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(w%pr[i]==<span class="number">0</span>)&#123;</span><br><span class="line">					<span class="keyword">while</span>(w%pr[i]==<span class="number">0</span>)&#123;</span><br><span class="line">						w/=pr[i];</span><br><span class="line">						update(<span class="number">1</span>,l,r,pr[i]);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;query(<span class="number">1</span>,l,r)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5 5</span></span><br><span class="line"><span class="comment">5 1 6 2 13</span></span><br><span class="line"><span class="comment">0 5 5 25</span></span><br><span class="line"><span class="comment">0 5 5 18</span></span><br><span class="line"><span class="comment">1 3 5</span></span><br><span class="line"><span class="comment">0 1 3 24</span></span><br><span class="line"><span class="comment">1 3 4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>第二种写法是用并查集维护一个区间中是否所有数字都可以被质因子c整除，$fa[i][j]$表示第i个质因子第j个位置的数字往右最多可以延申到哪一个位置，假如可以延伸到k，那么[当前位置,k-1]的区间的答案可以直接乘以$pr[i]$，然后把第k个位置单独乘以$c-1$，如此往复，去进行区间修改即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls u&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs u&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> arr[N],fa[<span class="number">26</span>][N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> l,r;</span><br><span class="line">	ll val;</span><br><span class="line">&#125; tr[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line">ll lazy[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">getphi</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">	<span class="type">int</span> res=x;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;=<span class="built_in">sqrt</span>(x); i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(x%i==<span class="number">0</span>) &#123;</span><br><span class="line">			res=res*(i<span class="number">-1</span>)/i;</span><br><span class="line">			<span class="keyword">while</span>(x%i==<span class="number">0</span>) x/=i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;<span class="number">1</span>) res=res*(x<span class="number">-1</span>)/x;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">pushup</span><span class="params">(<span class="type">int</span> u)</span> &#123;</span><br><span class="line">	tr[u].val=(tr[ls].val+tr[rs].val)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">pushdown</span><span class="params">(<span class="type">int</span> u)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(lazy[u]!=<span class="number">1</span>) &#123;</span><br><span class="line">		lazy[ls]=lazy[u]*lazy[ls]%mod;</span><br><span class="line">		lazy[rs]=lazy[u]*lazy[rs]%mod;</span><br><span class="line">		tr[ls].val=tr[ls].val*lazy[u]%mod;</span><br><span class="line">		tr[rs].val=tr[rs].val*lazy[u]%mod;</span><br><span class="line">		lazy[u]=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span> &#123;</span><br><span class="line">	lazy[u]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(l==r) tr[u]= &#123;l,r,getphi(arr[l])&#125;;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		tr[u]= &#123;l,r&#125;;</span><br><span class="line">		build(ls,l,mid);</span><br><span class="line">		build(rs,mid+<span class="number">1</span>,r);</span><br><span class="line">		pushup(u);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">ll <span class="title function_">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=tr[u].l &amp;&amp; tr[u].r&lt;=r) <span class="keyword">return</span> tr[u].val;</span><br><span class="line">	pushdown(u);</span><br><span class="line">	<span class="type">int</span> mid=(tr[u].l+tr[u].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	ll res=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=mid) res=(res+query(ls, l, r))%mod;</span><br><span class="line">	<span class="keyword">if</span>(r&gt;mid) res=(res+query(rs, l, r))%mod;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> pr[<span class="number">100</span>],tot;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;=<span class="number">100</span>; i++) &#123;</span><br><span class="line">		<span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>; j&lt;=<span class="built_in">sqrt</span>(i); j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(i%j==<span class="number">0</span>) flag=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!flag) pr[++tot]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=tot; i++) &#123;	<span class="comment">//初始化n个位置的fa数组</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=n; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(arr[j]%pr[i]==<span class="number">0</span>) fa[i][j]=j+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">mul</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> c)</span> &#123;	<span class="comment">//线段树区间乘法</span></span><br><span class="line">	<span class="keyword">if</span>(tr[u].l&gt;=l &amp;&amp; tr[u].r&lt;=r) &#123;</span><br><span class="line">		lazy[u]=lazy[u]*c%mod;</span><br><span class="line">		tr[u].val=tr[u].val*c%mod;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		pushdown(u);</span><br><span class="line">		<span class="type">int</span> mid=tr[u].l+tr[u].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(l&lt;=mid) mul(ls,l,r,c);</span><br><span class="line">		<span class="keyword">if</span>(r&gt;mid) mul(rs,l,r,c);</span><br><span class="line">		pushup(u);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> c,<span class="type">int</span> x)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(x==fa[c][x]) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">return</span> fa[c][x]=find(c,fa[c][x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> c)</span> &#123;	<span class="comment">//[l,r]区间乘以pr[c]</span></span><br><span class="line">	<span class="type">int</span> k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=l; ; i=k+<span class="number">1</span>) &#123;</span><br><span class="line">		k=find(c,i);</span><br><span class="line">		<span class="keyword">if</span>(k&gt;r) &#123;</span><br><span class="line">			mul(<span class="number">1</span>,i,r,pr[c]);	<span class="comment">//最后一个区间特判一下</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span>(k&gt;i) mul(<span class="number">1</span>,i,k<span class="number">-1</span>,pr[c]);</span><br><span class="line">			fa[c][i]=k+<span class="number">1</span>;	<span class="comment">//并查集合并</span></span><br><span class="line">			mul(<span class="number">1</span>,k,k,pr[c]<span class="number">-1</span>);	<span class="comment">//单独相乘</span></span><br><span class="line">			fa[c][k]=k+<span class="number">1</span>;	<span class="comment">//并查集合并</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> w)</span> &#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">25</span>; i++) &#123;	<span class="comment">//第i个质因子有几个乘几次</span></span><br><span class="line">		<span class="keyword">while</span>(w%pr[i]==<span class="number">0</span>) &#123;</span><br><span class="line">			merge(l,r,i);</span><br><span class="line">			w/=pr[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">signed</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;arr[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=<span class="number">25</span>; j++) fa[j][i]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=<span class="number">25</span>; j++) fa[j][n+<span class="number">1</span>]=n+<span class="number">1</span>;	<span class="comment">//因为fa数组指向的位置是(最后一个包含质因子c的下一个位置)，所以n+1也要进行初始化</span></span><br><span class="line">	init();</span><br><span class="line">	build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">	<span class="keyword">while</span>(m--) &#123;</span><br><span class="line">		<span class="type">int</span> op,l,r,w;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;op;</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r&gt;&gt;w;</span><br><span class="line">			update(l,r,w);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;query(<span class="number">1</span>,l,r)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5 5</span></span><br><span class="line"><span class="comment">5 1 6 2 13</span></span><br><span class="line"><span class="comment">0 5 5 25</span></span><br><span class="line"><span class="comment">0 5 5 18</span></span><br><span class="line"><span class="comment">1 3 5</span></span><br><span class="line"><span class="comment">0 1 3 24</span></span><br><span class="line"><span class="comment">1 3 4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="M-Addition"><a href="#M-Addition" class="headerlink" title="M Addition"></a>M Addition</h2><p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/image-20210930102733632.png" alt="image-20210930102733632"></p>
<p>可以借位的模拟题</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> s[N];</span><br><span class="line"><span class="type">int</span> a[N],b[N];</span><br><span class="line"><span class="type">int</span> ans[N];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;s[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;b[i];</span><br><span class="line">	<span class="type">int</span> flag=<span class="number">0</span>,pre;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i] &amp;&amp; b[i])&#123;</span><br><span class="line">				ans[i]=<span class="number">0</span>;</span><br><span class="line">				flag=<span class="number">1</span>;</span><br><span class="line">				pre=s[i];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>((a[i] &amp;&amp; !b[i]) || (!a[i] &amp;&amp; b[i])) ans[i]=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> ans[i]=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(s[i]==pre)&#123;</span><br><span class="line">				<span class="keyword">if</span>(!a[i] &amp;&amp; !b[i]) flag=<span class="number">0</span>;</span><br><span class="line">				<span class="keyword">if</span>((a[i] &amp;&amp; b[i]) || (!a[i] &amp;&amp; !b[i])) ans[i]=<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>((a[i] &amp;&amp; !b[i]) || (!a[i] &amp;&amp; b[i])) ans[i]=<span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">if</span>(a[i] || b[i]) flag=<span class="number">0</span>;</span><br><span class="line">				<span class="keyword">if</span>(a[i] &amp;&amp; b[i]) ans[i]=<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>((a[i] &amp;&amp; !b[i]) || (!a[i] &amp;&amp; b[i])) ans[i]=<span class="number">0</span>;</span><br><span class="line">				<span class="keyword">else</span> ans[i]=<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(i!=n) <span class="built_in">cout</span>&lt;&lt;ans[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;ans[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>线段树+欧拉函数</tag>
      </tags>
  </entry>
  <entry>
    <title>Java的线程池</title>
    <url>/posts/dc55cf3c.html</url>
    <content><![CDATA[<h1 id="线程池的参数"><a href="#线程池的参数" class="headerlink" title="线程池的参数"></a>线程池的参数</h1><p>所有与线程池相关的类继承关系如下：</p>
<p><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/20250915111018.png" alt="img"></p>
<p>因为<code>ExecutorService</code>只是接口，Java标准库提供的几个常用实现类有：</p>
<ul>
<li>FixedThreadPool：线程数固定的线程池；</li>
<li>ScheduledThreadPool: </li>
<li>CachedThreadPool：线程数根据任务动态调整的线程池；</li>
<li>SingleThreadExecutor：仅单线程执行的线程池。</li>
</ul>
<p>创建这些线程池的方法都被封装到<code>Executors</code>这个类中。</p>
<p>线程池相关的参数：</p>
<ul>
<li><p>corePoolSize（必需）：核心线程数。默认情况下，核心线程会一直存活，但是当将 allowCoreThreadTimeout 设置为 true 时，核心线程也会超时回收。</p>
</li>
<li><p>maximumPoolSize（必需）：线程池所能容纳的最大线程数。当活跃线程数达到该数值后，后续的新任务将会阻塞。</p>
</li>
<li>keepAliveTime（必需）：线程闲置超时时长。如果超过该时长，非核心线程就会被回收。如果将 allowCoreThreadTimeout 设置为 true 时，核心线程也会超时回收。</li>
<li>unit（必需）：指定 keepAliveTime 参数的时间单位。常用的有：TimeUnit.MILLISECONDS（毫秒）、TimeUnit.SECONDS（秒）、TimeUnit.MINUTES（分）。</li>
<li>workQueue（必需）：任务队列。通过线程池的 execute() 方法提交的 Runnable 对象将存储在该参数中。其采用阻塞队列实现。</li>
<li>threadFactory（可选）：线程工厂。用于指定为线程池创建新线程的方式。</li>
<li>handler（可选）：拒绝策略。当达到最大线程数时需要执行的饱和策略。</li>
</ul>
<h2 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h2><p>任务队列是基于阻塞队列实现的，即采用生产者消费者模式，在 Java 中需要实现 BlockingQueue 接口。但 Java 已经为我们提供了 7 种阻塞队列的实现：</p>
<ul>
<li><p>ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列（数组结构可配合指针实现一个环形队列）。</p>
</li>
<li><p>LinkedBlockingQueue： 一个由链表结构组成的有界阻塞队列，在未指明容量时，容量默认为 Integer.MAX_VALUE。</p>
</li>
<li>PriorityBlockingQueue： 一个支持优先级排序的无界阻塞队列，对元素没有要求，可以实现 Comparable 接口也可以提供 Comparator 来对队列中的元素进行比较。跟时间没有任何关系，仅仅是按照优先级取任务。</li>
<li>DelayQueue：类似于PriorityBlockingQueue，是二叉堆实现的无界优先级阻塞队列。要求元素都实现 Delayed 接口，通过执行时延从队列中提取任务，时间没到任务取不出来。</li>
<li>SynchronousQueue： 一个不存储元素的阻塞队列，消费者线程调用 take() 方法的时候就会发生阻塞，直到有一个生产者线程生产了一个元素，消费者线程就可以拿到这个元素并返回；生产者线程调用 put() 方法的时候也会发生阻塞，直到有一个消费者线程消费了一个元素，生产者才会返回。</li>
<li>LinkedBlockingDeque： 使用双向队列实现的有界双端阻塞队列。双端意味着可以像普通队列一样 FIFO（先进先出），也可以像栈一样 FILO（先进后出）。</li>
<li>LinkedTransferQueue： 它是ConcurrentLinkedQueue、LinkedBlockingQueue 和 SynchronousQueue 的结合体，但是把它用在 ThreadPoolExecutor 中，和 LinkedBlockingQueue 行为一致，但是是无界的阻塞队列。</li>
</ul>
<p>注意有界队列和无界队列的区别：如果使用有界队列，当队列饱和时并超过最大线程数时就会执行拒绝策略；而如果使用无界队列，因为任务队列永远都可以添加任务，所以设置 maximumPoolSize 没有任何意义。</p>
<h2 id="拒绝策略（handler）"><a href="#拒绝策略（handler）" class="headerlink" title="拒绝策略（handler）"></a>拒绝策略（handler）</h2><p>当线程池的线程数达到最大线程数时，需要执行拒绝策略。拒绝策略需要实现 RejectedExecutionHandler 接口，并实现 rejectedExecution(Runnable r, ThreadPoolExecutor executor) 方法。不过 Executors 框架已经为我们实现了 4 种拒绝策略：</p>
<ul>
<li><p>AbortPolicy（默认）：丢弃任务并抛出 RejectedExecutionException 异常。</p>
</li>
<li><p>CallerRunsPolicy：由调用线程处理该任务。</p>
</li>
<li>DiscardPolicy：丢弃任务，但是不抛出异常。可以配合这种模式进行自定义的处理方式。</li>
<li>DiscardOldestPolicy：丢弃队列最早的未处理任务，然后重新尝试执行任务。</li>
</ul>
<h1 id="线程池区别"><a href="#线程池区别" class="headerlink" title="线程池区别"></a>线程池区别</h1><h2 id="定长线程池（FixedThreadPool）"><a href="#定长线程池（FixedThreadPool）" class="headerlink" title="定长线程池（FixedThreadPool）"></a>定长线程池（FixedThreadPool）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads, ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>特点</strong>：只有核心线程，线程数量固定，执行完立即回收，任务队列为链表结构的有界队列。</li>
<li><strong>应用场景</strong>：控制线程最大并发数。</li>
</ul>
<h2 id="定时线程池（ScheduledThreadPool-）"><a href="#定时线程池（ScheduledThreadPool-）" class="headerlink" title="定时线程池（ScheduledThreadPool ）"></a>定时线程池（ScheduledThreadPool ）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">DEFAULT_KEEPALIVE_MILLIS</span> <span class="operator">=</span> <span class="number">10L</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">newScheduledThreadPool</span><span class="params">(<span class="type">int</span> corePoolSize)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ScheduledThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(corePoolSize, Integer.MAX_VALUE,</span><br><span class="line">          DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">DelayedWorkQueue</span>());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">newScheduledThreadPool</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="type">int</span> corePoolSize, ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(corePoolSize, threadFactory);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ScheduledThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                                   ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(corePoolSize, Integer.MAX_VALUE,</span><br><span class="line">          DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">DelayedWorkQueue</span>(), threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>特点</strong>：核心线程数量固定，非核心线程数量无限，执行完闲置 10ms 后回收，任务队列为延时阻塞队列。</li>
<li><strong>应用场景</strong>：执行定时或周期性的任务。</li>
</ul>
<h2 id="可缓存线程池（CachedThreadPool）"><a href="#可缓存线程池（CachedThreadPool）" class="headerlink" title="可缓存线程池（CachedThreadPool）"></a>可缓存线程池（CachedThreadPool）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>特点</strong>：无核心线程，非核心线程数量无限，执行完闲置 60s 后回收，任务队列为不存储元素的阻塞队列。</li>
<li><strong>应用场景</strong>：执行大量、耗时少的任务。</li>
</ul>
<h2 id="单线程化线程池（SingleThreadExecutor）"><a href="#单线程化线程池（SingleThreadExecutor）" class="headerlink" title="单线程化线程池（SingleThreadExecutor）"></a>单线程化线程池（SingleThreadExecutor）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                threadFactory));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>特点</strong>：只有 1 个核心线程，无非核心线程，执行完立即回收，任务队列为链表结构的有界队列。</li>
<li><strong>应用场景</strong>：不适合并发但可能引起 IO 阻塞性及影响 UI 线程响应的操作，如数据库操作、文件操作等。</li>
</ul>
<p><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/d1163af0928ceaaa1ec8661e7051f321.png" alt="img"></p>
<h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><p>Executors 的 4 个功能线程池虽然方便，但现在已经不建议使用了，而是建议直接通过使用 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                          TimeUnit unit,</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA的三种IO模型</title>
    <url>/posts/de0d9d4b.html</url>
    <content><![CDATA[<blockquote>
<p>之前一直看不明白的IO模型，今天看了一会就明白了，知识真的是迭代学习的过程</p>
</blockquote>
<h1 id="BIO（Blocking-IO）"><a href="#BIO（Blocking-IO）" class="headerlink" title="BIO（Blocking IO）"></a>BIO（Blocking IO）</h1><p>IO的过程就是读取数据的过程，这里以客户端请求服务端的过程为例，客户端向服务端请求的过程本质上就是服务端读取客户端发送来的数据的过程，下文也用这个例子讲解，BIO就是阻塞式IO，见下图</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/cf83d636acab3073c6dc2de894579b08.png" alt="img"></p>
<p>BIO中一个线程只能同时处理一个IO，多个客户端发起请求时，只能创建多个线程处理，线程读取数据调用read指令，read是阻塞的，线程等待数据从内核态拷贝到用户态，拷贝完毕后线程才能继续处理。</p>
<h1 id="NIO（NonBlocking-IO，多路复用模型）"><a href="#NIO（NonBlocking-IO，多路复用模型）" class="headerlink" title="NIO（NonBlocking IO，多路复用模型）"></a>NIO（NonBlocking IO，多路复用模型）</h1><p>NIO与BIO的区别有两点，第一，一个线程可以同时处理多个IO，宏观上同时处理，微观上串行处理，NIO引入了Selector（选择器）、Channel、Buufer，Selector 相当于对 select、poll 和 epoll 的封装，Channel 是对 FD 的封装，模型如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/90b3b0258bae91f00336952f874b4262.png" alt="img"></p>
<p>客户端会把数据写到Buffer里面，然后Channel负责把数据从Buffer交给线程，Channel本身无法存储数据，其内部没有存储结构，Selector和Channel的结合就是多路复用的实现，这就是第二个区别，操作系统提供了三种操作select、poll、epoll，Selector对这三种操作进行了封装，提供上层调用接口，实现的效果就是，线程不需要轮询每个通道看数据是不是准备好了，而是数据准备好了通知线程，这三个系统调用的区别如下，具体见下文的多路服用模型，大白话说明区别就是<strong>select有限，poll无限，epoll具体到文件描述符和提高性能</strong>：</p>
<ul>
<li><strong>select</strong>：是最早实现的 I/O 多路复用机制，几乎所有的操作系统都支持。它使用一个 <code>fd_set</code> 数据结构来存储需要监视的文件描述符集合，调用 <code>select</code> 函数时，进程会被阻塞，直到集合中的某个或多个文件描述符的 I/O 事件就绪，或者超时。<code>select</code> 函数返回后，需要遍历整个 <code>fd_set</code> 来找出哪些文件描述符的事件就绪。</li>
<li><strong>poll</strong>：与 <code>select</code> 类似，也是用于监视多个文件描述符的 I/O 事件。它使用一个 <code>pollfd</code> 结构体数组来存储需要监视的文件描述符及其感兴趣的事件。<code>poll</code> 函数会阻塞进程，直到有文件描述符的事件就绪。与 <code>select</code> 不同的是，<code>poll</code> 没有最大文件描述符数量的限制。</li>
<li><strong>epoll</strong>：是 Linux 特有的 I/O 多路复用机制，它使用事件驱动的方式来处理 I/O 事件。<code>epoll</code> 通过 <code>epoll_create</code> 创建一个 <code>epoll</code> 实例，使用 <code>epoll_ctl</code> 来添加、修改或删除需要监视的文件描述符及其事件，使用 <code>epoll_wait</code> 等待事件的发生。当有事件就绪时，<code>epoll</code> 会直接返回就绪的文件描述符列表，无需遍历所有文件描述符。</li>
</ul>
<p>通道判断数据是不是准备好了也是通过read命令，但是这里的read是非阻塞的，如果没有准备好会直接返回结果，这个表现就体现了NIO的NonBlocking，不是说线程调用select等不会阻塞，线程调用select还是会被阻塞，直到有数据准备好了才会提醒，当数据准备好了读取的过程还是阻塞的，只有读完了再次调用select才能继续监控其他数据。</p>
<h1 id="AIO（Aysc-IO）"><a href="#AIO（Aysc-IO）" class="headerlink" title="AIO（Aysc IO）"></a>AIO（Aysc IO）</h1><p>而AIO对NIO的优化是：读取数据不阻塞，把读取数据的工作交给操作系统，操作系统读完了通过回调函数告诉线程一声，因此这是真正实现了非阻塞式IO。</p>
<h1 id="多路复用模型"><a href="#多路复用模型" class="headerlink" title="多路复用模型"></a>多路复用模型</h1><p>I/O 多路复用（I/O Multiplexing）中的 “多路复用” 意味着在单个线程中同时管理多个 I/O 通道（如网络连接、文件描述符等），让一个线程可以处理多个 I/O 流的 I/O 事件，避免为每个 I/O 流创建一个单独的线程，从而提高系统资源的利用率和程序的并发处理能力。</p>
<ol>
<li>select<br>select 是最古老的 I/O 多路复用机制之一，在 Unix 系统中使用较为广泛。<br>select 使用一个<strong>位图</strong>来存储文件描述符，<strong>监视的文件描述符数量有限制</strong>，通常是 1024 个（可以通过修改文件描述符限制来提高数量，但仍受限制）。<br>select 每次调用时都需要将待监视的文件描述符集合<strong>从用户态拷贝到内核态</strong>，这会导致性能开销随着文件描述符数量的增加而增加。<br>select 对监视的文件描述符集合的扫描是线性的，随着文件描述符数量的增加，性能下降明显。</li>
<li>poll<br> <code>poll</code> 函数通过 <code>struct pollfd</code> 结构体数组来表示要监视的文件描述符集合<br> 与 select 类似，poll 每次调用时需要将待监视的文件描述符集合<strong>从用户态拷贝到内核态</strong>，但性能上相对于 select 有所提升。<br> poll 的主要缺点是，随着文件描述符数量的增加，性能会逐渐下降，因为 poll 仍然是线性扫描文件描述符集合。</li>
<li>epoll<br> epoll 是 Linux 下的一种高性能 I/O 多路复用机制，相比于 select 和 poll，epoll 的性能更好。<br> epoll 使用了<strong>事件驱动</strong>的方式，<strong>不需要每次调用时将待监视的文件描述符集合从用户态拷贝到内核态</strong>，而是采用了基于回调的方式，当文件描述符就绪时，内核直接通知应用程序。<br> epoll 支持三种工作模式：EPOLLIN（可读）、EPOLLOUT（可写）、EPOLLET（边缘触发模式），可以更加灵活地满足不同的需求。<br> epoll 对于大量文件描述符的管理具有更好的性能和扩展性，不会因为文件描述符数量的增加而导致性能下降。</li>
</ol>
<p>触发模式：在 epoll 中，有两种触发模式可以选择：水平触发（Level-Triggered，简称 LT）和边缘触发（Edge-Triggered，简称 ET）。这两种触发模式在处理文件描述符就绪事件时有所不同：</p>
<p>1.水平触发（LT）<strong>（只要没准备好每次都告诉）</strong></p>
<p>在水平触发模式下，当文件描述符就绪时，epoll_wait 函数会立即返回，并且会返回所有处于就绪状态的文件描述符。<br>如果应用程序没有处理完所有就绪事件，并且该文件描述符上的事件状态没有改变，下一次调用 epoll_wait 时，该文件描述符仍然会被返回。<br>水平触发模式是 epoll 的默认触发模式。<br>2.边缘触发（ET）<strong>（只提醒一次，这次你没处理好，下次我再也不提醒了）</strong></p>
<p>在边缘触发模式下，当文件描述符就绪时，epoll_wait 函数只会返回一次，并且只返回该文件描述符上自上次 epoll_wait 调用后发生的就绪事件。<br>如果应用程序没有处理完所有就绪事件，并且该文件描述符上的事件状态没有改变，下一次调用 epoll_wait 时，该文件描述符不会再次被返回，除非有新的就绪事件发生。<br>边缘触发模式要求应用程序对文件描述符的就绪事件立即进行处理，否则可能会错过事件。</p>
]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>AIO</tag>
        <tag>NIO</tag>
        <tag>BIO</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP</title>
    <url>/posts/ad32db8f.html</url>
    <content><![CDATA[<blockquote>
<p>暑假学习了KMP，奈何掌握不深，现在又来复习，结果又是从零开始</p>
</blockquote>
<h2 id="什么是KMP？"><a href="#什么是KMP？" class="headerlink" title="什么是KMP？"></a>什么是KMP？</h2><p>现在有一个原字符串，再给你一段模式串，问你在原字符串中是否存在一段子串等于模式串，或者模式串在原串中出现几次？</p>
<p>BF算法，也就是人人都会的指针回朔暴力算法，略过</p>
<p>原串： ABABABAABA  （i）</p>
<p>模式串： ABAA （j）</p>
<p>当匹配时第一个失配的位置是3(下标从0开始)，然后朴素做法是把i和j指针都回朔，但其实可以利用之前已经匹配的信息的，可以找到当前失配字符之前的最大公共前后缀长度，假设长度为k，则s[i-k]…s[i-1]==t[j-k]…t[j-1]，而t[0]…t[k-1]==t[j-k]…t[j-1]，所以s[i-k]..s[i-1]==t[0]…t[k-1]，所以只需要把j移到k位置就可以了，i指针不回朔，这样一来就只要j指针回朔，而且大概率没有回朔到0，省去大量时间，那么问题就来了，怎么找到模式串中每一个位置的k呢？</p>
<p>前面已经说了，k是每一个位置之前字符串(不包括k位置)的最长公共前后缀长度，而公共前后缀与原串无关，只是在模式串中求即可</p>
<h2 id="求解NEXT"><a href="#求解NEXT" class="headerlink" title="求解NEXT"></a>求解NEXT</h2><p>用next[i]表示i位置之前字符串的最长公共前后缀，所以求解next数组其实就是求模式串每一个前缀子串的最大公共前后缀！</p>
<p>ABABABAB</p>
<p>这段字符串的next数组就是：-1 0 0 1 2 3 4 5</p>
<p>先来看代码吧</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">get_next</span><span class="params">(<span class="type">int</span> len)</span>&#123;</span><br><span class="line">	<span class="type">int</span> i=<span class="number">0</span>, j=<span class="number">-1</span>;  <span class="comment">//这里j是初始化为-1！</span></span><br><span class="line">    ne[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;len)&#123;</span><br><span class="line">		<span class="keyword">if</span>(j==<span class="number">-1</span> || ch[i]==ch[j])&#123;</span><br><span class="line">			++i; ++j;</span><br><span class="line">			ne[i]=j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> j=ne[j];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先明白next[i]表示的是t[0]…t[i-1]的最大公共前后缀，是不包括t[i]的！！！</p>
<p>因此next[0]就初始化为-1，然后next[1]一定是0，因为就有一个字符，首先当两个位置字符相同时很好处理，next[i]=j+1，但是当位置字符不一样时为什么j=ne[j]呢？想一下，求next数组本质就是自己和自己匹配嘛(也就是模式串中抽象出来一个模式串)，当两个位置字符失配时，只需要把j移到之前的最大公共前后缀位置就可以了，而最大位置就是next[j]</p>
<p>明白了这个next就求出来了</p>
<font color="red" size=5>需要说明的是，next数组真正有效的部分是从1到n的，也就是原串从0开始，而next数组往后移了一位</font>

<h2 id="求解KMP"><a href="#求解KMP" class="headerlink" title="求解KMP"></a>求解KMP</h2><p>接下来就好办了，和求next差不多的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">kmp</span><span class="params">(<span class="type">int</span> len1, <span class="type">int</span> len2)</span>&#123;</span><br><span class="line">	<span class="type">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>, cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;len2)&#123;</span><br><span class="line">		<span class="keyword">if</span>(j==<span class="number">-1</span> || ch1[j]==ch2[i])&#123;</span><br><span class="line">			++i; ++j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> j=ne[j];</span><br><span class="line">		<span class="keyword">if</span>(j==len1) cnt++;  <span class="comment">// 匹配到</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OK，到这里就讲完了</p>
<h2 id="全代码"><a href="#全代码" class="headerlink" title="全代码"></a>全代码</h2><p>模板题：<a href="https://vjudge.net/contest/388842#problem/H"> <strong>KMP算法</strong></a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> ne[MAXN];</span><br><span class="line"><span class="type">char</span> ch1[MAXN],ch2[MAXN];</span><br><span class="line"><span class="type">void</span> <span class="title function_">get_next</span><span class="params">(<span class="type">int</span> len)</span>&#123;</span><br><span class="line">	<span class="type">int</span> i=<span class="number">0</span>, j=<span class="number">-1</span>;</span><br><span class="line">	ne[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;len)&#123;</span><br><span class="line">		<span class="keyword">if</span>(j==<span class="number">-1</span> || ch1[i]==ch1[j])&#123;</span><br><span class="line">			++i; ++j;</span><br><span class="line">			ne[i]=j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> j=ne[j];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">kmp</span><span class="params">(<span class="type">int</span> len1, <span class="type">int</span> len2)</span>&#123;</span><br><span class="line">	<span class="type">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>, cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;len2)&#123;</span><br><span class="line">		<span class="keyword">if</span>(j==<span class="number">-1</span> || ch1[j]==ch2[i])&#123;</span><br><span class="line">			++i; ++j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> j=ne[j];</span><br><span class="line">		<span class="keyword">if</span>(j==len1) cnt++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;ch1&gt;&gt;ch2;</span><br><span class="line">		<span class="type">int</span> len1=<span class="built_in">strlen</span>(ch1), len2=<span class="built_in">strlen</span>(ch2);</span><br><span class="line">		get_next(len1);</span><br><span class="line">		<span class="type">int</span> cnt=kmp(len1, len2);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;cnt&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>next数组并不是最优的，当一个模式串所有字符都相同，比如T=(aaaaaaaa)，那么求解出来的next数组表示的是当前位置之前字符串的最大前后缀，因为字符都相同，那么所有的i，ne[i]=i-1，但实际上所有字符都是相同的，当前字符失配的话那就可以直接把指针回朔到最前面了，也就是所有的nextval[i]=ne[0]=-1，这样进行下次循环时原串指针直接后移且模式串指针回朔到第一个位置，省去了一个一个位置回朔的时间</p>
<h2 id="求解nextval数组"><a href="#求解nextval数组" class="headerlink" title="求解nextval数组"></a>求解nextval数组</h2><p>当前位置的next数组值为下标的前一个位置的字符如果和当前字符一样，则当前位置的nextval值就是前面位置的nextval值，否则就是当前位置的next数组值，初始化第一个位置的nextval值为-1</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">get_nextval</span><span class="params">(<span class="type">int</span> len)</span>&#123;</span><br><span class="line">	<span class="type">int</span> i=<span class="number">0</span>, j=<span class="number">-1</span>;</span><br><span class="line">	nextval[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;len)&#123;</span><br><span class="line">		<span class="keyword">if</span>(j==<span class="number">-1</span> || ch1[i]==ch1[j])&#123;</span><br><span class="line">			++i; ++j;</span><br><span class="line">            <span class="comment">// 和求解next数组唯一不一样的地方</span></span><br><span class="line">			<span class="keyword">if</span>(ch1[i]!=ch1[j]) nextval[i]=j;  </span><br><span class="line">			<span class="keyword">else</span> nextval[i]=nextval[j]; <span class="comment">//当前位置和next[i]的字符相同时，则不需要回朔到next[i]位置，因为这个位置的字符一定会失配，所以让nextval[i]直接指向nextval[next[i]]，当没有跳步回朔操作时next和nextval值是一样的</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> j=nextval[j];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以先通过求解出next数组，然后求解出nextval数组</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>聚类算法</title>
    <url>/posts/35f08535.html</url>
    <content><![CDATA[<h1 id="一、K-means介绍"><a href="#一、K-means介绍" class="headerlink" title="一、K-means介绍"></a>一、K-means介绍</h1><p>K-means算法，也称为K-平均或者K-均值，是一种无监督的聚类算法。对于给定的样本集，按照样本之间的距离大小，将样本划分为K个簇，让簇内的点尽量紧密的连接在一起，而让簇间的距离尽量的大。K-means是一种使用广泛的最基础的聚类算法，通常作为学习聚类算法时的第一个算法。<br>其他的聚类算法还有：K-medoids、k-modes、Clara、Clarans等</p>
<p><strong>聚类</strong>：物理或抽象对象的集合分成由类似的对象组成的多个类的过程被称为聚类。由聚类所生成的簇是一组数据对象的集合，这些对象与同一个簇中的对象彼此相似，与其他簇中的对象相异。</p>
<p><strong>簇</strong>：本算法中可以理解为，把数据集聚类成k类，即k个簇。</p>
<p><strong>质心</strong>：指各个类别的中心位置，即簇中心。</p>
<p><strong>距离公式</strong>：常用的有：欧几里得距离（欧氏距离）、曼哈顿距离、闵可夫斯基距离等。</p>
<h1 id="二、算法步骤"><a href="#二、算法步骤" class="headerlink" title="二、算法步骤"></a>二、算法步骤</h1><h2 id="1-文字说明"><a href="#1-文字说明" class="headerlink" title="1.文字说明"></a>1.文字说明</h2><p>①.给定一个待处理的数据集；<br>        ②.记K个簇的中心分别为$c1,c2,…,ck$；每个簇的样本数量为$N1,N2,…,N3$；<br>        ③.通过欧几里得距离公式计算各点到各质心的距离，把每个点划分给与其距离最近的质心，从而初步把数据集分为了K类；<br>        ④.更新质心：通过下面的公式来更新每个质心。就是，新的质心的值等于当前该质心所属簇的所有点的平均值。</p>
<script type="math/tex; mode=display">
c_{j}=\frac{1}{N_{j}}\sum_{i=1}^{N{j}}x_{i},y_{i}</script><p>⑤.重复步骤3和步骤4，直到质心基本不再变化或者达到最大迭代次数。</p>
<h2 id="2-伪代码"><a href="#2-伪代码" class="headerlink" title="2.伪代码"></a>2.伪代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">导入或创建训练集，设定K值</span><br><span class="line">随机选取K个点作为初始质心（在数据集的范围内）</span><br><span class="line">repeat</span><br><span class="line">    <span class="keyword">for</span> i=<span class="number">1</span>,<span class="number">2</span>,...,m(m为样本个数）do</span><br><span class="line">       计算K个质心到所有样本的欧式距离</span><br><span class="line">       把样本中的点划分给距离最近的质心</span><br><span class="line">    end <span class="keyword">for</span></span><br><span class="line">    <span class="keyword">for</span> i=<span class="number">1</span>,<span class="number">2</span>,..,k do</span><br><span class="line">       求每一个簇的数据的平均值</span><br><span class="line">       将求出的平均值赋值给各质心</span><br><span class="line">    end <span class="keyword">for</span></span><br><span class="line">until 当前质心基本不变或者达到最大迭代次数</span><br></pre></td></tr></table></figure>
<h1 id="三、图形展示"><a href="#三、图形展示" class="headerlink" title="三、图形展示"></a>三、图形展示</h1><p>假设K=2，即有两个簇，绿色为最初的样本数据集（图a），红色标记和蓝色标记分别为两个质心（图b）。通过计算样本到红色质心和蓝色质心的距离，实现对样本的分类，然后再不断地更新质心的位置，最终得到了一个比较理想的聚类结果（图f）。<br><img src="https://img-blog.csdnimg.cn/img_convert/4ffa7521d16a213ad998090a6903dfdb.png" alt=""><br>顺序为：a→b→c→d→e→f<br>可以看到，整个算法是一个不断更新质心和簇的过程。</p>
<h1 id="四、代码实现"><a href="#四、代码实现" class="headerlink" title="四、代码实现"></a>四、代码实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> uniform</span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data = [[], []]</span><br><span class="line">n = <span class="number">50</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    <span class="keyword">if</span> i &lt; <span class="number">20</span>:</span><br><span class="line">        data[<span class="number">0</span>].append(uniform(<span class="number">0</span>, <span class="number">4</span>))</span><br><span class="line">        data[<span class="number">1</span>].append(uniform(<span class="number">0</span>, <span class="number">12</span>))</span><br><span class="line">    <span class="keyword">elif</span> i &gt;= <span class="number">20</span> <span class="keyword">and</span> i &lt; <span class="number">30</span>:</span><br><span class="line">        data[<span class="number">0</span>].append(uniform(<span class="number">0</span>, <span class="number">10</span>))</span><br><span class="line">        data[<span class="number">1</span>].append(uniform(<span class="number">0</span>, <span class="number">10</span>))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        data[<span class="number">0</span>].append(uniform(<span class="number">9</span>, <span class="number">12</span>))</span><br><span class="line">        data[<span class="number">1</span>].append(uniform(<span class="number">0</span>, <span class="number">12</span>))</span><br><span class="line">plt.scatter(data[<span class="number">0</span>], data[<span class="number">1</span>], marker=<span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line">plt.xlim(<span class="number">0</span>, <span class="number">12</span>)</span><br><span class="line">plt.ylim(<span class="number">0</span>, <span class="number">12</span>)</span><br><span class="line">cent = np.empty((<span class="number">3</span>, <span class="number">2</span>)) <span class="comment"># 创建中心</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):  <span class="comment"># 随机初始化中心</span></span><br><span class="line">    cent[i][<span class="number">0</span>] = uniform(<span class="number">0</span>, <span class="number">12</span>)</span><br><span class="line">    cent[i][<span class="number">1</span>] = uniform(<span class="number">0</span>, <span class="number">12</span>)</span><br><span class="line">dist = np.empty((<span class="number">3</span>, n)) <span class="comment"># 距离中心的距离</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">distEuclid</span>(<span class="params">x1, y1, x2, y2</span>): <span class="comment"># 计算欧几里得距离</span></span><br><span class="line">    <span class="keyword">return</span> sqrt(<span class="built_in">pow</span>(x1-x2, <span class="number">2</span>) + <span class="built_in">pow</span>(y1-y2, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">k_means</span>():  <span class="comment"># k-means算法</span></span><br><span class="line">    <span class="keyword">for</span> step <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">50</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):  <span class="comment"># 计算距离</span></span><br><span class="line">                dist[j][i]=distEuclid(data[<span class="number">0</span>][i], data[<span class="number">1</span>][i], cent[j][<span class="number">0</span>], cent[j][<span class="number">1</span>])</span><br><span class="line">        sumX = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]    <span class="comment"># 记录距离每一个中心最近的点X和</span></span><br><span class="line">        sumY = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]    <span class="comment"># 记录距离每一个中心最近的点Y和</span></span><br><span class="line">        num = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]     <span class="comment"># 记录距离每一个中心最近的点数量</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            mi = <span class="built_in">min</span>(dist[<span class="number">0</span>][i], dist[<span class="number">1</span>][i], dist[<span class="number">2</span>][i])</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">                <span class="keyword">if</span>(dist[j][i] == mi):</span><br><span class="line">                    sumX[j] += data[<span class="number">0</span>][i]   <span class="comment"># update</span></span><br><span class="line">                    sumY[j] += data[<span class="number">1</span>][i]</span><br><span class="line">                    num[j] += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span>(step == <span class="number">49</span>): <span class="comment"># 最后一次分配画图</span></span><br><span class="line">                        c = <span class="string">&#x27;&#x27;</span></span><br><span class="line">                        <span class="keyword">if</span> (j == <span class="number">0</span>):</span><br><span class="line">                            c = <span class="string">&#x27;g&#x27;</span></span><br><span class="line">                        <span class="keyword">elif</span> (j == <span class="number">1</span>):</span><br><span class="line">                            c = <span class="string">&#x27;b&#x27;</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            c = <span class="string">&#x27;r&#x27;</span></span><br><span class="line">                        plt.scatter(data[<span class="number">0</span>][i], data[<span class="number">1</span>][i], marker=<span class="string">&#x27;+&#x27;</span>, color=c)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):  <span class="comment"># 画中心</span></span><br><span class="line">        plt.scatter(cent[i][<span class="number">0</span>], cent[i][<span class="number">1</span>], marker=<span class="string">&#x27;*&#x27;</span>, c=<span class="string">&#x27;k&#x27;</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    k_means()</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/8d163f326b134233af8e6820311de9ae.png" alt="请添加图片描述"></p>
<h1 id="五、K-means-算法存在的问题"><a href="#五、K-means-算法存在的问题" class="headerlink" title="五、K-means 算法存在的问题"></a>五、K-means 算法存在的问题</h1><p>由于K-means算法简单且易于实现，因此K-means算法得到了很多的应用，但是从K-means算法的过程中可以发现两个问题：<br>1.簇中心的个数K是需要事先给定的，对事先比较了解的数据集可以很好地进行分类，但在处理未知数据时无法确定K的值为多少时更合适，就无从下手或者只能盲目尝试。<br>2.K-means算法在聚类之前，需要随机初始化K个质心，如果质心选择不好，如上面的图形所示，最后的聚类结果会非常差。</p>
<h1 id="六、在线K-means"><a href="#六、在线K-means" class="headerlink" title="六、在线K-means"></a>六、在线K-means</h1><p>现实情况中，数据并不是一下子就能全部获得的，通常是以数据流的形式请求，所以在线聚类是很有必要的。</p>
<p>下面是在线聚类的流程：</p>
<p>对于新到来的一个或者一串数据，求出距离数据最近的簇，每个簇都有一个中心点，这个点不一定是样本点，比如一个簇只有两个样本点，则中心点就在两个样本点的中间，是一个虚拟点。</p>
<p>然后把新的数据加入到对应的簇中，更新簇的中心，更新方法有许多，有精度高（时复也高）的，也有精度低（时复也低）的。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>代码59行利用了“学习率”来更新簇中心，其思想是：当簇中样本点足够多的情况下，新来的点影响就会变小，学习率也就会变小，新点在更新簇中心的公式中，权重变低。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> uniform</span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OnlineKMeans</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot; Online K Means Algorithm &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,</span></span><br><span class="line"><span class="params">                 num_features: <span class="built_in">int</span>,</span></span><br><span class="line"><span class="params">                 num_clusters: <span class="built_in">int</span>,</span></span><br><span class="line"><span class="params">                 lr: <span class="built_in">tuple</span> = <span class="literal">None</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :param num_features: The dimension of the data</span></span><br><span class="line"><span class="string">        :param num_clusters: The number of clusters to form as well as the number of centroids to generate.</span></span><br><span class="line"><span class="string">        :param lr: The learning rate of the online k-means (c&#x27;, t0). If None, then we will use the simplest update</span></span><br><span class="line"><span class="string">        rule (c&#x27;=1, t0=0) as described in the lecture.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> num_features &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">f&quot;num_features must be greater or equal to 1!\nGet <span class="subst">&#123;num_features&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> num_clusters &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">f&quot;num_clusters must be greater or equal to 1!\nGet <span class="subst">&#123;num_clusters&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        self.num_features = num_features</span><br><span class="line">        self.num_clusters = num_clusters</span><br><span class="line"></span><br><span class="line">        self.num_centroids = <span class="number">0</span></span><br><span class="line">        self.centroid = np.zeros((num_clusters, num_features))</span><br><span class="line">        self.cluster_counter = np.zeros(num_clusters)  <span class="comment"># Count how many points have been assigned into this cluster</span></span><br><span class="line"></span><br><span class="line">        self.num_samples = <span class="number">0</span></span><br><span class="line">        self.lr = lr</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fit</span>(<span class="params">self, X</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Receive a sample (or mini batch of samples) online, and update the centroids of the clusters</span></span><br><span class="line"><span class="string">        :param X: (num_features,) or (num_samples, num_features)</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(X.shape) == <span class="number">1</span>:</span><br><span class="line">            X = X[np.newaxis, :]</span><br><span class="line">        num_samples, num_features = X.shape</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_samples):</span><br><span class="line">            self.num_samples += <span class="number">1</span></span><br><span class="line">            <span class="comment"># Did not find enough samples, directly set it to mean</span></span><br><span class="line">            <span class="keyword">if</span> self.num_centroids &lt; self.num_clusters:</span><br><span class="line">                self.centroid[self.num_centroids] = X[i]</span><br><span class="line">                self.cluster_counter[self.num_centroids] += <span class="number">1</span></span><br><span class="line">                self.num_centroids += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># Determine the closest centroid for this sample</span></span><br><span class="line">                sample = X[i]</span><br><span class="line">                dist = np.linalg.norm(self.centroid - sample, axis=<span class="number">1</span>)</span><br><span class="line">                centroid_idx = np.argmin(dist)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> self.lr <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                    self.centroid[centroid_idx] = (self.cluster_counter[centroid_idx] * self.centroid[centroid_idx] +</span><br><span class="line">                                                   sample) / (self.cluster_counter[centroid_idx] + <span class="number">1</span>)</span><br><span class="line">                    self.cluster_counter[centroid_idx] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    c_prime, t0 = self.lr</span><br><span class="line">                    rate = c_prime / (t0 + self.num_samples)</span><br><span class="line">                    <span class="comment"># rate = self.lr</span></span><br><span class="line">                    self.centroid[centroid_idx] = (<span class="number">1</span> - rate) * self.centroid[centroid_idx] + rate * sample</span><br><span class="line">                    self.cluster_counter[centroid_idx] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">self, X</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Predict the cluster labels for each sample in X</span></span><br><span class="line"><span class="string">        :param X: (num_features,) or (num_samples, num_features)</span></span><br><span class="line"><span class="string">        :return: Returned index starts from zero</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(X.shape) == <span class="number">1</span>:</span><br><span class="line">            X = X[np.newaxis, :]</span><br><span class="line">        num_samples, num_features = X.shape</span><br><span class="line"></span><br><span class="line">        clusters = np.zeros(num_samples)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_samples):</span><br><span class="line">            sample = X[i]</span><br><span class="line">            dist = np.linalg.norm(self.centroid - sample, axis=<span class="number">1</span>)</span><br><span class="line">            clusters[i] = np.argmin(dist)</span><br><span class="line">        <span class="keyword">return</span> clusters</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fit_predict</span>(<span class="params">self, X</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Compute cluster centers and predict cluster index for each sample.</span></span><br><span class="line"><span class="string">        :param X: (num_features,) or (num_samples, num_features)</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># Because the centroid may change in the online setting, we cannot determine the cluster of each label until</span></span><br><span class="line">        <span class="comment"># we finish fitting.</span></span><br><span class="line">        self.fit(X)</span><br><span class="line">        <span class="keyword">return</span> self.predict(X)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">calculate_cost</span>(<span class="params">self, X</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Calculate the KMean cost on the dataset X</span></span><br><span class="line"><span class="string">        The cost is defined in the L2 distance.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param X: (num_features,) or (num_samples, num_features) the dataset</span></span><br><span class="line"><span class="string">        :return: The cost of this KMean</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(X.shape) == <span class="number">1</span>:</span><br><span class="line">            X = X[np.newaxis, :]</span><br><span class="line">        num_samples, num_features = X.shape</span><br><span class="line"></span><br><span class="line">        cost = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_samples):</span><br><span class="line">            <span class="comment"># Determine the closest centroid for this sample</span></span><br><span class="line">            sample = X[i]</span><br><span class="line">            dist = np.linalg.norm(self.centroid - sample, axis=<span class="number">1</span>)</span><br><span class="line">            cost += np.square(np.<span class="built_in">min</span>(dist))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cost</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成一组随机数据</span></span><br><span class="line">X = np.concatenate([np.random.normal(loc=<span class="number">0</span>, scale=<span class="number">1</span>, size=(<span class="number">100</span>, <span class="number">2</span>)),</span><br><span class="line">                    np.random.normal(loc=<span class="number">5</span>, scale=<span class="number">1</span>, size=(<span class="number">100</span>, <span class="number">2</span>))])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 OnlineKMeans 对象</span></span><br><span class="line">num_clusters = <span class="number">3</span></span><br><span class="line">online_kmeans = OnlineKMeans(num_features=<span class="number">2</span>, num_clusters=num_clusters, lr=(<span class="number">1</span>, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历数据，逐步进行在线聚类</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(X)):</span><br><span class="line">    online_kmeans.fit(X[i])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预测聚类结果</span></span><br><span class="line">predictions = online_kmeans.predict(X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制数据点和聚类中心</span></span><br><span class="line">plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=predictions, cmap=<span class="string">&#x27;viridis&#x27;</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line">plt.scatter(online_kmeans.centroid[:, <span class="number">0</span>], online_kmeans.centroid[:, <span class="number">1</span>], marker=<span class="string">&#x27;X&#x27;</span>, s=<span class="number">200</span>, c=<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&quot;Online K-Means Clustering&quot;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Feature 1&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Feature 2&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>kmeans</tag>
      </tags>
  </entry>
  <entry>
    <title>LCA最小公共祖先</title>
    <url>/posts/98bfed5f.html</url>
    <content><![CDATA[<h2 id="LCA-公共祖先"><a href="#LCA-公共祖先" class="headerlink" title="LCA 公共祖先"></a>LCA 公共祖先</h2><p>什么是最小公共祖先，顾名思义就是俩点最近的公共祖先</p>
<p><img src="https://cdn.luogu.com.cn/upload/pic/2282.png" alt=""></p>
<p>如图所示：</p>
<ol>
<li>2和5的最小公共祖先就是4</li>
<li>2和1的最小公共祖先就是4</li>
<li>3和5的最小公共祖先是1</li>
</ol>
<p>那么怎么求呢？</p>
<p>先介绍两种朴素的做法，<del>也就是超时的做法🐷</del></p>
<p>第一种： <code>向上标记法</code></p>
<p>想求两个点的最小公共祖先可以先从其中一个点往上找父亲结点，直到根节点，把路径标记一下，然后从另一个点开始做同样的操作，当遇到已经标记过的点的时候就停下来，这个点一定是最小公共祖先（ 每次查询时间复杂度：O(n) ）</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">500100</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vt[MAXN];</span><br><span class="line"><span class="type">int</span> fa[MAXN];</span><br><span class="line"><span class="type">bool</span> vis[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> len=vt[u].<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">		<span class="type">int</span> v=vt[u][i];</span><br><span class="line">		<span class="keyword">if</span>(v==fa[u]) <span class="keyword">continue</span>;</span><br><span class="line">		fa[v]=u;</span><br><span class="line">		<span class="built_in">dfs</span>(v);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">	<span class="keyword">while</span>(l)&#123;</span><br><span class="line">		vis[l]=<span class="number">1</span>;</span><br><span class="line">		l=fa[l];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(!vis[r]) r=fa[r];</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> n,m,s;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">		<span class="type">int</span> x,y;</span><br><span class="line">		cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">		vt[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">		vt[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfs</span>(s); <span class="comment">//找到每一个点的父亲结点是谁</span></span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="type">int</span> l,r;</span><br><span class="line">		cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">		cout&lt;&lt;<span class="built_in">lca</span>(l,r)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>
<p>第二种： <code>利用深度法</code></p>
<p>在上面的dfs函数稍微改一下，得到每一个点到根节点的深度（从0开始），当询问两个点的lca时，我们先把深度大的那个点网上搜，直到两个点的深度相同，深度相同后，两个点一起往上搜直到两个点合并到一起，那么这个点就是lca</p>
<h3 id="CODE-1"><a href="#CODE-1" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">500100</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; vt[MAXN];</span><br><span class="line"><span class="type">int</span> fa[MAXN],dep[MAXN];</span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> d)</span>&#123;</span><br><span class="line">	dep[u]=d; <span class="comment">//处理出每一个点的深度</span></span><br><span class="line">	<span class="type">int</span> len=vt[u].size();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">		<span class="type">int</span> v=vt[u][i];</span><br><span class="line">		<span class="keyword">if</span>(v==fa[u]) <span class="keyword">continue</span>;</span><br><span class="line">		fa[v]=u;</span><br><span class="line">		dfs(v,d+<span class="number">1</span>); <span class="comment">//子节点深度加一</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">lca</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(dep[l]&lt;dep[r]) swap(l,r); <span class="comment">//保证l是深度大的那个点</span></span><br><span class="line">	<span class="keyword">while</span>(dep[l]&gt;dep[r]) l=fa[l]; <span class="comment">//从深度大的那个开始往上走</span></span><br><span class="line">	<span class="keyword">while</span>(l!=r)&#123; <span class="comment">//一起往上</span></span><br><span class="line">		l=fa[l];</span><br><span class="line">		r=fa[r];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> n,m,s;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;s;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">		<span class="type">int</span> x,y;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">		vt[x].push_back(y);</span><br><span class="line">		vt[y].push_back(x);</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(s,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="type">int</span> l,r;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;lca(l,r)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>
<h2 id="倍增找LCA"><a href="#倍增找LCA" class="headerlink" title="倍增找LCA"></a>倍增找LCA</h2><p> 详细讲解：</p>
<p><a href="https://www.bilibili.com/video/BV155411h7CG?p=2">视频</a></p>
<p><a href="https://www.cnblogs.com/darlingroot/p/10597611.html">LCA博客讲解</a></p>
<h2 id="P3379-【模板】最近公共祖先（LCA）"><a href="#P3379-【模板】最近公共祖先（LCA）" class="headerlink" title="P3379 【模板】最近公共祖先（LCA）"></a><a href="https://www.luogu.com.cn/problem/P3379">P3379 【模板】最近公共祖先（LCA）</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">500010</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; ve[MAXN];</span><br><span class="line"><span class="type">int</span> dep[MAXN],f[MAXN][<span class="number">22</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa, <span class="type">int</span> d)</span>&#123;  <span class="comment">//找到每一个节点的父亲节点以及深度大小</span></span><br><span class="line">	f[u][<span class="number">0</span>]=fa;  <span class="comment">//每一个节点往上走2^0步就是父亲节点</span></span><br><span class="line">	dep[u]=d;  <span class="comment">//深度</span></span><br><span class="line">	<span class="type">int</span> sz=ve[u].size();  <span class="comment">//遍历后继节点</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;sz;i++)&#123;</span><br><span class="line">		<span class="type">int</span> v=ve[u][i];  </span><br><span class="line">		<span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;  <span class="comment">//记住不能往回走</span></span><br><span class="line">		dfs(v, u, d+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">bz</span><span class="params">(<span class="type">int</span> n)</span>&#123;  <span class="comment">//预处理出每一个节点往上2^i步后到达的节点</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">22</span>;i++)&#123;  <span class="comment">//2^22 &gt; 4e7，能处理最大深度不超过4e7的树</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> u=<span class="number">1</span>;u&lt;=n;u++)&#123;</span><br><span class="line">			f[u][i]=f[f[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];  <span class="comment">//当前节点向上走2^i步就等于先向上走2^(i-1)再向上走2^(i-1)步</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">lca</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(dep[x]&lt;dep[y]) swap(x,y);  <span class="comment">//保证x的深度大于y</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=log2(dep[x]-dep[y]);i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">		<span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;i)&lt;=dep[x]-dep[y]) x=f[x][i]; <span class="comment">//注意dep[x]-dep[y]时刻在变化，也正是因为这个所以dep[x]一定最后和dep[y] </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(x==y) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=log2(dep[x]);i&gt;=<span class="number">0</span>;i--)&#123;  <span class="comment">//此时两个节点的深度相同，就需要一起往上面走</span></span><br><span class="line">		<span class="keyword">if</span>(f[x][i]!=f[y][i])&#123;  <span class="comment">//一起走2^i后不能相同，因为相同了可能导致超过（最近）公共祖先！</span></span><br><span class="line">			x=f[x][i];</span><br><span class="line">			y=f[y][i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//走完后一定到达了最近公共祖先的子节点，因为这种方法本质上就是二分</span></span><br><span class="line">	<span class="keyword">return</span> f[x][<span class="number">0</span>]; <span class="comment">//父节点就是lca</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>); <span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> n,m,s;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;s;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">		<span class="type">int</span> a,b;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">		ve[a].push_back(b);</span><br><span class="line">		ve[b].push_back(a);</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(s,<span class="number">0</span>,<span class="number">0</span>);  <span class="comment">//这里很巧妙哦，假设还有一个0节点，而0是s的父亲节点，这样每一个节点往上走2^i就算走过了根节点也会是0</span></span><br><span class="line">	bz(n);  <span class="comment">//预处理</span></span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="type">int</span> x,y;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;lca(x,y)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-1915-最美字符串数量</title>
    <url>/posts/46a8a662.html</url>
    <content><![CDATA[<h2 id="最美子字符串的数目"><a href="#最美子字符串的数目" class="headerlink" title="最美子字符串的数目"></a><a href="https://leetcode-cn.com/problems/number-of-wonderful-substrings/">最美子字符串的数目</a></h2><p>美丽的字符串定义为该字符串<strong>至多一个</strong>字母出现<strong>奇数</strong>次，给定一个字符串求该字符串包含多少个美丽的子串。（该字符串由前十个小写英文字母组成）</p>
<p>由于只会由前10个字母组成，所以可以把所有的字符当作一个二进制位，0表示该字符出现了偶数次，1代表字符出现了奇数次，那么现在好的状态就变成了0和2^i^，我们从前往后遍历字符串，求一个前缀异或状态，两个前缀异或起来即可得到一段区间的状态，那么问题就转化为了所有的位置前面有多少个状态和当前状态异或后是一个好的状态，如此我们就可以开一个数组cnt[i]记录从起始位置到当前位置i状态出现的次数，ans+=cnt[good^state]即是答案，good是一个好的状态，state是当前状态。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">wonderfulSubstrings</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">		<span class="type">long</span> <span class="type">long</span> res=<span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> cnt[<span class="number">1025</span>];</span><br><span class="line">		<span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span> cnt);</span><br><span class="line">		vector&lt;<span class="type">int</span>&gt; good;</span><br><span class="line">		good.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) good.<span class="built_in">push_back</span>(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">		<span class="type">int</span> len=word.<span class="built_in">size</span>(),state=<span class="number">0</span>;</span><br><span class="line">		cnt[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">			<span class="type">int</span> now=<span class="number">1</span>&lt;&lt;(word[i]-<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">			state^=now;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">auto</span> p:good)&#123;</span><br><span class="line">				res+=cnt[p^state];</span><br><span class="line">			&#125;</span><br><span class="line">			cnt[state]++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>状压+前缀异或和</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-42-接雨水（单调栈写法）</title>
    <url>/posts/407e2a21.html</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode.cn/problems/trapping-rain-water/description/?envType=study-plan-v2&amp;envId=top-100-liked">题目链接</a></p>
<h1 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h1><p>求出前缀最大和后缀最大，用两者较小值减去当前高度，累加即可，这个思路容易想到，这里不赘述</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preMx</span><span class="params">(height.size())</span>, <span class="title">postMx</span><span class="params">(height.size())</span></span>;</span><br><span class="line">        <span class="type">int</span> mx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; height.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            preMx[i] = mx;</span><br><span class="line">            mx = <span class="built_in">max</span>(mx, height[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        mx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = height.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            postMx[i] = mx;</span><br><span class="line">            mx = <span class="built_in">max</span>(mx, height[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; height.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> mi = <span class="built_in">min</span>(preMx[i], postMx[i]);</span><br><span class="line">            <span class="keyword">if</span> (mi - height[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ans += mi - height[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h1><p>主要学习单调栈的写法，解法一是考虑下竖着计算，计算每个位置的水的高度，而单调栈则是横着计算，如下图：<br><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/1dcd1b62d4044b859b5360c2041edfde.png" alt="单调栈"><br>维护一个栈，满足从栈底到栈顶元素大小递减。如果当前元素高于栈顶，且栈内有至少2个元素，则形成了一个凹槽，及一个图中横着的红色矩形，将它的面积累加即可，第一次写难在维护单调栈中计算面积和。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] stack = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">20010</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> -<span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; height.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (top != -<span class="number">1</span> &amp;&amp; height[i] &gt; height[stack[top]]) &#123;</span><br><span class="line">	            <span class="comment">//高度为(Math.min(height[i], height[stack[top-1]]) - height[stack[top]])</span></span><br><span class="line">	            <span class="comment">//宽度为(i - stack[top-1] - 1)</span></span><br><span class="line">                <span class="keyword">if</span> (top &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">                    ans += (Math.min(height[i], height[stack[top-<span class="number">1</span>]]) - height[stack[top]]) * (i - stack[top-<span class="number">1</span>] - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                top--;</span><br><span class="line">            &#125;</span><br><span class="line">            stack[++top] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Millionaire Madness</title>
    <url>/posts/8a005a29.html</url>
    <content><![CDATA[<blockquote>
<p>计蒜客之前比赛的一道题目，记录一下</p>
</blockquote>
<h2 id="G-Millionaire-Madness"><a href="#G-Millionaire-Madness" class="headerlink" title="G Millionaire Madness"></a>G Millionaire Madness</h2><blockquote>
<p>A close friend of yours, a duck with financial problems, has requested your help with a matter that will help him pay off his debts. He is the nephew of an extremely wealthy duck, who has a large vault, filled with mountains of coins. This wealthy duck has a certain coin in his possession which has a lot of sentimental value to him. Usually, it is kept under a protective glass dome on a velvet cushion.However, during a recent relocating of the coins in the vault, the special coin was accidentally moved into the vault, leading to an extremely stressful situation for your friend’s uncle. Luckily, the coin has recently been located. Unfortunately, it is completely opposite to the entrance to the vault, and due to the mountains of coins inside the vault, actually reaching the coin is no simple task.He is therefore willing to pay your friend to retrieve this coin, provided that he brings his own equipment to scale the mountains of coins. Your friend has decided he will bring a ladder, but he is still uncertain about its length. While a longer ladder means that he can scale higher cliffs, it also costs more money. He therefore wants to buy the shortest ladder such that he can reach the special coin, so that he has the largest amount of money left to pay off his debts.The vault can be represented as a rectangular grid of stacks of coins of various heights (in meters), with the entrance at the north west corner (the first height in the input, the entrance to the vault is at this height as well) and the special coin at the south east corner (the last height in the input). Your avian companion has figured out the height of the coins in each of these squares. From a stack of coins he can attempt to climb up or jump down to the stack immediately north, west, south or east of it. Because your friend cannot jump or fly (he is a very special kind of duck that even wears clothes), successfully performing a climb of n<em>n</em> meters will require him to bring a ladder of at least n<em>n</em> meters. He does not mind jumping down, no matter the height; he just lets gravity do all the work. </p>
<p><strong>Input</strong></p>
<p>The first line contains two integers: the length M<em>M</em>, and the width N<em>N</em> of the vault, satisfying 1 \leq M,N \leq 10001≤<em>M</em>,<em>N</em>≤1000.The following M<em>M</em> lines each contain N<em>N</em> integers. Each integer specifies the height of the pile of coins in the vault at the corresponding position. (The first line describes the north-most stacks from west to east; the last line describes the south-most stacks from west to east). The heights are given in meters and all heights are at least 00 and at most 10^9109 (yes, your friend’s uncle is very rich). </p>
<p><strong>Output</strong></p>
<p>Output a single line containing a single integer: the length in meters of the shortest ladder that allows you to get from the north west corner to the south east corner.</p>
<h4 id="样例输入1"><a href="#样例输入1" class="headerlink" title="样例输入1"></a>样例输入1</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2 3</span><br><span class="line">6 5 4</span><br><span class="line">7 8 9</span><br></pre></td></tr></table></figure>
<h4 id="样例输出1"><a href="#样例输出1" class="headerlink" title="样例输出1"></a>样例输出1</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>
<h4 id="样例输入2"><a href="#样例输入2" class="headerlink" title="样例输入2"></a>样例输入2</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 4</span><br><span class="line">4 3 2 1</span><br></pre></td></tr></table></figure>
<h4 id="样例输出2"><a href="#样例输出2" class="headerlink" title="样例输出2"></a>样例输出2</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure>
<h4 id="样例输入3"><a href="#样例输入3" class="headerlink" title="样例输入3"></a>样例输入3</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7 5</span><br><span class="line">10 11 12 13 14</span><br><span class="line">11 20 16 17 16</span><br><span class="line">12 10 18 21 24</span><br><span class="line">14 10 14 14 22</span><br><span class="line">16 18 20 20 25</span><br><span class="line">25 24 22 10 25</span><br><span class="line">26 27 28 21 25</span><br></pre></td></tr></table></figure>
<h4 id="样例输出3"><a href="#样例输出3" class="headerlink" title="样例输出3"></a>样例输出3</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h3><p>给定一个矩阵，从第一个点到最后一个点需要的最短梯子长度，从一个数到一个比它大的数需要一个两数之差的梯子长度，需要注意这个梯子可以反复使用，其实就是求从起点到终点的一条路径，这条路径的任意两个相邻数最大的差值最小，问这个差值是多少？</p>
<h3 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h3><p>既然要求从起点到终点最短梯子长度，那可以这样想，求从起点到离终点只有一步的那个点到终点需要的梯子长度和从起点到终点所需的最短梯子长度取大的，同理继续往前推可以知道每一次递推都是由之前的那个点到起点所需最短梯子长度推过来的，因此每次都是求这个点到下一个点的最小梯子长度，如何求最短呢？肯定想到优先队列，而一层一层的往外推则是bfs，因此这道题就出来了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> x,y,v;</span><br><span class="line">    <span class="type">bool</span> operator&lt;(<span class="type">const</span> node &amp; o)<span class="type">const</span>&#123; <span class="comment">//v代表每一个点到起点需要的梯子数量</span></span><br><span class="line">        <span class="keyword">return</span> v&gt;o.v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">priority_queue</span>&lt;node&gt; p;</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">1006</span>][<span class="number">1006</span>];</span><br><span class="line"><span class="type">int</span> arr[<span class="number">1006</span>][<span class="number">1006</span>],dir[<span class="number">4</span>][<span class="number">2</span>]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;,n,m;</span><br><span class="line"><span class="type">int</span> <span class="title function_">bfs</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!p.empty())&#123;</span><br><span class="line">        node d=p.top();</span><br><span class="line">        p.pop();</span><br><span class="line">        <span class="type">int</span> x=d.x,y=d.y,v=d.v;</span><br><span class="line">        <span class="keyword">if</span>(x==n&amp;&amp;y==m) <span class="keyword">return</span> v; <span class="comment">//到达了终点</span></span><br><span class="line">        <span class="keyword">if</span>(vis[x][y]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[x][y]=<span class="number">1</span>; <span class="comment">//记得标记</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;++i)&#123;</span><br><span class="line">            <span class="type">int</span> x1=x+dir[i][<span class="number">0</span>],y1=y+dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(x1&lt;=<span class="number">0</span>||x1&gt;n||y1&lt;=<span class="number">0</span>||y1&gt;m) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> tmp;</span><br><span class="line">            <span class="keyword">if</span>(arr[x1][y1]-arr[x][y]&lt;<span class="number">0</span>) tmp=<span class="number">0</span>; <span class="comment">//这是刚开始如果下一个点比这个点小不能用负数，得用0</span></span><br><span class="line">            <span class="keyword">else</span> tmp=arr[x1][y1]-arr[x][y]; 这段需要的梯子长度</span><br><span class="line">            <span class="type">int</span> v1=max(v,tmp); <span class="comment">//取他们较大的那个</span></span><br><span class="line">            p.push(&#123;x1,y1,v1&#125;); <span class="comment">//放进队列</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ios;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;++j)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;arr[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    p.push(&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;bfs()&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>P1131拯救大兵瑞恩</title>
    <url>/posts/e655dcb8.html</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/20210320104811.png" alt="image-20210320104759568" style="zoom:50%;" /></p>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>从(1,1)出发走到(n,m)，途中有墙有门有钥匙，问最短几步走到右下角。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>利用状态压缩，用二进制位表示第几种钥匙是否持有，利用BFS爆搜，再开一个数组储存状态来记忆化剪枝</p>
<p>实现方法有很多种，可以利用邻接表建边，可以直接利用Next数组表示下一个位置，邻接表利用空间换取了时间，表示墙和门时如果不用邻接表，则需要用map<pair<int,int>,pair<int,int>&gt;这种结构来表示，而邻接表可以用边权来表示，但都是可以过的</p>
<h3 id="CODE1-优先队列"><a href="#CODE1-优先队列" class="headerlink" title="CODE1(优先队列)"></a>CODE1(优先队列)</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SUB=<span class="number">-0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-4</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> E=<span class="built_in">exp</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> x1,y1,x2,y2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> x,y,d,z;</span><br><span class="line">	<span class="type">bool</span> operator&lt;(<span class="type">const</span> Node &amp;o) <span class="type">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> d&gt;o.d;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> n,m,k,p,s;</span><br><span class="line"><span class="type">int</span> Next[<span class="number">4</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span> key[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">pair</span>&lt;pii,pii&gt;,<span class="type">int</span>&gt; wal,dor;</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">20</span>][<span class="number">20</span>][<span class="number">1</span>&lt;&lt;<span class="number">10</span>];</span><br><span class="line"><span class="built_in">priority_queue</span>&lt;Node&gt; q;</span><br><span class="line"><span class="type">int</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">	<span class="type">int</span> tmp=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(key[x][y]) tmp=key[x][y];</span><br><span class="line">	q.push(&#123;x,y,<span class="number">0</span>,tmp&#125;);</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		Node fr=q.top();</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="keyword">if</span>(fr.x==n &amp;&amp; fr.y==m) <span class="keyword">return</span> fr.d;</span><br><span class="line">		<span class="keyword">if</span>(vis[fr.x][fr.y][fr.z]) <span class="keyword">continue</span>;</span><br><span class="line">		vis[fr.x][fr.y][fr.z]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">			<span class="type">int</span> nx=fr.x+Next[i][<span class="number">0</span>];</span><br><span class="line">			<span class="type">int</span> ny=fr.y+Next[i][<span class="number">1</span>];</span><br><span class="line">			<span class="keyword">if</span>(nx&lt;<span class="number">1</span> || nx&gt;n || ny&lt;<span class="number">1</span> || ny&gt;m) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(wal[&#123;&#123;fr.x,fr.y&#125;,&#123;nx,ny&#125;&#125;]) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(dor[&#123;&#123;fr.x,fr.y&#125;,&#123;nx,ny&#125;&#125;] &amp;&amp; ((fr.z&gt;&gt;(dor[&#123;&#123;fr.x,fr.y&#125;,&#123;nx,ny&#125;&#125;]<span class="number">-1</span>))&amp;<span class="number">1</span>)==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="type">int</span> now=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span>(key[nx][ny]) now=key[nx][ny];</span><br><span class="line">			q.push(&#123;nx,ny,fr.d+<span class="number">1</span>,fr.z|now&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;p&gt;&gt;k;</span><br><span class="line">	<span class="keyword">while</span>(k--)&#123;</span><br><span class="line">		<span class="type">int</span> x1,y1,x2,y2,G;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2&gt;&gt;G;</span><br><span class="line">		<span class="keyword">if</span>(G==<span class="number">0</span>)&#123;</span><br><span class="line">			wal[&#123;&#123;x1,y1&#125;,&#123;x2,y2&#125;&#125;]=<span class="number">1</span>;</span><br><span class="line">			wal[&#123;&#123;x2,y2&#125;,&#123;x1,y1&#125;&#125;]=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			dor[&#123;&#123;x1,y1&#125;,&#123;x2,y2&#125;&#125;]=G;</span><br><span class="line">			dor[&#123;&#123;x2,y2&#125;,&#123;x1,y1&#125;&#125;]=G;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=s;i++)&#123;</span><br><span class="line">		<span class="type">int</span> x,y,g;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;g;</span><br><span class="line">		key[x][y]|=(<span class="number">1</span>&lt;&lt;g<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> ans=bfs(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CODE2-dis数组"><a href="#CODE2-dis数组" class="headerlink" title="CODE2(dis数组)"></a>CODE2(dis数组)</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> first x</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> second y</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SUB=<span class="number">-0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-4</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> E=<span class="built_in">exp</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> x,y,state;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> n,m,p,k;</span><br><span class="line"><span class="type">int</span> key[<span class="number">11</span>][<span class="number">11</span>],dis[<span class="number">11</span>][<span class="number">11</span>][<span class="number">1</span>&lt;&lt;<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> Next[<span class="number">4</span>][<span class="number">2</span>]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">bool</span> st[<span class="number">11</span>][<span class="number">11</span>][<span class="number">1</span>&lt;&lt;<span class="number">10</span>];</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">pair</span>&lt;pii,pii&gt;&gt; wal;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">pair</span>&lt;pii,pii&gt;,<span class="type">int</span>&gt; dor;</span><br><span class="line"><span class="built_in">deque</span>&lt;node&gt; dq;</span><br><span class="line"><span class="type">int</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dis);</span><br><span class="line">	dq.push_back(&#123;x,y,<span class="number">0</span>&#125;);</span><br><span class="line">	dis[x][y][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!dq.empty())&#123;</span><br><span class="line">		node now=dq.front();</span><br><span class="line">		dq.pop_front();</span><br><span class="line">		<span class="keyword">if</span>(now.x==n &amp;&amp; now.y==m) <span class="keyword">return</span> dis[n][m][now.state];</span><br><span class="line">		<span class="keyword">if</span>(st[now.x][now.y][now.state]) <span class="keyword">continue</span>;</span><br><span class="line">		st[now.x][now.y][now.state]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(key[now.x][now.y])&#123;</span><br><span class="line">			<span class="keyword">if</span>(dis[now.x][now.y][key[now.x][now.y]|now.state]&gt;dis[now.x][now.y][now.state])&#123;</span><br><span class="line">				dis[now.x][now.y][ key[now.x][now.y] | now.state]=dis[now.x][now.y][now.state];</span><br><span class="line">			&#125;</span><br><span class="line">			now.state|=key[now.x][now.y];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">			<span class="type">int</span> nx=now.x+Next[i][<span class="number">0</span>];</span><br><span class="line">			<span class="type">int</span> ny=now.y+Next[i][<span class="number">1</span>];</span><br><span class="line">			<span class="keyword">if</span>(nx&lt;<span class="number">1</span> || nx&gt;n || ny&lt;<span class="number">1</span> || ny&gt;m) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(wal.count(&#123;&#123;now.x,now.y&#125;,&#123;nx,ny&#125;&#125;)) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(dor[&#123;&#123;now.x,now.y&#125;,&#123;nx,ny&#125;&#125;] &amp;&amp; (( <span class="number">1</span>&lt;&lt;(dor[&#123;&#123;now.x,now.y&#125;,&#123;nx,ny&#125;&#125;]<span class="number">-1</span>) ) &amp; now.state)==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(dis[nx][ny][now.state]&gt;dis[now.x][now.y][now.state]+<span class="number">1</span>)&#123;</span><br><span class="line">				dis[nx][ny][now.state]=dis[now.x][now.y][now.state]+<span class="number">1</span>;				</span><br><span class="line">				dq.push_back(&#123;nx,ny,now.state&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;p&gt;&gt;k;</span><br><span class="line">	<span class="keyword">while</span>(k--)&#123;</span><br><span class="line">		<span class="type">int</span> x1,y1,x2,y2,c;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2&gt;&gt;c;</span><br><span class="line">		<span class="keyword">if</span>(c)&#123;</span><br><span class="line">			dor[&#123;&#123;x1,y1&#125;,&#123;x2,y2&#125;&#125;]=c;</span><br><span class="line">			dor[&#123;&#123;x2,y2&#125;,&#123;x1,y1&#125;&#125;]=c;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			wal.insert(&#123;&#123;x1,y1&#125;,&#123;x2,y2&#125;&#125;);</span><br><span class="line">			wal.insert(&#123;&#123;x2,y2&#125;,&#123;x1,y1&#125;&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> s;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=s;i++)&#123;</span><br><span class="line">		<span class="type">int</span> x,y,g;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;g;</span><br><span class="line">		key[x][y]|=( <span class="number">1</span>&lt;&lt; g<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> ans=bfs(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>P175电路维修</title>
    <url>/posts/564fb150.html</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/20210319205828.png" alt="image-20210319205815067" style="zoom:50%;" /></p>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>如图所示，旋转最少的电线使得左面的电源和发光器相连、</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>考虑把所有电线已经相连的点设为边权为0，没有连接的，比如电线是主对角线，副对角线上的两个点就应该设为边权为1，最后跑一个从左上角到右下角的最短路径，将每一个点映射到一维数组中。</p>
<p>dijstla当然可以做，但是双端队列更高，因为这个图中只有边权为0和1的点，可以把优先队列的log(n)省掉，当遇到边权为0的点时就把点直接添加到队头，遇到边权为1的点放到队尾，并且判断能否更新当前点离起点的距离。</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SUB=<span class="number">-0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-4</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> E=<span class="built_in">exp</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> to,next,w;</span><br><span class="line">&#125;e[MAXN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> head[MAXN],dis[MAXN];</span><br><span class="line"><span class="type">int</span> t,n,tot,m;</span><br><span class="line"><span class="type">bool</span> vis[MAXN];</span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span>&#123;</span><br><span class="line">	e[tot]=&#123;v,head[u],w&#125;;</span><br><span class="line">	head[u]=tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (x<span class="number">-1</span>)*(m+<span class="number">1</span>)+y;</span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> u,d;</span><br><span class="line">	<span class="type">bool</span> operator&lt;(<span class="type">const</span> Node &amp;o) <span class="type">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> d&gt;o.d;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//priority_queue&lt;Node&gt; pq;</span></span><br><span class="line"><span class="comment">//void dij(int s)&#123;</span></span><br><span class="line"><span class="comment">//	memset(vis,0,sizeof vis);</span></span><br><span class="line"><span class="comment">//	memset(dis,0x3f,sizeof(dis));</span></span><br><span class="line"><span class="comment">//	pq.push(&#123;s,0&#125;);</span></span><br><span class="line"><span class="comment">//	dis[s]=0;</span></span><br><span class="line"><span class="comment">//	while(!pq.empty())&#123;</span></span><br><span class="line"><span class="comment">//		Node now=pq.top();</span></span><br><span class="line"><span class="comment">//		pq.pop();</span></span><br><span class="line"><span class="comment">//		if(vis[now.u]) continue;</span></span><br><span class="line"><span class="comment">////		cout&lt;&lt;now.u&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line"><span class="comment">//		vis[now.u]=1;</span></span><br><span class="line"><span class="comment">//		for(int i=head[now.u];~i;i=e[i].next)&#123;</span></span><br><span class="line"><span class="comment">//			int v=e[i].to,w=e[i].w;</span></span><br><span class="line"><span class="comment">//			if(dis[v]&gt;dis[now.u]+w)&#123;</span></span><br><span class="line"><span class="comment">//				dis[v]=dis[now.u]+w;</span></span><br><span class="line"><span class="comment">//				pq.push(&#123;v,dis[v]&#125;);</span></span><br><span class="line"><span class="comment">//			&#125;</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="type">int</span>&gt; dq;</span><br><span class="line"><span class="type">void</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span> s)</span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dis);</span><br><span class="line">	<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">	dq.push_back(s);</span><br><span class="line">	dis[s]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!dq.empty())&#123;</span><br><span class="line">		<span class="type">int</span> fr=dq.front();</span><br><span class="line">		dq.pop_front();</span><br><span class="line">		<span class="keyword">if</span>(vis[fr]) <span class="keyword">continue</span>;</span><br><span class="line">		vis[fr]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=head[fr];~i;i=e[i].next)&#123;</span><br><span class="line">			<span class="type">int</span> v=e[i].to,w=e[i].w;</span><br><span class="line">			<span class="keyword">if</span>(w==<span class="number">0</span>)&#123;</span><br><span class="line">				dis[v]=dis[fr];</span><br><span class="line">				dq.push_front(v);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">if</span>(dis[v]&gt;dis[fr]+w)&#123;</span><br><span class="line">					dis[v]=dis[fr]+w;</span><br><span class="line">					dq.push_back(v);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		tot=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span> head);</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">				<span class="type">char</span> ch;</span><br><span class="line">				<span class="built_in">cin</span>&gt;&gt;ch;</span><br><span class="line">				<span class="keyword">if</span>(ch==<span class="string">&#x27;\\&#x27;</span>)&#123;</span><br><span class="line">					add(get(i,j),get(i+<span class="number">1</span>,j+<span class="number">1</span>),<span class="number">0</span>);</span><br><span class="line">					add(get(i+<span class="number">1</span>,j+<span class="number">1</span>),get(i,j),<span class="number">0</span>);</span><br><span class="line">					add(get(i,j+<span class="number">1</span>),get(i+<span class="number">1</span>,j),<span class="number">1</span>);</span><br><span class="line">					add(get(i+<span class="number">1</span>,j),get(i,j+<span class="number">1</span>),<span class="number">1</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span>&#123;</span><br><span class="line">					add(get(i,j+<span class="number">1</span>),get(i+<span class="number">1</span>,j),<span class="number">0</span>);</span><br><span class="line">					add(get(i+<span class="number">1</span>,j),get(i,j+<span class="number">1</span>),<span class="number">0</span>);</span><br><span class="line">					add(get(i,j),get(i+<span class="number">1</span>,j+<span class="number">1</span>),<span class="number">1</span>);</span><br><span class="line">					add(get(i+<span class="number">1</span>,j+<span class="number">1</span>),get(i,j),<span class="number">1</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		bfs(get(<span class="number">1</span>,<span class="number">1</span>));</span><br><span class="line">		<span class="keyword">if</span>(dis[get(n+<span class="number">1</span>,m+<span class="number">1</span>)]==INF) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;NO SOLUTION\n&quot;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;dis[get(n+<span class="number">1</span>,m+<span class="number">1</span>)]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>双端队列+BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>P342道路与航线</title>
    <url>/posts/86e7fea8.html</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/20210318200510.png" alt="image-20210318200457249" style="zoom:50%;" /></p>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定t个点，r条道路，p条航线，和一个起点，道路可互相到达，航线只能单向到达，且航线的权值可能为负数，问从起点到各个点的最小距离是多少？若不可到达输出“NO PATH”</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>把所有道路相连的点组成联通块，给他们编上号，从起点所在的联通块往后跑一个拓扑排序，连通块内跑dijstla，松弛时发现松驰的点和当前点不在一个连通块内，则把更新的点所在的联通块入度-1，大致思路是这样，但是还是有许多细节问题</p>
<ol>
<li>为什么一开始要加入入度为0的点？<ul>
<li>因为要保证拓扑序列的进行。假设s所在块编号为a，a连向块c，块b连向块c，且块a块b不相连。此时，如果你不加入入度为0的点，那么b块就不会访问到，c的入度也就不会减到0，也就不会访问到。</li>
</ul>
</li>
<li>判断无解为什么不写出==inf？<ul>
<li>因为有坑1的存在。还是上面那个例子，再加2个条件：<ol>
<li>块d-&gt;块b，块a与块d不相连。</li>
<li>d到b的路为负边权<ul>
<li>此时显然应该块b、d里所有的点都是NOPATH，而且dis都为inf。但其实在用块d内的点更新块b时，会松弛成功，因为存在负边权。所以无解时不一定dis就为inf</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li>对每一个连通块跑最短路时，不知道那个点作为起点，理论上是最小的那个点，但是考虑到可能从一个联通块到当前联通块距离比较小，但是从起点所在的联通块到当前联通块距离较大，但是两条路不相交，即不可互相到达，这样会导致起点到这个联通块的路径反而消失了，所以把所有点放到优先队列里才是合适的做法</li>
</ol>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">500000</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> to,next,w;</span><br><span class="line">&#125;e[MAXN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> u,d;</span><br><span class="line">	<span class="type">bool</span> operator&lt;(<span class="type">const</span> Node &amp;o)<span class="type">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> d&gt;o.d;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> head[MAXN],dis[MAXN],id[MAXN],in[MAXN];</span><br><span class="line"><span class="type">int</span> n,r,p,s,tot,bcnt;</span><br><span class="line"><span class="type">bool</span> vis[MAXN];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; ve[MAXN];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="built_in">priority_queue</span>&lt;Node&gt; pq;</span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span>&#123;</span><br><span class="line">	e[tot]=&#123;v,head[u],w&#125;;</span><br><span class="line">	head[u]=tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">	ve[bcnt].push_back(x);</span><br><span class="line">	id[x]=bcnt;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[x];~i;i=e[i].next)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!id[e[i].to]) dfs(e[i].to);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dij</span><span class="params">(<span class="type">int</span> s)</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> i:ve[s]) pq.push(&#123;i,dis[i]&#125;);</span><br><span class="line">	<span class="keyword">while</span>(!pq.empty())&#123;</span><br><span class="line">		Node now=pq.top();</span><br><span class="line">		pq.pop();</span><br><span class="line">		<span class="keyword">if</span>(vis[now.u]) <span class="keyword">continue</span>;</span><br><span class="line">		vis[now.u]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=head[now.u];~i;i=e[i].next)&#123;</span><br><span class="line">			<span class="type">int</span> v=e[i].to,w=e[i].w;</span><br><span class="line">			<span class="keyword">if</span>(dis[v]&gt;dis[now.u]+w)&#123;</span><br><span class="line">				dis[v]=dis[now.u]+w;</span><br><span class="line">				<span class="keyword">if</span>(id[v]==id[now.u]) pq.push(&#123;v,dis[v]&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(id[v]!=id[now.u])&#123;</span><br><span class="line">				in[id[v]]--;</span><br><span class="line">				<span class="keyword">if</span>(in[id[v]]==<span class="number">0</span>) q.push(id[v]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">tupo</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dis);</span><br><span class="line">	dis[s]=<span class="number">0</span>;</span><br><span class="line">	q.push(id[s]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=bcnt;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!in[i]) q.push(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		<span class="type">int</span> fr=q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		dij(fr);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span> head);</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;r&gt;&gt;p&gt;&gt;s;</span><br><span class="line">	<span class="keyword">while</span>(r--)&#123;</span><br><span class="line">		<span class="type">int</span> u,v,w;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">		add(u,v,w);</span><br><span class="line">		add(v,u,w);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!id[i])&#123;</span><br><span class="line">			bcnt++;</span><br><span class="line">			dfs(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(p--)&#123;</span><br><span class="line">		<span class="type">int</span> u,v,w;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">		add(u,v,w);</span><br><span class="line">		in[id[v]]++;</span><br><span class="line">	&#125;</span><br><span class="line">	tupo();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(dis[i]&gt;INF/<span class="number">2</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;NO PATH&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;  <span class="comment">//可能存在到不了的点却被负权边更新了</span></span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;dis[i]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>PPT上例题(含倍增)</title>
    <url>/posts/f79e8551.html</url>
    <content><![CDATA[<blockquote>
<p>PPT上面的好多题都做不了，ACWING上的题要报名才能做，Codeforces 1000C搜不出来，就做了剩下的，不过二维差分前缀和早就掌握了</p>
</blockquote>
<h2 id="ACWING-797-差分"><a href="#ACWING-797-差分" class="headerlink" title="ACWING-797. 差分"></a>ACWING-797. 差分</h2><p>超级模板</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> val[MAXN],cha[MAXN];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n,m;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;val[i];</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="type">int</span> l,r,c;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r&gt;&gt;c;</span><br><span class="line">		cha[l]+=c; cha[r+<span class="number">1</span>]-=c; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		cha[i]+=cha[i<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">if</span>(i!=n) <span class="built_in">cout</span>&lt;&lt;val[i]+cha[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;val[i]+cha[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>
<h2 id="洛谷-海底高铁"><a href="#洛谷-海底高铁" class="headerlink" title="洛谷-海底高铁"></a>洛谷-海底高铁</h2><p>算出每两个城市的往返次数，然后贪心一下，找到最小的，这道题之前做过，当时第一次就AC了，这道题应该不难</p>
<h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll; </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> A[MAXN],B[MAXN],C[MAXN],X[MAXN],cha[MAXN];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	ios;</span><br><span class="line">    <span class="type">int</span> n,m; <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">cin</span>&gt;&gt;X[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">    	<span class="built_in">cin</span>&gt;&gt;A[i]&gt;&gt;B[i]&gt;&gt;C[i];</span><br><span class="line">    	A[i]+=A[i<span class="number">-1</span>];</span><br><span class="line">    	B[i]+=B[i<span class="number">-1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m<span class="number">-1</span>;i++)&#123;</span><br><span class="line">		<span class="type">int</span> l=min(X[i],X[i+<span class="number">1</span>]);</span><br><span class="line">		<span class="type">int</span> r=max(X[i],X[i+<span class="number">1</span>]);</span><br><span class="line">		cha[l]++; cha[r]--;</span><br><span class="line">	&#125;</span><br><span class="line">	ll sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">		cha[i]+=cha[i<span class="number">-1</span>];</span><br><span class="line">		ll t1=cha[i]*(A[i]-A[i<span class="number">-1</span>]);</span><br><span class="line">		ll t2=cha[i]*(B[i]-B[i<span class="number">-1</span>])+C[i];</span><br><span class="line">		sum+=min(t1,t2);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="倍增-amp-amp-ST表"><a href="#倍增-amp-amp-ST表" class="headerlink" title="倍增&amp;&amp;ST表"></a>倍增&amp;&amp;ST表</h2><p>首先明白倍增是一种思想而不是模板，它与ST并没有必然的联系，不是主要有倍增就必然出现ST，做倍增题一定要明白是对什么倍增的，通常就是对区间长度或者距离倍增，使用倍增通常有(RMQ)即区间最值查询(第二道题)，以及LAC这个还没学，ST表的核心是找到ST的递推关系，从小往大推，直到打完所有表，时间复杂度是O(mlogn)，m为结点数量，n是走的步数(2^0,2^1…)， <code>2^20</code> 就已经超过 <code>1e6</code> 了，<code>2^64</code> 大于 <code>1e20</code>，所以logn是非常小的，最多几十次，复杂度记乎可以看成O(N*10)</p>
<h3 id="AtCoder-abc167-d"><a href="#AtCoder-abc167-d" class="headerlink" title="AtCoder - abc167_d"></a>AtCoder - abc167_d</h3><p>一道图上倍增的题目，别看这个1e18很大，它的log级别比64还小，用倍增做时间复杂度变成了O(NlongM)，就是2e6的样子<br>这里st表很直接，储存的就是跳了N此后到达位置，特别特别需要注意的是查询千万不能用( 1 &lt;&lt; i )，这是特别大的数字，我不明白为啥m是ll，就算把( 1 &lt;&lt; i )转化为ll类型再进行与操作还是不行，ll不是64位的吗？范围应该是够的，奇怪，不过以后最好让m右移这样不会爆int，当然也可以用while遍历每一位</p>
<h4 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">2e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> st[maxn][<span class="number">70</span>],a[maxn];</span><br><span class="line"><span class="type">int</span> n,pos=<span class="number">1</span>;</span><br><span class="line">ll m;</span><br><span class="line"><span class="type">void</span> <span class="title function_">bz</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> len=log2(m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) st[i][<span class="number">0</span>]=a[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)&#123;</span><br><span class="line">			st[j][i]=st[st[j][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">	bz();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">64</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="number">1</span>&amp;(m&gt;&gt;i))&#123;</span><br><span class="line">			pos=st[pos][i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;pos&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="ACWING-1270-数列区间最大值"><a href="#ACWING-1270-数列区间最大值" class="headerlink" title="ACWING-1270. 数列区间最大值"></a>ACWING-1270. 数列区间最大值</h3><p>一道模板RMQ题目，这道题ST储存的是每一段区间的最值，倍增的是区间长度，就这道题而言，一段区间的最大值可以由这段区间从中间分开的两端区间的最值的合并，而且每一个数都是可以用2进制表示的，那么就一定用st表中的数相加得到</p>
<p>st[i][j]表示从i这一点开始数2^j^个数的最值，即往后数2^(j-1)^个数的最值</p>
<h4 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0) </span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> st[MAXN][<span class="number">22</span>],a[MAXN];</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) st[i][<span class="number">0</span>]=a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;(<span class="number">1</span>&lt;&lt;j)&lt;=n;j++)&#123;<span class="comment">//区间长度不能超过n</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>&lt;=n;i++)&#123;</span><br><span class="line">            st[i][j]=max(st[i][j<span class="number">-1</span>],st[i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)][j<span class="number">-1</span>]); <span class="comment">//我这里卡了好久，倍增的是区间长度，而st储存的是最值，所以max第二个st第一个括号应该是倍增后的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="type">int</span> r,l;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        <span class="type">int</span> k=log2(r-l+<span class="number">1</span>); <span class="comment">//注意，最后查询将两个区间最值合并</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;max(st[l][k],st[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k])&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="牛客竞赛-15429-倍增"><a href="#牛客竞赛-15429-倍增" class="headerlink" title="牛客竞赛- 15429 倍增"></a>牛客竞赛- 15429 倍增</h3><p>这道题卡了一天，还是由于我对倍增理解不深，这道题是对往后分2^j^段倍增的，ST表储存的是分成2^j^段对多能到达的距离，讲解全在代码里了</p>
<h4 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> n,m,k;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> st[MAXN][<span class="number">21</span>],book[MAXN],sum[MAXN];</span><br><span class="line"><span class="comment">//这里st存的是往右最多走到的距离 </span></span><br><span class="line"><span class="comment">//这里 st表的关系是：一个点往右分成2^j段最多到达的点==先分成2^(j-1)到达的点再往后走2^(j-1) </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		st[i][<span class="number">0</span>]=upper_bound(sum+<span class="number">1</span>,sum+<span class="number">1</span>+n,sum[i<span class="number">-1</span>]+k)-sum;<span class="comment">//很巧妙的sum[i-1]+k，分成一段最多可以到那个数 </span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;(<span class="number">1</span>&lt;&lt;i)&lt;=n;i++)<span class="comment">//当每一个数都小于k并且每两个相邻的数都大于k时就分成了n份，这也是最多分成n份 </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;<span class="comment">//记录从每一个点开始分成(2^i)段对多到达哪一个点 </span></span><br><span class="line">        	st[j][i]=st[st[j][i<span class="number">-1</span>]][i<span class="number">-1</span>];<span class="comment">//st的关系 </span></span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">1</span>;</span><br><span class="line">	 <span class="comment">//这里必须从大到小，因为要分最小段的数量，</span></span><br><span class="line">	<span class="comment">//所以要尽可能让点往右走，从大到小去试，同理当分成最多段时就要从小到大 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">20</span>;st[l][<span class="number">0</span>]&lt;=r;i--)&#123;<span class="comment">//从当前点分成一段当可以到达的点不能超过r </span></span><br><span class="line">		<span class="keyword">if</span>(st[l][i]&lt;=r&amp;&amp;st[l][i])&#123;<span class="comment">//往右最多不能超过r </span></span><br><span class="line">			l=st[l][i];<span class="comment">//更新当前位置 </span></span><br><span class="line">			ans+=(<span class="number">1</span>&lt;&lt;i);<span class="comment">//加上当前分成的段的数量 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="type">int</span> t; <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">		sum[i]=t+sum[i<span class="number">-1</span>];<span class="comment">//前缀和优化将区间和查询优化为O(1) </span></span><br><span class="line">		book[i]=book[i<span class="number">-1</span>]+(t&gt;k);<span class="comment">//很巧妙的前缀和，记录前i个数中大于k的数有几个 </span></span><br><span class="line">	&#125;</span><br><span class="line">	init();</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="type">int</span> l,r;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r;</span><br><span class="line">		<span class="keyword">if</span>(book[r]-book[l<span class="number">-1</span>]&gt;<span class="number">0</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Chtholly&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;<span class="comment">//若[l,r]有数大于k则不可能，直接输出 </span></span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;query(l,r)&lt;&lt;<span class="string">&quot;\n&quot;</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<font color="red" size=4>
做了这三道倍增题感觉对倍增有了新的认识，但是我还是处理不好ST和倍增的关系，经常处理不好ST之间的关系，真的感觉自己好菜😢
</font>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title>Philosopher‘s Walk(大模拟+爆搜)</title>
    <url>/posts/d641c02f.html</url>
    <content><![CDATA[<h1 id="ICPC训练赛-Philosopher‘s-Walk"><a href="#ICPC训练赛-Philosopher‘s-Walk" class="headerlink" title="ICPC训练赛-Philosopher‘s Walk"></a>ICPC训练赛-Philosopher‘s Walk</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/20210415121221.png" alt="image-20210415121210364" style="zoom:50%;" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/20210415121232.png" alt="image-20210415121231522" style="zoom:50%;" /></p>
<p>如图所示，给定这样的一个n阶图形，每次从左下角开始走，问走了m步后的位置坐标？</p>
<p>这个图是有规律可循的，定义f(i)是i阶图的样子，那么f(i+1)就是四个f(i)拼成的，上面两个和f(i)一样，左下角是f(i)顺时针旋转90度得到，右下角是f(i)逆时针旋转90度得到，因此可以定一个dfs函数返回的是坐标，不管这个图形是否旋转，我们只求这个图形没有旋转，也就是正着放时走m步的坐标，即使它旋转了，这个坐标也只不过是换了一个角度而已，我们是知道图形的尺寸的，那就可以根据这个尺寸来推出这个点的坐标</p>
<h2 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,m; </span><br><span class="line">pii <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==<span class="number">1</span>) <span class="keyword">return</span> &#123;<span class="number">1</span>,<span class="number">1</span>&#125;;  <span class="comment">//一阶方阵直接返回坐标(1,1)</span></span><br><span class="line">	x/=<span class="number">2</span>;  </span><br><span class="line">	<span class="type">int</span> res=x*x;  <span class="comment">//算出1/4的尺寸有多少个小方格</span></span><br><span class="line">	<span class="keyword">if</span>(m&gt;<span class="number">3</span>*res)&#123;  <span class="comment">//如果在第4个子图内</span></span><br><span class="line">		m-=<span class="number">3</span>*res;  <span class="comment">//减一下步数</span></span><br><span class="line">		pii tmp=dfs(x);  <span class="comment">//得到在这个小子图(正着放)左下角开始跑m步的坐标</span></span><br><span class="line">		<span class="keyword">return</span> &#123;x*<span class="number">2</span>-tmp.second+<span class="number">1</span>,x-tmp.first+<span class="number">1</span>&#125;;  <span class="comment">//核心，尽管跑出来的是正着放的坐标，但是可以转化为在当前图形的坐标</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(m&gt;<span class="number">2</span>*res)&#123;</span><br><span class="line">		m-=<span class="number">2</span>*res;</span><br><span class="line">		pii tmp=dfs(x);</span><br><span class="line">		<span class="keyword">return</span> &#123;x+tmp.first,x+tmp.second&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(m&gt;res)&#123;</span><br><span class="line">		m-=res;</span><br><span class="line">		pii tmp=dfs(x);</span><br><span class="line">		<span class="keyword">return</span> &#123;tmp.first,x+tmp.second&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		pii tmp=dfs(x);</span><br><span class="line">		<span class="keyword">return</span> &#123;tmp.second,tmp.first&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    pii ans=dfs(n);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans.first&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;ans.second&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Sakura Theme美化</title>
    <url>/posts/7d649817.html</url>
    <content><![CDATA[<h3 id="https-www-jianshu-com-p-e378b320c184"><a href="#https-www-jianshu-com-p-e378b320c184" class="headerlink" title="https://www.jianshu.com/p/e378b320c184"></a><a href="https://www.jianshu.com/p/e378b320c184">https://www.jianshu.com/p/e378b320c184</a></h3><p>超级详细的一个网址</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>P340通信线路</title>
    <url>/posts/ef84d4b4.html</url>
    <content><![CDATA[<h2 id="340-通信线路"><a href="#340-通信线路" class="headerlink" title="340. 通信线路"></a>340. 通信线路</h2><h3 id="分层图做法"><a href="#分层图做法" class="headerlink" title="分层图做法"></a>分层图做法</h3><p>建k+1层图，相邻两层图之间权值为0，代表免费升级，在一层图里面跑就去找最大值，最后的答案就是第k+1层的dis[n]也就是dis[(k+1)*n]，注意的是这样的做法只有在边数大于k时成立，当全部边都可以免费升级时，会出现问题，还没有跑到最后一层图就到达终点了，这时就会往回跑，导致边权增加，就会出错，所以需要把层与层之间的终点连接起来，使它们可以免费互相到达</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SUB=<span class="number">-0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-4</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> E=<span class="built_in">exp</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> to,next,w;</span><br><span class="line">&#125;e[<span class="number">10000010</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> u,d;</span><br><span class="line">	<span class="type">bool</span> operator&lt;(<span class="type">const</span> Node &amp;o)<span class="type">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> d&gt;o.d;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> head[MAXN];</span><br><span class="line"><span class="type">int</span> dis[MAXN];</span><br><span class="line"><span class="type">int</span> n,p,k,tot;</span><br><span class="line"><span class="built_in">priority_queue</span>&lt;Node&gt; pq;</span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span>&#123;</span><br><span class="line">	e[tot]=&#123;v,head[u],w&#125;;</span><br><span class="line">	head[u]=tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dij</span><span class="params">(<span class="type">int</span> s)</span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dis);</span><br><span class="line">	pq.push(&#123;s,<span class="number">0</span>&#125;);</span><br><span class="line">	dis[s]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!pq.empty())&#123;</span><br><span class="line">		Node now=pq.top();</span><br><span class="line">		pq.pop();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=head[now.u];~i;i=e[i].next)&#123;</span><br><span class="line">			<span class="type">int</span> v=e[i].to,w=e[i].w;</span><br><span class="line">			<span class="keyword">if</span>(dis[v]&gt;max(dis[now.u],w))&#123;</span><br><span class="line">				dis[v]=max(dis[now.u],w);</span><br><span class="line">				pq.push(&#123;v,dis[v]&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span> head);</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;p&gt;&gt;k;</span><br><span class="line">	<span class="keyword">while</span>(p--)&#123;</span><br><span class="line">		<span class="type">int</span> u,v,w;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">		add(u,v,w);</span><br><span class="line">		add(v,u,w);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=k;j++)&#123;</span><br><span class="line">			add(u+(j<span class="number">-1</span>)*n,v+j*n,<span class="number">0</span>);</span><br><span class="line">			add(v+(j<span class="number">-1</span>)*n,u+j*n,<span class="number">0</span>);</span><br><span class="line">			add(u+j*n,v+j*n,w);</span><br><span class="line">			add(v+j*n,u+j*n,w);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">		add(i*n,(i+<span class="number">1</span>)*n,<span class="number">0</span>);  <span class="comment">//把终点连成一体 </span></span><br><span class="line">	&#125;</span><br><span class="line">	dij(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(dis[(k+<span class="number">1</span>)*n]!=INF)<span class="built_in">cout</span>&lt;&lt;dis[(k+<span class="number">1</span>)*n]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="二分做法"><a href="#二分做法" class="headerlink" title="二分做法"></a>二分做法</h3><p>题目求的就是第k+1大最小，一看求较大值最小，就要想到二分，二分答案，验证答案，标记大于验证值的边权为1，小于等于的为0，求起点到终点的最短路径，路径和小于等于k时即满足要求，否则不满足</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SUB=<span class="number">-0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-4</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> E=<span class="built_in">exp</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> to,next,w;</span><br><span class="line">&#125;e[MAXN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> u,d;</span><br><span class="line">	<span class="type">bool</span> operator&lt;(<span class="type">const</span> Node &amp;o)<span class="type">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> d&gt;o.d;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> head[MAXN],dis[MAXN];</span><br><span class="line"><span class="type">int</span> n,p,k,tot;</span><br><span class="line"><span class="built_in">priority_queue</span>&lt;Node&gt; pq;</span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span>&#123;</span><br><span class="line">	e[tot]=&#123;v,head[u],w&#125;;</span><br><span class="line">	head[u]=tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dis);</span><br><span class="line">	dis[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">	pq.push(&#123;<span class="number">1</span>,<span class="number">0</span>&#125;);</span><br><span class="line">	<span class="keyword">while</span>(!pq.empty())&#123;</span><br><span class="line">		Node now=pq.top();</span><br><span class="line">		pq.pop();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=head[now.u];~i;i=e[i].next)&#123;</span><br><span class="line">			<span class="type">int</span> v=e[i].to,w=e[i].w&gt;x?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span>(dis[v]&gt;dis[now.u]+w)&#123;</span><br><span class="line">				dis[v]=dis[now.u]+w;</span><br><span class="line">				pq.push(&#123;v,dis[v]&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(dis[n]&lt;=k) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span> head);</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;p&gt;&gt;k;</span><br><span class="line">	<span class="keyword">while</span>(p--)&#123;</span><br><span class="line">		<span class="type">int</span> u,v,w;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">		add(u,v,w);</span><br><span class="line">		add(v,u,w);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">1000000</span>,ans=INF,mid;</span><br><span class="line">	<span class="keyword">while</span>(r&gt;=l)&#123;</span><br><span class="line">		mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(check(mid))&#123;</span><br><span class="line">			ans=mid;</span><br><span class="line">			r=mid<span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> l=mid+<span class="number">1</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(ans!=INF) <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="动态规划做法"><a href="#动态规划做法" class="headerlink" title="动态规划做法"></a>动态规划做法</h3><p>从起点到终点的一条路径中最多有k条免费升级，那给dis数组多加一维表示从起点到这个点已经免费升级几条边了，数组值依旧表示这个状态需要升级的最大值</p>
<p>转移方程：</p>
<blockquote>
<p>若在这条边不使用机会：dis[y, p] = min(dis[y, p], max(dis[x, p], w))<br>若在这条边使用机会：dis[y, p+1] = min(dis[y, p+1], dis[x, p])</p>
</blockquote>
<p>题解中很多都用SPFA，但这道题目都是正权，dijistla就可以，省了常数的时间，更新dis数组时变成转移方程就可以了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SUB=<span class="number">-0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-4</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> E=<span class="built_in">exp</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> to,next,w;</span><br><span class="line">&#125;e[MAXN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> u,c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> head[MAXN],dis[<span class="number">1100</span>][<span class="number">1010</span>];</span><br><span class="line"><span class="type">int</span> n,m,tot,k;</span><br><span class="line"><span class="built_in">queue</span>&lt;Node&gt; pq;</span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span>&#123;</span><br><span class="line">	e[tot]=&#123;v,head[u],w&#125;;</span><br><span class="line">	head[u]=tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dij</span><span class="params">(<span class="type">int</span> s)</span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dis);</span><br><span class="line">	pq.push(&#123;s,<span class="number">0</span>&#125;);</span><br><span class="line">	dis[s][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!pq.empty())&#123;</span><br><span class="line">		Node now=pq.front();</span><br><span class="line">		pq.pop();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=head[now.u];~i;i=e[i].next)&#123;</span><br><span class="line">			<span class="type">int</span> v=e[i].to,w=e[i].w;</span><br><span class="line">			<span class="keyword">if</span>(dis[v][now.c]&gt;max(dis[now.u][now.c],w))&#123;</span><br><span class="line">				dis[v][now.c]=max(dis[now.u][now.c],w);</span><br><span class="line">				pq.push(&#123;v,now.c&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(now.c+<span class="number">1</span>&lt;=k &amp;&amp; dis[v][now.c+<span class="number">1</span>]&gt;dis[now.u][now.c])&#123;</span><br><span class="line">				dis[v][now.c+<span class="number">1</span>]=dis[now.u][now.c];</span><br><span class="line">				pq.push(&#123;v,now.c+<span class="number">1</span>&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span> head);</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="type">int</span> u,v,w;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">		add(u,v,w);</span><br><span class="line">		add(v,u,w);</span><br><span class="line">	&#125;</span><br><span class="line">	dij(<span class="number">1</span>);</span><br><span class="line">	<span class="type">int</span> ans=INF;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=k;i++)&#123;</span><br><span class="line">		ans=min(ans,dis[n][i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(ans!=INF)<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈01背包和完全背包</title>
    <url>/posts/e4f859ea.html</url>
    <content><![CDATA[<blockquote>
<p>今天做了查并集和01背包结合的一道题，致使我对背包开始了学习</p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>背包问题属于动态规划里面的一大块内容，包括九讲，本文主要讲01背包和完全背包</p>
<p>两个背包差别在于01背包每一个物品只能选一次，完全背包则可以选无限次，只要背包容积足够</p>
<h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><p><strong>结合题目进行讲解</strong></p>
<p>01背包问题</p>
<p>有 NN 件物品和一个容量是 VV 的背包。每件物品只能使用一次。</p>
<p>第 ii 件物品的体积是 vi，价值是 wi。</p>
<p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>输出最大价值。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行两个整数，N，VN，V，用空格隔开，分别表示物品数量和背包容积。</p>
<p>接下来有 NN 行，每行两个整数 vi,wi，用空格隔开，分别表示第 ii 件物品的体积和价值。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一个整数，表示最大价值。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><script type="math/tex; mode=display">
0<N,V≤1000
0<vi,wi≤1000</script><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 5</span><br><span class="line">1 2</span><br><span class="line">2 4</span><br><span class="line">3 4</span><br><span class="line">4 5</span><br></pre></td></tr></table></figure>
<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这是一道01背包模板题</p>
<p>首先从二维开始，我们用dp[i] [j]表示前i个物品当体积为j时最大收益，那么<code>dp[0][j]</code>和<code>dp[i][0]</code>就都为0，分别对应二维数组的第一行和第一列，接下来就从这两列一步一步往最后推，当碰到第i个物品，我们有两个选择，选或者不选，假若背包装不下，那么不选，<code>dp[i][j]=dp[i-1][j]</code>，假若能装下，应该考虑装它是否能使利益最大化，所以应该在装和不装之间取大的，<code>dp[i][j]=max(dp[i-1][j],dp[i-1][j-w[i]]+v[i])</code>，注意这里装不一定比不装收益高，因为可能前几件价值大，第i件价值小，选择了第i件就舍弃了前面价值大的。</p>
<p>详细分析<a href="https://blog.csdn.net/qq_37767455/article/details/99086678">点击我</a></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e3</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> dp[MAXN][MAXN],w[MAXN],c[MAXN]; </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ios;</span><br><span class="line">    <span class="type">int</span> n,v;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;c[i]&gt;&gt;w[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=v;j++)&#123;</span><br><span class="line">    		<span class="keyword">if</span>(j&gt;=c[i]) dp[i][j]=max(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j-c[i]]+w[i]);</span><br><span class="line">    		<span class="keyword">else</span> dp[i][j]=dp[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="comment">//两种写法都一样</span></span><br><span class="line">    	    <span class="comment">//dp[i][j]=dp[i-1][j];</span></span><br><span class="line">    		<span class="comment">//if(j&gt;=c[i]) dp[i][j]=max(dp[i][j],dp[i-1][j-c[i]]+w[i]);            </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;dp[n][v]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="降维"><a href="#降维" class="headerlink" title="降维"></a>降维</h3><p>这个时间复杂的是O(NV)的，已经是最优了，但是空间还可以优化，观察上面的递推公式，当前前i个物品的状态只与前i-1个物品的状态有关，也就是在图上只与正上方和左上方有关，而这两个状态是已知的，因此可以用滚动数组从前往后推，也可以用一维数组从后往前推(<code>必须从后往前推，否则前一次循环保存下来的值将会被修改，从而造成推后面时用的值发生改变</code>)</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e3</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> dp[MAXN],w[MAXN],c[MAXN]; </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ios;</span><br><span class="line">    <span class="type">int</span> n,v;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;c[i]&gt;&gt;w[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="type">int</span> j=v;j&gt;=c[i];j--)&#123;</span><br><span class="line">    	   dp[j]=max(dp[j],dp[j-c[i]]+w[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;dp[v]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><p>完全背包其实和01背包是超级相似的</p>
<p>其公式的推导可见<a href="https://www.acwing.com/video/945/">闫式DP分析法</a>，利用数学公式直接推出完全背包公式：<code>dp[i][j]=max(dp[i-1][j],dp[i][j-w[i]]+v[i])</code>，这个公式和01背包只有最后max第二部分的i-1换成了i，当降维后，01背包和完全背包就只有一个差别，倒着推和正着推😂</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> dp[N],w[N],c[N]; </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ios;</span><br><span class="line">    <span class="type">int</span> n,v;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;c[i]&gt;&gt;w[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=c[i];j&lt;=v;j++)&#123;</span><br><span class="line">            dp[j]=max(dp[j],dp[j-c[i]]+w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;dp[v]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title>P341最优贸易</title>
    <url>/posts/83ce6fe2.html</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/20210318220038.png" alt="image-20210318220033300" style="zoom:50%;" /></p>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>n个城市，从1到n点，有有向边，也有无向边，每个城市都有宝石价格，从一个点买一个宝石，再在后面走的点卖出，问最多赚多少钱？</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>对每一个路径求一个前缀最小值和后缀最大值，对每一个点后缀减去前缀取最大值即是答案，细节就是，求后缀可以反建图，开一个rhead数组</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">500000</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> to,next;</span><br><span class="line">&#125;e[MAXN];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="type">int</span> head[MAXN],val[MAXN],mi[MAXN],mx[MAXN],rhead[MAXN];</span><br><span class="line"><span class="type">int</span> n,m,tot,s,flag=<span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> head[])</span>&#123;</span><br><span class="line">	e[tot]=&#123;v,head[u]&#125;;</span><br><span class="line">	head[u]=tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">spfa</span><span class="params">(<span class="type">int</span> s)</span>&#123;</span><br><span class="line">	q.push(s);</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		<span class="type">int</span> fr=q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="type">int</span> i=flag==<span class="number">0</span>?head[fr]:rhead[fr];</span><br><span class="line">		<span class="keyword">for</span>( ;~i;i=e[i].next)&#123;</span><br><span class="line">			<span class="type">int</span> v=e[i].to;</span><br><span class="line">			<span class="keyword">if</span>(!flag &amp;&amp; min(mi[fr],val[v])&lt;mi[v])&#123;</span><br><span class="line">				mi[v]=min(mi[fr],val[v]);</span><br><span class="line">				q.push(v);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(flag &amp;&amp; max(mx[fr],val[v])&gt;mx[v])&#123;</span><br><span class="line">				mx[v]=max(mx[fr],val[v]);</span><br><span class="line">				q.push(v);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span> head);</span><br><span class="line">	<span class="built_in">memset</span>(rhead,<span class="number">-1</span>,<span class="keyword">sizeof</span> rhead);</span><br><span class="line">	<span class="built_in">memset</span>(mi,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> mi);</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;val[i];</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="type">int</span> u,v,o;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v&gt;&gt;o;</span><br><span class="line">		add(u,v,head);</span><br><span class="line">		add(v,u,rhead);</span><br><span class="line">		<span class="keyword">if</span>(o==<span class="number">2</span>)&#123;</span><br><span class="line">			add(v,u,head);</span><br><span class="line">			add(u,v,rhead);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	mi[<span class="number">1</span>]=val[<span class="number">1</span>];</span><br><span class="line">	mx[n]=val[n];</span><br><span class="line">	spfa(<span class="number">1</span>);</span><br><span class="line">	flag=<span class="number">1</span>;</span><br><span class="line">	spfa(n);</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) ans=max(ans,mx[i]-mi[i]);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>bitset</title>
    <url>/posts/9dd4d1cb.html</url>
    <content><![CDATA[<h1 id="bitset"><a href="#bitset" class="headerlink" title="bitset"></a>bitset</h1><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>这个东西相当于一个bool数组，int是32位表示一个数，而这个32位表示32个数，每一位只能存1或者0，这就使得可以开的空间是int的32倍，时间复杂度为（位数）N/W(计算机常数一般为32)，而访问其中某一位时间复杂度为O(1)，这个的用处多用于数组开不下1e9以上的空间，用unordered_map插入时复O(logn)级别，就可以用bitset优化时间为O(1)</p>
<h3 id="定义与初始化"><a href="#定义与初始化" class="headerlink" title="定义与初始化"></a>定义与初始化</h3><p>使用bitset类型需<code>#include&lt;bitset&gt;</code></p>
<p>bitset类型在定义时就需要指定所占的空间，例如</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bitset</span>&lt;<span class="number">233</span>&gt;bit;</span><br></pre></td></tr></table></figure>
<p>bitset类型可以用string和整数初始化（整数转化成对应的二进制）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">bitset</span>&lt;<span class="number">23</span>&gt;bit (<span class="built_in">string</span>(<span class="string">&quot;11101001&quot;</span>));</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;bit&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    bit=<span class="number">233</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;bit&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">00000000000000011101001</span></span><br><span class="line"><span class="number">00000000000000011101001</span></span><br></pre></td></tr></table></figure>
<h2 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h2><p>bitset支持所有<strong>位运算</strong></p>
<p>使用这个来进行位运算要比数组模拟位运算快32倍</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bitset</span>&lt;<span class="number">23</span>&gt;bita(<span class="built_in">string</span>(<span class="string">&quot;11101001&quot;</span>));</span><br><span class="line"><span class="built_in">bitset</span>&lt;<span class="number">23</span>&gt;bitb(<span class="built_in">string</span>(<span class="string">&quot;11101000&quot;</span>));</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;(bita^bitb)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//输出00000000000000000000001 </span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bitset</span>&lt;<span class="number">23</span>&gt;bita(<span class="built_in">string</span>(<span class="string">&quot;11101001&quot;</span>));</span><br><span class="line"><span class="built_in">bitset</span>&lt;<span class="number">23</span>&gt;bitb(<span class="built_in">string</span>(<span class="string">&quot;11101000&quot;</span>));</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;(bita|bitb)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//输出00000000000000011101001</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bitset</span>&lt;<span class="number">23</span>&gt;bita(<span class="built_in">string</span>(<span class="string">&quot;11101001&quot;</span>));</span><br><span class="line"><span class="built_in">bitset</span>&lt;<span class="number">23</span>&gt;bitb(<span class="built_in">string</span>(<span class="string">&quot;11101000&quot;</span>));</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;(bita&amp;bitb)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//输出00000000000000011101000</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bitset</span>&lt;<span class="number">23</span>&gt;bit(<span class="built_in">string</span>(<span class="string">&quot;11101001&quot;</span>));</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;(bit&lt;&lt;<span class="number">5</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//输出00000000001110100100000</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bitset</span>&lt;<span class="number">23</span>&gt;bit(<span class="built_in">string</span>(<span class="string">&quot;11101001&quot;</span>));</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;(bit&gt;&gt;<span class="number">5</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//输出00000000000000000000111</span></span><br></pre></td></tr></table></figure>
<h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><p>对于一个叫做bit的bitset：</p>
<ul>
<li>bit.size()       返回大小（位数）</li>
<li>bit.count()     返回1的个数</li>
<li>bit.any()       返回是否有1</li>
<li>bit.none()      返回是否没有1</li>
<li>bit.set()       全都变成1</li>
<li>bit.set(p)      将第p + 1位变成1（bitset是从第0位开始的！） </li>
<li>bit.set(p, x)   将第p + 1位变成x</li>
<li>bit.reset()     全都变成0</li>
<li>bit.reset(p)    将第p + 1位变成0</li>
<li>bit.flip()      全都取反</li>
<li>bit.flip(p)     将第p + 1位取反</li>
<li>bit.to_ulong()  返回它转换为unsigned long的结果，如果超出范围则报错</li>
<li>bit.to_ullong() 返回它转换为unsigned long long的结果，如果超出范围则报错</li>
<li>bit.to_string() 返回它转换为string的结果</li>
</ul>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://ac.nowcoder.com/acm/contest/11160/D">https://ac.nowcoder.com/acm/contest/11160/D</a></p>
<p>利用bitset可以卡过去</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="type">const</span> ll MAXN=<span class="number">1e6</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> ll MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll SUB=<span class="number">-0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll eps=<span class="number">1e-4</span>;</span><br><span class="line">ll n,m;</span><br><span class="line">ll a[MAXN],b[MAXN]; </span><br><span class="line"><span class="built_in">unordered_map</span>&lt;ll,ll&gt; mp;</span><br><span class="line"><span class="built_in">bitset</span>&lt;<span class="number">1</span>&lt;&lt;<span class="number">30</span>&gt; bt;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;b[i];</span><br><span class="line">		bt.<span class="built_in">set</span>(b[i]);</span><br><span class="line">		mp[b[i]]++;</span><br><span class="line">	&#125;</span><br><span class="line">	ll ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(ll j=<span class="number">0</span>;j&lt;<span class="number">30</span>;j++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(ll k=j+<span class="number">1</span>;k&lt;<span class="number">30</span>;k++)&#123;</span><br><span class="line">				ll now=(<span class="number">1</span>&lt;&lt;j)+(<span class="number">1</span>&lt;&lt;k);</span><br><span class="line">				<span class="keyword">if</span>(bt[a[i]^now]) ans+=mp[a[i]^now];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>bitset优化</tag>
      </tags>
  </entry>
  <entry>
    <title>博弈论</title>
    <url>/posts/12bcd26e.html</url>
    <content><![CDATA[<p><strong>注意注意注意：</strong> 异或运算符优先级比等于还要低！！！！二进制的运算符尽量都加上括号</p>
<ol>
<li>必胜状态后继节点一定有必败</li>
<li>必败状态后继都是必胜</li>
</ol>
<h2 id="巴什博弈"><a href="#巴什博弈" class="headerlink" title="巴什博弈"></a>巴什博弈</h2><blockquote>
<p>数上博弈<br><strong>俩人轮流取数，一次可以取走1到m个数，假如有m+1个数，则第一个人怎么取第二个人都可以一次取走，</strong><br><strong>第二个人就赢了，现在有x个数，这x个数可能是m+1的倍数，也可能不是，假设不是，那么那么第一个人</strong><br><strong>就可以第一次取s个数，把m+1这个必败状态给对方，假如是，则自己就是必败了</strong><br><code>x=n*(m+1)+s</code></p>
</blockquote>
<h3 id="Brave-game-HDU1846"><a href="#Brave-game-HDU1846" class="headerlink" title="Brave game (HDU1846)"></a>Brave game (HDU1846)</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="type">int</span> mod=a%(b+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(mod&gt;=<span class="number">1</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;first&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;second&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h3 id="Public-Sale-HDU2149"><a href="#Public-Sale-HDU2149" class="headerlink" title="Public Sale (HDU2149)"></a>Public Sale (HDU2149)</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;b&gt;&gt;a)&#123;</span><br><span class="line">        <span class="type">int</span> mod=b%(a+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(a&gt;=b)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=b;i&lt;=a;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i!=a) <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span>(mod&gt;=<span class="number">1</span>) <span class="built_in">cout</span>&lt;&lt;mod&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;none&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<blockquote>
<p>图上巴什博弈问题，终结点为必败点，由终结点去推其他店直到推出起点的属性，最后找规律</p>
<ol>
<li><strong>只能走到必胜点的是必败点</strong></li>
<li><strong>可以走到必败点的是必胜点</strong></li>
</ol>
<p><strong>注意：</strong>这里的必败必胜表示的是从这个点开始走的属性而不是走到这个点的属性</p>
</blockquote>
<h3 id="kiki’s-game-HDU2147"><a href="#kiki’s-game-HDU2147" class="headerlink" title="kiki’s game (HDU2147)"></a>kiki’s game (HDU2147)</h3><p><img src="https://img-blog.csdn.net/20140429205410484?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSUFjY2VwdGVk/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>这道题只要n或者m有一个偶数则起点就是必胜点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> n,m;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m)&#123;</span><br><span class="line">		<span class="keyword">if</span>(n==<span class="number">0</span> &amp;&amp; m==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span>(!(n&amp;<span class="number">1</span>) || !(m&amp;<span class="number">1</span>)) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Wonderful!&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;What a pity!&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="斐波那契博弈"><a href="#斐波那契博弈" class="headerlink" title="斐波那契博弈"></a>斐波那契博弈</h2><p>当n是一个斐波那契数的时候必胜或者必输，所以对于一道题可以从小推个十来个数，看看必胜或者必输的点如果正好符合斐波那契数列则可以尝试用这种方法</p>
<h3 id="取石子游戏-HDU2516"><a href="#取石子游戏-HDU2516" class="headerlink" title="取石子游戏 (HDU2516)"></a>取石子游戏 (HDU2516)</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> fbi[<span class="number">51</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	fbi[<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">	fbi[<span class="number">2</span>]=<span class="number">3</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=<span class="number">44</span>;i++) fbi[i]=fbi[i<span class="number">-1</span>]+fbi[i<span class="number">-2</span>]; <span class="comment">//注意用二分的话必须尺寸必须正好后面不能有0</span></span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123;</span><br><span class="line">		<span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		<span class="type">int</span> x=lower_bound(fbi+<span class="number">1</span>,fbi+<span class="number">1</span>+<span class="number">44</span>,n)-fbi;</span><br><span class="line">		<span class="keyword">if</span>(fbi[x]==n) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Second win&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;First win&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="威佐夫博弈"><a href="#威佐夫博弈" class="headerlink" title="威佐夫博弈"></a>威佐夫博弈</h2><p>这个博弈的证明是非常非常复杂的，而且没啥用，所以只需要记住结论会判断哪一个状态是奇异状态，也就是必败状态就可以了</p>
<p>结论：(判断一个状态是否为奇异状态) </p>
<script type="math/tex; mode=display">
\frac{(\sqrt{5}+1)}{2}*(y-x)=x</script><p>满足上面等式则该状态是奇异状态</p>
<h3 id="取石子游戏"><a href="#取石子游戏" class="headerlink" title="取石子游戏"></a>取石子游戏</h3><p>两堆石子，每次可以从两堆石子取走相等数量的石子，或者从一堆中取走任意数量的石子，谁最后没有石子取谁就输了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">	<span class="type">int</span> x=(b-a)*(<span class="built_in">sqrt</span>(<span class="number">5</span>)+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span>(x==a) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a,b;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b)&#123;</span><br><span class="line">		<span class="keyword">if</span>(a&gt;b) swap(a,b);</span><br><span class="line">		<span class="keyword">if</span>(check(a,b)) <span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Nim游戏"><a href="#Nim游戏" class="headerlink" title="Nim游戏"></a>Nim游戏</h2><h3 id="Being-a-Good-Boy-in-Spring-Festival（HDU1850）"><a href="#Being-a-Good-Boy-in-Spring-Festival（HDU1850）" class="headerlink" title="Being a Good Boy in Spring Festival（HDU1850）"></a>Being a Good Boy in Spring Festival（HDU1850）</h3><p>有n堆扑克牌，每堆扑克牌数量为ai，两个人轮流取，每个人可以取走一堆中任意数量的扑克牌，最后没人有牌取就输了</p>
<p>典型nim游戏，奇异局势为当前剩下的所有扑克牌每一堆的数量的异或等于0，即</p>
<script type="math/tex; mode=display">
a1 \oplus a2 \oplus a3 \oplus a4 ...=0(n>=i>=1)</script><p>计算第一步有多少中方式转化为奇异局势，就是用异或和去和a数组中每一个数一一进行异或，就相当于减去了这个数，然后判断得数是否小于a[i]，当小于a[i]则表示可以把a[i]通过异或转变成为除了这个数以外其他数的异或和，就变成了奇异局势</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> a[<span class="number">1000100</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123;</span><br><span class="line">		<span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		<span class="type">int</span> nim=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">			nim^=a[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(nim==<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="type">int</span> k=nim^a[i];</span><br><span class="line">			<span class="keyword">if</span>(k&lt;a[i]) cnt++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;cnt&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="SG函数"><a href="#SG函数" class="headerlink" title="SG函数"></a>SG函数</h2><p><a href="https://www.cnblogs.com/DWVictor/p/10235851.html"><strong>参考文章</strong></a></p>
<p>所谓SG函数其实本质上就是打表，算出每一个点是否为必败情况</p>
<p> 首先定义mex(minimal excludant)运算，这是施加于一个集合的运算，表示最小的不属于这个集合的非负整数。例如mex{0,1,2,4}=3、mex{2,3,5}=0、mex{}=0。</p>
<p> 对于任意状态 x ， 定义 SG(x) = mex(S),其中 S 是 x 后继状态的SG函数值的集合。如 x 有三个后继状态分别为 SG(a),SG(b),SG(c)，那么SG(x) = mex{SG(a),SG(b),SG(c)}。 这样 集合S 的终态必然是空集，所以SG函数的终态为 SG(x) = 0,当且仅当 x 为必败点P时。</p>
<p><strong>【实例】取石子问题</strong></p>
<p>有1堆n个的石子，每次只能取{ 1, 3, 4 }个石子，先取完石子者胜利，那么各个数的SG值为多少？</p>
<p>SG[0]=0，f[]={1,3,4},</p>
<p>x=1 时，可以取走1 - f{1}个石子，剩余{0}个，所以 SG[1] = mex{ SG[0] }= mex{0} = 1;</p>
<p>x=2 时，可以取走2 - f{1}个石子，剩余{1}个，所以 SG[2] = mex{ SG[1] }= mex{1} = 0;</p>
<p>x=3 时，可以取走3 - f{1,3}个石子，剩余{2,0}个，所以 SG[3] = mex{SG[2],SG[0]} = mex{0,0} =1;</p>
<p>x=4 时，可以取走4-  f{1,3,4}个石子，剩余{3,1,0}个，所以 SG[4] = mex{SG[3],SG[1],SG[0]} = mex{1,1,0} = 2;</p>
<p>x=5 时，可以取走5 - f{1,3,4}个石子，剩余{4,2,1}个，所以SG[5] = mex{SG[4],SG[2],SG[1]} =mex{2,0,1} = 3;</p>
<p>以此类推…..</p>
<p>  x    0 1 2 3 4 5 6 7 8….</p>
<p>SG[x]  0 1 0 1 2 3 2 0 1….</p>
<p>由上述实例我们就可以得到SG函数值求解步骤，那么计算1~n的SG函数值步骤如下：</p>
<p>1、使用 数组f 将 可改变当前状态 的方式记录下来。</p>
<p>2、然后我们使用 另一个数组 将当前状态x 的后继状态标记。</p>
<p>3、最后模拟mex运算，也就是我们在标记值中 搜索 未被标记值 的最小值，将其赋值给SG(x)。</p>
<p>4、我们不断的重复 2 - 3 的步骤，就完成了 计算1~n 的函数值。</p>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//f[N]:可改变当前状态的方式，N为方式的种类，f[N]要在getSG之前先预处理</span></span><br><span class="line"><span class="comment">//SG[]:0~n的SG函数值</span></span><br><span class="line"><span class="comment">//S[]:为x后继状态的集合</span></span><br><span class="line"><span class="type">int</span> f[N],SG[MAXN],S[MAXN];</span><br><span class="line"><span class="type">void</span>  <span class="title function_">getSG</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="built_in">memset</span>(SG,<span class="number">0</span>,<span class="keyword">sizeof</span>(SG));</span><br><span class="line">    <span class="comment">//因为SG[0]始终等于0，所以i从1开始</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="comment">//每一次都要将上一状态 的 后继集合 重置</span></span><br><span class="line">        <span class="built_in">memset</span>(S,<span class="number">0</span>,<span class="keyword">sizeof</span>(S));</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span>; f[j] &lt;= i &amp;&amp; j &lt;= N; j++)</span><br><span class="line">            S[SG[i-f[j]]] = <span class="number">1</span>;  <span class="comment">//将后继状态的SG函数值进行标记</span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>;; j++) <span class="keyword">if</span>(!S[j])&#123;   <span class="comment">//查询当前后继状态SG值中最小的非零值</span></span><br><span class="line">            SG[i] = j;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一道题如果会打SG表这道题就做出来了，<del>但是就是打不出来😭</del>，就算空间不够，不能纯打SG表也可以根据SG表求规律的，给你那么多的数据总不会求不出来巴</p>
<p>再看一道经典例题：<a href="https://vjudge.net/contest/396428#problem/H">Nim or not Nim?</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 1000 + 10</span></span><br><span class="line"><span class="comment">//int sg[MAXN];</span></span><br><span class="line"><span class="comment">//bool vis[MAXN];</span></span><br><span class="line"><span class="comment">//void init(int n)&#123;</span></span><br><span class="line"><span class="comment">//	sg[0]=0;</span></span><br><span class="line"><span class="comment">//	sg[1]=1;</span></span><br><span class="line"><span class="comment">//	for(int i=2;i&lt;=n;i++)&#123;</span></span><br><span class="line"><span class="comment">//		memset(vis,0,sizeof vis);</span></span><br><span class="line"><span class="comment">//		for(int j=1;j&lt;=i;j++)&#123;</span></span><br><span class="line"><span class="comment">//			vis[sg[i-j]]=1;</span></span><br><span class="line"><span class="comment">//			if(j!=i) vis[sg[i-j]^sg[j]]=1;</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"><span class="comment">//		for(int j=0;;j++)&#123;</span></span><br><span class="line"><span class="comment">//			if(!vis[j])&#123;</span></span><br><span class="line"><span class="comment">//				sg[i]=j;</span></span><br><span class="line"><span class="comment">//				break;</span></span><br><span class="line"><span class="comment">//			&#125;</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sg</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x%<span class="number">4</span>==<span class="number">0</span>) <span class="keyword">return</span> x<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(x%<span class="number">4</span>==<span class="number">3</span>) <span class="keyword">return</span> x+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>); <span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>); </span><br><span class="line"><span class="comment">//    init(100);</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">    	<span class="type">int</span> n;</span><br><span class="line">    	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    	<span class="type">int</span> c=<span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="type">int</span> tmp;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;tmp;</span><br><span class="line">			c^=sg(tmp); </span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">if</span>(c==<span class="number">0</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Bob&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Alice&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title>倍增与tarjan求解lca</title>
    <url>/posts/8c7b4dc1.html</url>
    <content><![CDATA[<blockquote>
<p><strong>倍增</strong></p>
<p>以倍增方式向上跳，时间复杂度是O(q*logn)</p>
<p><strong>tarjan</strong></p>
<p>树上算法，实现过程通过dfs+并查集来离线求出lca(最近公共祖先)，时间复杂度O(n+q)，n是结点数，q是查询数</p>
</blockquote>
<h2 id="算法实现过程"><a href="#算法实现过程" class="headerlink" title="算法实现过程"></a>算法实现过程</h2><p><strong>倍增算法流程:</strong></p>
<ol>
<li><p>用一个dfs得出每一个点的父亲节点还有它的深度，用数组保存起来，其中保存父亲的数组用dp[i][j]表示，意义是i节点向上跳2^j^步后到达的节点，父亲节点保存在dp[i][0]中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa,<span class="type">int</span> d)</span>&#123;  <span class="comment">//得到每一个点的深度和父亲节点</span></span><br><span class="line">	dp[u][<span class="number">0</span>]=fa;</span><br><span class="line">	dep[u]=d;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u];~i;i=e[i].next)&#123;</span><br><span class="line">		<span class="type">int</span> v=e[i].to;</span><br><span class="line">		<span class="keyword">if</span>(v!=fa) dfs(v,u,d+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后倍增预处理出每一个节点向上跳2^i^步到的的节点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bz</span><span class="params">()</span>&#123; <span class="comment">//预处理</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">22</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> u=<span class="number">1</span>;u&lt;=n;u++)&#123;</span><br><span class="line">			dp[u][i]=dp[dp[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>求两个点的lca时，先让深度小的跳到两个点深度相同的位置，如果跳后两个点重合则这个位置就是lca，否则两个点一起往上跳，直到lca的儿子节点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(dep[u]&lt;dep[v]) <span class="built_in">swap</span>(u,v);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="built_in">log2</span>(dep[u]-dep[v]);i&gt;=<span class="number">0</span>;i--)&#123;  <span class="comment">//跳到相同深度</span></span><br><span class="line">		<span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;i)&lt;=dep[u]-dep[v]) u=dp[u][i]; <span class="comment">//注意dep[x]-dep[y]时刻在变化，也正是因为这个所以dep[x]一定最后和dep[y]相等</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(u==v) <span class="keyword">return</span> u;  <span class="comment">//节点重合即lca</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="built_in">log2</span>(dep[u]);i&gt;=<span class="number">0</span>;i--)&#123;  <span class="comment">//一起往上跳</span></span><br><span class="line">		<span class="keyword">if</span>(dp[u][i]!=dp[v][i])&#123;  <span class="comment">//保证不会跳过lca，但同样的也不能跳到lca了，回跳到lca的儿子结点</span></span><br><span class="line">			u=dp[u][i];</span><br><span class="line">			v=dp[v][i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[u][<span class="number">0</span>];  <span class="comment">//父亲节点即为lca </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>tarjan算法流程：</strong></p>
<ol>
<li><p>保存用两个图去存树和查询关系图</p>
</li>
<li><p>对这棵树进行dfs搜索，从根开始，搜索到一个点把这个点标记，直到把当前结点的<code>所有子树都被标记并和它们的父亲结点合并</code>后，再查询哪些结点和当前结点有查询关系，对于这些结点如果已经被标记过了，那么这个节点的祖先就是这两个点的最近公共祖先(这里是难点)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">tarjan</span><span class="params">(<span class="type">int</span> u)</span>&#123;</span><br><span class="line">	vis[u]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u];~i;i=e[i].next)&#123;</span><br><span class="line">		<span class="type">int</span> v=e[i].to;</span><br><span class="line">		<span class="keyword">if</span>(vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">		tarjan(v);  <span class="comment">//到这里u结点还没有向上合并</span></span><br><span class="line">		fa[v]=u;  <span class="comment">//合并下一个结点和当前结点</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>当得出两个点的Lca后储存答案到lca数组中，因为查询关系图是无向图，不知道dfs搜索时顺序如何，需要给每一条查询关系图的边编个号，把lca答案储存到偶数或者奇数下标内</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ans=find(v);</span><br><span class="line"><span class="keyword">if</span>(ve[u][i].id%<span class="number">2</span>) lca[ve[u][i].id+<span class="number">1</span>]=ans;</span><br><span class="line"><span class="keyword">else</span> lca[ve[u][i].id]=ans;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>为什么和当前点有查询关系的那个点被标记后那个点的祖先就是最近公共祖先呢？</p>
<p>无非就两种情况，用u表示当前结点，v表示另一个点，因为v被标记过，说明v一定在u之前被访问过，那么v要不就是在u的子树中，这种情况v的祖先就是u，<code>因为u还没有向上合并(u以下的所有子树都已经合并完成了)</code>，要不就是不和u在一个分支里，那么dfs一定是经过u和v的lca结点的，这时两个点的路径连线就是一个角，角的顶点就是lca</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><a href="https://www.luogu.com.cn/problem/P3379">链接</a></p>
<h3 id="tarjan"><a href="#tarjan" class="headerlink" title="tarjan"></a>tarjan</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">500100</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> to,next;</span><br><span class="line">&#125;e[MAXN&lt;&lt;<span class="number">1</span>];  <span class="comment">//无向边记得开两倍空间</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xxx</span>&#123;</span>  <span class="comment">//关系图的编号要储存下来</span></span><br><span class="line">	<span class="type">int</span> to,id;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;xxx&gt; ve[MAXN];  <span class="comment">//存储关系图</span></span><br><span class="line"><span class="type">bool</span> vis[MAXN];</span><br><span class="line"><span class="type">int</span> fa[MAXN],head[MAXN],lca[MAXN*<span class="number">2</span>];  <span class="comment">//两倍查询关系无向图</span></span><br><span class="line"><span class="type">int</span> tot;</span><br><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==fa[x]) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">return</span> fa[x]=find(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span>&#123;</span><br><span class="line">	e[tot].to=v;</span><br><span class="line">	e[tot].next=head[u];</span><br><span class="line">	head[u]=tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">tarjan</span><span class="params">(<span class="type">int</span> u)</span>&#123;</span><br><span class="line">	vis[u]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u];~i;i=e[i].next)&#123;</span><br><span class="line">		<span class="type">int</span> v=e[i].to;</span><br><span class="line">		<span class="keyword">if</span>(vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">		tarjan(v);</span><br><span class="line">		fa[v]=u;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> sz=ve[u].size();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;sz;i++)&#123;</span><br><span class="line">		<span class="type">int</span> v=ve[u][i].to;</span><br><span class="line">		<span class="keyword">if</span>(vis[v])&#123;</span><br><span class="line">			<span class="type">int</span> ans=find(v);</span><br><span class="line">			<span class="keyword">if</span>(ve[u][i].id%<span class="number">2</span>) lca[ve[u][i].id+<span class="number">1</span>]=ans;</span><br><span class="line">			<span class="keyword">else</span> lca[ve[u][i].id]=ans;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">	tot=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		fa[i]=i;</span><br><span class="line">		head[i]=<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n,m,s;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;s;</span><br><span class="line">	init(n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">		<span class="type">int</span> u,v;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">		add(u,v);</span><br><span class="line">		add(v,u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="type">int</span> u,v;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">		ve[u].push_back(&#123;v,i*<span class="number">2</span><span class="number">-1</span>&#125;);  <span class="comment">//注意这里放进去这条边的编号</span></span><br><span class="line">		ve[v].push_back(&#123;u,i*<span class="number">2</span>&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	tarjan(s);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;  <span class="comment">//输出偶数下标的lca数组</span></span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;lca[i*<span class="number">2</span>]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>
<h3 id="倍增"><a href="#倍增" class="headerlink" title="倍增"></a>倍增</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">500500</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> to,next;</span><br><span class="line">&#125;e[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> head[MAXN],dep[MAXN],dp[MAXN][<span class="number">25</span>];</span><br><span class="line"><span class="type">int</span> tot,n,m,s;</span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span>&#123;</span><br><span class="line">	e[tot].to=v;</span><br><span class="line">	e[tot].next=head[u];</span><br><span class="line">	head[u]=tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa,<span class="type">int</span> d)</span>&#123;  <span class="comment">//得到每一个点的深度和父亲节点</span></span><br><span class="line">	dp[u][<span class="number">0</span>]=fa;</span><br><span class="line">	dep[u]=d;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u];~i;i=e[i].next)&#123;</span><br><span class="line">		<span class="type">int</span> v=e[i].to;</span><br><span class="line">		<span class="keyword">if</span>(v!=fa) dfs(v,u,d+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">bz</span><span class="params">()</span>&#123; <span class="comment">//预处理</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">22</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> u=<span class="number">1</span>;u&lt;=n;u++)&#123;</span><br><span class="line">			dp[u][i]=dp[dp[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">lca</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(dep[u]&lt;dep[v]) swap(u,v);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=log2(dep[u]-dep[v]);i&gt;=<span class="number">0</span>;i--)&#123;  <span class="comment">//跳到相同深度</span></span><br><span class="line">		<span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;i)&lt;=dep[u]-dep[v]) u=dp[u][i]; <span class="comment">//注意dep[x]-dep[y]时刻在变化，也正是因为这个所以dep[x]一定最后和dep[y]相等</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(u==v) <span class="keyword">return</span> u;  <span class="comment">//节点重合即lca</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=log2(dep[u]);i&gt;=<span class="number">0</span>;i--)&#123;  <span class="comment">//一起往上跳</span></span><br><span class="line">		<span class="keyword">if</span>(dp[u][i]!=dp[v][i])&#123;  <span class="comment">//保证不会跳过lca，但同样的也不能跳到lca了，回跳到lca的儿子结点</span></span><br><span class="line">			u=dp[u][i];</span><br><span class="line">			v=dp[v][i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[u][<span class="number">0</span>];  <span class="comment">//父亲节点即为lca </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;s;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++) head[i]=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">		<span class="type">int</span> u,v;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">		add(u,v);</span><br><span class="line">		add(v,u);</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(s,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">	bz();</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="type">int</span> u,v;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;lca(u,v)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title>查并集</title>
    <url>/posts/1f0cd9a2.html</url>
    <content><![CDATA[<p>查并集也是一种比较常用的算法，有必要掌握<br>下面文章转载于CSDN上的一篇博客，我觉得写的很详细，就把它贴出来吧<br>地址：<a href="https://blog.csdn.net/Hacker_ZhiDian/article/details/60965556">https://blog.csdn.net/Hacker_ZhiDian/article/details/60965556</a></p>
<p>基础</p>
<p>对于今天要总结的算法，我想先通过一道题目来看一下：</p>
<p>假设现在我有一个任务交给你：要求你查看 id 为 x 和 id 为 y 的两个人是不是朋友，<br>在一开始我会在第一行中输入 3 个数字 n、m 、k。<br>n 是代表总人数。<br>接下来 m 行，每一行我会输入两个数字： Xi 、 Yi， 代表 id 为 Xi 和 id 为 Yi 的两个人是朋友（注意：朋友的朋友也是朋友），<br> 接下来 k 行，每一行我也会输入两个数字： a 和 b ，代表我要你查询 id 为 a 和 id 为 b 的两个人是不是朋友，<br> 如果这两个人是朋友，那么在一行中输出“yes”否则在一行中输出“no”。<br> 数据约束：0 &lt; n, m, k &lt; 10000， 所有人的 id 都是正整数，并且 id 不会超过 n </p>
<p>样例输入：</p>
<pre><code>7 5 4
1 3 
2 4
3 4
1 4
5 6
1 4
2 3
2 5
6 7
</code></pre><p>样例输出：</p>
<pre><code>yes
yes
no
no
</code></pre><p>在上面的题目中，如果没有说“朋友的朋友也是朋友”这句话，那么就好办了，我们直接用一个二维数组来记录每一组朋友的信息，然后进行筛选就行了。但是有了这句话，我们就不能简单的用二维数组来解决了。那么怎么解决呢？</p>
<p>首先，我们可以这样想，我们先把所有的人看成独立的群体，也就是说每个人的朋友只有他自己，那么这样的话一开始就有 n 个朋友圈，之后当题目数据输入的时候我们将输入的 id 所代表的的两个人所在的两个朋友圈合并成一个大的朋友圈，那么在这个合并之后的朋友圈中，所有的人两两都是朋友（朋友的朋友也是朋友），不断重复上面的合并过程，直到题目中给的 m 行的朋友对数据全部都合并完成。之后要判断两个人是不是朋友只需要判断他们是不是在同一个朋友圈里面就可以了。</p>
<p>我们用题目中给出的数据来模拟这个过程，先看代码：</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;
const int N = 10010;

int f[N];

/*
* 将表示朋友圈的数组初始化，即将所有人的“朋友祖先”都设置为自己的 id ，
* 于是就有了 n 个不同的朋友圈 
*/
void init(int n) &#123;
    for(int i = 1; i &lt;= n; i++) &#123;
        f[i] = i;
    &#125;
&#125;

// 得到 id 为 v 的人的“朋友祖先”的 id 
int getFriend(int v) &#123;  
    if(f[v] == v) &#123;
        return v;
    &#125;
    /*
    * 如果发现“朋友祖先”不是自己，那么他肯定被合并到别的朋友圈里面去了，
    * 那么继续调用这个函数来找这个朋友圈里面的“朋友祖先”，
    * 并且在这个过程中将找到的人都设置为同一个“朋友祖先”（因为都在同一个朋友圈里面） 
    */
    return f[v] = getFriend(f[v]);
&#125;

// 将两个人所在的两个朋友圈合并为一个朋友圈 
void merge(int a, int b) &#123;
    int t1 = getFriend(a); // 得到左边的人的“朋友祖先” 
    int t2 = getFriend(b); // 得到右边的人的“朋友祖先” 
    /* 这里我们制定一个“靠左原则”：一旦发现两个人的“朋友祖先”不一样，
    * 那么右边那个人的“朋友祖先”的“朋友祖先”设置为左边的人的“朋友祖先”，
    * 当然，也可以制定“靠右原则” 
    */ 
    if(t1 != t2) &#123;  
        f[t2] = t1;
    &#125;
&#125;

int main() &#123;
    int n, m, k;
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;
    int x, y;
    init(n);

    for(int i = 0; i &lt; m; i++) &#123;
        cin &gt;&gt; x &gt;&gt; y;
        merge(x, y);
    &#125; 
    for(int i = 0; i &lt; k; i++) &#123;
        cin &gt;&gt; x &gt;&gt; y;
        // 如果两个人的“朋友祖先”不相同，证明他们不在同一个朋友圈内，也就不是朋友
        if(getFriend(x) != getFriend(y)) &#123;
            cout &lt;&lt; &quot;no&quot; &lt;&lt; endl; 
        &#125; else &#123;
            cout &lt;&lt; &quot;yes&quot; &lt;&lt; endl;
        &#125;
    &#125;

    return 0;
&#125; 
</code></pre><p>用图来模拟这一过程：</p>
<p><img src="https://img-blog.csdn.net/20170309180913015?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSGFja2VyX1poaURpYW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>如果不能理解可以把例题数据带进去代码中自己模拟一遍就知道了，最后我们来看一下运行结果：<br><img src="https://img-blog.csdn.net/20170309184447706?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSGFja2VyX1poaURpYW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>我们可以加一段代码来输出合并之后的数组情况：</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;
const int N = 10010;

int f[N];

/*
* 将表示朋友圈的数组初始化，即将所有人的“朋友祖先”都设置为自己的 id ，
* 于是就有了 n 个不同的朋友圈 
*/
void init(int n) &#123;
    for(int i = 1; i &lt;= n; i++) &#123;
        f[i] = i;
    &#125;
&#125;

// 得到 id 为 v 的人的“朋友祖先”的 id 
int getFriend(int v) &#123;  
    if(f[v] == v) &#123;
        return v;
    &#125;
    /*
    * 如果发现“朋友祖先”不是自己，那么他肯定被合并到别的朋友圈里面去了，
    * 那么继续调用这个函数来找这个朋友圈里面的“朋友祖先”，
    * 并且在这个过程中将找到的人都设置为同一个“朋友祖先”（因为都在同一个朋友圈里面） 
    */
    return f[v] = getFriend(f[v]);
&#125;

// 将两个人所在的两个朋友圈合并为一个朋友圈 
void merge(int a, int b) &#123;
    int t1 = getFriend(a); // 得到左边的人的“朋友祖先” 
    int t2 = getFriend(b); // 得到右边的人的“朋友祖先” 
    /* 这里我们制定一个“靠左原则”：一旦发现两个人的“朋友祖先”不一样，
    * 那么右边那个人的“朋友祖先”的“朋友祖先”设置为左边的人的“朋友祖先”，
    * 当然，也可以制定“靠右原则” 
    */ 
    if(t1 != t2) &#123;  
        f[t2] = t1;
    &#125;
&#125;

int main() &#123;
    int n, m, k;
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;
    int x, y;
    init(n);

    for(int i = 0; i &lt; m; i++) &#123;
        cin &gt;&gt; x &gt;&gt; y;
        merge(x, y);
    &#125;

    /*
    * 输出合并之后的数组情况
    */
    for(int i = 1; i &lt;= n; i++) &#123;
        if(i != 1) &#123;
            cout &lt;&lt; &quot; &quot;;
        &#125;
        cout &lt;&lt; f[i];
    &#125;
    cout &lt;&lt; endl;

    for(int i = 0; i &lt; k; i++) &#123;
        cin &gt;&gt; x &gt;&gt; y;
        // 如果两个人的“朋友祖先”不相同，证明他们不在同一个朋友圈内，也就不是朋友
        if(getFriend(x) != getFriend(y)) &#123;
            cout &lt;&lt; &quot;no&quot; &lt;&lt; endl; 
        &#125; else &#123;
            cout &lt;&lt; &quot;yes&quot; &lt;&lt; endl;
        &#125;
    &#125;

    return 0;

&#125; 
</code></pre><p>结果：</p>
<p><img src="https://img-blog.csdn.net/20170309185244123?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSGFja2VyX1poaURpYW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>和我们在纸上模拟的结果一样，一共有三个朋友圈。<br>这个时候当数组某个位置的值等于其所在下标的时候，id 等于这个值的人就是这个朋友圈的“朋友祖先”， 有多少个“朋友祖先”就有多少个朋友圈。</p>
<p>Ok，其实上面说的这种算法思想就是查并集，其标准的描述也是通过树和森林来定义的：在一个森林中有很多棵不同的树，我们通过一些信息来将一些不同的分开的树合并成一棵大的树。在这道题目中，一开始森林中有 7 棵不同根节点的树，树的根节点在这道题目中就相当于“朋友祖先”（7 个朋友圈，每个朋友圈中只有一个人，即为他自己，也是每个朋友圈的“朋友祖先”），通过题中所给的信息不断合并朋友圈（合并森林中不同的树），合并结束之后森林中树的棵树或者不同的树的根节点的个数（“朋友祖先”的个数）就是朋友圈的个数。</p>
<p>好了，查并集的基本思想就总结到这里了，如果你想更深入的了解其优化，那么请往下看：<br>优化</p>
<p>我们在刚刚合并两个不同的朋友圈为一个大朋友圈的时候，我们制定了一个“靠左原则”，即为将右边的朋友圈作为子圈合并到左边那个朋友圈中，那么现在假设我们有这么两个朋友圈：</p>
<p><img src="https://img-blog.csdn.net/20180305120413608?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSGFja2VyX1poaURpYW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>
<p>如果说现在我们要 合并下标为 1 的人所在的朋友圈 和 下标为 2 的人所在的朋友圈，按照我们刚刚定制的 “靠左原则”，此时我们应该把 朋友圈2 作为朋友圈1 的子圈并且合并到 朋友圈1 中。也就是执行一次我们上面代码中的 merge(1, 2) ，对那么合并之后的朋友圈就是：</p>
<p><img src="https://img-blog.csdn.net/20180305122202998?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSGFja2VyX1poaURpYW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>
<p>祖先坐标改变的部分我用红字表出来了。那么接下来，如果此时我要找出下标为 4 的人所在的朋友圈的祖先，因为此时两个朋友圈已经合并成一个了， 我们调用 getFriend(1) ，首先会查找到 3 ，然后是 2 ，然后是 1。也就是说此时我们要向上递归查找 3 次才能找到。这个效率相对来说不算高。那么问题在哪呢？其实是在我们合并两个朋友圈的时候定制的“靠左原则”。对于上面那种情况，我们明明应该将左边的朋友圈合并到右边的朋友圈效率才更高，此时合并的结果应该是：</p>
<p><img src="https://img-blog.csdn.net/20180305122440975?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSGFja2VyX1poaURpYW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>
<p>此时再查找下标为 4 的人所在的朋友圈就只需要向上递归 2 次就可以了。那么我们应该如何确定合并朋友圈的方式呢？可能到这里你已经想到了：将高度较小的那一个朋友圈作为子圈合并到高度较大的朋友圈。那么我们怎么获取每个朋友圈的高度呢？我们可以用一个数组来保存每个朋友圈的高度，在合并的时候比较两个朋友圈的高度来确定合并方式，合并完成之后调整一下合并后的朋友圈高度。 在上面代码的基础上，我们给出实现代码：</p>
<pre><code>int high[N]; // 一个全局数组。保存每个朋友圈的高度，初始时都是 0 

// 省略其他代码......

/**
* 将两个人所在的两个朋友圈合并为一个朋友圈 
* 这里通过两个朋友圈的高度来决定合并方式 
*/
void merge(int a, int b) &#123;
    int t1 = getFriend(a); // 得到左边的人的“朋友祖先” 
    int t2 = getFriend(b); // 得到右边的人的“朋友祖先” 
    // 两个人的“朋友祖先”不一样，合并两个朋友圈 
    if(t1 != t2) &#123;  
        // 如果左边的朋友圈的高度大于右边的朋友圈的高度，
        // 那么将右边的朋友圈合并到左边的朋友圈中 
        if (high[t1] &gt; high[t2]) &#123;
            f[t2] = t1;
        // 否则就把左边的朋友圈合并到右边的朋友圈中 
        &#125; else &#123;
            f[t1] = t2;
            // 如果当前两个朋友圈的高度相等，那么合并之后的朋友圈高度要加一
            if (high[t1] == high[t2]) &#123;
                high[t2]++;
            &#125;
        &#125;
    &#125;
&#125;

// 省略其他代码......
</code></pre><p>为了方便，我就只给出 merge 函数，因为只有 merge 函数改变了，其它函数都没变。<br>merge 函数里面有一句注释：// 如果当前两个朋友圈的高度相等，那么合并之后的朋友圈高度要加一 。这句话可能会有点难理解，看一幅图就知道了：</p>
<p><img src="https://img-blog.csdn.net/20180305125346468?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSGFja2VyX1poaURpYW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>
<p>因为代码中设定的每个朋友圈初始高度为 0，,所以为了统一，图中也设置只有一个人的朋友圈高度为 0，这里注意一下。经过这样优化之后，我们的查并集的效率就很高了。</p>
<p>最后，我们来看一下程序的运行结果：</p>
<p><img src="https://img-blog.csdn.net/20180305125905988?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSGFja2VyX1poaURpYW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>
<p>结果依然是 3 个朋友圈，并且之后判断两个人是否是同一个朋友圈的结果也是对的，但是每个朋友圈祖先的编号却和原来不一样，这其实是因为我们修改了合并两个朋友圈的方式，即从原来的“靠左原则”变成了“比较朋友圈高度原则”。</p>
<p>最后还是贴一下优化之后的完整代码：</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;
const int N = 10010;

int f[N];
int high[N]; // 保存每个朋友圈的高度，初始时都是 0 

/*
* 将表示朋友圈的数组初始化，即将所有人的“朋友祖先”都设置为自己的 id ，
* 于是就有了 n 个不同的朋友圈 
*/
void init(int n) &#123;
    for(int i = 1; i &lt;= n; i++) &#123;
        f[i] = i;
    &#125;
&#125;

// 得到 id 为 v 的人的“朋友祖先”的 id 
int getFriend(int v) &#123;  
    if(f[v] == v) &#123;
        return v;
    &#125;
    /*
    * 如果发现“朋友祖先”不是自己，那么他肯定被合并到别的朋友圈里面去了，
    * 那么继续调用这个函数来找这个朋友圈里面的“朋友祖先”，
    * 并且在这个过程中将找到的人都设置为同一个“朋友祖先”（因为都在同一个朋友圈里面） 
    */
    return f[v] = getFriend(f[v]);
&#125;

/**
* 将两个人所在的两个朋友圈合并为一个朋友圈 
* 这里通过两个朋友圈的高度来决定合并方式 
*/
void merge(int a, int b) &#123;
    int t1 = getFriend(a); // 得到左边的人的“朋友祖先” 
    int t2 = getFriend(b); // 得到右边的人的“朋友祖先” 
    // 两个人的“朋友祖先”不一样，合并两个朋友圈 
    if(t1 != t2) &#123;  
        // 如果左边的朋友圈的高度大于右边的朋友圈的高度，
        // 那么将右边的朋友圈合并到左边的朋友圈中 
        if (high[t1] &gt; high[t2]) &#123;
            f[t2] = t1;
        // 否则就把左边的朋友圈合并到右边的朋友圈中 
        &#125; else &#123;
            f[t1] = t2;
            // 如果当前两个朋友圈的高度相等，那么合并之后的朋友圈高度要加一， 
            if (high[t1] == high[t2]) &#123;
                high[t2]++;
            &#125;
        &#125;
    &#125;
&#125;

int main() &#123;
    int n, m, k;
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;
    int x, y;
    init(n);

    for(int i = 0; i &lt; m; i++) &#123;
        cin &gt;&gt; x &gt;&gt; y;
        merge(x, y);
    &#125;

    /*
    * 输出合并之后的数组情况
    */
    for(int i = 1; i &lt;= n; i++) &#123;
        if(i != 1) &#123;
            cout &lt;&lt; &quot; &quot;;
        &#125;
        cout &lt;&lt; f[i];
    &#125;
    cout &lt;&lt; endl;

    for(int i = 0; i &lt; k; i++) &#123;
        cin &gt;&gt; x &gt;&gt; y;
        // 如果两个人的“朋友祖先”不相同，证明他们不在同一个朋友圈内，也就不是朋友
        if(getFriend(x) != getFriend(y)) &#123;
            cout &lt;&lt; &quot;no&quot; &lt;&lt; endl; 
        &#125; else &#123;
            cout &lt;&lt; &quot;yes&quot; &lt;&lt; endl;
        &#125;
    &#125;

    return 0;

&#125; 
</code></pre><h2 id="模板题"><a href="#模板题" class="headerlink" title="模板题"></a>模板题</h2><p>地址：<a href="https://nanti.jisuanke.com/t/T1260">https://nanti.jisuanke.com/t/T1260</a></p>
<p>宗教信仰</p>
<p>世界上有许多宗教，你感兴趣的是你学校里的同学信仰多少种宗教。你的学校有 nnn 名学生（0&lt;n≤500000 &lt; n \le 500000&lt;n≤50000），你不太可能询问每个人的宗教信仰，因为他们不太愿意透露。但是当你同时找到 222 名学生，他们却愿意告诉你他们是否信仰同一宗教，你可以通过很多这样的询问估算学校里的宗教数目的上限。你可以认为每名学生只会信仰最多一种宗教。<br>输入格式</p>
<p>输入包括多组数据。每组数据的第一行包括 nnn 和 mmm，0≤m≤n(n−1)/20 \le m \le n(n-1)/20≤m≤n(n−1)/2，其后 mmm 行每行包括两个数字 iii 和 jjj，表示学生 iii 和学生 jjj 信仰同一宗教，学生被标号为 111 至 nnn。</p>
<p>输入以一行 n=m=0n = m = 0n=m=0 作为结束。<br>输出格式</p>
<p>对于每组数据，先输出它的编号（从 111 开始），接着输出学生信仰的不同宗教的数目上限。</p>
<p>输出时每行末尾的多余空格，不影响答案正确性<br>样例输入</p>
<pre><code>10 9
1 2
1 3
1 4
1 5
1 6
1 7
1 8
1 9
1 10
10 4
2 3
4 5
4 8
5 8
0 0
</code></pre><p>样例输出</p>
<pre><code>Case 1: 1
Case 2: 7
</code></pre><p>AC代码：</p>
<pre><code>#include&lt;iostream&gt;
using namespace std;
const int N=50010;
int f[N];
int res=0;
void init(int n)&#123;
    for(int i=1;i&lt;=n;i++)&#123;
        f[i]=i;
    &#125;
&#125;
int getfriend(int v)&#123;
    if(f[v]==v) return v;
    else return f[v]=getfriend(f[v]);
&#125;
void merge(int a,int b)&#123;

    int x=getfriend(a);
    int y=getfriend(b);
    if(x!=y)&#123;
        f[y]=x;
        res++;
    &#125;
&#125;
int main()
&#123;
    int n,m,k=0,x,y;
    while(1)&#123;
        res=0;
        k++;
        cin&gt;&gt;n&gt;&gt;m;
        if(n==0&amp;&amp;m==0) break;
        init(n);
        for(int i=1;i&lt;=m;i++)&#123;
            cin&gt;&gt;x&gt;&gt;y;
            merge(x,y);
        &#125;
        cout&lt;&lt;&quot;Case &quot;&lt;&lt;k&lt;&lt;&quot;: &quot;;
        cout&lt;&lt;n-res&lt;&lt;endl;        
    &#125;

    return 0;
&#125;
</code></pre><blockquote>
<p>制作不易，您的赞助是我最大的动力，谢谢观看（owo）</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>差分</title>
    <url>/posts/a0b0b7bd.html</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>题目：</p>
<p>输入一个长度为n的整数序列。<br>接下来输入m个操作，每个操作包含三个整数l, r, c，表示将序列中[l, r]之间的每个数加上c。<br>请你输出进行完所有操作后的序列。</p>
<p>输入格式</p>
<p>第一行包含两个整数n和m。<br>第二行包含n个整数，表示整数序列。<br>接下来m行，每行包含三个整数l，r，c，表示一个操作。</p>
<p>输出格式</p>
<p>共一行，包含n个整数，表示最终序列。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>对一个区间内的数加C，如果暴力加，会浪费很多时间，我们可以开一个新数组用于差分操作，数组下标就代表数轴上的每一个数，每次给定一个区间，把以区间左端点未下标的数组值加上C，而以（区间右端点+1）为下标的数组值减去C，进行m次操作后，再求一次前缀和并加上原来数组的值就是进行区间操作后的数组，参考下图：<br><img src="差分/0.jpg" alt=""></p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int a[100],b[100];  //例题，开的很小，你可以开大</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">//	freopen(&quot;test.txt&quot;,&quot;r&quot;,stdin); </span><br><span class="line">	int n,m;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line">//		b[i]+=a[i];</span><br><span class="line">//		b[i+1]-=a[i];  //也可以初始化b数组就加上a数组的值，如果这样做了，下面就不能加a数组的值了</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">		int l,r,c;</span><br><span class="line">		cin&gt;&gt;l&gt;&gt;r&gt;&gt;c;</span><br><span class="line">		b[l]+=c;</span><br><span class="line">		b[r+1]-=c;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=1;i&lt;=n;i++) b[i]+=b[i-1]; //前缀和</span><br><span class="line">	for(int i=1;i&lt;=n;i++) cout&lt;&lt;b[i]+a[i]&lt;&lt;&quot; &quot;;  //一定要记得加上原数组的值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>复杂度： O(N)，小于1e8的数据量都可以过</p>
</blockquote>
<p>很简单的算法吧（owo）</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces div4</title>
    <url>/posts/6b47ae8.html</url>
    <content><![CDATA[<p><blockquote>
唯一一场每道题都有思路的比赛，感觉还行，虽然有思路不代表能AC，不过还是很开心的，因为除了E题的桶没想到外其他都是自力更生做出来的😊   
</blockquote><br><img src="https://cdn.jsdelivr.net/gh/uncleacc/Sucai/8~1.webp" alt=""></p>
<h2 id="A-Sum-of-Round-Numbers"><a href="#A-Sum-of-Round-Numbers" class="headerlink" title="A Sum of Round Numbers"></a>A Sum of Round Numbers</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>签到题，就是遍历数的每一位，求出非0的位数有几位，然后int一个v=1，之后没走一个数v*=10，然后当一位数不等于0时就乘上v就行了，这道题用字符串应该更简单，但是我想试试用while，练练手</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#define ios ios::sync_with_stdio(0)</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN=1e4+100;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	int t,k;</span><br><span class="line">	cin&gt;&gt;t;</span><br><span class="line">	while(t--)&#123;</span><br><span class="line">		cin&gt;&gt;k;</span><br><span class="line">		int cnt=0,x=k,v=1;</span><br><span class="line">		while(k/10)&#123;</span><br><span class="line">			int tt=k%10;</span><br><span class="line">			if(tt!=0) cnt++;</span><br><span class="line">			k/=10;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;cnt+1&lt;&lt;endl;</span><br><span class="line">		while(x/10)&#123;</span><br><span class="line">			int tt=x%10;</span><br><span class="line">			if(x/10&amp;&amp;tt!=0) cout&lt;&lt;tt*v&lt;&lt;&quot; &quot;;</span><br><span class="line">			x/=10; v*=10;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;(x%10)*v&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="B-Same-Parity-Summands"><a href="#B-Same-Parity-Summands" class="headerlink" title="B - Same Parity Summands"></a>B - Same Parity Summands</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>这道题是给你一个a和b，让你用b个同为偶数或者奇数的数加起来等于a，输出这些数，刚开始我一直在找规律，感觉很麻烦，找了半小时也没涵盖所有情况，后来发现直接暴力枚举就行了，我们可以考虑极端，当都为奇数时，让除了最后一个数以外的数都是1，然后最后一个数=a-(b-1)，加起来正好等于a，同理都为偶数时，让除了最后一个数以外的数全部变成2，最后一个数为n-2*(k-1)，条件都不符合输出NO<del>想通这个就AC了</del></p>
<h3 id="CODE-1"><a href="#CODE-1" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#define ios ios::sync_with_stdio(0)</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN=1e4+100;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	int t,k,n;</span><br><span class="line">	cin&gt;&gt;t;</span><br><span class="line">	while(t--)&#123;</span><br><span class="line">		cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">		int m=n-(k-1);</span><br><span class="line">		if(m&gt;0&amp;&amp;m%2)&#123;</span><br><span class="line">			cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;</span><br><span class="line">			for(int i=0;i&lt;k-1;i++)&#123;</span><br><span class="line">				cout&lt;&lt;1&lt;&lt;&quot; &quot;;</span><br><span class="line">			&#125;</span><br><span class="line">			cout&lt;&lt;m&lt;&lt;endl;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		m=n-2*(k-1);</span><br><span class="line">		if(m&gt;0&amp;&amp;m%2==0)&#123;</span><br><span class="line">			cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;</span><br><span class="line">			for(int i=0;i&lt;k-1;i++)&#123;</span><br><span class="line">				cout&lt;&lt;2&lt;&lt;&quot; &quot;;</span><br><span class="line">			&#125;</span><br><span class="line">			cout&lt;&lt;m&lt;&lt;endl;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="C-K-th-Not-Divisible-by-n"><a href="#C-K-th-Not-Divisible-by-n" class="headerlink" title="C - K-th Not Divisible by n"></a>C - K-th Not Divisible by n</h2><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>看题目就知道大意，不被n整除的第K个数，首先我们清楚被N整除的数之间的数数量一定是相同的，比如能整除8的：8 16 24…数之间都相差8，那这就是一个找规律嘛，用“%”找到该数在一段区间的那个位置，然后用“/”找到在第几个区间就行了</p>
<h3 id="CODE-2"><a href="#CODE-2" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#define ios ios::sync_with_stdio(0)</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN=1e4+100;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	int t,k,n;</span><br><span class="line">	cin&gt;&gt;t;</span><br><span class="line">	while(t--)&#123;</span><br><span class="line">		int a,b;</span><br><span class="line">		cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">		int k=b%(a-1);</span><br><span class="line">		if(k==0)&#123;</span><br><span class="line">			cout&lt;&lt;(b/(a-1)*a)-1&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">		else cout&lt;&lt;(b/(a-1)*a)+k&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="D-Alice-Bob-and-Candies"><a href="#D-Alice-Bob-and-Candies" class="headerlink" title="D. Alice, Bob and Candies"></a>D. Alice, Bob and Candies</h2><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>这道题好长啊，我第一眼就被吓住了，<del>不战而屈人之兵，不过狠下心来读一读，发现就是一个双向指针往中间合拢，</del>好像这叫双向队列~~，再多定义几个变量记录每次每个人吃多少，每个人上次吃了多少，就是一个模拟，只要能写对条件，就能AC了</p>
<h3 id="CODE-3"><a href="#CODE-3" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#define ios ios::sync_with_stdio(0)</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN=1e4;</span><br><span class="line">int val[MAXN];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	int t; cin&gt;&gt;t;</span><br><span class="line">	while(t--)&#123;</span><br><span class="line">		int n,pa=0,pb=0,flg=0;; cin&gt;&gt;n;</span><br><span class="line">		int sum=0;</span><br><span class="line">		for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">			cin&gt;&gt;val[i];</span><br><span class="line">			sum+=val[i];</span><br><span class="line">		&#125;</span><br><span class="line">		int ea=0,eb=0,cnt=1,sa,sb,head=1,tail=n;</span><br><span class="line">		while(tail-head&gt;=0)&#123;</span><br><span class="line">			sa=0; sb=0;</span><br><span class="line">			if(flg==0&amp;&amp;sum-ea-eb&gt;pb)&#123;</span><br><span class="line">				while(sa&lt;=pb)&#123;</span><br><span class="line">					sa+=val[head];</span><br><span class="line">					ea+=val[head];</span><br><span class="line">					head++; </span><br><span class="line">				&#125;</span><br><span class="line">				pa=sa; flg=1; cnt++;</span><br><span class="line">				continue;</span><br><span class="line">			&#125;</span><br><span class="line">			if(flg==1&amp;&amp;sum-ea-eb&gt;pa)&#123;</span><br><span class="line">				while(sb&lt;=pa)&#123;</span><br><span class="line">					sb+=val[tail];</span><br><span class="line">					eb+=val[tail];</span><br><span class="line">					tail--;</span><br><span class="line">				&#125;</span><br><span class="line">				pb=sb; flg=0; cnt++;</span><br><span class="line">				continue;</span><br><span class="line">			&#125;</span><br><span class="line">			cnt++;</span><br><span class="line">			if(flg==0)&#123;</span><br><span class="line">				ea+=sum-ea-eb;</span><br><span class="line">				break;</span><br><span class="line">			&#125;else&#123;</span><br><span class="line">				eb+=sum-ea-eb;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;cnt-1&lt;&lt;&quot; &quot;&lt;&lt;ea&lt;&lt;&quot; &quot;&lt;&lt;eb&lt;&lt;&quot; &quot;&lt;&lt;endl;</span><br><span class="line">	&#125; </span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">双向队列超级简单，水题</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">deque&lt;int&gt; dq;</span><br><span class="line">int main()</span><br><span class="line">&#123;	</span><br><span class="line">	int t;</span><br><span class="line">	cin&gt;&gt;t;</span><br><span class="line">	while(t--)&#123;</span><br><span class="line">		dq.clear();</span><br><span class="line">		int n; cin&gt;&gt;n;</span><br><span class="line">		for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">			int temp; cin&gt;&gt;temp;</span><br><span class="line">			dq.push_back(temp);</span><br><span class="line">		&#125;</span><br><span class="line">		ll pa=0,pb=0,suma=0,sumb=0,res=1,ansa=0,ansb=0,cnt=0;</span><br><span class="line">		while(!dq.empty())&#123;</span><br><span class="line">			cnt++;</span><br><span class="line">			suma=sumb=0;</span><br><span class="line">			if(res&amp;1)&#123;</span><br><span class="line">				while(suma&lt;=pb&amp;&amp;!dq.empty())&#123;</span><br><span class="line">					suma+=dq.front();</span><br><span class="line">					dq.pop_front();</span><br><span class="line">				&#125;</span><br><span class="line">				ansa+=suma; </span><br><span class="line">				pa=suma;</span><br><span class="line">			&#125;else&#123;</span><br><span class="line">				while(sumb&lt;=pa&amp;&amp;!dq.empty())&#123;</span><br><span class="line">					sumb+=dq.back();</span><br><span class="line">					dq.pop_back();</span><br><span class="line">				&#125;</span><br><span class="line">				ansb+=sumb;</span><br><span class="line">				pb=sumb;</span><br><span class="line">			&#125;</span><br><span class="line">			res++;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;cnt&lt;&lt;&quot; &quot;&lt;&lt;ansa&lt;&lt;&quot; &quot;&lt;&lt;ansb&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="E-Special-Elements"><a href="#E-Special-Elements" class="headerlink" title="E. Special Elements"></a>E. Special Elements</h2><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>最好理解的一道题目🌝也是我唯一一道看了题解的题目😂一个前缀和，这道题数据量很小，只有8000，直接装进桶里就行了，而我就是没想到，一直在纠结怎么降低复杂度（好菜啊）求出每一个区间的和看看这个和对应的桶编号里面装没装数，<del>其实是道水题</del></p>
<h3 id="CODE-4"><a href="#CODE-4" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#define ios ios::sync_with_stdio(0)</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN=1e4;</span><br><span class="line">int val[MAXN],book[MAXN];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	int t; cin&gt;&gt;t;</span><br><span class="line">	while(t--)&#123;</span><br><span class="line">		memset(book,0,sizeof book);</span><br><span class="line">		memset(val,0,sizeof val);</span><br><span class="line">		int n; cin&gt;&gt;n;</span><br><span class="line">		for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">			cin&gt;&gt;val[i];</span><br><span class="line">			book[val[i]]++;</span><br><span class="line">			val[i]+=val[i-1];</span><br><span class="line">		&#125;</span><br><span class="line">		int cnt=0;</span><br><span class="line">		for(int i=0;i&lt;n-1;i++)&#123;</span><br><span class="line">			for(int j=i+2;j&lt;=n;j++)&#123;</span><br><span class="line">				int sum=val[j]-val[i];</span><br><span class="line">//				cout&lt;&lt;sum&lt;&lt;&#x27; &#x27;&lt;&lt;book[sum]&lt;&lt;endl;</span><br><span class="line">				if(sum&lt;=n&amp;&amp;book[sum])&#123;</span><br><span class="line">					cnt+=book[sum]; 					</span><br><span class="line">					book[sum]=0;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">	&#125; </span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="F-Binary-String-Reconstruction"><a href="#F-Binary-String-Reconstruction" class="headerlink" title="F - Binary String Reconstruction"></a>F - Binary String Reconstruction</h2><h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><p>又是思维题，给你一个n0,n1,n2让你构造一个二进制序列，这个序列子序列中00的个数为n0，01或10的个数为n1，11的个数为n2，首先n0和n2的序列容易构造，因为只包含一个数字，n1我们可以定义顺序为1010…n1=1:10 n1=2:101 n1=3:1010，每次增加一个数，单独构造容易，合起来难，三个序列合起来中间肯定会多出一些，所以只要在本上演算一下，再把多出的那一部分去掉就行了，然后我构造的序列顺序是n0n2n1，感觉这样构造简单🐶说实话我交代码时都没敢想能AC，因为感觉没考虑全，但是测试几组数据发现能过就抱着试一试的态度交上去了，结果A了:smile:</p>
<h3 id="CODE-5"><a href="#CODE-5" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#define ios ios::sync_with_stdio(0)</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN=1e4;</span><br><span class="line">int val[MAXN],book[MAXN];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	int t; cin&gt;&gt;t;</span><br><span class="line">	while(t--)&#123;</span><br><span class="line">		int n0,n1,n2;</span><br><span class="line">		string ans;</span><br><span class="line">		cin&gt;&gt;n0&gt;&gt;n1&gt;&gt;n2;</span><br><span class="line">		for(int i=1;i&lt;=n0+1;i++)&#123;</span><br><span class="line">			if(n1!=0||n1==0&amp;&amp;n2==0) ans+=&quot;0&quot;;</span><br><span class="line">		&#125;</span><br><span class="line">		for(int i=1;i&lt;=n2;i++)&#123;</span><br><span class="line">			ans+=&quot;1&quot;;</span><br><span class="line">		&#125;</span><br><span class="line">		for(int i=1;i&lt;=n1;i++)&#123;</span><br><span class="line">			if(i%2) ans+=&quot;1&quot;;</span><br><span class="line">			else ans+=&quot;0&quot;;</span><br><span class="line">		&#125;</span><br><span class="line">		if(n0==0&amp;&amp;n1==0) ans+=&quot;1&quot;;</span><br><span class="line">		cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">	&#125; </span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="G-Special-Permutation"><a href="#G-Special-Permutation" class="headerlink" title="G - Special Permutation"></a>G - Special Permutation</h2><h3 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h3><p>说实话我不知道这道题为啥放在最后，<del>感觉难度并不大，反而挺简单的</del>🌚就是让你构造一个相邻两个数之差的绝对值在2到4的区间内（闭区间），我们只要把奇偶分开就行了，但是我有一个疑问，我的思路是把偶数写在前面奇数的倒序列放在后面，例如：<br>8：2 4 6 8 7 5 3 1<br>很明显只有中间不符合条件，所以只动中间就行了，让7和5（奇数序列的前两个）交换：<br>8：2 4 6 8 5 7 3 1（满足条件）<br>再举个例子：<br>9：2 4 6 8 9 7 5 3 1<br>还是只动中间，因为9比8（奇数第一个和偶数最后一个）大所以让5跑到9中间（奇数第3个移动到奇数和偶数序列之间）：<br>9：2 4 6 8 5 9 7 3 1（满足条件）<br>这样的思路我仔细想了想感觉没毛病，就交了，结果wrong了？我不服气，发现中间可能是换行的问题，又交又wrong…<br><img src="https://cdn.jsdelivr.net/gh/uncleacc/Sucai/5~1.webp" alt=""><br>我枯了，为啥？<br>后来换思路：<br>给2 4 1 3的序列两边添加数，先左后右轮换添加，例如：   </p>
<ol>
<li>8：2 4 1 3  </li>
<li>8：5 2 4 1 3  </li>
<li>8：5 2 4 1 3 6  </li>
<li>8：7 5 2 4 1 3 6  </li>
<li>8：7 5 2 4 1 3 6 8<br>完成~，交了AC了。。AC后看了测试数据发现我原来的代码测试数据1应该是对的啊！希望网友那位可以为我解惑（不胜感激）<br><img src="https://cdn.jsdelivr.net/gh/uncleacc/Sucai/7~1.webp" alt=""></li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/Sucai/6~1.webp" alt=""></p>
<h3 id="wrong-CODE"><a href="#wrong-CODE" class="headerlink" title="wrong CODE"></a>wrong CODE</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#define ios ios::sync_with_stdio(0)</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN=1e4;</span><br><span class="line">void swap(int &amp;a,int &amp;b)&#123;</span><br><span class="line">	int t=a;</span><br><span class="line">	a=b;</span><br><span class="line">	b=t;</span><br><span class="line">&#125;</span><br><span class="line">int val[MAXN],book[MAXN];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	int t; cin&gt;&gt;t;</span><br><span class="line">	while(t--)&#123;</span><br><span class="line">		memset(val,0,sizeof val); </span><br><span class="line">		int n; cin&gt;&gt;n;</span><br><span class="line">		if(n==2||n==3)&#123;</span><br><span class="line">			cout&lt;&lt;-1&lt;&lt;endl;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		int tail=0;</span><br><span class="line">		for(int i=2;i&lt;=n;i+=2)&#123;</span><br><span class="line">			val[++tail]=i;</span><br><span class="line">		&#125;</span><br><span class="line">		int flag=tail;</span><br><span class="line">		int p=n%2?n:n-1;</span><br><span class="line">		for(int i=p;i&gt;=1;i-=2)&#123;</span><br><span class="line">			val[++tail]=i;</span><br><span class="line">		&#125;</span><br><span class="line">		if(val[flag+1]&lt;val[flag]) swap(val[flag+1],val[flag+2]);</span><br><span class="line">		else&#123;</span><br><span class="line">			for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">				if(i==flag+1)&#123;</span><br><span class="line">					printf(&quot;%d%c&quot;,val[flag+3],i==n?&#x27;\n&#x27;:&#x27; &#x27;);</span><br><span class="line">				&#125;</span><br><span class="line">				if(i==flag+3)&#123;</span><br><span class="line">					continue;</span><br><span class="line">				&#125;</span><br><span class="line">				printf(&quot;%d%c&quot;,val[i],i==n?&#x27;\n&#x27;:&#x27; &#x27;);</span><br><span class="line">			&#125;</span><br><span class="line">			if(n==5) cout&lt;&lt;endl;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		for(int i=1;i&lt;=n;i++) printf(&quot;%d%c&quot;,val[i],i==n?&#x27;\n&#x27;:&#x27; &#x27;);</span><br><span class="line">	&#125; </span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AC-CODE"><a href="#AC-CODE" class="headerlink" title="AC CODE"></a>AC CODE</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">string ans;</span><br><span class="line">void bd(int n)&#123;</span><br><span class="line">	if(n&lt;=9)&#123;</span><br><span class="line">		ans=(char)(n+&#x27;0&#x27;)+ans;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		while(n!=0)&#123;</span><br><span class="line">			char c=(char)(n%10+&#x27;0&#x27;);</span><br><span class="line">			ans=c+ans;</span><br><span class="line">			n/=10;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void pd(int n)&#123;</span><br><span class="line">		if(n&lt;=9)&#123;</span><br><span class="line">		ans+=(char)(n+&#x27;0&#x27;);</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		char ch[2000];</span><br><span class="line">		int tail=0;</span><br><span class="line">		while(n!=0)&#123;</span><br><span class="line">			char c=(char)(n%10+&#x27;0&#x27;);</span><br><span class="line">			ch[++tail]=c;</span><br><span class="line">			n/=10;</span><br><span class="line">		&#125;</span><br><span class="line">		for(int i=tail;i&gt;=1;i--)&#123;</span><br><span class="line">			ans+=ch[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int t; cin&gt;&gt;t;</span><br><span class="line">	while(t--)&#123;</span><br><span class="line">		ans.clear();</span><br><span class="line">		int n; cin&gt;&gt;n;</span><br><span class="line">		if(n&lt;=3)&#123;</span><br><span class="line">			puts(&quot;-1&quot;);</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		ans+=&quot;2 4 1 3&quot;;</span><br><span class="line">		int flag=1;</span><br><span class="line">		for(int i=5;i&lt;=n;i++)&#123;</span><br><span class="line">			if(i%2)&#123;</span><br><span class="line">				ans=&quot; &quot;+ans;</span><br><span class="line">				bd(i);</span><br><span class="line">			&#125;</span><br><span class="line">			else&#123;</span><br><span class="line">				ans+=&quot; &quot;;</span><br><span class="line">				pd(i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Ending~撒花<font color="red" size=6>不要白嫖了，留下一个赞吧👍<font></p>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>比赛</tag>
      </tags>
  </entry>
  <entry>
    <title>dfs记忆化搜索</title>
    <url>/posts/b58a3aa9.html</url>
    <content><![CDATA[<p>今天学习了记忆化搜索，也练习了许多题，我果然是一个蒟蒻（qwq）</p>
<p>希望下面的讲解对您有所帮助</p>
<h2 id="仙岛求药"><a href="#仙岛求药" class="headerlink" title="仙岛求药"></a>仙岛求药</h2><p>少年李逍遥的婶婶病了，王小虎介绍他去一趟仙灵岛，向仙女姐姐要仙丹救婶婶。叛逆但孝顺的李逍遥闯进了仙灵岛，克服了千险万难来到岛的中心，发现仙药摆在了迷阵的深处。迷阵由 M×NM \times NM×N 个方格组成，有的方格内有可以瞬秒李逍遥的怪物，而有的方格内则是安全。现在李逍遥想尽快找到仙药，显然他应避开有怪物的方格，并经过最少的方格，而且那里会有神秘人物等待着他。现在要求你来帮助他实现这个目标。</p>
<p>输入格式</p>
<p>第一行输入两个非零整数 MMM 和 NNN，两者均不大于 202020。MMM 表示迷阵行数, NNN 表示迷阵列数。</p>
<p>接下来有 MMM 行, 每行包含 NNN 个字符,不同字符分别代表不同含义:</p>
<p>1) ‘@’：少年李逍遥所在的位置；2) ‘.’：可以安全通行的方格；3) ‘#’：有怪物的方格；4) ‘*’：仙药所在位置。</p>
<p>输出格式</p>
<p>输出一行，该行包含李逍遥找到仙药需要穿过的最少的方格数目(计数包括初始位置的方块)。如果他不可能找到仙药, 则输出 −1-1−1。</p>
<p>输出时每行末尾的多余空格，不影响答案正确性</p>
<p>样例输入1</p>
<p>8 8<br>.@##…#</p>
<h1 id="…"><a href="#…" class="headerlink" title="….#."></a>….#.</h1><h1 id=""><a href="#" class="headerlink" title=".#.##.."></a>.#.##..</h1><p>..#.###.</p>
<h1 id="…-1"><a href="#…-1" class="headerlink" title=".#…#."></a>.#…#.</h1><p>..###.#.<br>…#.*..<br>.#…###</p>
<p>样例输出1</p>
<p>10</p>
<p>样例输入2</p>
<p>6 5</p>
<p>.*.#.</p>
<p>.#…</p>
<p>..##.</p>
<p>…..</p>
<p>.#…</p>
<p>….@</p>
<p>样例输出2</p>
<p>8</p>
<p>样例输入3</p>
<p>9 6</p>
<p>.#..#. </p>
<p>.#.*.# </p>
<p>.####. </p>
<p>..#… </p>
<p>..#… </p>
<p>..#… </p>
<p>..#… </p>
<h1 id="-1"><a href="#-1" class="headerlink" title=".@."></a>.@.</h1><p>.#..#.</p>
<p>样例输出3</p>
<p>-1</p>
<p>这是一道典型的搜索题目，不过如果你只贴上dfs的模板指定是过不了的，必须进行优化，但是使用BFS的话就直接可以过了，BFS我下一篇文章讲有，我们知道dfs的思路是不撞南墙不回头，但其实有些路径走到一半就知道这是一条不归路了，我们可以用一个数组来储存到达每一个坐标点的最短路径，当搜索的时候如果现在的步数加一大于到达下一个坐标位置的最短路径，则无需继续，直接改变方向，贴代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">char a[25][25];  //地图</span><br><span class="line">int step[25][25];  //记录每一个走到的位置的最短路径</span><br><span class="line">int dx[5]=&#123;1,0,0,-1&#125;;  //下一个位置</span><br><span class="line">int dy[5]=&#123;0,1,-1,0&#125;;</span><br><span class="line">int n,m;  //地图大小</span><br><span class="line">bool flag = false;  //标记</span><br><span class="line">void dfs(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">    if(a[x][y]==&#x27;*&#x27;)&#123;  //到达终点返回</span><br><span class="line">        flag = true;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;4;i++)&#123;</span><br><span class="line">//就是优化到这里了，加了一个判断如果当前位置的步数+1 &gt; 下一个位置的最小步数，就不用走了否则就更新下一个位置的最小步数</span><br><span class="line"></span><br><span class="line">        int tx=x+dx[i];</span><br><span class="line">        int ty=y+dy[i];</span><br><span class="line">        if(tx&gt;=0 &amp;&amp; tx&lt;n &amp;&amp; ty&lt;m &amp;&amp; ty&gt;=0 &amp;&amp; a[tx][ty]!=&#x27;#&#x27;&amp;&amp; step[x][y]+1&lt;step[tx][ty])&#123;</span><br><span class="line">            step[tx][ty] = step[x][y]+1;  //更新这个位置的最小坐标</span><br><span class="line">        	dfs(tx,ty);  //继续搜索下一位置</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int qx,zx,qy,zy;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">        for(int j=0;j&lt;m;j++)</span><br><span class="line">            step[i][j]=1&lt;&lt;30; //初始化每一个坐标的最小路径，初始值很大</span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">        for(int j=0;j&lt;m;j++)&#123;</span><br><span class="line">            cin &gt;&gt; a[i][j];</span><br><span class="line">            if(a[i][j]==&#x27;@&#x27;)&#123;</span><br><span class="line">                qx = i; qy = j; //找到起始位置，把起始位置的最短路径设置为0</span><br><span class="line">                step[qx][qy]=0;</span><br><span class="line">            &#125;</span><br><span class="line">            if(a[i][j]==&#x27;*&#x27;)&#123;  //找到终点</span><br><span class="line">                zx = i; zy = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(qx,qy);</span><br><span class="line">    if(flag)</span><br><span class="line">        cout &lt;&lt; step[zx][zy];</span><br><span class="line">    else</span><br><span class="line">        cout &lt;&lt; &quot;-1&quot;;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="滑雪"><a href="#滑雪" class="headerlink" title="滑雪"></a>滑雪</h2><p>Description<br>Michael喜欢滑雪百这并不奇怪， 因为滑雪的确很刺激。可是为了获得速度，滑的区域必须向下倾斜，而且当你滑到坡底，你不得不再次走上坡或者等待升降机来载你。Michael想知道载一个区域中最长底滑坡。区域由一个二维数组给出。数组的每个数字代表点的高度。下面是一个例子 </p>
<p> 1  2  3  4 5</p>
<p>16 17 18 19 6</p>
<p>15 24 25 20 7</p>
<p>14 23 22 21 8</p>
<p>13 12 11 10 9</p>
<p>一个人可以从某个点滑向上下左右相邻四个点之一，当且仅当高度减小。在上面的例子中，一条可滑行的滑坡为24-17-16-1。当然25-24-23-…-3-2-1更长。事实上，这是最长的一条。</p>
<p>Input</p>
<p>输入的第一行表示区域的行数R和列数C(1 &lt;= R,C &lt;= 100)。下面是R行，每行有C个整数，代表高度h，0&lt;=h&lt;=10000。</p>
<p>Output</p>
<p>输出最长区域的长度。</p>
<p>Sample Input</p>
<p>5 5</p>
<p>1 2 3 4 5</p>
<p>16 17 18 19 6</p>
<p>15 24 25 20 7</p>
<p>14 23 22 21 8</p>
<p>13 12 11 10 9</p>
<p>Sample Output</p>
<p>25</p>
<p>Source<br>SHTSC 2002</p>
<p>解题思路：</p>
<p>记忆化搜索比普通的搜索效率要高，已经搜索过的就不用再搜索了，有DP的思想.step[i][j] 保存的是当前坐标i,j可以到达的最大距离（不包括自己），比如3 2 1，当前是3，那么可以到达的最大距离为2，对于每个坐标，可以上下左右四个方向搜索，取距离最大的那个，作为该坐标的step[][]。记忆化搜索这里体现的就是当搜索到某一个坐标时，该坐标的step[][]已经有值（搜索过了），且肯定是最优的，那么直接返回该step[][]值就可以了。</p>
<p>代码：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=110;</span><br><span class="line">int map[maxn][maxn];</span><br><span class="line">int step[maxn][maxn];</span><br><span class="line">int Next[][2]=&#123;&#123;1,0&#125;,&#123;0,1&#125;,&#123;-1,0&#125;,&#123;0,-1&#125;&#125;;</span><br><span class="line">int m,n;</span><br><span class="line">int judge(int x,int y)&#123;</span><br><span class="line">	if(x&gt;=0&amp;&amp;x&lt;m&amp;&amp;y&gt;=0&amp;&amp;y&lt;n) return 1;</span><br><span class="line">	else return 0;</span><br><span class="line">&#125;</span><br><span class="line">int dfs(int x,int y)&#123;</span><br><span class="line">	if(step[x][y]) return step[x][y];</span><br><span class="line">	for(int i=0;i&lt;4;i++)&#123;</span><br><span class="line">		int tx=x+Next[i][0];</span><br><span class="line">		int ty=y+Next[i][1];</span><br><span class="line">		if(judge(tx,ty)&amp;&amp;map[tx][ty]&lt;map[x][y])&#123;</span><br><span class="line">			int temp=dfs(tx,ty)+1;</span><br><span class="line">			step[x][y]=max(temp,step[x][y]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return step[x][y];</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int ans=0;</span><br><span class="line">	cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line">	for(int i=0;i&lt;m;i++)&#123;</span><br><span class="line">		for(int j=0;j&lt;n;j++)&#123;</span><br><span class="line">			cin&gt;&gt;map[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=0;i&lt;m;i++)&#123;</span><br><span class="line">		for(int j=0;j&lt;n;j++)&#123;</span><br><span class="line">			step[i][j]=dfs(i,j);</span><br><span class="line">			if(ans&lt;step[i][j]) ans=step[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans+1&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>制作不易，各位老板，可否赏小可怜2毛钱呢（owo），感谢各位老板</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>dfs记忆化搜索</title>
    <url>/posts/b58a3aa9.html</url>
    <content><![CDATA[<blockquote>
<p>dfs标记的位置太重要了，放在不同位置产生的效果都有巨大的差别，记录今天的一些dfs记忆化搜索题目</p>
</blockquote>
<h2 id="A-Function-Run-Fun"><a href="#A-Function-Run-Fun" class="headerlink" title="A- Function Run Fun"></a>A- Function Run Fun</h2><p><a href="https://vjudge.net/contest/387584#problem/A">题目链接</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">using namespace std;</span><br><span class="line">ll used[50][50][50];</span><br><span class="line">ll w(int x,int y,int z)&#123;</span><br><span class="line">	if(x&lt;=0||y&lt;=0||z&lt;=0) return 1;</span><br><span class="line">	if(x&gt;20||y&gt;20||z&gt;20) return w(20,20,20);</span><br><span class="line">	if(used[x][y][z]) return used[x][y][z];</span><br><span class="line">	if(x&lt;y&amp;&amp;y&lt;z) return used[x][y][z]=w(x,y,z-1)+w(x,y-1,z-1)-w(x,y-1,z);</span><br><span class="line">	return used[x][y][z]=w(x-1,y,z)+w(x-1,y-1,z)+w(x-1,y,z-1)-w(x-1,y-1,z-1);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int a,b,c;</span><br><span class="line">	while(cin&gt;&gt;a&gt;&gt;b&gt;&gt;c)&#123;</span><br><span class="line">		if(a==-1&amp;&amp;b==-1&amp;&amp;c==-1) break;</span><br><span class="line">		memset(used,0,sizeof used);</span><br><span class="line">		printf(&quot;w(%d, %d, %d) = %lld\n&quot;,a,b,c,w(a,b,c));</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>
<h2 id="B-滑雪"><a href="#B-滑雪" class="headerlink" title="B- 滑雪"></a>B- 滑雪</h2><p><a href="https://vjudge.net/contest/387584#problem/B">题目链接</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span><br><span class="line">typedef long long ll;</span><br><span class="line">using namespace std;</span><br><span class="line">int G[110][110],step[110][110];</span><br><span class="line">int Next[4][2]=&#123;1,0,0,1,-1,0,0,-1&#125;;</span><br><span class="line">int r,c;</span><br><span class="line">int dfs(int x,int y)&#123;</span><br><span class="line">	if(step[x][y]) return step[x][y];</span><br><span class="line">	step[x][y]=1; //因为记忆化搜索要判断该点是否为零，所以初始化要放到这里</span><br><span class="line">	for(int i=0;i&lt;4;i++)&#123;</span><br><span class="line">		int nx=x+Next[i][0];</span><br><span class="line">		int ny=y+Next[i][1];</span><br><span class="line">		if(nx&gt;=1&amp;&amp;nx&lt;=r&amp;&amp;ny&gt;=1&amp;&amp;ny&lt;=c&amp;&amp;G[nx][ny]&lt;G[x][y])&#123;</span><br><span class="line">			step[x][y]=max(step[x][y],dfs(nx,ny)+1); </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return step[x][y];</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	cin&gt;&gt;r&gt;&gt;c;</span><br><span class="line">	for(int i=1;i&lt;=r;i++)&#123;</span><br><span class="line">		for(int j=1;j&lt;=c;j++)&#123;</span><br><span class="line">			cin&gt;&gt;G[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	int maxn=-1;</span><br><span class="line">	for(int i=1;i&lt;=r;i++)&#123;</span><br><span class="line">		for(int j=1;j&lt;=c;j++)&#123;</span><br><span class="line">			maxn=max(maxn,dfs(i,j));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;maxn&lt;&lt;&#x27;\n&#x27;;</span><br><span class="line">	return 0;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>
<h2 id="C-漫步校园"><a href="#C-漫步校园" class="headerlink" title="C- 漫步校园"></a>C- 漫步校园</h2><p><a href="https://vjudge.net/contest/387584#problem/C">题目链接</a></p>
<p>这道题涉及到求每一个点到某一点的最短路径，听着很耳熟吧，没错就是dijistla算法！这不过这个是通过矩阵给你了，但是性质没变，依旧是用一个bfs，只不过找一个点的邻接点方式变成了上下左右！依旧是通过最小点去更新其他点，可以看以下两段代码，优化后时间31ms，没优化46ms，朴素版本的没有采用标记法，虽然答案一样，但是其走了许多不必要走的点，这些点的最短路径已经确定了，根本不可能更新但还是去比较了，浪费了时间</p>
<p>记忆化搜索在递归的过程中已经算出来了许多点的值，以后的递归过程中当用这个点的值时可以直接返回</p>
<h3 id="优化-CODE"><a href="#优化-CODE" class="headerlink" title="优化 CODE"></a>优化 CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> x,y,step;</span><br><span class="line">	<span class="type">bool</span> operator &lt; (<span class="type">const</span> node &amp;o) <span class="type">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> step&gt;o.step;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> G[<span class="number">110</span>][<span class="number">110</span>],dis[<span class="number">110</span>][<span class="number">110</span>],vis[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line">ll used[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="type">int</span> Next[<span class="number">4</span>][<span class="number">2</span>]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="built_in">priority_queue</span>&lt;node&gt; pq;</span><br><span class="line"><span class="type">void</span> <span class="title function_">bfs</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(!pq.empty()) pq.pop();</span><br><span class="line">	<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">	<span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dis);</span><br><span class="line">	node s=&#123;n,n,G[n][n]&#125;;</span><br><span class="line">	pq.push(s);</span><br><span class="line">	dis[n][n]=G[n][n];</span><br><span class="line">	<span class="keyword">while</span>(!pq.empty())&#123;</span><br><span class="line">		node tmp=pq.top(); pq.pop();</span><br><span class="line">		<span class="keyword">if</span>(vis[tmp.x][tmp.y]) <span class="keyword">continue</span>; <span class="comment">//已经确定最短路径的点</span></span><br><span class="line">		vis[tmp.x][tmp.y]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">			<span class="type">int</span> nx=tmp.x+Next[i][<span class="number">0</span>];</span><br><span class="line">			<span class="type">int</span> ny=tmp.y+Next[i][<span class="number">1</span>];</span><br><span class="line">			<span class="keyword">if</span>(nx&lt;<span class="number">1</span>||nx&gt;n||ny&lt;<span class="number">1</span>||ny&gt;n) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(dis[tmp.x][tmp.y]+G[nx][ny]&lt;dis[nx][ny])&#123;</span><br><span class="line">				dis[nx][ny]=dis[tmp.x][tmp.y]+G[nx][ny];</span><br><span class="line">				pq.push(&#123;nx,ny,dis[nx][ny]&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">ll <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123; <span class="comment">//注意ll</span></span><br><span class="line">	<span class="keyword">if</span>(used[x][y]) <span class="keyword">return</span> used[x][y]; </span><br><span class="line">	used[x][y]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">		<span class="type">int</span> nx=x+Next[i][<span class="number">0</span>];</span><br><span class="line">		<span class="type">int</span> ny=y+Next[i][<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span>(nx&lt;<span class="number">1</span>||nx&gt;n||ny&lt;<span class="number">1</span>||ny&gt;n) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(dis[x][y]&gt;dis[nx][ny])&#123;</span><br><span class="line">			used[x][y]+=dfs(nx,ny); <span class="comment">//一个点的所有走法等于它周围所有点的走法之和</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> used[x][y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">				<span class="built_in">cin</span>&gt;&gt;G[i][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		bfs();</span><br><span class="line"><span class="comment">//		for(int i=1;i&lt;=n;i++)&#123;</span></span><br><span class="line"><span class="comment">//			for(int j=1;j&lt;=n;j++)&#123;</span></span><br><span class="line"><span class="comment">//				if(j!=n) cout&lt;&lt;dis[i][j]&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line"><span class="comment">//				else cout&lt;&lt;dis[i][j]&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line"><span class="comment">//			&#125;</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line">		<span class="built_in">memset</span>(used,<span class="number">0</span>,<span class="keyword">sizeof</span> used);</span><br><span class="line">		used[n][n]=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;dfs(<span class="number">1</span>,<span class="number">1</span>)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>
<h3 id="朴素-CODE"><a href="#朴素-CODE" class="headerlink" title="朴素 CODE"></a>朴素 CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> G[<span class="number">110</span>][<span class="number">110</span>],dis[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line">ll used[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="type">int</span> Next[<span class="number">4</span>][<span class="number">2</span>]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="built_in">queue</span>&lt;node&gt; q;</span><br><span class="line"><span class="type">void</span> <span class="title function_">bfs</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(!q.empty()) q.pop();</span><br><span class="line">	<span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dis);</span><br><span class="line">	node s=&#123;n,n&#125;;</span><br><span class="line">	q.push(s);</span><br><span class="line">	dis[n][n]=G[n][n];</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		node tmp=q.front(); q.pop();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">			<span class="type">int</span> nx=tmp.x+Next[i][<span class="number">0</span>];</span><br><span class="line">			<span class="type">int</span> ny=tmp.y+Next[i][<span class="number">1</span>];</span><br><span class="line">			<span class="keyword">if</span>(nx&lt;<span class="number">1</span>||nx&gt;n||ny&lt;<span class="number">1</span>||ny&gt;n) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(dis[tmp.x][tmp.y]+G[nx][ny]&lt;dis[nx][ny])&#123;</span><br><span class="line">				dis[nx][ny]=dis[tmp.x][tmp.y]+G[nx][ny];</span><br><span class="line">				q.push(&#123;nx,ny&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">ll <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(used[x][y]) <span class="keyword">return</span> used[x][y];</span><br><span class="line">	ll sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">		<span class="type">int</span> nx=x+Next[i][<span class="number">0</span>];</span><br><span class="line">		<span class="type">int</span> ny=y+Next[i][<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span>(nx&lt;<span class="number">1</span>||nx&gt;n||ny&lt;<span class="number">1</span>||ny&gt;n) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(dis[x][y]&gt;dis[nx][ny])&#123;</span><br><span class="line">			sum+=dfs(nx,ny);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	used[x][y]=sum;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">				<span class="built_in">cin</span>&gt;&gt;G[i][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		bfs();</span><br><span class="line">		<span class="built_in">memset</span>(used,<span class="number">0</span>,<span class="keyword">sizeof</span> used);</span><br><span class="line">		used[n][n]=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;dfs(<span class="number">1</span>,<span class="number">1</span>)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>
<h2 id="E-Zipper"><a href="#E-Zipper" class="headerlink" title="E  Zipper"></a>E  Zipper</h2><p><a href="https://vjudge.net/contest/387584#problem/E">题目链接</a></p>
<p>感觉是一道难题，可能是对我来说吧，这道题不能简单的遍历，当前两个字符串出现相同字符时，没有办法确定该字符在第三个字符串中的位置，例如样例2： <code>cat tree catrtee</code> 人眼第一眼看都以为输出no，但是仔细想一想，如果cat的t是最后一个t那么这就是可行的，这种判断是哪个t的操作普通遍历是不可行的，这种题目就有dp的思想，首先我们判断前两个字符串的首字母和最后一个字符串的首字母相同否，因为第三个字符串如果可以由前俩字符串组成，那么里面的所有字符要不是第一个字符串里的要不是第二个里面的，假若最后一个字符串的首字母既不是A里面的也不是B里面的，那一定是不可行的，若是A或B里面的，就分为3种情况</p>
<ol>
<li>假若是A里面的不是B里面的，那么A的第一个字符和C的第一个字符就可以同时去掉了！问题就变成了判断A(除了第一个字符)和B是否能组成C(除了第一个字符)，这就把问题分成了子问题，</li>
<li>假若是B里面的不是A里面的，性质同第一种情况</li>
<li>同时是A又是B里面的，这样就要分两种情况去走了，例如样例2<code>cat tree catrtee</code>，首先我们把t当作是第一个的t，然后再当作第二个的，分别看看能否有解，只要有一个有解就说明是可行的</li>
</ol>
<p>这种子问题和原问题性质一样的题目就可以用递归去解，写一个dfs函数，三个参数分别是ABC的当前下标，什么时候结束呢？当前两个字符串的下标移到了最后就说明该解可行，标记flag返回就行了。</p>
<p>但是还没完，到这里还没用记忆化搜索，这样会超时，为什么用到了记忆化搜索？例如：<code>ttt ttt tttttt</code>，这是一组数据，因为里面每一个字符都相同，那么就都要分两种情况去搜索，有很多种情况都是重复搜索的，例如：<code>tt tt tttt</code>，既可以由<code>ttt tt ttttt</code>，转化过来也可以由<code>tt ttt ttttt</code>转化过来，那么就被计算了两次，那么就可以存下运算结果，标记这种情况已经算过了，以后再到这种情况直接返回</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="built_in">string</span> s1,s2,s3;</span><br><span class="line"><span class="type">int</span> n,len1,len2,len3,flag;</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">500</span>][<span class="number">500</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> pos1,<span class="type">int</span> pos2,<span class="type">int</span> pos3)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(pos1==len1&amp;&amp;pos2==len2)&#123; <span class="comment">//找到可行解</span></span><br><span class="line">		flag=<span class="number">1</span>; <span class="comment">//标记</span></span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(s1[pos1]!=s3[pos3]&amp;&amp;s2[pos2]!=s3[pos3]) <span class="keyword">return</span> ; <span class="comment">//C字符串字符一定是A或者B里的一个，不是则不可行</span></span><br><span class="line">	<span class="keyword">if</span>(vis[pos1][pos2]) <span class="keyword">return</span> ; <span class="comment">//记忆化搜索标记</span></span><br><span class="line">	vis[pos1][pos2]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(s1[pos1]==s3[pos3]) dfs(pos1+<span class="number">1</span>,pos2,pos3+<span class="number">1</span>); <span class="comment">//分两种情况</span></span><br><span class="line">	<span class="keyword">if</span>(s2[pos2]==s3[pos3]) dfs(pos1,pos2+<span class="number">1</span>,pos3+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="type">int</span> t,kase=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;s1&gt;&gt;s2&gt;&gt;s3;</span><br><span class="line">		len1=s1.size();</span><br><span class="line">		len2=s2.size();</span><br><span class="line">		len3=s3.size();</span><br><span class="line">		flag=<span class="number">0</span>;</span><br><span class="line">		dfs(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>); </span><br><span class="line">		<span class="keyword">if</span>(flag) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Data set &quot;</span>&lt;&lt;++kase&lt;&lt;<span class="string">&quot;: yes&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Data set &quot;</span>&lt;&lt;++kase&lt;&lt;<span class="string">&quot;: no&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>
<h2 id="G-FatMouse-and-Cheese"><a href="#G-FatMouse-and-Cheese" class="headerlink" title="G- FatMouse and Cheese"></a>G- FatMouse and Cheese</h2><p><a href="https://vjudge.net/contest/387584#problem/G">题目链接</a></p>
<p>和B滑雪很相似，代码一些细节很重要，标注部分，采用此方式速度甚至会快一些</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> G[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line">ll used[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="type">int</span> Next[<span class="number">4</span>][<span class="number">2</span>]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">ll <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(used[x][y]) <span class="keyword">return</span> used[x][y];</span><br><span class="line">	used[x][y]=G[x][y]; <span class="comment">//每一个点的初始分数都是它本身，这个不能放到主函数进行，因为会影响上一句if的判断，实际上这是一句细思极秒的操作，这个操作避免了许多临界问题</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=m;k++)&#123;</span><br><span class="line">			<span class="type">int</span> nx=x+k*Next[i][<span class="number">0</span>];</span><br><span class="line">			<span class="type">int</span> ny=y+k*Next[i][<span class="number">1</span>];</span><br><span class="line">			<span class="keyword">if</span>(nx&lt;<span class="number">1</span>||nx&gt;n||ny&lt;<span class="number">1</span>||ny&gt;n) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(G[nx][ny]&gt;G[x][y])&#123;</span><br><span class="line">				used[x][y]=max(used[x][y],dfs(nx,ny)+G[x][y]); <span class="comment">//这个点往下走后这个点就不会再用了，换句话说就是由这个点拓展出去的点不会反过来拓展该点，因此可以直接在循环里面更新其最值</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> used[x][y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m)&#123;</span><br><span class="line">		<span class="keyword">if</span>(n==<span class="number">-1</span>&amp;&amp;m==<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">				<span class="built_in">cin</span>&gt;&gt;G[i][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">memset</span>(used,<span class="number">0</span>,<span class="keyword">sizeof</span> used);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;dfs(<span class="number">1</span>,<span class="number">1</span>)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>集训</tag>
      </tags>
  </entry>
  <entry>
    <title>飞翔的小鸟C语言小游戏</title>
    <url>/posts/3e57986e.html</url>
    <content><![CDATA[<blockquote>
<p>今天有些疲倦，不想学习，就去网上学习做了一个小游戏，如果你是网友，没接触过图形库，要先安装esayx库，网上有许多，在这里不贴了，素材地址： <a href="https://pan.baidu.com/s/1GWnLePCiLcxlJHOaBKEeaA">https://pan.baidu.com/s/1GWnLePCiLcxlJHOaBKEeaA</a> 密码：pmzq 💪</p>
</blockquote>
<ul>
<li>成品视频: <a href="https://www.bilibili.com/video/BV1354y1Q7iB">Here</a><center>
<font color="black" size=4>
希望该文章能帮助到您
</font>
<font color="red" size=5>
不要白嫖了！！！留下您的评论吧
</font>
</center>
<center>
<font color="green" size=2>
谁能帮我测试一下下面的赏是不是出错了😘
</font>
</center>

</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">1.创建一个可视化窗口</span><br><span class="line">2.显示一张背景图</span><br><span class="line">*/</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;graphics.h&gt;</span><br><span class="line">#include &lt;conio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">#include &lt;mmsystem.h&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line">#pragma comment(lib,&quot;winmm.lib&quot;)</span><br><span class="line"></span><br><span class="line">IMAGE mybird[2];//给图片起名字</span><br><span class="line">IMAGE BG;//背景图片</span><br><span class="line">IMAGE overimg[2];//游戏结束图片</span><br><span class="line">IMAGE up[2];//上面柱子</span><br><span class="line">IMAGE down[2];//下面柱子</span><br><span class="line"></span><br><span class="line">struct bird &#123;//鸟的属性</span><br><span class="line">    int x, y;</span><br><span class="line">    int speed;</span><br><span class="line">&#125;;</span><br><span class="line">struct zhuzi &#123;</span><br><span class="line">    int x, y;//起始坐标</span><br><span class="line">    int h;//高度</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bird flybird = &#123; 124,304,100 &#125;;//初始化鸟</span><br><span class="line">void loadresource() &#123;</span><br><span class="line">    loadimage(&amp;BG, &quot;飞翔的小鸟/background.bmp&quot;);//背景</span><br><span class="line">    loadimage(&amp;mybird[0], &quot;飞翔的小鸟/birdy.bmp&quot;, 48, 48);</span><br><span class="line">    loadimage(&amp;mybird[1], &quot;飞翔的小鸟/bird.bmp&quot;, 48, 48);</span><br><span class="line">    loadimage(&amp;overimg[0], &quot;飞翔的小鸟/endy.bmp&quot;);</span><br><span class="line">    loadimage(&amp;overimg[1], &quot;飞翔的小鸟/end.bmp&quot;);</span><br><span class="line">    loadimage(&amp;up[0], &quot;飞翔的小鸟/upy.bmp&quot;);</span><br><span class="line">    loadimage(&amp;up[1], &quot;飞翔的小鸟/up.bmp&quot;);</span><br><span class="line">    loadimage(&amp;down[0], &quot;飞翔的小鸟/downy.bmp&quot;);</span><br><span class="line">    loadimage(&amp;down[1], &quot;飞翔的小鸟/down.bmp&quot;);</span><br><span class="line">&#125;</span><br><span class="line">void drawbird(int x,int y) &#123;</span><br><span class="line">    //SCAND的方式贴掩码图</span><br><span class="line">    putimage(x, y, &amp;mybird[0], SRCAND);</span><br><span class="line">    //SRCPAINT的方式贴背景图</span><br><span class="line">    putimage(x, y, &amp;mybird[1], SRCPAINT);</span><br><span class="line">&#125;</span><br><span class="line">//多线程处理音乐因为直接在按键函数里面写会有画面停顿感</span><br><span class="line">DWORD WINAPI playmusic(LPVOID lpParamer) &#123;</span><br><span class="line">    mciSendString(&quot;open 飞翔的小鸟/jump.mp3&quot;, 0, 0, 0);</span><br><span class="line">    mciSendString(&quot;play 飞翔的小鸟/jump.mp3 wait&quot;, 0, 0, 0);</span><br><span class="line">    mciSendString(&quot;close 飞翔的小鸟/jump.mp3&quot;, 0, 0, 0);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">//撞击柱子</span><br><span class="line">DWORD WINAPI playMusic1(LPVOID lpParamer) &#123; //多线程</span><br><span class="line">    mciSendString(&quot;open 飞翔的小鸟/hit.mp3&quot;, 0, 0, 0); </span><br><span class="line">    mciSendString(&quot;play 飞翔的小鸟/hit.mp3 wait&quot;, 0, 0, 0);</span><br><span class="line">    mciSendString(&quot;close 飞翔的小鸟/hit.mp3&quot;, 0, 0, 0);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">DWORD WINAPI playMusic2(LPVOID lpParamer) &#123; //多线程</span><br><span class="line">    mciSendString(&quot;open 飞翔的小鸟/gameover.mp3&quot;, 0, 0, 0);</span><br><span class="line">    mciSendString(&quot;play 飞翔的小鸟/gameover.mp3 wait&quot;, 0, 0, 0);</span><br><span class="line">    mciSendString(&quot;close 飞翔的小鸟/gameover.mp3&quot;, 0, 0, 0);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">//结束动画</span><br><span class="line">void Gameover() &#123;</span><br><span class="line">    //图片初始位置</span><br><span class="line">    int x = 50;</span><br><span class="line">    int y = 608;</span><br><span class="line">    while (y &gt;= 240) &#123;</span><br><span class="line">        putimage(0, 0, &amp;BG);</span><br><span class="line">        putimage(x, y, &amp;overimg[0], SRCAND);</span><br><span class="line">        putimage(x, y, &amp;overimg[1], SRCPAINT);</span><br><span class="line">        y -= 50;</span><br><span class="line">        Sleep(50);</span><br><span class="line">    &#125;</span><br><span class="line">    CreateThread(NULL, NULL, playMusic2, NULL, NULL, NULL);</span><br><span class="line">    Sleep(5000);</span><br><span class="line">&#125;</span><br><span class="line">//撞击地板或是天花板</span><br><span class="line">int hitfloor() &#123;</span><br><span class="line">    if (flybird.y &lt;= 0 || flybird.y &gt;= (608 - 96)) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">//撞到柱子</span><br><span class="line">int hitPillar(zhuzi myPillar[]) &#123;  //撞到柱子</span><br><span class="line">    for (int i = 0; i &lt; 3; ++i) &#123;</span><br><span class="line">        if ((flybird.x+48) &gt;= myPillar[i].x &amp;&amp; (flybird.x+48) &lt;= myPillar[i].x + 52|| </span><br><span class="line">            flybird.x &gt;= myPillar[i].x &amp;&amp; flybird.x &lt;= myPillar[i].x + 52)</span><br><span class="line">        &#123;</span><br><span class="line">            if (flybird.y+12 &lt;= myPillar[i].h || flybird.y+12 &gt;= (512 - 320 + myPillar[i].h)||</span><br><span class="line">                (flybird.y+36) &lt;= myPillar[i].h || (flybird.y+36) &gt;= (512 - 320 + myPillar[i].h))</span><br><span class="line">            &#123;</span><br><span class="line">                CreateThread(NULL, NULL, playMusic1, NULL, NULL, NULL);</span><br><span class="line">                return 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">//用户按键处理</span><br><span class="line">void keydown(zhuzi pillar[]) &#123;</span><br><span class="line">    /*</span><br><span class="line">        mciSendString(&quot;指令&quot;,0,0,0)</span><br><span class="line">        指令:</span><br><span class="line">            open: 打开</span><br><span class="line">            play: 播放</span><br><span class="line">            pause: 暂停</span><br><span class="line">            wait: 等待</span><br><span class="line">            stop: 暂停</span><br><span class="line">            close: 关闭</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    char userkey = _getch();</span><br><span class="line">    switch (userkey) &#123;</span><br><span class="line">    case &#x27; &#x27;:</span><br><span class="line">        for (int i = 1; i &lt;= flybird.speed - 30; i++) &#123;</span><br><span class="line">            flybird.y -= 1;</span><br><span class="line">            if (hitPillar(pillar)) Gameover();</span><br><span class="line">        &#125;</span><br><span class="line">        CreateThread(NULL, NULL, playmusic, NULL, NULL, NULL);</span><br><span class="line">        break;</span><br><span class="line">    case&#x27;z&#x27;: case&#x27;Z&#x27;:</span><br><span class="line">            char c;</span><br><span class="line">            while (c = _getch()) &#123;</span><br><span class="line">                if (c == &#x27;z&#x27; || c == &#x27;Z&#x27;) break;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">    default:</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void initpillar(zhuzi pillar[], int i) &#123;</span><br><span class="line">    pillar[i].h = rand() % 100 + 160;//最低高度160，最大259，[160,259]</span><br><span class="line">    pillar[i].x = 288;</span><br><span class="line">    pillar[i].y = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void drawpillar(zhuzi pillar) &#123;</span><br><span class="line">    putimage(pillar.x, 0, 52, pillar.h, &amp;down[0], 0, 320 - pillar.h, SRCAND);//柱子宽度为52</span><br><span class="line">    putimage(pillar.x, 0, 52, pillar.h, &amp;down[1], 0, 320 - pillar.h, SRCPAINT);</span><br><span class="line">    putimage(pillar.x, 512 - (320 - pillar.h), 52, 320 - pillar.h, &amp;up[0], 0, 0, SRCAND);</span><br><span class="line">    putimage(pillar.x, 512 - (320 - pillar.h), 52, 320 - pillar.h, &amp;up[1], 0, 0, SRCPAINT);</span><br><span class="line">&#125;</span><br><span class="line">void xiazhui(zhuzi pillar[]) &#123;</span><br><span class="line">    for (int i = 1; i &lt;= 5; i++) &#123;</span><br><span class="line">        flybird.y += 1;</span><br><span class="line">        if (hitfloor() || hitPillar(pillar)) Gameover();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    initgraph(288, 608);</span><br><span class="line">    srand((unsigned int)time(NULL));</span><br><span class="line">    zhuzi pillar[3];//柱子英文pillar,窗口大小只能容下三根柱子</span><br><span class="line">    for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">        initpillar(pillar, i);</span><br><span class="line">        //让柱子之间有差距</span><br><span class="line">        pillar[i].x = 288 + i * 150;//柱子之间间距150</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    loadresource();</span><br><span class="line">    putimage(0, 0, &amp;BG);</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        putimage(0, 0, &amp;BG);</span><br><span class="line">        drawbird(flybird.x, flybird.y);</span><br><span class="line">        xiazhui(pillar);</span><br><span class="line">        for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">            pillar[i].x -= 10;</span><br><span class="line">            if (pillar[i].x &lt; (-52 - 150)) &#123;</span><br><span class="line">                initpillar(pillar, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">            drawpillar(pillar[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        //一定判断按键是否存在</span><br><span class="line">        if (_kbhit())&#123;</span><br><span class="line">            keydown(pillar);</span><br><span class="line">        &#125;</span><br><span class="line">        if (hitfloor() || hitPillar(pillar)) &#123;</span><br><span class="line">            Gameover();//这里不break可以无限播放Gameover动画</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        Sleep(50);</span><br><span class="line">    &#125;</span><br><span class="line">    closegraph();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>小游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>二进制补码</title>
    <url>/posts/ccdf9d65.html</url>
    <content><![CDATA[<p>这道题看百度上的题解把我看蒙了，想了半天没想通，直到我看见在计算机中负数是用补码来表示的，我才恍然大悟，咋把这个给忘了（抓狂）<br><img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/20200703225037185.png" alt=""></p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>蒜头君有一个 int\text{int}int 的整数，输出它的 323232 位二进制补码。</p>
<p>输入格式</p>
<p>一个整型整数。</p>
<p>输出格式</p>
<p>输出一行，即该整数的补码表示。</p>
<p>输出时每行末尾的多余空格，不影响答案正确性</p>
<p>样例输入：</p>
<p>7</p>
<p>样例输出</p>
<p>00000000000000000000000000000111</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>做这道题就是明白一点：计算机中负数用补码来表示，因为整数补码是本身，所以这道题其实就是输出一个数在计算机中的二进制形式，超级简单了</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
using namespace std;
int map1[110][110],map2[110][110];
int main()
&#123;
  int n;
  cin&gt;&gt;n;
  for(int i=31;i&gt;=0;i--)&#123;
    cout&lt;&lt;((n&gt;&gt;i)&amp;1); //输出这一位的数
  &#125;
&#125;
</code></pre><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p><a href="https://zhidao.baidu.com/question/1370612947989125499.html">传送门</a></p>
<h3 id="i的作用"><a href="#i的作用" class="headerlink" title="%i的作用"></a>%i的作用</h3><p>%i和%d区别在scanf中，%i功能更强大，能根据输入的形式转换成十进制并赋值给变量，比如下面程序：</p>
<pre><code>int n;
  scanf(&quot;%i&quot;,&amp;n);
  cout&lt;&lt;n;
&#125;
</code></pre><p>输入0X10，输出16,输入0010输出8(八进制)</p>
<blockquote>
<p>c语言不能直接表示二进制,没有数字前缀表示</p>
<h3 id="itoa函数"><a href="#itoa函数" class="headerlink" title="itoa函数"></a>itoa函数</h3><p><a href="https://baike.baidu.com/item/itoa%E5%87%BD%E6%95%B0/3260813?fr=aladdin">传送门</a></p>
</blockquote>
<p>C语言中可以用%o %d/%i %x输出8 10 16进制的数但是没有二进制的输出字符，但是有itoa的函数，</p>
<blockquote>
<p>注意: 计算机中负数用补码表示，所以itoa函数求出的负数也是补码形式</p>
</blockquote>
<p>函数原型：</p>
<pre><code>char *itoa( int value, char *string,int radix); [1] 
原型说明：
value：欲转换的数据。
string：目标字符串的地址。
radix：转换后的进制数，可以是10进制、16进制等。
</code></pre><p>参考代码：</p>
<p>1</p>
<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
int main(void)
&#123;
    int number = 12345;
    char string[32];
    itoa(number, string, 10);
    printf(&quot;integer = %d string = %s\n&quot;, number, string);
    return 0;
&#125;
</code></pre><p>2</p>
<pre><code>/* itoa example */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
int main ()&#123;
    int i;
    char buffer[33];
    printf (&quot;Enter a number: &quot;);
    scanf (&quot;%d&quot;,&amp;i);    //输入整数i
    itoa (i,buffer,10);    //将i转化为10进制数，存到buffer中
    printf (&quot;decimal: %s\n&quot;,buffer);    //输出打印buffer
    itoa (i,buffer,16);    //将i转化为16进制数，存到buffer中
    printf (&quot;hexadecimal: %s\n&quot;,buffer);    //输出打印buffer
    itoa (i,buffer,2);    //将i转化为2进制数，存到buffer中
    printf (&quot;binary: %s\n&quot;,buffer);    //输出打印buffer
    return 0;&#125;
OUTPUT:
Enter a number: 1750
decimal: 1750
hexadecimal: 6d6
binary: 11011010110
</code></pre><blockquote>
<p>注意事项</p>
</blockquote>
<p>itoa() 函数有3个参数：第一个参数是要转换的数字，第二个参数是要写入转换结果的目标字符串，第三个参数是转移数字时所用的基数(进制)。在上例中，转换基数为10，就意味着以10为转换进制。10：十进制；2：二进制…</p>
<p>itoa 并不是一个标准的C函数，它是Windows特有的，如果要写跨平台的程序，请用sprintf。</p>
<p>标准库中有sprintf，功能比这个更强，用法跟printf类似：</p>
<p>char str[255];</p>
<p>sprintf(str, “%x”, 100); //将100转为16进制表示的字符串。</p>
<p>下列函数也可以将相应类型的整数转换为字符串：</p>
<figure class="highlight plaintext"><figcaption><span>*ultoa(unsigned long value,char *string,int radix)</span></figcaption><table><tr><td class="code"><pre><span class="line">　　将无符号整型数value转换成字符串并返回该字符串,radix为转换时所用基数</span><br><span class="line">　　char *ltoa(long value,char *string,int radix)</span><br><span class="line">　　将长整型数value转换成字符串并返回该字符串,radix为转换时所用基数</span><br><span class="line">　　char *itoa(int value,char *string,int radix)</span><br><span class="line">　　将整数value转换成字串存入string,radix为转换所用基数.</span><br><span class="line">　　double atof(char *nptr)</span><br><span class="line">　　将字符串nptr转换成双精度数,并返回这个数,错误返回0</span><br><span class="line">　　int atoi(char *nptr)</span><br><span class="line">　　将字符串nptr转换成整型数, 并返回这个数,错误返回0</span><br><span class="line">　　long atol(char *nptr)</span><br><span class="line">　　将字符串nptr转换成长整型数,并返回这个数,错误返回0</span><br><span class="line">　　double strtod(char *str,char **endptr)</span><br><span class="line">　　将字符串str转换成双精度数,并返回这个数,</span><br><span class="line">　　long strtol(char *str,char **endptr,int base)</span><br><span class="line">　　将字符串str转换成长整型数, 并返回这个数</span><br></pre></td></tr></table></figure>
<p>ok,又11点多了，哎！啥也不是</p>
]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title>高精加减乘除</title>
    <url>/posts/b98ecf14.html</url>
    <content><![CDATA[<h2 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> <span class="title function_">add</span><span class="params">(<span class="built_in">string</span> a,<span class="built_in">string</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.size() &gt; b.size()) swap(a,b);</span><br><span class="line">    b.insert(b.begin(),<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = b.size()<span class="number">-1</span>,j = a.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--,j--)&#123;</span><br><span class="line">        <span class="type">int</span> cur;</span><br><span class="line">        <span class="keyword">if</span>(j&gt;=<span class="number">0</span>) cur = (a[j]-<span class="string">&#x27;0&#x27;</span>) + (b[i]-<span class="string">&#x27;0&#x27;</span>) + t;</span><br><span class="line">        <span class="keyword">else</span> cur = (b[i] - <span class="string">&#x27;0&#x27;</span>) +t;</span><br><span class="line">        b[i] = (cur%<span class="number">10</span>) + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        t = cur/<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> idx = b.find_first_not_of(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> idx != <span class="number">-1</span>? b.substr(idx): <span class="string">&quot;0&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> <span class="title function_">sub</span><span class="params">(<span class="built_in">string</span> a,<span class="built_in">string</span> b)</span>&#123;</span><br><span class="line">    <span class="comment">//a大b小</span></span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = a.size()<span class="number">-1</span>,j = b.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--,j--)&#123;</span><br><span class="line">        <span class="type">int</span> up = <span class="number">0</span>,down = <span class="number">0</span>;</span><br><span class="line">        up = (a[i]-<span class="string">&#x27;0&#x27;</span>) + t; t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(j&gt;=<span class="number">0</span>) down = (b[j]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>(up &lt; down) up+=<span class="number">10</span>,t = <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> cur = up-down;</span><br><span class="line">        a[i] = cur+<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> idx = a.find_first_not_of(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> idx != <span class="number">-1</span>? a.substr(idx) : <span class="string">&quot;0&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="乘法（高精度乘高精度）"><a href="#乘法（高精度乘高精度）" class="headerlink" title="乘法（高精度乘高精度）"></a>乘法（高精度乘高精度）</h2><pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
using namespace std;
int r[50000],r_a[50000],r_b[50000];
int main()
&#123;
  string a,b;
  int len,res=0,cnt=0,k; //cnt进位，res保存每位数相乘结果 
  cin&gt;&gt;a&gt;&gt;b;
  for(int i=1;i&lt;=a.size();i++) r_a[i]=a[i-1]-&#39;0&#39;;
  for(int i=1;i&lt;=b.size();i++) r_b[i]=b[i-1]-&#39;0&#39;;
  len=b.size()+a.size()-1;  //给长度初始化为两个数位数之和 
  for(int i=a.size();i&gt;=1;i--)&#123;
    cnt=0; res=0; k=a.size()-i+1;  //k给r数组计数 
    for(int j=b.size();j&gt;=1;j--)&#123;
      res=r_a[i]*r_b[j]+cnt+r[k];//每一位数相乘有进位就进位 ,这
                    //里计算每一位数字乘积的时候 ，
                    //一定要加上上一次该位置的数 
      cnt=res/10;  //刷新进位 
      r[k++]=res%10;
      if(j==1&amp;&amp;cnt)&#123;
        r[k++]=cnt;//如果每次最后进位了就要在r数组中向后移动一个位置填上该数 
      &#125;
      if(j==1&amp;&amp;i==1&amp;&amp;cnt)    len++;//若最后进位长度要加一  
    &#125;
  &#125;
  while(len&gt;1&amp;&amp;r[len]==0) len--;
  for(int i=len;i&gt;=1;i--)&#123;
    cout&lt;&lt;r[i];
  &#125;
  return 0;
&#125;
</code></pre><h2 id="乘法（高精度乘低精度）"><a href="#乘法（高精度乘低精度）" class="headerlink" title="乘法（高精度乘低精度）"></a>乘法（高精度乘低精度）</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> <span class="title function_">mul</span><span class="params">(<span class="built_in">string</span> a,ll b)</span>&#123;</span><br><span class="line">    <span class="built_in">string</span> c = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    ll t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = a.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span> || t;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=<span class="number">0</span>) t += (a[i]-<span class="string">&#x27;0&#x27;</span>)*b;</span><br><span class="line">        c += (t%<span class="number">10</span>) +<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        t/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(c.begin(),c.end());</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="大数乘大数-高精度乘高精度"><a href="#大数乘大数-高精度乘高精度" class="headerlink" title="大数乘大数(高精度乘高精度)"></a>大数乘大数(高精度乘高精度)</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10000</span>],b[<span class="number">10000</span>],ans[<span class="number">10000</span>];<span class="comment">//注意全局变量 </span></span><br><span class="line"><span class="built_in">string</span> x,y;</span><br><span class="line"><span class="type">int</span> len1,len2,pos;</span><br><span class="line"><span class="type">void</span> <span class="title function_">change</span><span class="params">(<span class="built_in">string</span> x,<span class="built_in">string</span> y)</span>&#123;<span class="comment">//接受字符串更换成int数组 </span></span><br><span class="line">	len1=x.size(),len2=y.size();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len1;i++) a[i]=x[len1-i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len2;i++) b[i]=y[len2-i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span> *<span class="title function_">hpre</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> b[])</span>&#123; <span class="comment">//接受int数组结果储存于ans数组 </span></span><br><span class="line">	<span class="keyword">if</span>((len1==<span class="number">1</span>&amp;&amp;a[<span class="number">1</span>]==<span class="number">0</span>)||(len2==<span class="number">1</span>&amp;&amp;b[<span class="number">1</span>]==<span class="number">0</span>))&#123;</span><br><span class="line">		ans[++pos]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> jin=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">//注意低位在前 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len1;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=len2;j++)&#123;</span><br><span class="line">			pos=j+i<span class="number">-1</span>;</span><br><span class="line">			<span class="type">int</span> x=a[i]*b[j]+ans[pos];</span><br><span class="line">			jin=x/<span class="number">10</span>;</span><br><span class="line">			<span class="keyword">if</span>(jin) ans[pos+<span class="number">1</span>]+=jin;</span><br><span class="line">			ans[pos]=x%<span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> ans[])</span>&#123;<span class="comment">//输出ans数组 </span></span><br><span class="line">	<span class="keyword">if</span>(ans[pos+<span class="number">1</span>]!=<span class="number">0</span>) <span class="built_in">cout</span>&lt;&lt;ans[pos];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=pos;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;ans[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="除法（高精度除低精度）"><a href="#除法（高精度除低精度）" class="headerlink" title="除法（高精度除低精度）"></a>除法（高精度除低精度）</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> <span class="title function_">div</span><span class="params">(<span class="built_in">string</span> a,ll b)</span>&#123;</span><br><span class="line">    <span class="built_in">string</span> c = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    ll cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;a.size();i++)&#123;</span><br><span class="line">        cur = cur*<span class="number">10</span> + (a[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        c += to_string(cur/b);</span><br><span class="line">        cur %= b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> idx = c.find_first_not_of(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> idx!=<span class="number">-1</span> ? c.substr(idx) : <span class="string">&quot;0&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="大数取模"><a href="#大数取模" class="headerlink" title="大数取模"></a>大数取模</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mod</span><span class="params">(<span class="type">char</span> str[],<span class="type">int</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> number[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(str);i++)</span><br><span class="line">    	number[i]=str[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(str);i++)<span class="comment">//大数取模就是按照每一位取模,不断重复</span></span><br><span class="line">    &#123;</span><br><span class="line">        sum=((<span class="type">long</span> <span class="type">long</span>)sum*<span class="number">10</span>+number[i])%c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="比较大小"><a href="#比较大小" class="headerlink" title="比较大小"></a>比较大小</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">cmp</span><span class="params">(<span class="built_in">string</span> a,<span class="built_in">string</span> b)</span>&#123;</span><br><span class="line">    <span class="type">int</span> idx1 = a.find_first_not_of(<span class="string">&#x27;0&#x27;</span>),idx2 = b.find_first_not_of(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    a = idx1!=<span class="number">-1</span>? a.substr(idx1) : <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    b = idx2!=<span class="number">-1</span>? b.substr(idx2) : <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(a.size() != b.size()) <span class="keyword">return</span> a.size() &gt;= b.size();</span><br><span class="line">    <span class="keyword">return</span> a&gt;=b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>告诉你个秘密点击下面的赏字就能赞助我了哦（owo）</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>高精</tag>
      </tags>
  </entry>
  <entry>
    <title>皇后问题</title>
    <url>/posts/c4be8714.html</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>题目描述</p>
<p>一个如下的 6×6 的跳棋棋盘，有六个棋子被放置在棋盘上，使得每行、每列有且只有一个，每条对角线（包括两条主对角线的所有平行线）上至多有一个棋子。</p>
<p><img src="https://cdn.luogu.com.cn/upload/pic/60.png" alt=""></p>
<p>上面的布局可以用序列 2 4 6 1 3 5 来描述，第 i 个数字表示在第 i 行的相应位置有一个棋子，如下：</p>
<p>行号 1 2 3 4 5 6</p>
<p>列号 2 4 6 1 3 5</p>
<p>这只是棋子放置的一个解。请编一个程序找出所有棋子放置的解。<br>并把它们以上面的序列方法输出，解按字典顺序排列。<br>请输出前 333 个解。最后一行是解的总个数。</p>
<p>输入格式</p>
<p>一行一个正整数 n，表示棋盘是 n×n 大小的。</p>
<p>输出格式</p>
<p>前三行为前三个解，每个解的两个数字之间用一个空格隔开。第四行只有一个数字，表示解的总数。<br>输入输出样例</p>
<p>输入 #1</p>
<p>6</p>
<p>输出 #1</p>
<p>2 4 6 1 3 5</p>
<p>3 6 2 5 1 4</p>
<p>4 1 5 2 6 3</p>
<p>4</p>
<p>说明/提示</p>
<p>【数据范围】<br>对于 100%100\%100% 的数据，6≤n≤136 \le n \le 136≤n≤13。</p>
<p>题目翻译来自NOCOW。</p>
<p>USACO Training Section 1.5</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int col[20],l[100],r[100],a[100],n,cnt;</span><br><span class="line">void queen(int i)&#123;</span><br><span class="line">	if(i&gt;n)&#123;</span><br><span class="line">		if(cnt&lt;3) for(int j=1;j&lt;=n;j++) printf(&quot;%d%c&quot;,a[j],j==n?&#x27;\n&#x27;:&#x27; &#x27;);</span><br><span class="line">		cnt++; return;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">		if(!col[j]&amp;&amp;!l[n-i+j]&amp;&amp;!r[i+j-1])&#123;</span><br><span class="line">			a[i]=j;</span><br><span class="line">			col[j]=1; l[n-i+j]=1; r[i+j-1]=1;</span><br><span class="line">			queen(i+1);</span><br><span class="line">			col[j]=0; l[n-i+j]=0; r[i+j-1]=0;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return ;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	queen(1);</span><br><span class="line">	cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>基础算法练习</title>
    <url>/posts/d2d64791.html</url>
    <content><![CDATA[<h2 id="A-前M大的数"><a href="#A-前M大的数" class="headerlink" title="A 前M大的数"></a>A 前M大的数</h2><p>暴力累加每两组数，再排序输出前M个<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#define ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0) </span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN=3e3+100;</span><br><span class="line">int v1[MAXN],v2[5000000];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">//	ios;</span><br><span class="line">    int n,m;</span><br><span class="line">	while(scanf(&quot;%d %d&quot;,&amp;n,&amp;m)!=EOF)&#123;</span><br><span class="line">		for(int i=1;i&lt;=n;i++) cin&gt;&gt;v1[i];</span><br><span class="line">		int tail=0;</span><br><span class="line">		for(int i=1;i&lt;n;i++)&#123;</span><br><span class="line">			for(int j=i+1;j&lt;=n;j++)&#123;</span><br><span class="line">				v2[++tail]=v1[i]+v1[j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		sort(v2+1,v2+1+tail);</span><br><span class="line">		int len=tail-m;</span><br><span class="line">		for(int i=tail;i&gt;len;i--)&#123;</span><br><span class="line">			if(i!=len+1) cout&lt;&lt;v2[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">			else cout&lt;&lt;v2[i]&lt;&lt;&#x27;\n&#x27;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="B-稳定排序"><a href="#B-稳定排序" class="headerlink" title="B 稳定排序"></a>B 稳定排序</h2><p>注意sort不是稳定的，用stable_sort排再一一比较<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#define ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0) </span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN=3e3+100;</span><br><span class="line">struct node&#123;</span><br><span class="line">	int score;</span><br><span class="line">	string name;</span><br><span class="line">&#125;stu[400],stu2[400];</span><br><span class="line">bool cmp(node a,node b)&#123;</span><br><span class="line">	return a.score&gt;b.score;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">//	ios;</span><br><span class="line">    int n;</span><br><span class="line">	while(scanf(&quot;%d&quot;,&amp;n)!=EOF)&#123;</span><br><span class="line">		for(int i=1;i&lt;=n;i++) cin&gt;&gt;stu[i].name&gt;&gt;stu[i].score;</span><br><span class="line">		for(int i=1;i&lt;=n;i++) cin&gt;&gt;stu2[i].name&gt;&gt;stu2[i].score;</span><br><span class="line">		stable_sort(stu+1,stu+1+n,cmp);</span><br><span class="line">		int flag=0,book=0;</span><br><span class="line">		for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">			if(stu[i].score!=stu2[i].score)&#123;</span><br><span class="line">				flag=1;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">			if(stu[i].name!=stu2[i].name)&#123;</span><br><span class="line">				book=1;</span><br><span class="line">				break;</span><br><span class="line">			&#125; </span><br><span class="line">		&#125; </span><br><span class="line">		if(flag==1)&#123;</span><br><span class="line">			cout&lt;&lt;&quot;Error&quot;&lt;&lt;endl;</span><br><span class="line">			for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">				cout&lt;&lt;stu[i].name&lt;&lt;&quot; &quot;&lt;&lt;stu[i].score&lt;&lt;endl;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			if(book==1)&#123;</span><br><span class="line">				cout&lt;&lt;&quot;Not Stable&quot;&lt;&lt;endl;</span><br><span class="line">				for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">					cout&lt;&lt;stu[i].name&lt;&lt;&quot; &quot;&lt;&lt;stu[i].score&lt;&lt;endl;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;else cout&lt;&lt;&quot;Right&quot;&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="C-开门人和关门人"><a href="#C-开门人和关门人" class="headerlink" title="C 开门人和关门人"></a>C 开门人和关门人</h2><p>技巧在于时间可以用字符串来代替，因为时间长度都是一样的<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#define ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0) </span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN=3e3+100;</span><br><span class="line">struct node&#123;</span><br><span class="line">	string name,qt,ht;</span><br><span class="line">&#125;stu[4000];</span><br><span class="line">bool cmp(node a,node b)&#123;</span><br><span class="line">	return a.qt&lt;b.qt;</span><br><span class="line">&#125;</span><br><span class="line">bool cmp1(node a,node b)&#123;</span><br><span class="line">	return a.ht&gt;b.ht;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">//	ios;</span><br><span class="line">    int n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	while(n--)&#123;</span><br><span class="line">		int m; cin&gt;&gt;m;</span><br><span class="line">		for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">			cin&gt;&gt;stu[i].name&gt;&gt;stu[i].qt&gt;&gt;stu[i].ht;</span><br><span class="line">		&#125; </span><br><span class="line">		sort(stu+1,stu+1+m,cmp);</span><br><span class="line">		cout&lt;&lt;stu[1].name&lt;&lt;&quot; &quot;;</span><br><span class="line">		sort(stu+1,stu+1+m,cmp1);</span><br><span class="line">		cout&lt;&lt;stu[1].name&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="D-EXCEL排序"><a href="#D-EXCEL排序" class="headerlink" title="D EXCEL排序"></a>D EXCEL排序</h2><p>注意字典序排序不是长的字符串大于短的字符串，而是一个个比较，遇到第一个不同的那个大那个字符串就大，当每个字符都一样则谁长谁大，strcmp也是如此<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN=1e5+100;</span><br><span class="line">struct node&#123;</span><br><span class="line">	string name,id;</span><br><span class="line">	int score;</span><br><span class="line">&#125;stu[MAXN]; </span><br><span class="line">bool cmp(node a,node b)&#123;</span><br><span class="line">	return a.id&lt;b.id;</span><br><span class="line">&#125;</span><br><span class="line">bool cmp1(node a,node b)&#123;</span><br><span class="line">	if(a.name==b.name) return a.id&lt;b.id;</span><br><span class="line">	return a.name&lt;b.name;</span><br><span class="line">&#125;</span><br><span class="line">bool cmp2(node a,node b)&#123;</span><br><span class="line">	if(a.score==b.score) return a.id&lt;b.id;</span><br><span class="line">	return a.score&lt;b.score;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n,c,kase=0;</span><br><span class="line">	while(cin&gt;&gt;n&gt;&gt;c)&#123;</span><br><span class="line">		if(n==0) break;</span><br><span class="line">		for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">			stu[i].id.clear();</span><br><span class="line">			stu[i].name.clear();</span><br><span class="line">		&#125;</span><br><span class="line">		for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">			cin&gt;&gt;stu[i].id&gt;&gt;stu[i].name&gt;&gt;stu[i].score;</span><br><span class="line">		&#125;</span><br><span class="line">		if(c==1) sort(stu,stu+n,cmp);</span><br><span class="line">		if(c==2) sort(stu,stu+n,cmp1);</span><br><span class="line">		if(c==3) sort(stu,stu+n,cmp2);</span><br><span class="line">		printf(&quot;Case %d:\n&quot;,++kase);</span><br><span class="line">		for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">			cout&lt;&lt;stu[i].id&lt;&lt;&quot; &quot;&lt;&lt;stu[i].name&lt;&lt;&quot; &quot;&lt;&lt;stu[i].score&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="E-A-B"><a href="#E-A-B" class="headerlink" title="E - {A} + {B}"></a>E - {A} + {B}</h2><p>用一个set来存，或者用桶标记,或者用unique去重<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#define ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0) </span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN=1e5+100;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">//	ios;</span><br><span class="line">	int n,m;</span><br><span class="line">    while(cin&gt;&gt;n&gt;&gt;m)&#123;</span><br><span class="line">    	set&lt;int&gt; st;</span><br><span class="line">    	for(int i=0;i&lt;n+m;i++)&#123;</span><br><span class="line">    		int t; cin&gt;&gt;t;</span><br><span class="line">    		st.insert(t);</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;*st.begin();</span><br><span class="line">		st.erase(st.begin());</span><br><span class="line">		while(!st.empty())&#123;</span><br><span class="line">			cout&lt;&lt;&quot; &quot;&lt;&lt;*st.begin(); </span><br><span class="line">			st.erase((st.begin()));</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="F-水果"><a href="#F-水果" class="headerlink" title="F - 水果"></a>F - 水果</h2><p>因为这道题涉及到求和的问题，直接用数组来做的话我觉得非常难输出，用map挺简单的，就是不熟练<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct node&#123;</span><br><span class="line">	map&lt;string,int&gt; mp;</span><br><span class="line">&#125;; </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	map&lt;string,node&gt; ma;</span><br><span class="line">	map&lt;string,node&gt;::iterator it;</span><br><span class="line">	map&lt;string,int&gt;::iterator mpit;</span><br><span class="line">	string f,p;</span><br><span class="line">	int cnt;</span><br><span class="line">	int n,t;</span><br><span class="line">	cin&gt;&gt;t;</span><br><span class="line">	while(t--)&#123;</span><br><span class="line">		ma.clear();</span><br><span class="line">		cin&gt;&gt;n;</span><br><span class="line">		while(n--)&#123;</span><br><span class="line">			cin&gt;&gt;f&gt;&gt;p&gt;&gt;cnt;</span><br><span class="line">			ma[p].mp[f]+=cnt;</span><br><span class="line">		&#125;</span><br><span class="line">		for(it=ma.begin();it!=ma.end();it++)&#123;</span><br><span class="line">			cout&lt;&lt;it-&gt;first&lt;&lt;endl;</span><br><span class="line">			for(mpit=it-&gt;second.mp.begin();mpit!=it-&gt;second.mp.end();mpit++)&#123;</span><br><span class="line">				cout&lt;&lt;&quot;   |----&quot;&lt;&lt;mpit-&gt;first&lt;&lt;&quot;(&quot;&lt;&lt;mpit-&gt;second&lt;&lt;&quot;)&quot;&lt;&lt;endl;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if(t!=0) cout&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="G-不重复数字"><a href="#G-不重复数字" class="headerlink" title="G - 不重复数字"></a>G - 不重复数字</h2><p>用桶标记或者用map性质一样，都是桶标记的思想<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#define ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0) </span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN=1e5+100;</span><br><span class="line">int val[MAXN];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">//	ios;</span><br><span class="line">	int t;</span><br><span class="line">	cin&gt;&gt;t;</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">    	map&lt;int,int&gt; st;</span><br><span class="line">    	int n,maxx=-1e9,tail=0;</span><br><span class="line">    	cin&gt;&gt;n;</span><br><span class="line">    	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">    		int tt; cin&gt;&gt;tt;</span><br><span class="line">    		maxx=max(maxx,tt);</span><br><span class="line">    		val[++tail]=tt;</span><br><span class="line">    		st[tt]=1;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;val[1];</span><br><span class="line">		st[val[1]]=0;</span><br><span class="line">    	for(int i=2;i&lt;=tail;i++)&#123;</span><br><span class="line">    		if(st[val[i]])&#123;</span><br><span class="line">    			cout&lt;&lt;&#x27; &#x27;&lt;&lt;val[i];</span><br><span class="line">    			st[val[i]]=0;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="H-表达式括号匹配"><a href="#H-表达式括号匹配" class="headerlink" title="H - 表达式括号匹配"></a>H - 表达式括号匹配</h2><p>用栈遇到一个左括号就入栈，遇到一个右括号如果栈里有元素就出栈，最后看看栈是否为空<br>昨天代码写的有问题，有一点xiao bug，改了一下，这没问题了<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	string sh;</span><br><span class="line">	cin&gt;&gt;sh;</span><br><span class="line">	stack&lt;char&gt; st;</span><br><span class="line">	for(int i=0;i&lt;sh.size();i++)&#123;</span><br><span class="line">		if(sh[i]==&#x27;(&#x27;) st.push(sh[i]);</span><br><span class="line">		if(sh[i]==&#x27;)&#x27;)&#123;</span><br><span class="line">			if(st.empty())&#123;</span><br><span class="line">				cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;</span><br><span class="line">				return 0;</span><br><span class="line">			&#125;else&#123;</span><br><span class="line">				st.pop();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if(!st.empty()) cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;</span><br><span class="line">	else cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="I-合并果子"><a href="#I-合并果子" class="headerlink" title="I - 合并果子"></a>I - 合并果子</h2><p>每次合并最小的两个代价最小，每次排序合并，直到最后剩一堆<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int a[1001];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int t;</span><br><span class="line">	cin&gt;&gt;t;</span><br><span class="line">	while(t--)&#123;</span><br><span class="line">		int n;</span><br><span class="line">		cin&gt;&gt;n;</span><br><span class="line">		for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i];</span><br><span class="line">		sort(a,a+n);</span><br><span class="line">		long long sum=0;</span><br><span class="line">		int head=0;</span><br><span class="line">		while(head+1&lt;n)&#123;</span><br><span class="line">			sum+=a[head]+a[head+1];</span><br><span class="line">			a[head+1]+=a[head];</span><br><span class="line">			if(a[head+1]&gt;a[head+2]) sort(a+head+1,a+n);</span><br><span class="line">			head++;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="J-Covered-Points-Count"><a href="#J-Covered-Points-Count" class="headerlink" title="J - Covered Points Count"></a>J - Covered Points Count</h2><p>这道题用了离散化和差分，我这里还不熟，俩星期前我专门做了几道这种题，当时明白了，过了俩星期又忘了，现在还有些迷<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxn=2e5+100;</span><br><span class="line">struct node&#123;</span><br><span class="line">	ll x,y;</span><br><span class="line">&#125;p[maxn];</span><br><span class="line">ll a[maxn&lt;&lt;1],b[maxn&lt;&lt;1],c[maxn];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	ios::sync_with_stdio(false);</span><br><span class="line">	int n,tail=0; cin&gt;&gt;n;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;p[i].x&gt;&gt;p[i].y;</span><br><span class="line">		a[++tail]=p[i].x;</span><br><span class="line">		a[++tail]=p[i].y+1; </span><br><span class="line">	&#125;</span><br><span class="line">	sort(a+1,a+1+tail);</span><br><span class="line">	int len=unique(a+1,a+1+tail)-a-1;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		int x=lower_bound(a+1,a+1+len,p[i].x)-a;</span><br><span class="line">		int y=lower_bound(a+1,a+1+len,p[i].y+1)-a;</span><br><span class="line">		b[x]++;b[y]--;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=1;i&lt;=len;i++)&#123;</span><br><span class="line">		b[i]+=b[i-1];</span><br><span class="line">		c[b[i]]+=a[i+1]-a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=1;i&lt;=n;i++) printf(&quot;%lld%c&quot;,c[i],i==n?&#x27;\n&#x27;:&#x27; &#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="K-Ignatius-and-the-Princess-IV"><a href="#K-Ignatius-and-the-Princess-IV" class="headerlink" title="K - Ignatius and the Princess IV"></a>K - Ignatius and the Princess IV</h2><p>非常水的题<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxn=2e5+100;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n;</span><br><span class="line">	while(cin&gt;&gt;n)&#123;</span><br><span class="line">		map&lt;int,int&gt; mp;</span><br><span class="line">		int temp=n;</span><br><span class="line">		while(n--)&#123;</span><br><span class="line">			int t; cin&gt;&gt;t;</span><br><span class="line">			mp[t]++;</span><br><span class="line">		&#125;</span><br><span class="line">		map&lt;int,int&gt;::iterator it;</span><br><span class="line">		for(it=mp.begin();it!=mp.end();it++)&#123;</span><br><span class="line">			if(it-&gt;second&gt;=(temp+1)/2)&#123;</span><br><span class="line">				cout&lt;&lt;it-&gt;first&lt;&lt;endl;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="L-Stones"><a href="#L-Stones" class="headerlink" title="L - Stones"></a>L - Stones</h2><p>这道题用优先队列模拟，主要是排列方式如何自定义，这个我今天才学，只会个基础<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">typedef pair&lt;int,int&gt; pr;</span><br><span class="line">struct node&#123;</span><br><span class="line">	int pos,dis;</span><br><span class="line">	friend bool operator &lt;(const node a,const node b)&#123;</span><br><span class="line">		if(a.pos==b.pos) return a.dis&gt;b.dis;</span><br><span class="line">		return a.pos&gt;b.pos;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int t;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">	while(t--)&#123;</span><br><span class="line">		priority_queue&lt;node&gt; oq;</span><br><span class="line">		int n; </span><br><span class="line">		scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">		for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">			node r;</span><br><span class="line">			scanf(&quot;%d %d&quot;,&amp;r.pos,&amp;r.dis);</span><br><span class="line">			oq.push(r);</span><br><span class="line">		&#125;</span><br><span class="line">		int cnt=1;</span><br><span class="line">		node y;</span><br><span class="line">		while(!oq.empty())&#123;</span><br><span class="line">			node x=oq.top();</span><br><span class="line">			oq.pop();</span><br><span class="line">			if(cnt&amp;1)&#123;</span><br><span class="line">				y.pos=x.pos+x.dis;;</span><br><span class="line">				y.dis=x.dis;</span><br><span class="line">				oq.push(y);</span><br><span class="line">			&#125;</span><br><span class="line">			cnt++;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%d\n&quot;,y.pos);</span><br><span class="line">	&#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="M-SnowWolf’s-Wine-Shop"><a href="#M-SnowWolf’s-Wine-Shop" class="headerlink" title="M - SnowWolf’s Wine Shop"></a>M - SnowWolf’s Wine Shop</h2><p>做了无数遍的题<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxn=2e5+100;</span><br><span class="line">multiset&lt;int&gt; mt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int t; cin&gt;&gt;t; int kase=0;</span><br><span class="line">	while(t--)&#123;</span><br><span class="line">		mt.clear();</span><br><span class="line">		printf(&quot;Case %d:\n&quot;,++kase);</span><br><span class="line">		int n,q,y;</span><br><span class="line">		cin&gt;&gt;n&gt;&gt;q&gt;&gt;y;</span><br><span class="line">		for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">			int tt; cin&gt;&gt;tt;</span><br><span class="line">			mt.insert(tt);</span><br><span class="line">		&#125;</span><br><span class="line">		while(q--)&#123;</span><br><span class="line">			int v; cin&gt;&gt;v;</span><br><span class="line">			auto it=mt.lower_bound(v);</span><br><span class="line">			if(it==mt.end()||*it-y&gt;v) printf(&quot;-1\n&quot;);</span><br><span class="line">			else&#123;</span><br><span class="line">				printf(&quot;%d\n&quot;,*it);</span><br><span class="line">				mt.erase(it);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="N-Alice-Bob-and-Candies"><a href="#N-Alice-Bob-and-Candies" class="headerlink" title="N - Alice, Bob and Candies"></a>N - Alice, Bob and Candies</h2><p>双指针模拟，以前不自信，总是不敢用STL，现在发现所谓STL也不过如此，加上我两分钟写好的双向队列代码🐷<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">deque&lt;int&gt; dq;</span><br><span class="line">int main()</span><br><span class="line">&#123;	</span><br><span class="line">	int t;</span><br><span class="line">	cin&gt;&gt;t;</span><br><span class="line">	while(t--)&#123;</span><br><span class="line">		dq.clear();</span><br><span class="line">		int n; cin&gt;&gt;n;</span><br><span class="line">		for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">			int temp; cin&gt;&gt;temp;</span><br><span class="line">			dq.push_back(temp);</span><br><span class="line">		&#125;</span><br><span class="line">		ll pa=0,pb=0,suma=0,sumb=0,res=1,ansa=0,ansb=0,cnt=0;</span><br><span class="line">		while(!dq.empty())&#123;</span><br><span class="line">			cnt++;</span><br><span class="line">			suma=sumb=0;</span><br><span class="line">			if(res&amp;1)&#123;</span><br><span class="line">				while(suma&lt;=pb&amp;&amp;!dq.empty())&#123;</span><br><span class="line">					suma+=dq.front();</span><br><span class="line">					dq.pop_front();</span><br><span class="line">				&#125;</span><br><span class="line">				ansa+=suma; </span><br><span class="line">				pa=suma;</span><br><span class="line">			&#125;else&#123;</span><br><span class="line">				while(sumb&lt;=pa&amp;&amp;!dq.empty())&#123;</span><br><span class="line">					sumb+=dq.back();</span><br><span class="line">					dq.pop_back();</span><br><span class="line">				&#125;</span><br><span class="line">				ansb+=sumb;</span><br><span class="line">				pb=sumb;</span><br><span class="line">			&#125;</span><br><span class="line">			res++;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;cnt&lt;&lt;&quot; &quot;&lt;&lt;ansa&lt;&lt;&quot; &quot;&lt;&lt;ansb&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#define ios ios::sync_with_stdio(0)</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN=1e4;</span><br><span class="line">int val[MAXN];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	int t; cin&gt;&gt;t;</span><br><span class="line">	while(t--)&#123;</span><br><span class="line">		int n,pa=0,pb=0,flg=0;; cin&gt;&gt;n;</span><br><span class="line">		int sum=0;</span><br><span class="line">		for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">			cin&gt;&gt;val[i];</span><br><span class="line">			sum+=val[i];</span><br><span class="line">		&#125;</span><br><span class="line">		int ea=0,eb=0,cnt=1,sa,sb,head=1,tail=n;</span><br><span class="line">		while(tail-head&gt;=0)&#123;</span><br><span class="line">			sa=0; sb=0;</span><br><span class="line">			if(flg==0&amp;&amp;sum-ea-eb&gt;pb)&#123;</span><br><span class="line">				while(sa&lt;=pb)&#123;</span><br><span class="line">					sa+=val[head];</span><br><span class="line">					ea+=val[head];</span><br><span class="line">					head++; </span><br><span class="line">				&#125;</span><br><span class="line">				pa=sa; flg=1; cnt++;</span><br><span class="line">				continue;</span><br><span class="line">			&#125;</span><br><span class="line">			if(flg==1&amp;&amp;sum-ea-eb&gt;pa)&#123;</span><br><span class="line">				while(sb&lt;=pa)&#123;</span><br><span class="line">					sb+=val[tail];</span><br><span class="line">					eb+=val[tail];</span><br><span class="line">					tail--;</span><br><span class="line">				&#125;</span><br><span class="line">				pb=sb; flg=0; cnt++;</span><br><span class="line">				continue;</span><br><span class="line">			&#125;</span><br><span class="line">			cnt++;</span><br><span class="line">			if(flg==0)&#123;</span><br><span class="line">				ea+=sum-ea-eb;</span><br><span class="line">				break;</span><br><span class="line">			&#125;else&#123;</span><br><span class="line">				eb+=sum-ea-eb;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;cnt-1&lt;&lt;&quot; &quot;&lt;&lt;ea&lt;&lt;&quot; &quot;&lt;&lt;eb&lt;&lt;&quot; &quot;&lt;&lt;endl;</span><br><span class="line">	&#125; </span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="O-Special-Elements"><a href="#O-Special-Elements" class="headerlink" title="O - Special Elements"></a>O - Special Elements</h2><p>div4的那道桶标记，用前缀和把复杂度将为O(1)，就做出来了<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#define ios ios::sync_with_stdio(0)</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN=1e4;</span><br><span class="line">int val[MAXN],book[MAXN];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	int t; cin&gt;&gt;t;</span><br><span class="line">	while(t--)&#123;</span><br><span class="line">		memset(book,0,sizeof book);</span><br><span class="line">		memset(val,0,sizeof val);</span><br><span class="line">		int n; cin&gt;&gt;n;</span><br><span class="line">		for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">			cin&gt;&gt;val[i];</span><br><span class="line">			book[val[i]]++;</span><br><span class="line">			val[i]+=val[i-1];</span><br><span class="line">		&#125;</span><br><span class="line">		int cnt=0;</span><br><span class="line">		for(int i=0;i&lt;n-1;i++)&#123;</span><br><span class="line">			for(int j=i+2;j&lt;=n;j++)&#123;</span><br><span class="line">				int sum=val[j]-val[i];</span><br><span class="line">//				cout&lt;&lt;sum&lt;&lt;&#x27; &#x27;&lt;&lt;book[sum]&lt;&lt;endl;</span><br><span class="line">				if(sum&lt;=n&amp;&amp;book[sum])&#123;</span><br><span class="line">					cnt+=book[sum]; 					</span><br><span class="line">					book[sum]=0;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">	&#125; </span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="P-Max-Sum"><a href="#P-Max-Sum" class="headerlink" title="P - Max Sum"></a>P - Max Sum</h2><p>这道题有点dp的味道，我觉得有点难，反正我没做出来，查了以前的代码才懂了，不过说实话这思路稍微把题目变一下我不知道还能做出来不能，这道题很坑的是用C++可以过，G++不行<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#define ios ios::sync_with_stdio(0)</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN=1e5+100;</span><br><span class="line">int val[MAXN];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	int t,kase=0; cin&gt;&gt;t;</span><br><span class="line">	while(t--)&#123;</span><br><span class="line">		memset(val,0,sizeof val);</span><br><span class="line">		int n; cin&gt;&gt;n;</span><br><span class="line">		for(int i=1;i&lt;=n;i++) cin&gt;&gt;val[i];</span><br><span class="line">		int summax=-1e9,b=0,e=0,k=1,sum=0; </span><br><span class="line">		for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">			sum+=val[i];</span><br><span class="line">			if(sum&gt;summax)&#123;</span><br><span class="line">				b=k;</span><br><span class="line">				e=i;</span><br><span class="line">				summax=sum;</span><br><span class="line">			&#125;</span><br><span class="line">			if(sum&lt;0)&#123;</span><br><span class="line">				sum=0;</span><br><span class="line">				k=i+1;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;Case %d:\n&quot;,++kase);</span><br><span class="line">		cout&lt;&lt;summax&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;&quot; &quot;&lt;&lt;e&lt;&lt;endl;</span><br><span class="line">//		printf(&quot;Case %d:\n%d %d %d\n&quot;,++kase,summax,b,e);</span><br><span class="line">		if(t!=0) printf(&quot;\n&quot;);</span><br><span class="line">//		if(t!=0) cout&lt;&lt;endl; </span><br><span class="line">	&#125; </span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以后尽量都用scanf和printf吧，这两个最稳定，不会报稀奇古怪的错误，然后记得字典序比较不是长的大于短的，记得字典序的排列方式，当用容器时一定记得判断容器中有没有元素，有了再pop，sort是不稳定排序，cin和cout配套,scanf和printf配套，两者不要混用</p>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>基础算法练习</tag>
      </tags>
  </entry>
  <entry>
    <title>基础算法2(快速幂，二分)</title>
    <url>/posts/8f3622b8.html</url>
    <content><![CDATA[<blockquote>
<p>发现了一些快速幂上的小问题，可以说很细节的问题了，导致我第一题巨水的一道题wrong了5次！！当时都懵了，感觉代码一点毛病都没有🐷（菜是原罪）</p>
</blockquote>
<font color="red">
把这次我在快速幂模板上踩的坑说一下，看下面两段代码
</font>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">代码一</span><br><span class="line">ll qpow(ll a,ll b)&#123;</span><br><span class="line">	if(b==0) return 1;</span><br><span class="line">	ll ans=qpow(a,b&gt;&gt;1)%MOD;</span><br><span class="line">	ans*=ans%MOD;</span><br><span class="line">	if(b&amp;1) ans*=a%MOD;</span><br><span class="line">	return ans%MOD;</span><br><span class="line">&#125;</span><br><span class="line">代码二</span><br><span class="line">ll qpow(ll a,ll b)&#123;</span><br><span class="line">	if(b==0) return 1;</span><br><span class="line">	ll ans=qpow(a,b&gt;&gt;1)%MOD;</span><br><span class="line">	ans=ans*ans%MOD;</span><br><span class="line">	if(b&amp;1) ans=ans*a%MOD;</span><br><span class="line">	return ans%MOD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<font color="red">
看着这两段代码没啥区别，就是把ans=ans*ans改成了ans*=ans，如果没有取模的话这俩没有任何区别，但是一旦取模就是AC和wrong的天壤之别，为什么？首先看ans*=ans%MOD这一段首先计算ans%MOD，我们要保证的是ans计算完必须要比MOD小，因为取余嘛！但是这一段代码先算ans%MOD的话，可能算出来的数跟MOD相差无几，再乘以ans的话就大于MOD了，直接升天，最后debug时真的直接就忽略了这个🙃
</font>

<h2 id="Pseudoprime-numbers"><a href="#Pseudoprime-numbers" class="headerlink" title="Pseudoprime numbers"></a>Pseudoprime numbers</h2><p><strong>题意:</strong>  </p>
<p>如果p是非质数，算a^p^%p是否==a，是的话输出yes否则输出no，否则输出no</p>
<p><del>很水的题，我在坑里跳了5次，，一直以为是cin，cout又在捣鬼，换了几次一直爆零</del></p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">ll MOD;</span><br><span class="line">ll qpow(ll a,ll b)&#123;</span><br><span class="line">	if(b==0) return 1;</span><br><span class="line">	ll ans=qpow(a,b&gt;&gt;1)%MOD;</span><br><span class="line">	ans=ans*ans%MOD;</span><br><span class="line">	if(b&amp;1) ans=ans*a%MOD;</span><br><span class="line">	return ans%MOD;</span><br><span class="line">&#125;</span><br><span class="line">int jug(ll p)&#123;</span><br><span class="line">	for(int i=2;i*i&lt;=p;i++)&#123;</span><br><span class="line">		if(p%i==0) return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	ll p,a;</span><br><span class="line">	while(scanf(&quot;%lld %lld&quot;,&amp;p,&amp;a)!=EOF )&#123;</span><br><span class="line">		if(a==p&amp;&amp;p==0) break;</span><br><span class="line">		MOD=p;</span><br><span class="line">		if(jug(p)) printf(&quot;no\n&quot;);</span><br><span class="line">		else&#123;</span><br><span class="line">			if(qpow(a,p)==a) printf(&quot;yes\n&quot;);</span><br><span class="line">			else printf(&quot;no\n&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Raising-Modulo-Numbers"><a href="#Raising-Modulo-Numbers" class="headerlink" title="Raising Modulo Numbers"></a>Raising Modulo Numbers</h2><p><strong>题意</strong><br>T组，M，H小组</p>
<p>每小组给出a，b的值，求a1^b1^+ a2^b2^+ …+an^bn^之和mod M的值</p>
<h3 id="CODE-1"><a href="#CODE-1" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">ll MOD;</span><br><span class="line">ll qpow(ll a, ll n) &#123;</span><br><span class="line">    ll res=1;</span><br><span class="line">    while(n)&#123;</span><br><span class="line">        if(n&amp;1) res=res*a%MOD;</span><br><span class="line">        a=a*a%MOD;</span><br><span class="line">        n&gt;&gt;=1;</span><br><span class="line">    &#125;</span><br><span class="line">    return res%MOD ;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	ll t,m,h; scanf(&quot;%lld&quot;,&amp;t);</span><br><span class="line">	while(t--)&#123;</span><br><span class="line">		scanf(&quot;%lld%lld&quot;,&amp;m,&amp;h);</span><br><span class="line">		ll sum=0;</span><br><span class="line">		MOD=m;</span><br><span class="line">		for(int i=1;i&lt;=h;i++)&#123;</span><br><span class="line">			ll a1,a2; scanf(&quot;%lld %lld&quot;,&amp;a1,&amp;a2);</span><br><span class="line">			sum+=qpow(a1,a2);</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%lld\n&quot;,sum%MOD);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Key-Set"><a href="#Key-Set" class="headerlink" title="Key Set"></a>Key Set</h2><p><strong>题意</strong><br>给你一个具有n个元素的集合S{1,2,…,n}，问集合S的非空子集中元素和为偶数的非空子集有多少个取模1000000007。<br><strong>解</strong><br>找规律，公式2^(n-1)^-1</p>
<h3 id="CODE-2"><a href="#CODE-2" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">ll MOD=1000000007;</span><br><span class="line">ll qpow(ll a, ll n) &#123;</span><br><span class="line">    ll res=1;</span><br><span class="line">    while(n)&#123;</span><br><span class="line">        if(n&amp;1) res=res*a%MOD;</span><br><span class="line">        a=a*a%MOD;</span><br><span class="line">        n&gt;&gt;=1;</span><br><span class="line">    &#125;</span><br><span class="line">    return res ;</span><br><span class="line">&#125;</span><br><span class="line">int jug(ll p)&#123;</span><br><span class="line">	for(int i=2;i*i&lt;=p;i++)&#123;</span><br><span class="line">		if(p%i==0) return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	ll a,t; scanf(&quot;%lld&quot;,&amp;t);</span><br><span class="line">	while(t--)&#123;</span><br><span class="line">		scanf(&quot;%lld&quot;,&amp;a);</span><br><span class="line">		a-=1;</span><br><span class="line">		printf(&quot;%lld\n&quot;,qpow(2,a)-1);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Distribution-money"><a href="#Distribution-money" class="headerlink" title="Distribution money"></a>Distribution money</h2><p><strong>题意</strong><br>随意排队领薪金，如果一个人领的超过其他人的总和那么这个人将受到惩罚输出这个人的工号，如果没人领的薪金超过其他人的总和输出-1<br><strong>解</strong><br>总共薪金是n，某个人可能领x，那么其他人的总和就是n-x，如果x&gt;n-x即x&gt;n/2，那么这个人领的薪金就超过其他人输出这个人的工号  </p>
<h3 id="CODE-3"><a href="#CODE-3" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int MAXN=1e4+100;</span><br><span class="line">ll MOD;</span><br><span class="line">ll qpow(ll a, ll n) &#123;</span><br><span class="line">    ll res=1;</span><br><span class="line">    while(n)&#123;</span><br><span class="line">        if(n&amp;1) res=res*a%MOD;</span><br><span class="line">        a=a*a%MOD;</span><br><span class="line">        n&gt;&gt;=1;</span><br><span class="line">    &#125;</span><br><span class="line">    return res%MOD ;</span><br><span class="line">&#125;</span><br><span class="line">int b[MAXN];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n,maxx=-1e9,id;</span><br><span class="line">	while(~scanf(&quot;%d&quot;,&amp;n))&#123;</span><br><span class="line">		memset(b,0,sizeof b);</span><br><span class="line">		id=-1;</span><br><span class="line">		for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">			int t;</span><br><span class="line">			scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">			b[t]++;</span><br><span class="line">		&#125; </span><br><span class="line">		for(int i=1;i&lt;=MAXN-10;i++)&#123;</span><br><span class="line">			if(b[i]&gt;n/2)&#123;</span><br><span class="line">				id=i;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%d\n&quot;,id);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Rightmost-Digit"><a href="#Rightmost-Digit" class="headerlink" title="Rightmost Digit"></a>Rightmost Digit</h2><p><strong>题意</strong><br>是输出一个数的几次方最右面的数字<br><strong>解</strong><br>快速幂对10取余</p>
<h3 id="CODE-4"><a href="#CODE-4" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">ll MOD=10;</span><br><span class="line">ll qpow(ll a, ll n) &#123;</span><br><span class="line">    ll res=1;</span><br><span class="line">    while(n)&#123;</span><br><span class="line">        if(n&amp;1) res=res*a%MOD;</span><br><span class="line">        a=a*a%MOD;</span><br><span class="line">        n&gt;&gt;=1;</span><br><span class="line">    &#125;</span><br><span class="line">    return res ;</span><br><span class="line">&#125;</span><br><span class="line">int jug(ll p)&#123;</span><br><span class="line">	for(int i=2;i*i&lt;=p;i++)&#123;</span><br><span class="line">		if(p%i==0) return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	ll a,t; scanf(&quot;%lld&quot;,&amp;t);</span><br><span class="line">	while(t--)&#123;</span><br><span class="line">		scanf(&quot;%lld&quot;,&amp;a);</span><br><span class="line">		printf(&quot;%lld\n&quot;,qpow(a,a));</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="人见人爱A-B"><a href="#人见人爱A-B" class="headerlink" title="人见人爱A^B"></a>人见人爱A^B</h2><p><strong>题意</strong><br>不说了<br><strong>解</strong><br>略  </p>
<h3 id="CODE-5"><a href="#CODE-5" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">ll MOD=1000;</span><br><span class="line">ll qpow(ll a, ll n) &#123;</span><br><span class="line">    ll res=1;</span><br><span class="line">    while(n)&#123;</span><br><span class="line">        if(n&amp;1) res=res*a%MOD;</span><br><span class="line">        a=a*a%MOD;</span><br><span class="line">        n&gt;&gt;=1;</span><br><span class="line">    &#125;</span><br><span class="line">    return res ;</span><br><span class="line">&#125;</span><br><span class="line">int jug(ll p)&#123;</span><br><span class="line">	for(int i=2;i*i&lt;=p;i++)&#123;</span><br><span class="line">		if(p%i==0) return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	ll p,a;</span><br><span class="line">	while(scanf(&quot;%lld %lld&quot;,&amp;a,&amp;p)!=EOF )&#123;</span><br><span class="line">		if(a==p&amp;&amp;p==0) break;</span><br><span class="line">		printf(&quot;%lld\n&quot;,qpow(a,p));</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Trailing-Zeroes-III"><a href="#Trailing-Zeroes-III" class="headerlink" title="Trailing Zeroes (III)"></a>Trailing Zeroes (III)</h2><p><strong>题意</strong><br>给你一个数n，问你最小的哪个数的阶层包含n个零<br><strong>解</strong><br>这道题是最难的一道了！！<del>我也不会，上网查了才知道</del>  </p>
<p>首先我们要知道一个数的阶层中0的个数由谁来提供？一定是由2乘5得来的0，哎不对呀！4乘5不是也能得到0吗？对！但是4不也是由2乘2得来的吗？所以n的阶层中0的个数就是由1~n的因子中2和5的数量决定的，再仔细想因子2的数量一定是大于5的，随便想都是这，所以10的个数就由因子5的数量来决定<br>比如：37的阶层<br>5 10 15 20 25(2) 30 35<br>上面一系列数都含有因子5，而25含有俩个因子5，所以总数是8个  </p>
<p>另外随着n的增大阶层中0的个数也不断增多，那这就是<code>有序</code>的，一看到有序，马上想起二分试错，二分n，如果n的阶层中0的数量不够，就去右边找，够了，要找最小，往左边找，思想就出来了，不过二分最难的不是思想，而是边界问题，整数上的二分最后一定是会到这样一种情况的left+1==right，因为每次都是right-1或者left+1，所以只要考虑好这种情况该怎么处理就行了  </p>
<p>再来看我们怎么算1~n中含有因子5的数量(n的阶层中0的数量)<br>一个数N,从1~N中包含因子M的数量为N/M<br>但是怎么去求1~N中因子M的数量呢？<br>这句话和上面的不一样<br>例如 N=36 M=5<br>那么1~N中包含因子5的数有：<br>5 10 15 20 25 30 35 （7）个<br>但是1~N中每一个数的因子M的数量和：<br>5(1) 10(1) 15(1) 20(1) 25(2) 30(1) 35(1)<br>这里面的25可以拆成5*5，是有两个因子5的<br>那如何求问题2呢？<br>可以这样去想，N/M表示包含因子M的数量<br>那N/=m之后就表示把从1~N里面的数包含因子M的数都除以了M<br>那么上面的数列就变成1~(N/5)：<br>1(0) 2(0) 3(0) 4(0) 5(1) 6(0) 7(5)<br>其实把N/M可以当作是把1~N中含有因子M的数都筛掉一遍<br>那么求1~N中含有因子M的数的的因子M的数量就是：  </p>
<p>代码：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while(n)&#123;  </span><br><span class="line">	ans+=(n/5);  </span><br><span class="line">	n/=5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="CODE-6"><a href="#CODE-6" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI acos(-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> mid)</span>&#123;</span><br><span class="line">	<span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(mid)&#123;</span><br><span class="line">		num+=mid/<span class="number">5</span>;</span><br><span class="line">		mid/=<span class="number">5</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t,kase=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		<span class="type">int</span> q;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;q;</span><br><span class="line">		<span class="type">int</span> l,r,mid,ans=<span class="number">0</span>;</span><br><span class="line">		l=<span class="number">5</span>; r=<span class="number">5e8</span>+<span class="number">10</span>;</span><br><span class="line">		<span class="keyword">while</span>(r&gt;=l)&#123;</span><br><span class="line">			mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(check(mid)&gt;=q)&#123;</span><br><span class="line">				r=mid<span class="number">-1</span>;</span><br><span class="line">				ans=mid;</span><br><span class="line">			&#125; </span><br><span class="line">			<span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Case &quot;</span>&lt;&lt;++kase&lt;&lt;<span class="string">&quot;: &quot;</span>;</span><br><span class="line">		<span class="keyword">if</span>(check(ans)==q) <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;impossible&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="Pie"><a href="#Pie" class="headerlink" title="Pie"></a>Pie</h2><p><strong>题意</strong><br>N种蛋糕，每个半径给出，要分给F+1个人，要求每个人分的体积一样（形状可以不一样），而且每人只能分得一种蛋糕（即一个人得到的蛋糕只能来自一块），求每人最大可以分到的体积。<br><strong>解</strong><br>一道实数上的二分题，有点像进击的奶牛那一道，都是猜一个答案去试错<br>double二分搜索</p>
<p>最小值是： 0 （大家都不吃）<br>最大值是：派的总体积 ÷ 总人数<br>每次取中间值 记作：mid，计算如果每个派切出 mid体积 能切多少块<br>如果能切够 F+1块，则将最小值更新为中间值<br>如果切不出 F+1块，则将最大值更新为中间值<br>直到两次中间值的差值 小于 10^(-4) 时就是结果了（精度）  </p>
<p>需要注意实数上的二分缩小区间时是r=mid或者l=mid</p>
<h3 id="CODE-7"><a href="#CODE-7" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#define pi acos(-1)</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN=1e4+100;</span><br><span class="line">double a[MAXN];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int t; cin&gt;&gt;t;</span><br><span class="line">	while(t--)&#123;</span><br><span class="line">		memset(a,0,sizeof a);</span><br><span class="line">		int n,f; cin&gt;&gt;n&gt;&gt;f;</span><br><span class="line">		double sum=0;</span><br><span class="line">		for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">			int tt; cin&gt;&gt;tt;</span><br><span class="line">			a[i]=pi*tt*tt;</span><br><span class="line">			sum+=a[i];</span><br><span class="line">		&#125;</span><br><span class="line">		double l,r,mid;</span><br><span class="line">		l=0; r=sum/(f+1);</span><br><span class="line">		while(1e-5&lt;r-l)&#123;</span><br><span class="line">			int sum2=0;</span><br><span class="line">			mid=(l+r)/2;</span><br><span class="line">			for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">				sum2+=(int)(a[i]/mid);</span><br><span class="line">			&#125;</span><br><span class="line">			if(sum2&gt;=(f+1))&#123;</span><br><span class="line">				l=mid;</span><br><span class="line">			&#125;else&#123;</span><br><span class="line">				r=mid;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%.4lf\n&quot;,mid);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Can-you-solve-this-equation"><a href="#Can-you-solve-this-equation" class="headerlink" title="Can you solve this equation?"></a>Can you solve this equation?</h2><p><strong>题意</strong><br>给出一个等式，和y的值，x为0~100之间的值，求出x(精确到4位小数)<br><strong>解</strong><br>经典二分题从0到一百二分答案试错就行了,注意精度要合适，大了会超时，小了误差大，具体看代码  </p>
<h3 id="CODE-8"><a href="#CODE-8" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;math.h&gt; </span><br><span class="line">using namespace std;</span><br><span class="line">double Y;</span><br><span class="line">double f(double x)&#123;</span><br><span class="line">	return 8*pow(x,4)+7*pow(x,3)+2*pow(x,2)+3*x+6-Y;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int t;</span><br><span class="line">	cin&gt;&gt;t;</span><br><span class="line">	while(t--)&#123;</span><br><span class="line">		cin&gt;&gt;Y;</span><br><span class="line">		if(f(0)*f(100)&gt;0) puts(&quot;No solution!&quot;);</span><br><span class="line">		else&#123;</span><br><span class="line">			double l=0,r=100,mid;</span><br><span class="line">			while(r-l&gt;1e-8)&#123;</span><br><span class="line">				mid=(l+r)/2;</span><br><span class="line">				if(f(mid)&lt;0) l=mid;</span><br><span class="line">				else r=mid;</span><br><span class="line">			&#125;</span><br><span class="line">			printf(&quot;%.4lf\n&quot;,mid);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Subsequence"><a href="#Subsequence" class="headerlink" title="Subsequence"></a>Subsequence</h2><p><strong>题意</strong><br>找到和大于等于给定数的最短子序列的长度<br><strong>解</strong><br>这道题不知道咋回事脑子抽了，<del>我直接排序了</del>，但是没注意到是子序列，但是wrong了还奇怪呢。。我真想抽自己一巴掌<br>我用的是尺取，毕竟时尺取的经典例题<br>二分的话预处理前缀和，然后二分后面的区间，大了往左看看能不能找到更小的，小了说明不够往右找 </p>
<h3 id="CODE-二分"><a href="#CODE-二分" class="headerlink" title="CODE(二分)"></a>CODE(二分)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxn=1e5+100;</span><br><span class="line">int a[maxn];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int t;</span><br><span class="line">	cin&gt;&gt;t;</span><br><span class="line">	while(t--)&#123;</span><br><span class="line">		memset(a,0,sizeof a); </span><br><span class="line">		int n,s,len=1e9;</span><br><span class="line">		cin&gt;&gt;n&gt;&gt;s;</span><br><span class="line">		for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">			cin&gt;&gt;a[i];</span><br><span class="line">			a[i]+=a[i-1];</span><br><span class="line">		&#125;</span><br><span class="line">		if(a[n]&lt;s)&#123;</span><br><span class="line">			cout&lt;&lt;&quot;0&quot;&lt;&lt;&#x27;\n&#x27;;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">			int temp=a[i];</span><br><span class="line">			int l=i+1,r=n,mid,len2=1e9;</span><br><span class="line">			while(l&lt;=r)&#123;</span><br><span class="line">				mid=(l+r)&gt;&gt;1;</span><br><span class="line">				if(a[mid]-temp&lt;s) l=mid+1;</span><br><span class="line">				else&#123;</span><br><span class="line">					len2=mid-i;</span><br><span class="line">					r=mid-1;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			len=min(len,len2);</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;len&lt;&lt;&#x27;\n&#x27;;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CODE-尺取"><a href="#CODE-尺取" class="headerlink" title="CODE(尺取)"></a>CODE(尺取)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int MAXN=1e5+100;</span><br><span class="line">int a[MAXN];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int t,n,s;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">	while(t--)&#123;</span><br><span class="line">		scanf(&quot;%d%d&quot;,&amp;n,&amp;s);</span><br><span class="line">		for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">		int l=1,r=0,ans=1e9,sum=0;</span><br><span class="line">		while(l&lt;=n)&#123;</span><br><span class="line">			while(r+1&lt;=n&amp;&amp;sum&lt;s) sum+=a[++r];</span><br><span class="line">			if(sum&gt;=s)&#123;</span><br><span class="line">				ans=min(ans,r-l+1);</span><br><span class="line">			&#125;</span><br><span class="line">			sum-=a[l];</span><br><span class="line">			l++;</span><br><span class="line">		&#125;</span><br><span class="line">		if(ans==1e9) printf(&quot;0\n&quot;);</span><br><span class="line">		else printf(&quot;%d\n&quot;,ans);</span><br><span class="line">	&#125;	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<font color="pink" size=4>
总结：题目还是很友好的，毕竟是基础 233~
</font>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>基础算法练习</tag>
      </tags>
  </entry>
  <entry>
    <title>积分赛3</title>
    <url>/posts/a5fa59a7.html</url>
    <content><![CDATA[<blockquote>
<p>学习了最短路后，感觉自己理解真的很一般，只会一些模板题目，稍微变一下就死了，而且发现我的思维很死，只会写套路题，做那些稍微灵活一点的题目感觉就很吃力，希望以后能有好转</p>
</blockquote>
<h2 id="B-张仙女的愧疚"><a href="#B-张仙女的愧疚" class="headerlink" title="B 张仙女的愧疚"></a>B 张仙女的愧疚</h2><blockquote>
<p>张仙女最近痴迷于游戏，可是他每周都得为学弟们准备一场积分赛。但，不是谁都能成为</p>
<p>时间管理大师。在游戏的诱惑下，他不小心出了几道难题，导致学弟们的心态可能爆炸，终于</p>
<p>他感到了深深的愧疚。决定这次一定友好一点。</p>
<p>他想到了一个有趣且简单的问题，准备交给学弟们解决。</p>
<p>给你一个数组<em>N</em>，数组的下标从1开始，数组中的每个数的值为<em>A**i</em>，你需要在这个数组中</p>
<p>找到两个数，使他们的数值和与他们的下标的差的绝对值相等，两个数为一组，张仙女想考考</p>
<p>你，在这个数组中你最多能找到可以满足题意的几组数。</p>
<p><strong>输入</strong></p>
<p>单组输入</p>
<p>第一行为数组的大小<em>N</em>(2 ⩽ <em>N</em> ⩽ 200000)</p>
<p>接下来一行<em>N</em>个以空格区分开的数表示数组中的值<em>A**i</em>1 <em>≤</em> <em>A**i</em> <em>≤</em> 109</p>
<p>(1 <em>≤</em> <em>i</em> <em>≤</em> <em>N</em>)</p>
<p><strong>输出数据</strong></p>
<p>一个数字，表示答案</p>
<p><strong>样例输入</strong></p>
<p>6</p>
<p>2 3 3 1 3 1</p>
<p><strong>样例输出</strong></p>
<p>3</p>
</blockquote>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>题意很简单求数组里面有多少对数满足数值和等于下标差，列出等式a[i]+a[j]==j-i，这道题就是一个简单的思维题，说简单，我还是没想出来，真的菜死了，这个式子可以变一下形把含i的弄到一边，这样a[i]+i==j-a[j]，这样一来我们只要遍历一遍看看数值等于a[i]+i的有多少个数，用map存下来，再遍历一遍，看看map下标等于j-a[j]的有多少个就行了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N= <span class="number">200010</span>;</span><br><span class="line"><span class="type">int</span> arr[N];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;arr[i];</span><br><span class="line">		mp[i+arr[i]]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(mp[i-arr[i]]) cnt+=mp[i-arr[i]];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;cnt&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>
<h2 id="C-何仙女的回文串"><a href="#C-何仙女的回文串" class="headerlink" title="C 何仙女的回文串"></a>C 何仙女的回文串</h2><blockquote>
<p>在一个遥远的国度里，有一个女儿国，里面住着很多很多的小仙女。某一天，一位英俊的</p>
<p>剑士前来寻求对象。国王告诉他，只要能回答出来一个问题，他就能娶走其中的何仙女；</p>
<p>现在有一个字符串S，S为所有仙女名字的首字母集合，国王命令他找出最长的字符串<strong>T</strong>， </p>
<p>T满足以下条件: </p>
<p>• T的长度不超过S的长度</p>
<p>• T是回文串</p>
<p>• 存在两个字符串A,B（可能为空），使得 T=A+B (‘+’表示连接两个字符串)，其中A是S的</p>
<p>前缀字符串，B是S的后缀字符串</p>
<p>剑士听后心头一颤，不知所措，暗地里告诉了你字符串S，希望没有对象的你能尽快告诉</p>
<p>他满足条件的字符串T是多少；</p>
<p><strong>输入数据</strong></p>
<p>第一行是一个整数<em>T</em>(1 ⩽ <em>t</em> ⩽ 1000)，表示样例的个数。</p>
<p>以后每个样例一行，是一个字符串S。 </p>
<p>(数据确保所有字符串长度不超过5000)</p>
<p><strong>输出数据</strong></p>
<p>对于每个测试用例，输出满足上述条件的最长字符串T。如果存在多个可能的解决方案，输</p>
<p>出其中任何一个。</p>
<p><strong>样例输入</strong></p>
<p>5</p>
<p>a</p>
<p>abcdfdcecba</p>
<p>abbaxyzyx</p>
<p>codeedoc</p>
<p>acbba</p>
<p><strong>样例输出</strong></p>
<p>a</p>
<p>abcdfdcba</p>
<p>xyzyx</p>
<p>codeedoc</p>
<p>abba</p>
</blockquote>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>其实这道题也不是很难的，我没做这道题很大的原因其实就是这道题没多少人AC，心理就有些抵触。。我把大量精力都放到了F，其实F是一道很难的题目，但是AC的人多我就去做了。。这道题既然要找最长回文串，还要求前后是源字符串的前缀和后缀，我们就可以从前后找，来一个双指针，找到第一个不同的字符然后找中间最长的回文串，把三段拼接在一起就行了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="built_in">string</span> s,ans;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span>&#123;  </span><br><span class="line">	<span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">		<span class="keyword">if</span>(s[l]!=s[r]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		l++,r--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> t; <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		ans.clear();</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">		<span class="type">int</span> l=<span class="number">0</span>,r=s.size()<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">while</span>(l&lt;r&amp;&amp;s[l]==s[r]) l++,r--;</span><br><span class="line">		<span class="type">int</span> i,j;</span><br><span class="line">		<span class="keyword">for</span>(i=l;i&lt;=r;i++) <span class="keyword">if</span>(check(i,r)) <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">for</span>(j=r;j&gt;=l;j--) <span class="keyword">if</span>(check(l,j)) <span class="keyword">break</span>;</span><br><span class="line">		<span class="type">int</span> ll,rr;</span><br><span class="line">		<span class="keyword">if</span>(r-i&gt;j-l) rr=r,ll=i;</span><br><span class="line">		<span class="keyword">else</span> rr=j,ll=l;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;l;i++) ans+=s[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=ll;i&lt;=rr;i++) ans+=s[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=r+<span class="number">1</span>;i&lt;s.size();i++) ans+=s[i];</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="E-拯救李仙女"><a href="#E-拯救李仙女" class="headerlink" title="E 拯救李仙女"></a>E 拯救李仙女</h2><blockquote>
<p>大魔王因为抓来的公主被勇士救走后很是不甘心，于是他将魔爪伸向了李仙女，这次为了</p>
<p>不再让强大的勇士阻止自己，他选择化身美男子让小仙女爱上自己，年轻的小仙女果不其然上</p>
<p>当了，她将不顾危险的来到大魔王的城堡中。</p>
<p>象征着爱与和平的尹法师想要阻止大魔王的阴谋，显然直接打败大魔王是不能拯救小仙女</p>
<p>的，于是大法师派遣<em>n</em>个人在沿途中劝阻小仙女，每个人都守在一个路口上，初始时小仙女对</p>
<p>大魔王的爱慕值为<em>w</em>，当她遇到第<em>i</em>个人，第<em>i</em>个人的影响力是<em>a**i</em>，将会使小仙女的爱慕值减少<em>a**i</em>，</p>
<p>小仙女很聪明，知道大法师不会让自己轻易见到心爱的人，并且获得了大法师派遣的人的位置</p>
<p>以及他们的影响力，她将选择受到最少阻拦的那条路，（即减少的爱慕值最少，如果有多条，那</p>
<p>么这几条路都有被选择的可能）。</p>
<p>如果小仙女在到达大魔王的城堡门口时，依旧爱着大魔王，大法师将出现在城堡门口。当</p>
<p>然大法师是没有丝毫作用的，不过如果此时的小仙女对大魔王的爱慕值是12的倍数，那么大法</p>
<p>师将获得神奇的力量，接下来，他将使用魔法进行召唤术（可进行无数次召唤），每次都会将</p>
<p>一个小仙女沿途不可能见过的人召唤到这里阻拦她（大法师是不知道小仙女具体走的哪条路，</p>
<p>且召换来的人依旧有与原来一样的影响力)，如果最后可以拦住请输出大法师最少的召唤次数。</p>
<p>当然如果爱慕力不是12的倍数大法师也不会获得神奇的力量，小仙女就会陷入大魔王的魔爪</p>
<p>中。</p>
<p>不可能见过即指小仙女一定不会遇到的人。</p>
<p><strong>输入数据</strong></p>
<p>第一行有两个整数<em>n m w</em>(1 ⩽ <em>n</em> ⩽ 100000<em>,</em> 1 ⩽ <em>m</em> ⩽ 200000<em>,</em> 1 ⩽ <em>w</em> ⩽ 1<em>e</em>9)，分别代表路口</p>
<p>数和道路数以及小仙女的初始爱慕值。</p>
<p>第二行有<em>n</em>个整数<em>a</em>1 <em>· · ·</em> <em>a**n</em>(1 ⩽ <em>a**i</em> ⩽ <em>w</em>)，<em>a**i</em>是第<em>i</em>个人的影响力。接下来的<em>m</em>行每行有两个</p>
<p>整数<em>i, j</em>(1 ⩽ <em>i, j</em> ⩽ <em>n</em>)，代表着第<em>i</em>号路口与第<em>j</em>号路口有一条路。（所给图不保证连通，当然不</p>
<p>连通大法师也就不必那么麻烦了）</p>
<p>初始时小仙女在1号路口处，大魔王的城堡在n号路口处，只要经过这个路口路口上的人就</p>
<p>会影响到小仙女，小仙女的爱慕力小于等于0的时候，小仙女就会放弃大魔王。</p>
<p><strong>输出数据</strong></p>
<p>如果最终可以阻止小仙女见到大魔王输出大法师使用的最少召唤次数，如果不可以输</p>
<p>出<em>ࠪ</em>1。</p>
<p><strong>样例输入1</strong></p>
<p>4 4 10</p>
<p>1 3 5 7</p>
<p>1 2</p>
<p>1 3</p>
<p>2 4</p>
<p>3 4</p>
<p><strong>样例输出1</strong></p>
<p>0</p>
<p><strong>样例输入2</strong></p>
<p>5 5 34</p>
<p>1 9 7 16 5</p>
<p>1 2</p>
<p>2 3</p>
<p>3 5</p>
<p>1 4</p>
<p>4 5</p>
<p><strong>样例输出2</strong></p>
<p>-1</p>
</blockquote>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>题意是公主爱上了大魔王，魔法师要劝她，安排了n个人在n个路口劝阻公主，公主有一个爱慕值，她会挑一个最短路去找大魔王，最短路指的是减少爱慕值最少的一条路，如果公主走到了大魔王前，大法师就会出现，如果此时爱慕值是十二的倍数，那么大法师就会召集所有非最短路径的人一起来劝阻公主，最短路径可能有多条</p>
<p>所以这道题就是首先从起点跑一遍迪杰斯特拉算法，找到最短路，判断是否爱慕值是十二的倍数，是的话就再标记所有最短路，难的就是标记最短路，具体看代码注释吧</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const ll N=100100;</span><br><span class="line">const ll M=200100;</span><br><span class="line">ll n,m,w;</span><br><span class="line">ll arr[M];</span><br><span class="line">ll val[N];</span><br><span class="line">bool vis2[N];</span><br><span class="line">struct node&#123; //链式前向星</span><br><span class="line">	ll pos; //这条边到达的结点</span><br><span class="line">	ll cost; //这条边的权值</span><br><span class="line">	ll next; //这条边的相邻边</span><br><span class="line">	bool operator &lt; (const node &amp;o) const&#123; //重载运算符</span><br><span class="line">		return cost&gt;o.cost;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;edge[M]; //链式前向星的边数组</span><br><span class="line">ll head[M]; //链式前向星的head数组，表示的是以u结点开始的最后一条边的编号</span><br><span class="line">ll size; //边的编号</span><br><span class="line">void add(ll u,ll v,ll w)&#123;</span><br><span class="line">	edge[size].cost=w; //这条边的权值</span><br><span class="line">	edge[size].pos=v; //这条边到达的结点</span><br><span class="line">	edge[size].next=head[u]; //这条边的邻边就是上次以这个节点开始的最后一条边的编号</span><br><span class="line">	head[u]=size++;//更新以这条边开始的最后一条边的编号，同时编号++</span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;node&gt; pq; //跑堆优化的迪杰斯特拉用的优先队列</span><br><span class="line">ll dis[N]; //存的是每一个点到起点的最短距离</span><br><span class="line">bool vis[N]; //记录是否确定了某一个点到起点的最短距离</span><br><span class="line">void init(ll n)&#123; //初始化函数</span><br><span class="line">	size=0; //边的序号更新为0</span><br><span class="line">	memset(head,-1,sizeof head); //head初始化为-1，也可以初始化为0，那样的话size就要从1开始</span><br><span class="line">	while(!pq.empty()) pq.pop(); //队列清空</span><br><span class="line">	memset(vis,0,sizeof vis); //vis重置</span><br><span class="line">	memset(dis,0x3f,sizeof dis); //memset以字节赋值longlong也可以使用这种方法</span><br><span class="line">&#125;</span><br><span class="line">void dij(ll s)&#123; //mlog(n)的复杂度</span><br><span class="line">	dis[s]=arr[s]; //起点的距离应该初始化为1结点的劝阻值</span><br><span class="line">	pq.push(&#123;s,arr[s]&#125;); //放进去起点</span><br><span class="line">	while(!pq.empty())&#123;</span><br><span class="line">		node x=pq.top(); pq.pop();</span><br><span class="line">		ll u=x.pos; //当前所有点离起点最近的</span><br><span class="line">		if(vis[u]) continue;</span><br><span class="line">		vis[u]=1; //这个点的最短路径就确定了，标记</span><br><span class="line">		for(ll e=head[u];e!=-1;e=edge[e].next)&#123; //找到以这个结点开始的最后一条边的编号，从这条边开始遍历邻边</span><br><span class="line">			ll v=edge[e].pos; //找到u结点所有邻接点</span><br><span class="line">			if(vis[v]) continue; //如果这个点的最短路径确定了continue</span><br><span class="line">			if(dis[v]&gt;dis[u]+edge[e].cost)&#123; //否则更新其到起点的最短距离</span><br><span class="line">				dis[v]=dis[u]+edge[e].cost;</span><br><span class="line">				pq.push(&#123;v,dis[v]&#125;); //放进队列，因为每次都是用所有结点离起点最近的点去更新每一个点的最短距离的</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void dfs(ll pos,ll d)&#123;</span><br><span class="line">	if(pos==1) return ; //到了起点退出</span><br><span class="line">	if(vis2[pos]) return ; //如果往回搜了退出</span><br><span class="line">	vis2[pos]=1; //标记父亲结点，防止往后走</span><br><span class="line">	for(ll e=head[pos];e!=-1;e=edge[e].next)&#123; //遍历当前点的邻接点</span><br><span class="line">		ll v=edge[e].pos; //邻接点</span><br><span class="line">		if(d==dis[v])&#123; //如果(当前点)减去(邻接点到当前点的那条边的权值)后等于(邻接点到起点的最短距离)，则说明当前点是由这个邻接点过来的，则这个邻接点一定是从起点到终点的最短路径中的一条</span><br><span class="line">			vis[v]=1; //标记该点</span><br><span class="line">			dfs(v,dis[v]-arr[v]); //从该点开始找</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	vis2[pos]=0; //其实这句在这里没有用，是恢复现场的，一条路撞到南墙了回来后每一个点都恢复原来的状态，加上这一句后其实不用再手动初始化vis2了</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;m,&amp;w); //n个结点，m条边，爱慕值</span><br><span class="line">	init(n); //初始化</span><br><span class="line">	for(ll i=1;i&lt;=n;i++)&#123; //输入每一个结点的人劝阻值</span><br><span class="line">		scanf(&quot;%lld&quot;,&amp;arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	while(m--)&#123;</span><br><span class="line">		ll u,v;</span><br><span class="line">		scanf(&quot;%lld%d&quot;,&amp;u,&amp;v);</span><br><span class="line">		add(u,v,arr[v]); //这里用一条边的终点的劝阻值作为这条边的权值</span><br><span class="line">		add(v,u,arr[u]); //无向边，但是权值不一样，但是不会有其他影响</span><br><span class="line">	&#125;</span><br><span class="line">	dij(1); //1起点，n终点</span><br><span class="line">	ll cost=dis[n]; //记录到n点的最少花费</span><br><span class="line">	</span><br><span class="line">	if(cost&gt;=w) printf(&quot;0\n&quot;); //如果公主到不了n点直接不用召唤了，输出0</span><br><span class="line">	else&#123;</span><br><span class="line">		if((w-cost)%12!=0) printf(&quot;-1\n&quot;);// 如果这时的爱慕值不是十二的倍数，则公主与大魔王相遇</span><br><span class="line">		else&#123;</span><br><span class="line">			memset(vis2,0,sizeof vis2); //dfs时不走回头路，这里其实不用初始化，因为dfs回朔已经全部恢复成0了，这里是一组数据，多组数据时就不用memset了，小优化</span><br><span class="line">			memset(vis,0,sizeof vis); //vis标记最短路</span><br><span class="line">			memset(val,0,sizeof val); //存非最短路的劝阻值</span><br><span class="line">			int tail=0; //非最短路的结点数量</span><br><span class="line">			vis[n]=1; //必须手动标记起点(dfs的起点)，因为直接就从起点的邻接点开始了</span><br><span class="line">			dfs(n,cost-arr[n]);//这里应该倒着去找，从n开始往前遍历</span><br><span class="line">			for(int i=1;i&lt;=n;i++)&#123; //遍历每一个结点，找到不是最短路径的点</span><br><span class="line">				if(!vis[i]) val[++tail]=arr[i];</span><br><span class="line">			&#125;</span><br><span class="line">			sort(val+1,val+1+tail,greater&lt;ll&gt;()); //从大到小排序，因为要输出最少召唤次数</span><br><span class="line">			ll cnt=0;</span><br><span class="line">			for(int i=1;i&lt;=tail;i++)&#123; //每次召唤最大的，使得召唤次数最少</span><br><span class="line">				if(w&lt;=cost) break;</span><br><span class="line">				w-=val[i];</span><br><span class="line">				cnt++;</span><br><span class="line">			&#125;</span><br><span class="line">			if(cost&gt;=w) printf(&quot;%lld\n&quot;,cnt);</span><br><span class="line">			else printf(&quot;-1\n&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>
<h2 id="F-黄仙女的生日"><a href="#F-黄仙女的生日" class="headerlink" title="F 黄仙女的生日"></a>F 黄仙女的生日</h2><blockquote>
<p>今天是黄仙女的生日，她妈妈给她买了一块很大很大的蛋糕，在吃蛋糕的时候需要把蛋糕</p>
<p>切开，黄仙女会法术，她每用一次法术就可以在蛋糕内任意选一点，发出两道激光（可以看作</p>
<p>同一点发出两道射线）把蛋糕切开。这两条激光不能重合，不在一条直线上。她想知道如果</p>
<p>用n次法术的话，最多可以把蛋糕分成多少块。（规定只能在蛋糕内选一点）    </p>
<p><strong>输入数据</strong></p>
<p>第一行是一个整数<em>T</em>(<em>T</em> ⩽ 1000)，表示测试实例的个数,然后是T行，每行有一个数字<em>n</em>(0 ⩽ </p>
<p><em>n</em> ⩽ 104)表示用n次法术</p>
<p><strong>输出数据</strong></p>
<p>T行数字，最多可以分多少块</p>
<p><strong>样例输入</strong></p>
<p>3</p>
<p>0</p>
<p>1</p>
<p>2</p>
<p><strong>样例输出</strong></p>
<p>1</p>
<p>2</p>
<p>7 </p>
</blockquote>
<h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>这道题明明这么难，竟然做出来的人这么多！！！可能是我真的太菜了，我现在这道题都没理解为什么这么画块最多，这道题不讲了</p>
<h3 id="CODE-1"><a href="#CODE-1" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">10001</span>;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">10001</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;<span class="number">10001</span>;i++)&#123;</span><br><span class="line">		dp[i]=dp[i<span class="number">-1</span>]+i*<span class="number">4</span><span class="number">-3</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		<span class="type">int</span> n;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;dp[n]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>
<h2 id="G-小仙女的树"><a href="#G-小仙女的树" class="headerlink" title="G 小仙女的树"></a>G 小仙女的树</h2><blockquote>
<p>小仙女在天上飞的时候，突然听到地面上有两个人争吵，Ayush和Ashish他们邀请小仙女</p>
<p>给他们做裁判，他们有一个无根树，每个人每一次都可以取一个叶子节点，树上有一个特殊节</p>
<p>点，问最后谁能取走特殊的节点。</p>
<p><strong>输入数据</strong></p>
<p>第一行输入表示有<em>T</em>(<em>T</em> ⩽ 10)组数据，第二行输入<em>n, x</em>(1 ⩽ <em>n, k</em> ⩽ 103),<em>n</em>表示有<em>n</em>个节点，</p>
<p><em>x</em>为特殊的节点,<em>x</em>小于等于<em>n</em>。下面的<em>nn</em> 1行每一行表表示两个节点无向互相连通，第一次</p>
<p>是Ayush开始走。</p>
<p><strong>输出数据</strong></p>
<p>输出两人谁能取到特殊节点</p>
<p><strong>样例输入</strong></p>
<p>1</p>
<p>3 1</p>
<p>2 1</p>
<p>3 1</p>
<p><strong>样例输出</strong></p>
<p>Ashish</p>
</blockquote>
<h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>少有的签到题目，可我还是很粗心，画图我想当然得看到x结点裸漏在外面就认为能取走了，其实它的度数是大于1的！！！</p>
<h3 id="CODE-2"><a href="#CODE-2" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const ll MOD= 998244353;</span><br><span class="line">ll degree[1100];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int t;</span><br><span class="line">	cin&gt;&gt;t;</span><br><span class="line">	while(t--)&#123;</span><br><span class="line">		int n,x;</span><br><span class="line">		cin&gt;&gt;n&gt;&gt;x;</span><br><span class="line">		n--;</span><br><span class="line">		while(n--)&#123;</span><br><span class="line">			int a,b;</span><br><span class="line">			cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">			degree[a]++;</span><br><span class="line">			degree[b]++;</span><br><span class="line">		&#125;</span><br><span class="line">		if(degree[x]==1||degree[x]==0)&#123;</span><br><span class="line">			cout&lt;&lt;&quot;Ayush&quot;&lt;&lt;&#x27;\n&#x27;;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			if(n==3) cout&lt;&lt;&quot;Ashish&quot;&lt;&lt;&#x27;\n&#x27;;</span><br><span class="line">			else if((n-3)&amp;1) cout&lt;&lt;&quot;Ayush&quot;&lt;&lt;&#x27;\n&#x27;;</span><br><span class="line">			else cout&lt;&lt;&quot;Ashish&quot;&lt;&lt;&#x27;\n&#x27;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>
<h2 id="H-仙女们的高数又双叒叕挂了"><a href="#H-仙女们的高数又双叒叕挂了" class="headerlink" title="H 仙女们的高数又双叒叕挂了"></a>H 仙女们的高数又双叒叕挂了</h2><blockquote>
<p>话说有棵树，挂了很多人，其中也不乏众多仙女。其中有道题目是这样的</p>
<p>从-1到1对(1-x^2^)^n^积分</p>
<p>给定n，求得上式的值</p>
<p><strong>输入数据</strong></p>
<p>输入包含多组测试，以文件结尾结束。每组测试包含一个整数n </p>
<p>1 <em>&lt;</em>= <em>n &lt;</em>= 1<em>e</em>6</p>
<p>样例总数不超过1<em>e</em>5</p>
<p><strong>输出数据</strong></p>
<p>结果若是整数，则直接输出</p>
<p>否则输出分数的最简形式，结果mod 998244353</p>
<p><strong>样例输入</strong></p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>455</p>
<p><strong>样例输出</strong></p>
<p>4/3</p>
<p>16/15</p>
<p>32/35</p>
<p>622707799/502563857</p>
</blockquote>
<h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><p>这道题我真的不信有人第一次就能手推出数学公式！！！不去网上查我是真的不信的！！！当然大神除外，不讲了，纯数学推导</p>
<h3 id="CODE-3"><a href="#CODE-3" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll MOD= <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> ll maxn=<span class="number">1e6</span>+<span class="number">7</span>;</span><br><span class="line">ll fac[maxn*<span class="number">2</span>+<span class="number">100</span>];</span><br><span class="line">ll <span class="title function_">ksm</span><span class="params">(ll a,ll b)</span>&#123;</span><br><span class="line">	ll ans=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(b)&#123;</span><br><span class="line">		<span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans=ans*a%MOD;</span><br><span class="line">		a=a*a%MOD;</span><br><span class="line">		b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">ll <span class="title function_">solve</span><span class="params">(ll n)</span>&#123;</span><br><span class="line">	ll ans=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		ans=ans*i%MOD;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">	fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=maxn*<span class="number">2</span>;i++) fac[i]=fac[i<span class="number">-1</span>]*i%MOD;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	init();</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123;</span><br><span class="line">		ll x=ksm(fac[n],<span class="number">2</span>)*ksm(<span class="number">2</span>,<span class="number">2</span>*n+<span class="number">1</span>)%MOD;</span><br><span class="line">		ll y=fac[<span class="number">2</span>*n+<span class="number">1</span>]%MOD;</span><br><span class="line">		ll tmp=__gcd(x,y);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;x/tmp&lt;&lt;<span class="string">&#x27;/&#x27;</span>&lt;&lt;y/tmp&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>
<h2 id="I-小仙女的善心"><a href="#I-小仙女的善心" class="headerlink" title="I  小仙女的善心"></a>I  小仙女的善心</h2><p>求两个矩形的覆盖面积</p>
<h3 id="CODE-4"><a href="#CODE-4" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll MOD= <span class="number">998244353</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ll a,b,c,d,e,f,g,h;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d&gt;&gt;e&gt;&gt;f&gt;&gt;g&gt;&gt;h;</span><br><span class="line">	ll s1=(c-a)*(d-b);</span><br><span class="line">	ll s2=(g-e)*(h-f);</span><br><span class="line">	<span class="keyword">if</span>(g&lt;=a||e&gt;=c||h&lt;=b||f&gt;=d)&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;s1+s2&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ll x1,y1,x2,y2;</span><br><span class="line">	x1=max(a,e);</span><br><span class="line">	y1=max(b,f);</span><br><span class="line">	x2=min(c,g);</span><br><span class="line">	y2=min(d,h);</span><br><span class="line">	ll mid=(x2-x1)*(y2-y1);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;s2+s1-mid&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>
<h2 id="J-林仙女的选美大赛"><a href="#J-林仙女的选美大赛" class="headerlink" title="J 林仙女的选美大赛"></a>J 林仙女的选美大赛</h2><blockquote>
<p>在马卡拉卡山脉的最深处，住着一群小仙女。最近，林仙女举办了一场选美大赛。有n名</p>
<p>小仙女参加了比赛。比赛现场有m名裁判仙女，每个裁判仙女会表达一个自己的观点。比如裁</p>
<p>判A说：“1=2”表示裁判A认为1号仙女和2号仙女一样美。选美比赛结束了，但是裁判仙女们</p>
<p>却犯了愁。因为他们不知道如何整理这些观点，无法给小仙女们排名。屏幕前的你能帮助林仙</p>
<p>女解决这个难题吗？如果根据所给信息可以给小仙女们排名请输出“OK”（可以存在并列排名）</p>
<p>,如果所给信息有冲突（裁判A认为1&gt;2, 裁判B认为1&lt;2）,请输出“CONFLICT”，如果所给信息</p>
<p>不全，无法确定排名请输出“UNCERTAIN”，如果信息中同时包含冲突且信息不完全，就输出</p>
<p>“CONFLICT”。</p>
<p><strong>输入数据</strong></p>
<p>本题目包含多组测试，请处理到文件结束。每组测试第一行包含两个整数N,M(0&lt;=N&lt;=10000,0&lt;=M&lt;=20000),</p>
<p>分别表示要参加选美比赛的小仙女数以及裁判仙女数。接下来有M行，分别是每个裁判的观</p>
<p>点(1&lt;=每个小仙女的编号&lt;=n)</p>
<p><strong>输出数据</strong></p>
<p>对于每组测试，在一行里按题目要求输出</p>
<p><strong>样例输入</strong></p>
<p>3 2</p>
<p>1 &gt; 2</p>
<p>2 = 3</p>
<p>3 3</p>
<p>1 &gt; 2</p>
<p>2 = 3</p>
<p>3 &gt; 1</p>
<p>3 1</p>
<p>1 &gt; 2</p>
<p><strong>样例输出</strong></p>
<p>OK</p>
<p>CONFLICT</p>
<p>UNCERTAIN</p>
</blockquote>
<h3 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h3><p>这是一道原题，虽然那道题当时删了，但还好我做了，这道题是用并查集去缩点，把所有=关系的点缩成一个，让它们的祖先代表他们，然后拓扑排序，看看是否有环</p>
<h3 id="CODE-5"><a href="#CODE-5" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">10100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">20100</span>;</span><br><span class="line"><span class="type">const</span> ll MOD= <span class="number">998244353</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> to;</span><br><span class="line">	ll cost;</span><br><span class="line">	<span class="type">int</span> next;</span><br><span class="line">&#125;edge[M];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">b</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> u,v;</span><br><span class="line">	<span class="type">char</span> c;</span><br><span class="line">&#125;arr[M];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line">ll dis[N];</span><br><span class="line"><span class="type">int</span> head[M],fa[N],in[N];</span><br><span class="line"><span class="type">int</span> size=<span class="number">0</span>,n,m,flag1,flag2,cnt;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span>&#123;</span><br><span class="line">	edge[size].to=v;</span><br><span class="line">	edge[size].cost=w;</span><br><span class="line">	edge[size].next=head[u];</span><br><span class="line">	head[u]=size++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">	size=<span class="number">0</span>; flag1=<span class="number">0</span>; flag2=<span class="number">0</span>; cnt=n;</span><br><span class="line">	<span class="keyword">while</span>(!q.empty()) q.pop();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++) head[i]=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++) fa[i]=i;</span><br><span class="line">	<span class="built_in">memset</span>(in,<span class="number">0</span>,<span class="keyword">sizeof</span> in);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==fa[x]) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">return</span> fa[x]=find(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">	<span class="type">int</span> x=find(a);</span><br><span class="line">	<span class="type">int</span> y=find(b);</span><br><span class="line">	<span class="keyword">if</span>(x!=y) fa[y]=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">tuo</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(fa[i]==i&amp;&amp;!in[i])&#123; <span class="comment">//祖先是自己并且入度为零</span></span><br><span class="line">			q.push(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		<span class="type">int</span> u=q.front(); q.pop();</span><br><span class="line">		<span class="keyword">if</span>(q.size()) flag2=<span class="number">1</span>; <span class="comment">//如果当前入度为0的点不止一个，则说明有两个点无法比较，Uncertain，这里还有一个很骚的操作，可以直接反向建图，直接在开始时候判断是否入度为0的点大于1个</span></span><br><span class="line">		cnt--; <span class="comment">//计数看看能拓扑排序的点有多少个</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> e=head[u];e!=<span class="number">-1</span>;e=edge[e].next)&#123;</span><br><span class="line">			<span class="type">int</span> v=edge[e].to;</span><br><span class="line">			in[v]--;</span><br><span class="line">			<span class="keyword">if</span>(!in[v]) q.push(v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m)&#123;</span><br><span class="line">		init(n);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;arr[i].u&gt;&gt;arr[i].c&gt;&gt;arr[i].v;</span><br><span class="line">			<span class="keyword">if</span>(arr[i].c==<span class="string">&#x27;=&#x27;</span>)&#123; <span class="comment">//把等于关系的两个点并到一个集合，即缩点</span></span><br><span class="line">				merge(arr[i].u,arr[i].v);</span><br><span class="line">				cnt--; <span class="comment">//cnt记录缩点后有几个点</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">			<span class="type">char</span> ch=arr[i].c;</span><br><span class="line">			<span class="type">int</span> u=find(arr[i].u), v=find(arr[i].v);<span class="comment">//没缩点的点祖先就是自己</span></span><br><span class="line">			<span class="keyword">if</span>(ch==<span class="string">&#x27;=&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(u==v) flag1=<span class="number">1</span>; <span class="comment">//矛盾</span></span><br><span class="line">			<span class="keyword">if</span>(ch==<span class="string">&#x27;&gt;&#x27;</span>)&#123;</span><br><span class="line">				add(u,v,<span class="number">0</span>);</span><br><span class="line">				in[v]++; </span><br><span class="line">			&#125; </span><br><span class="line">			<span class="keyword">if</span>(ch==<span class="string">&#x27;&lt;&#x27;</span>)&#123;</span><br><span class="line">				add(v,u,<span class="number">0</span>);</span><br><span class="line">				in[u]++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(flag1)&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;CONFLICT&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		tuo(); <span class="comment">//拓扑排序</span></span><br><span class="line">		<span class="keyword">if</span>(cnt&gt;<span class="number">0</span>||flag1) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;CONFLICT&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(flag2) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;UNCERTAIN&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;OK&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>集训</tag>
      </tags>
  </entry>
  <entry>
    <title>积分赛2</title>
    <url>/posts/d2fd6931.html</url>
    <content><![CDATA[<blockquote>
<p>前两天打了第二场积分赛，难度明显比上次高，感觉更考验思维了，收集了一些我认为有价值的题目，因为太懒了，不想自己写思路题解了，搬来了别人的代码和题解，以后争取养成保存代码的习惯🐷</p>
</blockquote>
<h2 id="A-徐半仙的数学难题"><a href="#A-徐半仙的数学难题" class="headerlink" title="A 徐半仙的数学难题"></a>A 徐半仙的数学难题</h2><blockquote>
<blockquote>
<p>描述</p>
</blockquote>
<p>徐半仙经常修炼。但是每次修炼所能提升的功力确是不确定的（可能是功力还不够深厚</p>
<p>吧）。</p>
<p>每次修炼结束之后，徐半仙的脑海中就会浮现出两个数字，<em>n</em>和<em>m</em>，他的师父跟他说他每</p>
<p>次修炼增加的功力就是由这两个数决定的。每次增加的功力为(<em>n</em>!!!)%<em>m</em>，即<em>n</em>的阶乘的阶乘的</p>
<p>阶乘对<em>m</em>取模之后的值。</p>
<p>徐半仙想让你帮他写一个程序，通过<em>n</em>和<em>m</em>得到他每次修炼之后提升了多少功力。如果这</p>
<p>次修炼后提升的功力为0，输出<em>baigei</em></p>
<blockquote>
<p>输入数据</p>
</blockquote>
<p>多组输入，第一行一个正整数<em>t</em>(1 <em>≤</em> <em>t</em> <em>≤</em> 105)表示数据组数</p>
<p>每组数据包含两个整数<em>n, m</em>(0 <em>≤</em> <em>n</em> <em>≤</em> 109<em>,</em> 1 <em>≤</em> <em>m</em> <em>≤</em> 109)</p>
<blockquote>
<p>输出数据</p>
</blockquote>
<p>对于每组数据，如果答案为0，输出<em>baigei</em>，否则输出答案（每次修炼后提升的功力）</p>
<blockquote>
<p>样例输入</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line"></span><br><span class="line">2 6553</span><br><span class="line"></span><br><span class="line">2 2</span><br></pre></td></tr></table></figure>
<blockquote>
<p>样例输出</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line"></span><br><span class="line">baigei</span><br></pre></td></tr></table></figure>
<blockquote>
<p>提示</p>
</blockquote>
<p>在样例中,(2!!!) = 2,对6553取模为2，直接输出，对2取模为0，输出<em>baigei</em></p>
</blockquote>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>我们知道模最大是109，并且很容易知道从4开始，这个数的阶乘的阶乘已经是大于109的，</p>
<p>并且因为我们求的是阶乘，阶乘最后取模和每次取模后相乘的结果相同，因为现在计算的数一</p>
<p>定大于模，所以一定会出现一项为0，因此最后的结果也为0。所以如果<em>n</em>小于4，我们直接暴力</p>
<p>计算就可以了，反之直接输出<em>baigei</em>即可</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc ++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> +<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> +<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0</span> x3f3f3f3f ;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> t; <span class="built_in">cin</span> &gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        ll n,m,ans;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt;n&gt;&gt;m;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        	ans =<span class="number">1</span>%m;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">2</span>)&#123;</span><br><span class="line">        	ans =<span class="number">2</span>%m;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">3</span>)&#123;</span><br><span class="line">        	ans=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(ll i=<span class="number">1</span>;i &lt;=<span class="number">720</span>;i++)&#123;</span><br><span class="line">            ans *=i;</span><br><span class="line">            ans %=m;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        	ans =<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans ==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;baigei\n&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        	<span class="built_in">cout</span> &lt;&lt;ans &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="B-徐半仙的八字谜盘"><a href="#B-徐半仙的八字谜盘" class="headerlink" title="B 徐半仙的八字谜盘"></a>B 徐半仙的八字谜盘</h2><blockquote>
<ul>
<li>题目描述</li>
</ul>
<p>有一天徐半仙正在街道上给人算八字，他摆弄一个棋盘，和<em>K</em>个棋子，棋盘是<em>N</em> <em>×</em> <em>N</em>的矩阵方</p>
<p>格图，共有<em>N</em> <em>×</em> <em>N</em>个格子。</p>
<p>突然一位神秘ACM大佬来了，对徐半仙说：大仙，是不是您什么难题都算得出来啊？</p>
<p>徐半仙：Of course!</p>
<p>ACM大佬：那你算算这<em>N</em> <em>×</em> <em>N</em>的棋盘，每个方格只能放一个棋子，要把K个棋子都放进去，并且</p>
<p>第一行，最后一行，第一列，最后一列，主对角线，副对角线都至少有一颗棋子的方案数是多</p>
<p>少？</p>
<p>顿时，徐半仙冷汗直流，不知如何应对这位不速之客，只好说：ok….ok…..</p>
<p>为了不显尴尬，徐半仙偷偷用他的迷你手机给你发了一通电报，告诉你N和K，请求你尽快把答</p>
<p>案发送给他。</p>
<ul>
<li>输入数据</li>
</ul>
<p>第一行为数据的组数<em>T</em> (<em>T</em> ⩽ 1000)</p>
<p>接下来T行，每行为两个整数<em>N</em>和<em>K</em> (2 ⩽ <em>N</em> ⩽ 100<em>,</em> 0 ⩽ <em>K</em> ⩽ 100)</p>
<ul>
<li>输出数据</li>
</ul>
<p>输出T行，第i行为第i组询问的答案。由于答案可能过大，请将答案模1e9+7之后再输出。</p>
<ul>
<li>样例输入</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;1</span><br><span class="line"></span><br><span class="line">&gt;3 3</span><br></pre></td></tr></table></figure>
<ul>
<li>样例输出</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;10</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>这题主要考察了组合数+容斥原理，其中组合数不是难点，直接套模板就行。</p>
<p>这里如果直接求就必须得考虑很多的情况，所以可以反着来，先求个无规则的任意的摆放数，</p>
<p>再从这个总数里面减去不符合规则的。</p>
<p>但是我们发现，如果减去了第一行没有棋子的摆放数A，再减去了最后一行没有棋子的摆放数B，</p>
<p>其实就多减去了第一行和最后一行没有棋子的情况，所以这一部分减多的，还要加回来。这里</p>
<p>就可以看到容斥原理了，然后就可以写一个二进制枚举，一共就6条线上的格子，2的6次方种</p>
<p>情况，对应0～31(1代表该条线上没有棋子，0代表可有可无)，如果是奇数个1就减去对应的摆</p>
<p>放数，如果是偶数个1，就加上对应的摆放数。代码稍微多点，但思路上并不难。</p>
<h3 id="CODE-1"><a href="#CODE-1" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll MAXN=<span class="number">10010</span>;</span><br><span class="line"><span class="type">const</span> ll MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">ll c[MAXN][<span class="number">110</span>];</span><br><span class="line"><span class="type">void</span> __initC(ll N = <span class="number">10005</span>)&#123;</span><br><span class="line">	c[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;=N;i++) c[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(ll j =<span class="number">1</span>;j&lt;=<span class="number">105</span>;j++)&#123;</span><br><span class="line">			c[i][j]=(ll)(c[i<span class="number">-1</span>][j]+c[i<span class="number">-1</span>][j<span class="number">-1</span>])% MOD;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">ll N,K;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	__initC();</span><br><span class="line">	ll t;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;t);</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;N,&amp;K);</span><br><span class="line">		ll ans=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;<span class="number">6</span>);i++)&#123;</span><br><span class="line">			ll cnt=<span class="number">0</span>,n=N,m=N,L=<span class="number">0</span>,R=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(ll j=<span class="number">0</span>;j&lt;<span class="number">6</span>;j++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(i&gt;&gt;j &amp;<span class="number">1</span>)&#123;</span><br><span class="line">					cnt++;</span><br><span class="line">					<span class="keyword">if</span>(j==<span class="number">0</span>||j==<span class="number">1</span>) n--;</span><br><span class="line">					<span class="keyword">if</span>(j==<span class="number">2</span>||j==<span class="number">3</span>) m--;</span><br><span class="line">					<span class="keyword">if</span>(j==<span class="number">4</span>)&#123;</span><br><span class="line">						L=N;</span><br><span class="line">						<span class="keyword">if</span>((i&gt;&gt;<span class="number">0</span>&amp;<span class="number">1</span>)||(i&gt;&gt;<span class="number">2</span>&amp;<span class="number">1</span>)) L--;</span><br><span class="line">						<span class="keyword">if</span>((i&gt;&gt;<span class="number">1</span>&amp;<span class="number">1</span>)||(i&gt;&gt;<span class="number">3</span>&amp;<span class="number">1</span>)) L--;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span>(j==<span class="number">5</span>)&#123;</span><br><span class="line">						R=N;</span><br><span class="line">						<span class="keyword">if</span>((i&gt;&gt;<span class="number">0</span>&amp;<span class="number">1</span>)||(i&gt;&gt;<span class="number">3</span>&amp;<span class="number">1</span>)) R--;</span><br><span class="line">						<span class="keyword">if</span>((i&gt;&gt;<span class="number">2</span>&amp;<span class="number">1</span>)||(i&gt;&gt;<span class="number">1</span>&amp;<span class="number">1</span>)) R--;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			ll num=n*m;</span><br><span class="line">			<span class="keyword">if</span>(L &amp;&amp; R &amp;&amp; N&amp;<span class="number">1</span>) num-=L+R<span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">else</span> num-=L+R;</span><br><span class="line">			<span class="keyword">if</span>(cnt&amp;<span class="number">1</span>) ans=(ans-c[num][K]+MOD)%MOD;</span><br><span class="line">			<span class="keyword">else</span> ans=(ans+c[num][K])%MOD;</span><br><span class="line">	 	&#125;</span><br><span class="line">	 	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="D-徐半仙的修仙之路"><a href="#D-徐半仙的修仙之路" class="headerlink" title="D 徐半仙的修仙之路"></a>D 徐半仙的修仙之路</h2><blockquote>
<ul>
<li>描述</li>
</ul>
<p>徐半仙每天闲来无事就在家中打坐，他相信这样能够悟道，得道升仙的方法；</p>
<p>有一天他接到了一个电话，电话中告诉他，蜀山的掌门给了他一次让他去蜀山学习的机会，约</p>
<p>他去城郊见面。于是他特别开心的答应了下来，但是他到了以后发现对方竟然是传销团伙，徐</p>
<p>半仙这时十分的后悔，他想偷偷的逃走但是这里守卫森严他一点办法都没有，这时他十分无助</p>
<p>的哭泣着并且十分后悔自己迷恋修仙。忽然旁边的憨憨龙告诉他，只要你能够计算出这个房子</p>
<p>有几间房间，并且最大的一间房间有多大就可以帮助他逃走了。</p>
<p>这个房子是只有一层，被分成了<em>n</em>行<em>m</em>列，每一间房间的面积都是1，但是因为传销团伙</p>
<p>为了节约空间，这些房间的四面墙有些被堵着了。并且如果两个房间连在一起就是一个面积</p>
<p>为2的房间。</p>
<p>这时徐半仙突然看到了机会，于是经过徐半仙的一波神奇的操作后他和憨憨龙一起逃出了</p>
<p>这个传销团伙，并且还配合警方抓捕了这个传销团伙。从这以后徐半仙再也不想着修仙了，他</p>
<p>一心专注于程序设计，并成为了一名优秀的acmer。</p>
<p>聪明的你一定想知道徐半仙如何计算的吗？那么你也来尝试一下吧，看看你和徐半仙谁更</p>
<p>厉害一点！</p>
<ul>
<li>输入数据</li>
</ul>
<p>每个测试有<em>T</em>组数据每组第一行输入两个数 <em>n, m</em> (1 ⩽ <em>n, m</em> ⩽ 50。接下来<em>n</em>行数据，每</p>
<p>行<em>m</em>个整数这个整数<em>p</em>表示表示这个房间所拥有的墙的编号和 (1表示左墙，2表示上墙，4表示</p>
<p>右墙，8表示下墙)</p>
<ul>
<li>输出数据</li>
</ul>
<p>输出两个整数分别代表房间的数量，和最大的房间面积。</p>
<ul>
<li>样例输入</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;1</span><br><span class="line"></span><br><span class="line">&gt;4 7</span><br><span class="line"></span><br><span class="line">&gt;11 6 11 6 3 10 6</span><br><span class="line"></span><br><span class="line">&gt;7 9 6 13 5 15 5</span><br><span class="line"></span><br><span class="line">&gt;1 10 12 7 13 7 5</span><br><span class="line"></span><br><span class="line">&gt;13 11 10 8 10 12 13</span><br></pre></td></tr></table></figure>
<ul>
<li>样例输出</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;5 9</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>这题主要考察你的dfs和你的建模能力。其实如果就是我们的一个模板题Oil Deposits</p>
<p>只是在这道题上加了一个走下一步的限制条件。</p>
<p>如果 <em>p</em>&amp;8 == 0 我们可以向下走</p>
<p>如果 <em>p</em>&amp;4 == 0 我们可以向右走</p>
<p>如果 <em>p</em>&amp;2 == 0 我们可以向上走</p>
<p>如果 <em>p</em>&amp;1 == 0 我们可以向左走</p>
<p>这样的话就和上面的模板题一样了</p>
<h3 id="CODE-2"><a href="#CODE-2" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> maze[<span class="number">60</span>][<span class="number">60</span>],M,N;</span><br><span class="line"><span class="type">int</span> book[<span class="number">60</span>][<span class="number">60</span>];</span><br><span class="line"><span class="type">int</span> roomnum =<span class="number">0</span>, maxroom =<span class="number">0</span>, room;<span class="comment">// 记录 房 间数 、 最大房间 、 目 前 房 间 大 小 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123; </span><br><span class="line">	<span class="keyword">if</span>(book[x][y]) <span class="keyword">return</span>;</span><br><span class="line">	room++;</span><br><span class="line">	book[x][y]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(( maze[x][y] &amp; <span class="number">1</span>)==<span class="number">0</span>) dfs(x,y<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">if</span>(( maze[x][y] &amp; <span class="number">2</span>)==<span class="number">0</span>) dfs(x<span class="number">-1</span>,y);</span><br><span class="line">	<span class="keyword">if</span>(( maze[x][y] &amp; <span class="number">4</span>)==<span class="number">0</span>) dfs(x,y+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(( maze[x][y] &amp; <span class="number">8</span>)==<span class="number">0</span>) dfs(x+<span class="number">1</span>,y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> t;<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;M&gt;&gt;N;</span><br><span class="line">		<span class="built_in">memset</span>(book ,<span class="number">0</span>,<span class="keyword">sizeof</span>(book ));</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;N;j++)&#123;</span><br><span class="line">				<span class="built_in">cin</span>&gt;&gt;maze[i][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;N;j++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(!book[i][j])&#123;</span><br><span class="line">					room=<span class="number">0</span>;</span><br><span class="line">					roomnum++;</span><br><span class="line">					dfs(i,j);</span><br><span class="line">					maxroom=max(maxroom,room );</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;roomnum&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;maxroom&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="G-徐半仙的数学问题"><a href="#G-徐半仙的数学问题" class="headerlink" title="G 徐半仙的数学问题"></a>G 徐半仙的数学问题</h2><blockquote>
<ul>
<li>描述</li>
</ul>
<p>已知有a,b,c,d四个正整数求满足下列两个等式的x的个数。</p>
<p><em>gcd</em> (<em>x, a</em>) = <em>b</em></p>
<p><em>lcm</em> (<em>x, c</em>) = <em>d</em></p>
<ul>
<li>输入数据</li>
</ul>
<p>第一行输入一个整数T，表示测试的组数</p>
<p>第2行到T+1行，每行4个整数,分别表示a,b,c,d.数据保证a能够被b整除，d能够被c整除</p>
<p>1 <em>&lt;</em>= <em>T &lt;</em>= 2000</p>
<p>1 <em>&lt;</em>= <em>a, b, c, d &lt;</em>= 2<em>e</em>9</p>
<ul>
<li>输出数据</li>
</ul>
<p>共T行，每行一个整数，如果不存在这样的x,输出0,否则,输出满足条件的x的个数</p>
<ul>
<li>样例输入</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;4</span><br><span class="line"></span><br><span class="line">&gt;41 1 96 288</span><br><span class="line"></span><br><span class="line">&gt;95 1 37 1776</span><br><span class="line"></span><br><span class="line">&gt;8481 1 999976991 1999953982</span><br><span class="line"></span><br><span class="line">&gt;32560 2 999992632 1999985264</span><br></pre></td></tr></table></figure>
<ul>
<li>样例输出</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;6</span><br><span class="line"></span><br><span class="line">&gt;2</span><br><span class="line"></span><br><span class="line">&gt;4</span><br><span class="line"></span><br><span class="line">&gt;0</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>考察了唯一分解定理求lcm和gcd，打一个素数表，枚举素数，打出质因子表。详细看<a href="https://www.bilibili.com/video/BV1Uc411h7Yq">bilibili</a></p>
<h3 id="CODE-3"><a href="#CODE-3" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#define ios ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0)</span><br><span class="line">#define debug  freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin),freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);</span><br><span class="line">#define PI acos(-1)</span><br><span class="line">#define fs first</span><br><span class="line">#define sc second</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">typedef pair&lt;int,int&gt; pii;</span><br><span class="line">const ll maxn = 1e6+10;</span><br><span class="line">double eps = 1e-8;</span><br><span class="line"> </span><br><span class="line">int T;</span><br><span class="line">int a0,a1,b0,b1;</span><br><span class="line">bool vis[maxn];</span><br><span class="line">int P[maxn],tail;</span><br><span class="line">struct node&#123;</span><br><span class="line">    int a,b,c,d;</span><br><span class="line">&#125;;</span><br><span class="line">map&lt;int,node&gt; mp;</span><br><span class="line">void initP(int N)&#123;</span><br><span class="line">    for(int i = 2;i&lt;=N;i++)&#123;</span><br><span class="line">        if(!vis[i]) P[tail++] = i;</span><br><span class="line">        for(int j = 0;P[j]&lt;=N/i;j++)&#123;</span><br><span class="line">            vis[P[j]*i] = true;</span><br><span class="line">            if(i%P[j] == 0) break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void divP()&#123;</span><br><span class="line">    int idx = 0;</span><br><span class="line">    for(int t:&#123;a0,a1,b0,b1&#125;)&#123;</span><br><span class="line">        ++idx;</span><br><span class="line">        for(int j = 0;j&lt;tail &amp;&amp; P[j]*P[j] &lt;=t;j++)&#123;</span><br><span class="line">            if(t%P[j] == 0)&#123;</span><br><span class="line">                int cnt = 0;</span><br><span class="line">                while(t%P[j] == 0)&#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                    t/=P[j];</span><br><span class="line">                &#125;</span><br><span class="line">                if(idx == 1) mp[P[j]].a = cnt;</span><br><span class="line">                if(idx == 2) mp[P[j]].b = cnt;</span><br><span class="line">                if(idx == 3) mp[P[j]].c = cnt;</span><br><span class="line">                if(idx == 4) mp[P[j]].d = cnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(t&gt;1)&#123;</span><br><span class="line">            if(idx == 1) mp[t].a = 1;</span><br><span class="line">            if(idx == 2) mp[t].b = 1;</span><br><span class="line">            if(idx == 3) mp[t].c = 1;</span><br><span class="line">            if(idx == 4) mp[t].d = 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ll fun()&#123;</span><br><span class="line">    ll res = 1;</span><br><span class="line">    for(auto p:mp)&#123;</span><br><span class="line">        node cur = p.second;</span><br><span class="line">        int a = cur.a,b = cur.b,c = cur.c,d = cur.d;</span><br><span class="line">        int cnt = 0;</span><br><span class="line">        for(int i = 0;i&lt;=31;i++)&#123;</span><br><span class="line">            if(min(i,a) == b &amp;&amp; max(i,c) == d) cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        res *= cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    ios;</span><br><span class="line">    initP(1&lt;&lt;16);</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        cin&gt;&gt;a0&gt;&gt;a1&gt;&gt;b0&gt;&gt;b1;</span><br><span class="line">        mp.clear();</span><br><span class="line">        divP();</span><br><span class="line">        cout&lt;&lt;fun()&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>集训</tag>
      </tags>
  </entry>
  <entry>
    <title>积分赛4</title>
    <url>/posts/3b9ecc04.html</url>
    <content><![CDATA[<p><a href="https://pan.baidu.com/s/1aWuvSuQW7LylPAX3pNOn4Q">题目面板</a> 提取码：k2fu</p>
<h2 id="A-胡图图的数学难题"><a href="#A-胡图图的数学难题" class="headerlink" title="A. 胡图图的数学难题"></a><strong>A.</strong> 胡图图的数学难题</h2><p>这道题很有意思让你求斐波那契数列的平方和，<a href="https://blog.csdn.net/lanchunhui/article/details/51840616?utm_source=blogxgwz5">一篇易懂的题解</a> 得到公式以后直接一个矩阵快速幂就解决了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	ll mat[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">memset</span>(mat,<span class="number">0</span>,<span class="keyword">sizeof</span> mat);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++) mat[i][i]=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	node <span class="keyword">operator</span> * (<span class="type">const</span> node &amp;o)&#123;</span><br><span class="line">		node ans;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>;j++)&#123;</span><br><span class="line">				ll sum=<span class="number">0</span>;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">2</span>;k++)&#123;</span><br><span class="line">					sum=(sum+mat[i][k]*o.mat[k][j]%MOD)%MOD;</span><br><span class="line">				&#125;</span><br><span class="line">				ans.mat[i][j]=sum;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">node p=&#123;</span><br><span class="line">	<span class="number">1</span>,<span class="number">1</span>,</span><br><span class="line">	<span class="number">1</span>,<span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">node <span class="title">ksm</span><span class="params">(node x,ll n)</span></span>&#123;</span><br><span class="line">	node ans;</span><br><span class="line">	ans.<span class="built_in">set</span>();</span><br><span class="line">	<span class="keyword">while</span>(n)&#123;</span><br><span class="line">		<span class="keyword">if</span>(n&amp;<span class="number">1</span>) ans=ans*x;</span><br><span class="line">		x=x*x;</span><br><span class="line">		n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios;</span><br><span class="line">	ll n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	node unit=<span class="built_in">ksm</span>(p,n<span class="number">-2</span>);</span><br><span class="line">	ll a=(unit.mat[<span class="number">0</span>][<span class="number">0</span>]+unit.mat[<span class="number">0</span>][<span class="number">1</span>])%MOD;</span><br><span class="line">	ll b=(unit.mat[<span class="number">1</span>][<span class="number">0</span>]+unit.mat[<span class="number">1</span>][<span class="number">1</span>])%MOD;</span><br><span class="line">	ll c=(a+b)%MOD;</span><br><span class="line">	cout&lt;&lt;(a*c)%MOD&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="C-胡图图公司大整改"><a href="#C-胡图图公司大整改" class="headerlink" title="C. 胡图图公司大整改"></a><strong>C.</strong> 胡图图公司大整改</h2><p>这道题是线段树的升级版，朴素版线段树是对一个连续的线段实现单点修改区间查询，而这道题则是在树上实现单点修改，区间查询，1结点是根节点，所以这道题就添加了一个操作把这n个点建成树的样子，然后对它们进行编号，编号方式是优先遍历子树，遍历到谁编号加一，这里用low数组来实现这个功能，到这里单点修改已经可以实现了，已经把一个线段上的每一个点都映射到了树上，但是区间查询还没有办法实现，为什么实现不了？这里要查询的是一个点的子树，这里的子树就相当于区间，我们上面优先遍历子树因此遍历完后，子树上的每一个点的序号是连续的，所以可以用high数组来记录子树区间的右端点，当遍历完一个点的所有子节点时就记录一下当前的序号，那么[lowi,highi]就表示了子树里面的点</p>
<p>总之这道题知识点就是用了一个dfs实现了将线段上的点映射到树上并且给之编号，实现了查询一个点的子树功能</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0), cin.tie(0), cout.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout );</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll,ll&gt; pii;</span><br><span class="line"><span class="type">const</span> ll maxn=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll inf=<span class="number">0x3f3f3f3f</span> ;</span><br><span class="line"></span><br><span class="line">ll N,Q;</span><br><span class="line">ll w[maxn]; <span class="comment">//每一个部门的薪资</span></span><br><span class="line">vector&lt;ll&gt; ve[maxn]; <span class="comment">//建边</span></span><br><span class="line">ll high[maxn],low[maxn],cnt; <span class="comment">//给树上的点编号</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    ll l,r;</span><br><span class="line">    ll minn,maxx;</span><br><span class="line">&#125;tr[maxn*<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(ll u)</span></span>&#123;</span><br><span class="line">    tr[u].minn=<span class="built_in">min</span>(tr[u&lt;&lt;<span class="number">1</span>].minn,tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].minn);</span><br><span class="line">    tr[u].maxx=<span class="built_in">max</span>(tr[u&lt;&lt;<span class="number">1</span>].maxx,tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].maxx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(ll u,ll l,ll r)</span></span>&#123; <span class="comment">//每一段的编号，范围</span></span><br><span class="line">    tr[u]=&#123;l,r&#125;;</span><br><span class="line">    <span class="keyword">if</span>(l!=r)&#123;</span><br><span class="line">        ll mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>,l,mid); <span class="comment">//建左端</span></span><br><span class="line">        <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r); <span class="comment">//建右端</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(ll u,ll x,ll c)</span></span>&#123; <span class="comment">//编号，要修改的位置，添加的值</span></span><br><span class="line">    <span class="keyword">if</span>(tr[u].l==x &amp;&amp; x==tr[u].r)&#123; <span class="comment">//找到位置</span></span><br><span class="line">        tr[u].minn+=c; <span class="comment">//此时只有一个点，因此最小值和最大值可以直接修改</span></span><br><span class="line">        tr[u].maxx+=c;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        ll mid=(tr[u].l+tr[u].r)&gt;&gt;<span class="number">1</span>; <span class="comment">//看看这个位置在左半边还是右半边</span></span><br><span class="line">        <span class="keyword">if</span>(x&lt;=mid) <span class="built_in">add</span>(u&lt;&lt;<span class="number">1</span>,x,c); <span class="comment">//左半边</span></span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">add</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,x,c); <span class="comment">//右半边</span></span><br><span class="line">        <span class="built_in">pushup</span>(u); <span class="comment">//每次修改节点的值后，都要上报给上级</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node <span class="title">query</span><span class="params">(ll u,ll l,ll r)</span></span>&#123; <span class="comment">//编号，范围</span></span><br><span class="line">    <span class="keyword">if</span>(l&lt;=tr[u].l &amp;&amp; tr[u].r&lt;=r) <span class="keyword">return</span> tr[u]; <span class="comment">//假若该段包含在给定范围内则直接返回</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        ll mid=(tr[u].l+tr[u].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(r&lt;=mid) <span class="keyword">return</span> <span class="built_in">query</span>(u&lt;&lt;<span class="number">1</span>,l,r); <span class="comment">//左端</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(l&gt;mid) <span class="keyword">return</span> <span class="built_in">query</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r); <span class="comment">//右端</span></span><br><span class="line">        <span class="keyword">else</span>&#123; <span class="comment">//左右两端中间</span></span><br><span class="line">            node ans,L,R;</span><br><span class="line">            L=<span class="built_in">query</span>(u&lt;&lt;<span class="number">1</span>,l,r); <span class="comment">//左半段</span></span><br><span class="line">            R=<span class="built_in">query</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r); <span class="comment">//右半段</span></span><br><span class="line">            ans.minn=<span class="built_in">min</span>(L.minn,R.minn);</span><br><span class="line">            ans.maxx=<span class="built_in">max</span>(L.maxx,R.maxx);</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//[low[x],high[x]]表示x结点下的结点编号范围</span></span><br><span class="line"><span class="comment">//high[x]-low[x]表示x结点下的子节点数量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(ll u,ll fa=<span class="number">-1</span>)</span></span>&#123; <span class="comment">//优先遍历每一个节点的子节点，给每一个结点编号</span></span><br><span class="line">    low[u]=++cnt; <span class="comment">//进入该节点时编个号</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v:ve[u])&#123; <span class="comment">//遍历每一个节点的子节点</span></span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>; <span class="comment">//注意不能返回原来的路</span></span><br><span class="line">        <span class="built_in">dfs</span>(v,u); <span class="comment">//优先遍历子节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    high[u]=cnt; <span class="comment">//遍历完该节点的子节点编个号，注意这里不能加</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    cin&gt;&gt;N&gt;&gt;Q; <span class="comment">//N个部门，Q组查询</span></span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=N;i++) cin&gt;&gt;w[i]; <span class="comment">//N个部门的薪资</span></span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=N<span class="number">-1</span>;i++)&#123; <span class="comment">//建树</span></span><br><span class="line">        ll u,v; cin&gt;&gt;u&gt;&gt;v; <span class="comment">//两个部门之间有从属关系即两者有边</span></span><br><span class="line">        ve[u].<span class="built_in">pb</span>(v);</span><br><span class="line">        ve[v].<span class="built_in">pb</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>); <span class="comment">//给树上的点进行编号，注意1是根节点</span></span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,N); <span class="comment">//建树，以上就是线段树的模板</span></span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=N;i++) <span class="built_in">add</span>(<span class="number">1</span>,low[i],w[i]); <span class="comment">//把原来的每一个点的权值映射到树上</span></span><br><span class="line">    <span class="keyword">while</span>(Q--)&#123;</span><br><span class="line">        ll op,x,y;</span><br><span class="line">        cin&gt;&gt;op;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">            cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">            <span class="built_in">add</span>(<span class="number">1</span>,low[x],y); <span class="comment">//x映射到书上就是low[x]的位置</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            node ans=<span class="built_in">query</span>(<span class="number">1</span>,low[x],high[x]); <span class="comment">//x的子树的范围就是[low[x],high[x]]</span></span><br><span class="line">            cout&lt;&lt; ans.maxx-ans.minn &lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="E-胡图图的难题"><a href="#E-胡图图的难题" class="headerlink" title="E. 胡图图的难题"></a><strong>E.</strong> 胡图图的难题</h2><p>1) 让最小的带最大的过去，最小的回来 fi = fii1 + ai + <em>a</em>1</p>
<p>2) 让最小的带第二小的过去，最小的回来，最大的两个过去，第二小的回来 <em>fi</em> = <em>fii</em> 2 + <em>ai</em> + a<em>1 + </em>a<em>1 + </em>a<em>2 </em>∗* 2</p>
<p>综上所述，fi = <em>min</em>(<em>fii</em> 1 + <em>ai</em> + <em>a</em>1<em>, fi</em>2 + <em>ai</em> + <em>a</em>1 + <em>a</em>2 <em>∗</em> 2)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc ++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mx =<span class="number">100000</span>+<span class="number">47</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> n,a[mx],f[mx];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">    sort(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line">    f[<span class="number">1</span>]=a[<span class="number">1</span>];</span><br><span class="line">    f[<span class="number">2</span>]=a[<span class="number">2</span>];</span><br><span class="line">    f[<span class="number">3</span>]=a[<span class="number">3</span>]+a[<span class="number">2</span>]+a[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">4</span>;i&lt;=n;i++)</span><br><span class="line">    f[i]= min(f[i <span class="number">-2</span>]+a[i]+a[<span class="number">1</span>]+(a[<span class="number">2</span>]&lt;&lt;<span class="number">1</span>),f[i <span class="number">-1</span>]+a[i]+a[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,f[n]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="F-胡图图找队友"><a href="#F-胡图图找队友" class="headerlink" title="F 胡图图找队友"></a>F 胡图图找队友</h2><h3 id="CODE1"><a href="#CODE1" class="headerlink" title="CODE1"></a>CODE1</h3><p>维护一个数组存储每一个点和根节点的关系，是否属于一个集合，因此每次只要通过根节点这个媒介联系两个结点的关系</p>
<p><a href="https://blog.csdn.net/freezhanacmore/article/details/8774033">详细题解</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e3</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> fa[MAXN],r[MAXN];</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		fa[i]=i;</span><br><span class="line">		r[i]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==fa[x]) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="type">int</span> tmp=fa[x]; <span class="comment">//备份父亲节点</span></span><br><span class="line">	fa[x]=find(fa[x]); <span class="comment">//递归特性先更新最里面的东西，因此在下面一行更新之前，父亲结点已经发生改变，同理递归深层也是如此，所以如今父亲节点记录的直接是和祖宗的关系</span></span><br><span class="line">	r[x]=(r[x]+r[tmp])%<span class="number">2</span>; <span class="comment">//因为压缩路径本质就是直接找到当前结点和根节点的关系，所以r数组记录的也要是和根节点的关系</span></span><br><span class="line">	<span class="keyword">return</span> fa[x]; <span class="comment">//fa[x]现在已经是根节点了，返回根节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Union</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span>&#123;</span><br><span class="line">	<span class="type">int</span> x=find(a), y=find(b);</span><br><span class="line">	<span class="keyword">if</span>(x!=y)&#123;</span><br><span class="line">		fa[y]=x; <span class="comment">//有一点要明白，并查集合并操作是对两个根节点的操作，儿子结点和根节点的联系是通过压缩路径去实现的</span></span><br><span class="line">		<span class="keyword">if</span>(c) r[y]=(r[a]+r[b]+<span class="number">1</span>)%<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">else</span> r[y]=(r[a]+r[b])%<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// ios;</span></span><br><span class="line">	<span class="comment">// debug;</span></span><br><span class="line">	<span class="type">int</span> t,n,m;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;t);</span><br><span class="line">	init(n);</span><br><span class="line">	<span class="type">char</span> c;</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c%d%d&quot;</span>,&amp;c,&amp;x,&amp;y);</span><br><span class="line">		<span class="keyword">if</span>(c==<span class="string">&#x27;B&#x27;</span>) Union(x,y,<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">else</span> Union(x,y,<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		<span class="type">int</span> a,b;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">		<span class="keyword">if</span>(find(a)==find(b))&#123;</span><br><span class="line">			<span class="keyword">if</span>(r[a]==r[b]) <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Not sure\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CODE2"><a href="#CODE2" class="headerlink" title="CODE2"></a>CODE2</h3><p>第二种思路，前n个作为第一个集合，后n个作为第二个集合，具体查看<a href="https://blog.csdn.net/u011008379/article/details/50999448?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param">题解</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e3</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> fa[MAXN*<span class="number">2</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++) fa[i]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==fa[x]) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">return</span> fa[x]=find(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Union</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">	<span class="type">int</span> x=find(a), y=find(b);</span><br><span class="line">	<span class="keyword">if</span>(x!=y) fa[y]=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> t,n,m;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;t);</span><br><span class="line">	init(<span class="number">2</span>*n);</span><br><span class="line">	<span class="type">char</span> c;</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot; %c%d%d&quot;</span>,&amp;c,&amp;x,&amp;y);</span><br><span class="line">		<span class="keyword">if</span>(c==<span class="string">&#x27;B&#x27;</span>)&#123;</span><br><span class="line">			Union(x,y);</span><br><span class="line">			Union(x+n,y+n);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			Union(x+n,y);</span><br><span class="line">			Union(x,y+n);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		<span class="type">int</span> a,b;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">		<span class="keyword">if</span>(find(a)==find(b)||find(a+n)==find(b+n)) <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(find(a+n)==find(b)||find(a)==find(b+n)) <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Not sure\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="H-胡图图的好兄弟"><a href="#H-胡图图的好兄弟" class="headerlink" title="H. 胡图图的好兄弟"></a>H. 胡图图的好兄弟</h2><p><strong>记忆化搜索</strong></p>
<p>首先不考虑<em>a</em>1为何值，先预处理出当<em>x &gt;</em> 1时的结果，首先定义一个数组dp[N] [2]，<em>dp</em>[<em>i</em>][<em>j</em>]是指<em>x</em> = <em>i</em>并且执行第<em>j</em>步操作时的最终结果。在过程中记录每一个<em>dp</em>[<em>i</em>][<em>j</em>]下一次再次来到<em>i</em>点便可以直接返回<em>dp</em>[<em>i</em>][<em>j</em>]。在这个过程中可能会遇到回到了<em>a</em>1，但是<em>a</em>1是不确定的。不过并没有影响，题目描述算法输出有两种情况，一个是<em>y</em>，一个是<em>ᱟ</em> 1，什么时候出现<em>⧠</em> 1，当出现循环的时候，比如说在一次程序运行中，已经计算了<em>dp</em>[<em>i</em>] [<em>j</em>]但是后来有来到了<em>dp</em>[<em>i</em>][<em>j</em>]，很明显此时陷入循环了，那么就会输出<em>ࠪ</em> 1，对于再次经过<em>a</em>1有两种情况，一种是<em>i</em> = 1<em>, j</em> = 0，即下一步<em>x</em> = <em>x</em> + <em>a</em>1，因为程序的第一步都是<em>i</em> = 1<em>, j</em> = 0，所以说，到这里陷入循环输出<em>ࠪ</em> 1。另外一种<em>i</em> = 1 <em>j</em> = 1是不会出现的。预处理完后，我们便可以逐个输dp<em>[i][1] + </em>ii<em> 1(</em>i &gt;<em> 1)，</em>ii<em> 1是指初始时经过</em>a<em>1也就是</em>dp*[1][0]的值。</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">100</span>;</span><br><span class="line">ll dp[N][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> arr[N];</span><br><span class="line"><span class="type">bool</span> vis[N][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123; <span class="comment">//表示当前在第几个点，当前经过了奇数还是偶数次操作</span></span><br><span class="line">    <span class="keyword">if</span>(vis[i][j]) <span class="keyword">return</span> ; <span class="comment">//如果当前点之前已经经过了则直接返回</span></span><br><span class="line">    <span class="type">int</span> nx; <span class="comment">//下一个点</span></span><br><span class="line">    vis[i][j]=<span class="number">1</span>; <span class="comment">//标记当前点已经访问过了</span></span><br><span class="line">    <span class="keyword">if</span>(j&amp;<span class="number">1</span>) nx=i-arr[i]; <span class="comment">//奇数次操作减</span></span><br><span class="line">    <span class="keyword">else</span> nx=i+arr[i]; <span class="comment">//偶数次操作加</span></span><br><span class="line">    <span class="keyword">if</span>(nx&lt;=<span class="number">0</span>||nx&gt;n)&#123; <span class="comment">//下一个点结束，则现在就可以直接记录答案，表示从第i个点开始经过奇偶次操作后结束答案为arr[i]</span></span><br><span class="line">        dp[i][j]=arr[i];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(nx,j^<span class="number">1</span>); <span class="comment">//下一个点没有结束则需要继续搜索，j变换奇偶</span></span><br><span class="line">    <span class="keyword">if</span>(dp[nx][j^<span class="number">1</span>]!=<span class="number">-1</span>)&#123; <span class="comment">//搜索完后如果从下一个点开始可以结束</span></span><br><span class="line">        dp[i][j]=arr[i]+dp[nx][j^<span class="number">1</span>]; <span class="comment">//加上下一步的答案</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ios;</span><br><span class="line">    vis[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>; <span class="comment">//表示从第一个点开始，经过了1次操作，也就是第一步后到达的第一个点</span></span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="keyword">sizeof</span> dp); <span class="comment">//初始化每一个点的答案都是-1，表示有循环</span></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;arr[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++) dfs(i,<span class="number">1</span>); <span class="comment">//预处理，得出每一个点的答案</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[i][<span class="number">1</span>]!=<span class="number">-1</span>) dp[i][<span class="number">1</span>]+=i<span class="number">-1</span>; <span class="comment">//因为是从第二步开始的，第一步i=1,j=0，因此需要加上a1，也就是i-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;dp[i][<span class="number">1</span>]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="I-胡图图吃桃子"><a href="#I-胡图图吃桃子" class="headerlink" title="I. 胡图图吃桃子"></a><strong>I.</strong> 胡图图吃桃子</h2><p>完全背包问题，算是比较模板，不过你得想到完全背包%%%</p>
<p>完全背包初始化我还不理解，不懂什么时候必须初始化一些东西，反正我现在的做法就是把能直接看出来答案的数都初始化一下</p>
<p><a href="https://www.luogu.com.cn/problem/solution/P1679">详细点击我</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> p[<span class="number">1000</span>],dp[<span class="number">120010</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> w;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;w;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">18</span>;i++) p[i]=<span class="built_in">pow</span>(i,<span class="number">4</span>); <span class="comment">//数据范围到1e5所以要算到18</span></span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dp); <span class="comment">//初始化为无穷大</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">18</span>;i++) dp[p[i]]=<span class="number">1</span>; <span class="comment">//因为是4次方所以最小值都是1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;p[i]&lt;=w;i++)&#123; <span class="comment">//注意条件</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=p[i];j&lt;=w;j++)&#123;</span><br><span class="line">            dp[j]=min(dp[j],dp[j-p[i]]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[w]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这道题我刚开始一直以为贪心做就可以了，但事实证明认为可行也只是我的个人感觉，我刚开始的做法就是每次对这个数开四次根号，再减去这个数的四次方，之前已知都没想到哪里错了，举了很多例子都找不出来错误，事实上例子确实不好找，跑了一下706到1里面错误的都很少，比如704=(4^4^)^2^+(2^4^)^12^,也就是14次，但是贪心每次都去最大四次方数就是二十次，错了</p>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>集训</tag>
      </tags>
  </entry>
  <entry>
    <title>积分赛5</title>
    <url>/posts/4c99fc92.html</url>
    <content><![CDATA[<blockquote>
<p><del>最友好的一次积分赛2333</del>应该也是最后一个个人积分赛了，不知道最后一次会不会是团队赛，再说吧，已经八月十五了，自从集训以来每天都有训练，虽然晚上一般都是有些时间去记录一些题解的，但是懒癌晚期的我真的不想去写，终于今天下定决心，趁着这两天我要补一下题解，把最近有意义的题目记录一下，也算是一个复习吧🎉</p>
</blockquote>
<h2 id="D-何不好的晨练"><a href="#D-何不好的晨练" class="headerlink" title="D 何不好的晨练"></a>D 何不好的晨练</h2><p><strong>描述</strong></p>
<p>何不好是一名晨练爱好者，每天他都要一大早出门进行晨跑锻炼，何不好生活的城市很大，</p>
<p>同时也比较繁荣，路边高楼耸立，道路上车辆往来，川流不息。</p>
<p>晨练的同时还可以欣赏路边的风景，于是，何不好打算每天选择 <em>M</em> 条路段，其中包括 <em>N</em></p>
<p>个路口。</p>
<p>但何不好想要从起点开始不重复的跑完所有路段，并且跑回起点，苦于是学渣的他不知道</p>
<p>能不能完成这个条件，于是他向你寻求帮助。</p>
<p><strong>输入数据</strong></p>
<p>第一行给定两个整数 <em>N</em> , <em>M</em> 。</p>
<p>接下来 <em>M</em> 行，每行有两个整数 <em>U</em>，<em>V</em> 代表路段相连的两个路口。</p>
<p>1 <em>≤</em> <em>N</em> <em>≤</em> 100,000. 0 <em>≤</em> <em>M</em> <em>≤</em> 100,000. 毎对儿 <em>U</em>, <em>V</em> 互不相同，且 <em>U</em>, <em>V</em> 不同。</p>
<p><strong>输出数据</strong></p>
<p>若能完成这个条件则输出Yes，否则输出No。</p>
<p><strong>样例输入</strong></p>
<p>4 4</p>
<p>1 2</p>
<p>2 3</p>
<p>3 4</p>
<p>4 1</p>
<p><strong>样例输出</strong></p>
<p>Yes</p>
<hr>
<p>不难的一道题，只要知道了一笔画问题就差不多能解决了，首先看两个概念</p>
<ol>
<li>欧拉通路：即可以不回到起点，但是必须经过每一条边，且只能一次。也叫”一笔画”问题。该路径成为欧拉路径。</li>
<li>图G的一个回路，如果恰通过图G的每一条边，则该回路称为欧拉回路，具有欧拉回路的图称为欧拉图。欧拉图就是从图上的一点出发，经过所有边且只能经过一次，最终回到起点的路径。</li>
</ol>
<p><strong>判定充要条件</strong></p>
<p>欧拉回路：    1:  图G是连通的，不能有孤立点存在。</p>
<p>　　　　　　2:  <code>对于无向图来说度数为奇数的点个数为0;  对于有向图来说每个点的入度必须等于出度</code>。</p>
<p>欧拉通路：    1:  图G是连通的，无孤立点存在。</p>
<p>　　　　　　2:  对于无向图来说，<code>度数为奇数的的点可以有2个或者0个，并且这两个奇点其中一个为起点另外一个为终点</code>。  对于有向图来说，可以<code>存在两个点，其入度不等于出度，其中一个出度比入度大1，为路径的起点；另外一个入度比出度大1，为路径的终点</code>。</p>
<p>知道了这个这个题目就只要判断<code>图是否联通+图上奇数度数点是否存在</code>，度数容易判断，图是否联通则可以用并查集来做，开一个son数组代表该结点作为根节点下方有多少点，合并时更新即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> fa[MAXN],son[MAXN];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;MAXN;i++)&#123; <span class="comment">//初始化</span></span><br><span class="line">    	fa[i]=i; son[i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(fa[x]==x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> fa[x]=find(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Union</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">    x=find(x);</span><br><span class="line">    y=find(y);</span><br><span class="line">    <span class="keyword">if</span>(x!=y)&#123;</span><br><span class="line">        fa[x]=y;</span><br><span class="line">        son[y]+=son[x]; <span class="comment">//右面结点的son数量加上左面结点的son数量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">    <span class="type">int</span> n,m,a,b;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        mp[a]++,mp[b]++;</span><br><span class="line">        Union(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> f1=<span class="number">0</span>,f2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> p:mp)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p.second&amp;<span class="number">1</span>) f1=<span class="number">1</span>; <span class="comment">//判奇数结点</span></span><br><span class="line">        <span class="keyword">if</span>(son[find(p.first)]!=n) f2=<span class="number">1</span>; <span class="comment">//若图联通则任意一个结点的祖先的son值一定等于所有节点的数量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f1||f2) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="E-何不好的博弈游戏"><a href="#E-何不好的博弈游戏" class="headerlink" title="E 何不好的博弈游戏"></a>E 何不好的博弈游戏</h2><p><strong>描述</strong></p>
<p>何不好要和他的好朋友Tom玩一个游戏，游戏规则是有n个硬币，正面向上围成一个圆圈，</p>
<p>并且排上序号1到n，确定一个数字k，每次只能翻序号连续的1到k个硬币（n和1连续），每个硬</p>
<p>币只能翻一次，如果最后谁没有硬币可以翻(所有的硬币都被翻过一次了)，谁就输掉了这个游</p>
<p>戏，每次都是何不好先手，如果两个人都很聪明，并且没有失误的话，问最后何不好能不能赢</p>
<p>得这次游戏。</p>
<p><strong>输入数据</strong></p>
<p>第一行是一个整数<em>T</em>(<em>T</em> ⩽ 10)</p>
<p>接下来有T行，每一行有两个整数<em>n</em>(1 ⩽ <em>n</em> ⩽ 103)，<em>k</em>(1 ⩽ <em>k</em> ⩽ 103)。</p>
<p><strong>输出数据</strong></p>
<p>如果何不好能赢这次游戏，输出“Yes”，如果不能，输出“No”。</p>
<p><strong>样例输入</strong></p>
<p>3</p>
<p>3 1</p>
<p>5 2</p>
<p>5 6</p>
<p><strong>样例输出</strong></p>
<p>Yes</p>
<p>No</p>
<p>Yes</p>
<hr>
<p><strong>思路</strong></p>
<p>博弈论个人理解就是智力题，这道题对不同情况分别讨论：</p>
<ol>
<li><p>如果 k&lt;n:</p>
<ol>
<li>当k=1时，如果n是奇数，先手一定能赢，n是偶数后手赢</li>
<li>当k&gt;1时，后手一定赢（先手第一次翻什么位置，后手就翻对称的位置，使剩下的硬币分为两个相同长度的序列），然后无论先手接下来怎么翻，后手就翻对称的位置，这样保证后手永远有硬币可以翻</li>
</ol>
</li>
<li><p>如果k&gt;=n:  后手赢，直接翻完就完事了</p>
</li>
</ol>
<p>把思路直接写成代码就行了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc ++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		<span class="type">int</span> n,k;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">		<span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(k&lt;n)&#123;</span><br><span class="line">			<span class="keyword">if</span>(k==<span class="number">1</span>&amp;&amp;(n&amp;<span class="number">1</span>)) flag=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(k&gt;=n) flag=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(flag==<span class="number">1</span>) <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="I-何不好的字符串"><a href="#I-何不好的字符串" class="headerlink" title="I 何不好的字符串"></a>I 何不好的字符串</h2><p><strong>描述</strong></p>
<p>何不好非常不好，因为别人给他一个字符串，要让他解答问题，何不好懒得写就把他交给</p>
<p>你们了，何不好可以不回答，但你们必须回答，给你一个字符串<em>S</em>,先将字符串扩充一次，比</p>
<p>如<em>AB</em>变成<em>ABAB</em>,在把字符串中随意加入一个字母构成字符串<em>U</em>，让你重新构造出字符串<em>S</em>;</p>
<p><strong>输入数据</strong></p>
<p>第一行输入表示字符串<em>U</em>长度为<em>N</em>(<em>N</em> ⩽ 20000001)，第二行输入字符串<em>U</em>;</p>
<p><strong>输出数据</strong></p>
<p>输出字符串<em>S</em>, 如果符串无法按照上述方法构造出来，输出<em>NOT P OSSIBLE</em>; 如果字符串<em>S</em>不唯一，输出<em>NOT UNIQUE</em>;</p>
<p><strong>样例输入1</strong></p>
<p>7</p>
<p>ABXCABC</p>
<p><strong>样例输出1</strong></p>
<p>ABC</p>
<p><strong>样例输入2</strong> </p>
<p>6</p>
<p>ABCDEF</p>
<p><strong>样例输出3</strong></p>
<p>NOT POSSIBLE</p>
<hr>
<p><strong>思路</strong></p>
<p>哈希预处理，使得字符串比较复杂度降低为O(1)，因此枚举每一个位置删除该位置后看看前半部分和后半部分是否相同，时间复杂度为O(n)，不过这个数据真的吓人2e7的字符串长度，计算机1s能算5e8的数据，能过的</p>
<p>现在给你两个字符串的哈希值，让你求两个字符串拼接后的哈希值，只需要让左面的乘以p^右面字符串长度^加上右面字符串哈希值就行了，这里卡了好久</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="type">const</span> ull base=<span class="number">2333</span>;</span><br><span class="line"><span class="type">const</span> ull N=<span class="number">20000101</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;ull,ull&gt; mp;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> n,len,cnt;</span><br><span class="line">ull Hash[N],p[N];</span><br><span class="line">ull <span class="title function_">gethash</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> Hash[y]-Hash[x<span class="number">-1</span>]*p[y-x+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> pos)</span>&#123;</span><br><span class="line">    ull hash1,hash2;</span><br><span class="line">    <span class="keyword">if</span>(pos&lt;=n+<span class="number">1</span>)&#123;</span><br><span class="line">    	hash1=Hash[pos<span class="number">-1</span>]*p[n+<span class="number">1</span>-pos]+gethash(pos+<span class="number">1</span>,n+<span class="number">1</span>); <span class="comment">//算出删除点左面哈希值和右面哈希值，然后把左面乘以相应权值然后加上右面就是拼接好的哈希值</span></span><br><span class="line">    	hash2=gethash(n+<span class="number">2</span>,len); <span class="comment">//因为删除点在左半部分，因此右面直接算哈希</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">    	hash1=Hash[n]; <span class="comment">//删除点在右半部分，左面直接算</span></span><br><span class="line">    	hash2=gethash(n+<span class="number">1</span>,pos<span class="number">-1</span>)*p[len-pos]+gethash(pos+<span class="number">1</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(hash1==hash2)&#123;</span><br><span class="line">        mp[hash1]++; <span class="comment">//把新得到的字符串的哈希值存到map里</span></span><br><span class="line">        <span class="keyword">if</span>(mp[hash1]==<span class="number">1</span>) cnt++; <span class="comment">//若该字符串是第一次出现则计数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">    len=n;</span><br><span class="line">    <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>)&#123; <span class="comment">//原串字符数量是偶数时直接输出不可能</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;NOT POSSIBLE&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    n/=<span class="number">2</span>; <span class="comment">//找到中点</span></span><br><span class="line">    p[<span class="number">0</span>]=<span class="number">1</span>; <span class="comment">//打一个每一位权值的表</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;++i)&#123; <span class="comment">//打哈希表加权值表</span></span><br><span class="line">    	p[i]=p[i<span class="number">-1</span>]*base;</span><br><span class="line">    	Hash[i]=Hash[i<span class="number">-1</span>]*base+(s[i]-<span class="string">&#x27;A&#x27;</span>+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> pos;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;++i)&#123;</span><br><span class="line">    	<span class="keyword">if</span>(check(i)) pos=i; <span class="comment">//枚举每一个点，当删除该点后左右字符串哈希值一样则表示符合条件记录该位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!cnt) <span class="built_in">puts</span>(<span class="string">&quot;NOT POSSIBLE&quot;</span>); <span class="comment">//枚举每一个点左右两边的哈希值都不一样就不可能</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(cnt&gt;<span class="number">1</span>) <span class="built_in">puts</span>(<span class="string">&quot;NOT UNIQUE&quot;</span>); <span class="comment">//当出现了两个解输出不唯一</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos&lt;=n+<span class="number">1</span>) <span class="keyword">for</span>(<span class="type">int</span> i=n+<span class="number">2</span>;i&lt;=len;++i) <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,s[i]); <span class="comment">//删除的字符在左面就输出右面</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,s[i]); <span class="comment">//否则输出左面</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>集训</tag>
      </tags>
  </entry>
  <entry>
    <title>进制转换模板</title>
    <url>/posts/6bf2ab0f.html</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请你编一程序实现两种不同进制之间的数据转换。</p>
<p>输入格式</p>
<p>共三行，第一行是一个正整数，表示需要转换的数的进制n(2≤n≤16)n(2≤n≤16)n(2≤n≤16)，第二行是一个n进制数，若n&gt;10n&gt;10n&gt;10则用大写字母A−FA-FA−F表示数码10−1510-1510−15，并且该nnn进制数对应的十进制的值不超过100000000010000000001000000000，第三行也是一个正整数，表示转换之后的数的进制m(2≤m≤16)m(2≤m≤16)m(2≤m≤16)。</p>
<p>输出格式</p>
<p>一个正整数，表示转换之后的mmm进制数。</p>
<p>输入输出样例</p>
<p>输入 #1</p>
<pre><code>16

FF

2
</code></pre><p>输出 #1</p>
<pre><code>11111111
</code></pre><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;math.h&gt;
#include&lt;vector&gt;
using namespace std;
int change(char ch)&#123;
  if(ch==&#39;A&#39;) return 10;
  if(ch==&#39;B&#39;) return 11;
  if(ch==&#39;C&#39;) return 12;
  if(ch==&#39;D&#39;) return 13;
  if(ch==&#39;E&#39;) return 14;
  if(ch==&#39;F&#39;) return 15;
&#125;
char judge(int a)&#123;
  if(a&gt;=0&amp;&amp;a&lt;=9) return char(a+&#39;0&#39;);
  if(a==10) return &#39;A&#39;;
  if(a==11) return &#39;B&#39;;
  if(a==12) return &#39;C&#39;;
  if(a==13) return &#39;D&#39;;
  if(a==14) return &#39;E&#39;;
  if(a==15) return &#39;F&#39;;
&#125;
int main()
&#123;
  int n,m,i=0,cnt=0;
  long long sum=0;
  vector&lt;int&gt; arr;
  string num;
  cin&gt;&gt;m&gt;&gt;num&gt;&gt;n;
  for(int i=num.size()-1;i&gt;=0;i--,cnt++)&#123;
    if(num[i]&gt;=&#39;A&#39;&amp;&amp;num[i]&lt;=&#39;F&#39;)&#123;
      int t=change(num[i]);
      sum+=t*pow(m,cnt);
    &#125;
    else sum+=(num[i]-&#39;0&#39;)*pow(m,cnt);    
  &#125;
//    cout&lt;&lt;sum&lt;&lt;endl;
  if(n==10) cout&lt;&lt;sum&lt;&lt;endl;
  else if(n&gt;=2&amp;&amp;n&lt;10||n&gt;10&amp;&amp;n&lt;=16)&#123;
    string s=&quot;&quot;;
    while(sum!=0)&#123;
      s=judge(sum%n)+s;
      sum/=n;
    &#125;
    cout&lt;&lt;s&lt;&lt;endl;
  &#125;
&#125; 
</code></pre>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>集训第一天</title>
    <url>/posts/1f97ad2b.html</url>
    <content><![CDATA[<blockquote>
<p>紧张刺激而又枯燥的集训开始了🐷</p>
</blockquote>
<h2 id="problem1"><a href="#problem1" class="headerlink" title="problem1"></a>problem1</h2><p><a href="https://vjudge.net/contest/382262#problem/D">题目链接</a></p>
<p>一道思维题，很容易想到从大往小减，这是一个误区，可以这样思考，任意两个数如果差为偶数一定是满足题目要求的，当这两个数高度相同时就可以看成一棵树了，再让这个数去和其他的数比较，当差又是偶数时便又满足题目要求，便可以得出规律，只要给定序列任意两个数相差为偶数便满足题意</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI acos(-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> h[MAXN];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">    	<span class="type">int</span> n;</span><br><span class="line">    	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;h[i];</span><br><span class="line">		<span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>((h[i]-h[i<span class="number">-1</span>])%<span class="number">2</span>)&#123;</span><br><span class="line">				flag=<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(flag) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;no&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;yes&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="Problem2"><a href="#Problem2" class="headerlink" title="Problem2"></a>Problem2</h2><p><a href="https://vjudge.net/contest/382262#problem/G">题目链接</a></p>
<p>英文不好真的读不懂题。。。这道题意思是机器人从原点出发，经过一系列走法之后到达一点，问能不能删除这一系列走法中的字串，使得终点不变而删除的字串长度最小</p>
<p>不难看出当走到以前经过的一点时，这中间的序列一定是可以删除的，那么我们可以每一点上一次走到这里花费的步数(注意不是最小步数因为我们要求的是删除的字串长度最小)，当再次走到该点时用此时的步数减去上一次走到该点的步数得到的就是可以删除的字串长度，若该长度最小那么更新答案便可以了，这里如何记录一个点是否走过呢？假设用数组来存就需要二维数组，里面大多数点都是没用的，就很浪费空间，这道题开不了这么大的空间，可以用map来存，map<pair<int,int>,int&gt;</p>
<h3 id="CODE-1"><a href="#CODE-1" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt;,<span class="type">int</span>&gt; mp;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		mp.clear();</span><br><span class="line">		<span class="type">int</span> n,maxn=<span class="number">1e9</span>;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;s;</span><br><span class="line">		s=<span class="string">&#x27; &#x27;</span>+s;</span><br><span class="line">		<span class="type">int</span> l,r,x=<span class="number">0</span>,y=<span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> len=s.size();</span><br><span class="line">		mp[<span class="built_in">make_pair</span>(x,y)]=<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(s[i]==<span class="string">&#x27;L&#x27;</span>) x--;</span><br><span class="line">			<span class="keyword">if</span>(s[i]==<span class="string">&#x27;R&#x27;</span>) x++;</span><br><span class="line">			<span class="keyword">if</span>(s[i]==<span class="string">&#x27;D&#x27;</span>) y--;</span><br><span class="line">			<span class="keyword">if</span>(s[i]==<span class="string">&#x27;U&#x27;</span>) y++;</span><br><span class="line">			<span class="type">int</span> m=mp[<span class="built_in">make_pair</span>(x,y)];</span><br><span class="line">			<span class="keyword">if</span>(m!=<span class="number">0</span>)&#123;</span><br><span class="line">				<span class="keyword">if</span>(m==<span class="number">-1</span>) m=<span class="number">0</span>;</span><br><span class="line">				<span class="keyword">if</span>(i-m&lt;maxn)&#123;</span><br><span class="line">					maxn=i-m;</span><br><span class="line">					l=m+<span class="number">1</span>; r=i;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			mp[<span class="built_in">make_pair</span>(x,y)]=i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(maxn==<span class="number">1e9</span>) <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;l&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;r&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="problem3"><a href="#problem3" class="headerlink" title="problem3"></a>problem3</h2><p><a href="https://vjudge.net/contest/382262#problem/K">题目链接</a></p>
<p>这道题我想错方向了，我在想把两个字符串连接后转化成新数，然后这个问题就转换成了从1到a，从1到b挑出两个数满足题意，这样我最多就能想出二分优化成NlogN，但是数据量1e9，指定过不了，就在这可了很久很久，原来这道题两个数连接不是让用字符串连接的，是让你用a10^(b的位数)+b来连接的，这样一来原来的a+b+ab==a10^(b的位数)+b，两边消去b，然后等式都除以a，就把a消去了，然后就能算出来b的公式，b=10^(b的位数)-1，啊！这道题其实不难，就是方向错了，难受😫</p>
<h3 id="CODE-2"><a href="#CODE-2" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> <span class="title function_">check</span><span class="params">(ll t)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(t&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">int</span> x=t%<span class="number">10</span>;</span><br><span class="line">        t/=<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span>(x!=<span class="number">9</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        ll a,b;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        ll cnt=<span class="number">0</span>;</span><br><span class="line">        ll temp=b;</span><br><span class="line">        <span class="keyword">while</span>(temp&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            temp/=<span class="number">10</span>;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(check(b)) <span class="built_in">cout</span>&lt;&lt;a*cnt&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;a*(cnt<span class="number">-1</span>)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Problem4"><a href="#Problem4" class="headerlink" title="Problem4"></a>Problem4</h2><p><a href="https://vjudge.net/contest/382262#problem/J">题目链接</a></p>
<p>这道题也算是一道思维题吧，要想让数最大，一定是数的位数优先，两位数肯定比一位数大对吧，想通了这再举几个例子就能看出来这是一个递归的过程，递归出口就是2和3</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI acos(-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> h[MAXN];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">    	<span class="type">int</span> n;</span><br><span class="line">    	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;h[i];</span><br><span class="line">		<span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>((h[i]-h[i<span class="number">-1</span>])%<span class="number">2</span>)&#123;</span><br><span class="line">				flag=<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(flag) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;no&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;yes&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>集训</tag>
      </tags>
  </entry>
  <entry>
    <title>STL集训典型题目</title>
    <url>/posts/c024eb61.html</url>
    <content><![CDATA[<blockquote>
<p>自己找题，做课件，还得学习新的东西，不得不说确实挺费时间的，光找找题目就花了2个小时左右，还是因为自己的题量少的原因，只能去搜一些题目自己再做做，不过粘贴题目AC的感觉真的美妙🐷</p>
</blockquote>
<h2 id="Running-Medians"><a href="#Running-Medians" class="headerlink" title="Running Medians"></a>Running Medians</h2><p>For this problem, you will write a program that reads in a sequence of 32-bit signed integers. After each <em>odd-indexed</em> value is read, output the median (middle value) of the elements received so far.</p>
<blockquote>
<p><strong>Input</strong></p>
<p>The first line of input contains a single integer P, (1 ≤ P ≤ 1000), which is the number of data sets that follow. The first line of each data set contains the data set number, followed by a space, followed by an odd decimal integer M, (1 ≤ M ≤ 9999), giving the total number of signed integers to be processed.<br>The remaining line(s) in the dataset consists of the values, 10 per line, separated by a single space.<br>The last line in the dataset may contain less than 10 values.</p>
<p><strong>Output</strong></p>
<p>For each data set the first line of output contains the data set number, a single space and the number of medians output (which should be one-half the number of input values plus one). The output medians will be on the following lines, 10 per line separated by a single space. The last line may have less than 10 elements, but at least 1 element. There should be no blank lines in the output.</p>
<p><strong>Sample Input</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">9</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br><span class="line"><span class="number">2</span> <span class="number">9</span></span><br><span class="line"><span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">23</span></span><br><span class="line"><span class="number">23</span> <span class="number">41</span> <span class="number">13</span> <span class="number">22</span> <span class="number">-3</span> <span class="number">24</span> <span class="number">-31</span> <span class="number">-11</span> <span class="number">-8</span> <span class="number">-7</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">103</span> <span class="number">211</span> <span class="number">-311</span> <span class="number">-45</span> <span class="number">-67</span> <span class="number">-73</span> <span class="number">-81</span> <span class="number">-99</span></span><br><span class="line"><span class="number">-33</span> <span class="number">24</span> <span class="number">56</span></span><br></pre></td></tr></table></figure>
<p>Sample Output</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;<span class="number">1</span> <span class="number">5</span></span><br><span class="line">&gt;<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line">&gt;<span class="number">2</span> <span class="number">5</span></span><br><span class="line">&gt;<span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span></span><br><span class="line">&gt;<span class="number">3</span> <span class="number">12</span></span><br><span class="line">&gt;<span class="number">23</span> <span class="number">23</span> <span class="number">22</span> <span class="number">22</span> <span class="number">13</span> <span class="number">3</span> <span class="number">5</span> <span class="number">5</span> <span class="number">3</span> <span class="number">-3</span></span><br><span class="line">&gt;<span class="number">-7</span> <span class="number">-3</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>一道对顶堆的典型例题，对顶堆是优先队列的一种典型使用方式，主要就是开辟两个优先队列，一个大根一个小根，动态维护它们的元素数量以及两个队列的队头大小关系，永远保证大根堆头比小根堆头小，从而使整个序列元素有序，因此每次进来一个新元素只要判断其是该放到哪一个堆就行了</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> T,n,m,a[<span class="number">50005</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">priority_queue</span>&lt;<span class="type">int</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt; &gt; q;</span><br><span class="line"></span><br><span class="line"><span class="built_in">priority_queue</span>&lt;<span class="type">int</span>&gt; p;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())q.pop();</span><br><span class="line">        <span class="keyword">while</span>(!p.empty())p.pop();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;m,&amp;n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,m,(n+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        q.push(a[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a[<span class="number">1</span>]);</span><br><span class="line">        <span class="type">int</span> cnt=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;q.top()) q.push(a[i]);</span><br><span class="line">            <span class="keyword">else</span> p.push(a[i]);</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(p.size()&gt;(i/<span class="number">2</span>))&#123;</span><br><span class="line">                    q.push(p.top());</span><br><span class="line">                    p.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>(q.size()&gt;(i-(i/<span class="number">2</span>)))&#123;</span><br><span class="line">                    p.push(q.top());</span><br><span class="line">                    q.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                cnt++;</span><br><span class="line">                <span class="keyword">if</span>(cnt%<span class="number">10</span>==<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;\n%d&quot;</span>,q.top());</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>,q.top());</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Constructing-the-Array"><a href="#Constructing-the-Array" class="headerlink" title="Constructing the Array"></a>Constructing the Array</h2><p><a href="https://vjudge.net/contest/382426#problem/I">题目链接</a></p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>这道题拿到手应该第一反应就是找规律，找规律是能做出来的，情况也就是那么多种，但是这道题更官方的做法是用优先队列来做，什么你问我怎么做？我们只要每一段连续0的字符串当作一个优先队列，定义一个结构体，装这对序列的最左面元素的下标和这段序列的长度，优先按长度从大到小排列，然后再按下标从小到大排列，每次将指定元素放到到指定位置时，以这个元素作为分割线从中间分开，之后就会出现两个队列，依次入队，每次重复这样的操作，直到放完所有的元素</p>
<h3 id="CODE-1"><a href="#CODE-1" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> len,l,r;</span><br><span class="line">	<span class="type">bool</span> operator &lt; (<span class="type">const</span> node &amp;a) <span class="type">const</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(a.len==len) <span class="keyword">return</span> l&gt;a.l;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> len&lt;a.len;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">priority_queue</span>&lt;node&gt; pq;</span><br><span class="line"><span class="type">int</span> ans[N];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		<span class="type">int</span> n;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">		<span class="built_in">memset</span>(ans,<span class="number">0</span>,<span class="keyword">sizeof</span> ans);</span><br><span class="line">		<span class="keyword">while</span>(!pq.empty()) pq.pop();</span><br><span class="line">		pq.push((node)&#123;n,<span class="number">1</span>,n&#125;);</span><br><span class="line">		<span class="type">int</span> cnt=<span class="number">0</span>,mid;</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">			node now=pq.top(); pq.pop();</span><br><span class="line">			<span class="keyword">if</span>((now.r-now.l+<span class="number">1</span>)&amp;<span class="number">1</span>)&#123;</span><br><span class="line">				ans[(now.l+now.r)&gt;&gt;<span class="number">1</span>]=++cnt;</span><br><span class="line">				mid=(now.l+now.r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				ans[(now.l+now.r<span class="number">-1</span>)&gt;&gt;<span class="number">1</span>]=++cnt;</span><br><span class="line">				mid=(now.l+now.r<span class="number">-1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(cnt==n) <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">if</span>(mid<span class="number">-1</span>&gt;=now.l) pq.push((node)&#123;mid-now.l,now.l,mid<span class="number">-1</span>&#125;);</span><br><span class="line">			<span class="keyword">if</span>(now.r&gt;=mid+<span class="number">1</span>) pq.push((node)&#123;now.r-mid,mid+<span class="number">1</span>,now.r&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cout</span>&lt;&lt;ans[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>集训前缀和与差分</title>
    <url>/posts/a36c6b85.html</url>
    <content><![CDATA[<h2 id="程序设计：蒜头君的数轴"><a href="#程序设计：蒜头君的数轴" class="headerlink" title="程序设计：蒜头君的数轴"></a>程序设计：蒜头君的数轴</h2><p>题目来源 ：<a href="https://nanti.jisuanke.com/t/A1633">点击我</a></p>
<p>今天蒜头君拿到了一个数轴，上边有 n 个点，但是蒜头君嫌这根数轴不够优美，想要通过加一些点让它变优美，所谓优美是指考虑相邻两个点的距离，最多只有一对点的距离与其它的不同。</p>
<p>蒜头君想知道，他最少需要加多少个点使这个数轴变优美。</p>
<blockquote>
<p><strong>输入格式</strong></p>
<p>输入第一行为一个整数 n(1 &lt;=n ,q&lt;= 10^5)(1≤<em>n</em>≤105)，表示数轴上的点数。</p>
<p>第二行为 n个不重复的整数</p>
<p><em>x</em>1,<em>x</em>2,…, xn (−109≤xi≤109)，表示这些点的坐标，点坐标乱序排列。</p>
<p><strong>输出格式</strong></p>
<p>输出一行，为一个整数，表示蒜头君最少需要加多少个点使这个数轴变优美。</p>
<p><strong>样例输入</strong></p>
<p>4<br>1 3 7 15</p>
<p><strong>样例输出</strong></p>
<p>1</p>
</blockquote>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>题目很简单，意思就是在一个数轴给你n个点，让在数轴上添加最少的点使得任意两点之间距离都相等(允许一组点间距和其他不等)。</p>
<p>这道题目用到了gcd，如果不考虑允许一组间距和其他的不相等的情况的话，那么就应该把所有区间都变成长度为gcd(所有点间距)(下面用gcd代替)，现在允许一组不等，那么可以枚举这n-1个区间，删除一个区间看看此时需要添加的最小点数量是多少，取其中最小值，如何求点数量呢？任意一段区间想把它变成gcd就要添加x/gcd-1，x表示这一段区间长度，这是显而易见的，两个连续点是这样的情况，那n个点呢？就应该是这n个点每一组区间的点数加起来，而gcd是一样的，也就是说分母一样，分子是这一段区间长度，而后面减去了多少个一呢？原本有n-1段区间，现在删去了一个，剩下了n-2个，所以计算了n-2次，就是说最后公式就变成了len/gcd-n+2，len表示减去区间后的长度，OK到这里思路就很清晰了，不过还有一点，删去一个区间后你怎么算剩下的区间的gcd呢？每次删去难道都要枚举一下吗？那也太费时了，这里就用到了前缀的思想(注意没有“和”字哦)，开一个gcd1的数组，gcd1[i]表示前i个区间的gcd，再开一个gcd2数组，gcd2[i]表示i之后所有区间的gcd(包括i)，每次删去一个区间，就可以更新gcd为__gcd(gcd1[i-1]gcd2[i+1])，OK分析完毕，接下来就可以<del>开心</del>的写代码了</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF= <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> val[N],gcd1[N],gcd2[N],dis[N];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n,sum=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;val[i];</span><br><span class="line">	sort(val+<span class="number">1</span>,val+<span class="number">1</span>+n); <span class="comment">//因为输入是乱序，所以要排一下序</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">		dis[i]=val[i+<span class="number">1</span>]-val[i];</span><br><span class="line">		sum+=dis[i];</span><br><span class="line">	&#125;</span><br><span class="line">	gcd1[<span class="number">0</span>]=<span class="number">0</span>;<span class="comment">//注意初始化</span></span><br><span class="line">	gcd2[n]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++) gcd1[i]=__gcd(gcd1[i<span class="number">-1</span>],dis[i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--) gcd2[i]=__gcd(gcd2[i+<span class="number">1</span>],dis[i]);</span><br><span class="line">	<span class="type">int</span> ans=INF;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">		<span class="type">int</span> len=sum-dis[i];</span><br><span class="line">		<span class="type">int</span> temp;</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">1</span>) temp=(len/gcd2[i+<span class="number">1</span>])-n+<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(i==n<span class="number">-1</span>) temp=(len/gcd1[n<span class="number">-2</span>])-n+<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">else</span> temp=(len/__gcd(gcd1[i<span class="number">-1</span>],gcd2[i+<span class="number">1</span>]))-n+<span class="number">2</span>;</span><br><span class="line">		ans=min(ans,temp);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>
<h2 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h2><p>Xiaoteng has a large area of land for growing crops, and the land can be seen as a rectangle of $n \times m$.</p>
<p>But recently Xiaoteng found that his crops were often stolen by a group of people, so he decided to install some monitors to find all the people and then negotiate with them.</p>
<p>However, Xiao Teng bought bad monitors, each monitor can only monitor the crops inside a rectangle. There are $p$ monitors installed by Xiaoteng, and the rectangle monitored by each monitor is known.</p>
<p>Xiao Teng guess that the thieves would also steal $q$ times of crops. he also guessed the range they were going to steal, which was also a rectangle. Xiao Teng wants to know if his monitors can see all the thieves at a time.</p>
<blockquote>
<p><strong>Input</strong></p>
<p>There are mutiple test cases.</p>
<p>Each case starts with a line containing two integers $n,m (1 &lt;= n,1 &lt;= m , n \times m &lt;= 10^7)$ which represent the area of the land.</p>
<p>And the secend line contain a integer $p(1 &lt;=p &lt;= 10^6)$ which represent the number of the monitor Xiaoteng has installed. This is followed by p lines each describing a rectangle. Each of these lines contains four intergers $x_1,y_1,x_2~and~y_2(1&lt;=x_1 &lt;=x_2 &lt;= n,1&lt;= y_1 &lt;= y_2 &lt;= m)$ ,meaning the lower left corner and upper right corner of the rectangle.</p>
<p>Next line contain a integer $q(1 &lt;= q&lt;= 10^6)$ which represent the number of times that thieves will steal the crops. This is followed by q lines each describing a rectangle. Each of these lines contains four intergers $x_1,y_1,x_2~and~y_2(1&lt;= x_1 &lt;= x_2 &lt;= n,1&lt;= y_1 &lt;= y_2 &lt;= m)$,meaning the lower left corner and upper right corner of the rectangle.</p>
<p><strong>Output</strong></p>
<p>For each case you should print $q$ lines.</p>
<p>Each line containing <strong>YES</strong> or <strong>NO</strong> mean the all thieves whether can be seen.</p>
<p><strong>Sample Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6 6</span><br><span class="line">3</span><br><span class="line">2 2 4 4</span><br><span class="line">3 3 5 6</span><br><span class="line">5 1 6 2</span><br><span class="line">2</span><br><span class="line">3 2 5 4</span><br><span class="line">1 5 6 5</span><br></pre></td></tr></table></figure>
</blockquote>
<p>&gt;<br>&gt;</p>
<blockquote>
<p><strong>Sample Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;YES</span><br><span class="line">&gt;NO</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>题意比较好理解，给你几个矩形区域，这些区域是可以被监控到的，之后再给一些矩形区域，问你这些区域是不是包含在监控区域内部，</p>
<p>很明显我们可以用差分和前缀和把所有监控区域标记为1，然后看偷庄稼的区域面积是不是等于该区域对应值的和，是则包含，否则不包含，这道题难就难在数据量，只说了n*m&lt;=1e7，却没有说n和m的范围，这很为难人啊，你开小一点，万一坐标给你来一个（1，1e7），那不就炸了，你必须开到[ 1e7 ] [1e7]的量才能过，但是会爆内存，这时有一种非常巧妙的方法，把二维映射到一维，具体怎么做呢？比如(2 , 3)，映射规则就是 (x-1)m+y，那这一点就映射到了m+3这一点上，这样可以把这种映射规则写成一个函数，参数就是二维坐标，函数返回映射到一维数组的位置。特别需要注意的一点就是如果你传入参数坐标有0或者大于n或者m了一定要返回0，因为二维前缀和的边界都是0，然后就可以写代码了</p>
<h3 id="CODE-1"><a href="#CODE-1" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI acos(-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e7</span>+<span class="number">100</span>;</span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> n,m,v[N];</span><br><span class="line"><span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==<span class="number">0</span>||y==<span class="number">0</span>||x&gt;n||y&gt;m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> (x<span class="number">-1</span>)*m+y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m))&#123;</span><br><span class="line">		<span class="built_in">memset</span>(v,<span class="number">0</span>,<span class="keyword">sizeof</span> v);</span><br><span class="line">		<span class="type">int</span> t; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">		<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">			<span class="type">int</span> x1,x2,y1,y2;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);</span><br><span class="line">			v[get(x1,y1)]++; </span><br><span class="line">			v[get(x2+<span class="number">1</span>,y2+<span class="number">1</span>)]++;</span><br><span class="line">			v[get(x1,y2+<span class="number">1</span>)]--;</span><br><span class="line">			v[get(x2+<span class="number">1</span>,y1)]--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">				v[get(i,j)]+=v[get(i<span class="number">-1</span>,j)]+v[get(i,j<span class="number">-1</span>)]-v[get(i<span class="number">-1</span>,j<span class="number">-1</span>)];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(v[get(i,j)]&gt;<span class="number">0</span>) v[get(i,j)]=<span class="number">1</span>;</span><br><span class="line">				v[get(i,j)]+=v[get(i<span class="number">-1</span>,j)]+v[get(i,j<span class="number">-1</span>)]-v[get(i<span class="number">-1</span>,j<span class="number">-1</span>)];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> q; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q);</span><br><span class="line">		<span class="keyword">while</span>(q--)&#123;</span><br><span class="line">			<span class="type">int</span> x1,x2,y1,y2;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);</span><br><span class="line">			<span class="type">int</span> ans=v[get(x2,y2)]+v[get(x1<span class="number">-1</span>,y1<span class="number">-1</span>)]-v[get(x2,y1<span class="number">-1</span>)]-v[get(x1<span class="number">-1</span>,y2)];</span><br><span class="line">			<span class="keyword">if</span>(ans==(x2-x1+<span class="number">1</span>)*(y2-y1+<span class="number">1</span>))<span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>
<h3 id="做法二"><a href="#做法二" class="headerlink" title="做法二"></a>做法二</h3><p>这道题内存问题还可以用vector来解，因为vector是动态的嘛，定义方式vector<vector< int >&gt; ve(n+10, vector&lt; int &gt;(m+10,0))</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,m,p,q;</span><br><span class="line">int main()&#123; </span><br><span class="line">	while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m))&#123; </span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt; ve(n+10,vector&lt;int&gt;(m+10,0));</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;p); </span><br><span class="line">        int x1,y1,x2,y2;</span><br><span class="line">        while(p--)&#123;</span><br><span class="line">            scanf(&quot;%d%d%d%d&quot;,&amp;x1,&amp;y1,&amp;x2,&amp;y2);</span><br><span class="line">            // cout&lt;&lt;x1&lt;&lt;y1&lt;&lt;x2&lt;&lt;y2&lt;&lt;endl;</span><br><span class="line">            ve[x1][y1]++;</span><br><span class="line">            ve[x2+1][y1]--;</span><br><span class="line">            ve[x1][y2+1]--;</span><br><span class="line">            ve[x2+1][y2+1]++;</span><br><span class="line">        &#125;</span><br><span class="line">        //二维差分求前缀和</span><br><span class="line">		for(int i=1;i&lt;=n;i++)</span><br><span class="line">		for(int j=1;j&lt;=m;j++)&#123;</span><br><span class="line">			ve[i][j]+=ve[i-1][j]+ve[i][j-1]-ve[i-1][j-1];</span><br><span class="line">		&#125;</span><br><span class="line">		//把每个格子都置为1</span><br><span class="line">        for(int i=1;i&lt;=n;i++)</span><br><span class="line">            for(int j=1;j&lt;=m;j++)&#123;</span><br><span class="line">                ve[i][j]=min(1,ve[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        for(int i=1;i&lt;=n;i++)</span><br><span class="line">            for(int j=1;j&lt;=m;j++)&#123;</span><br><span class="line">                ve[i][j]+=ve[i-1][j]+ve[i][j-1]-ve[i-1][j-1];</span><br><span class="line">            &#125;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;q);</span><br><span class="line">        while(q--)&#123;</span><br><span class="line">            scanf(&quot;%d%d%d%d&quot;,&amp;x1,&amp;y1,&amp;x2,&amp;y2);</span><br><span class="line">            int t=ve[x2][y2]-ve[x2][y1-1]-ve[x1-1][y2]+ve[x1-1][y1-1];</span><br><span class="line">            if(t==(x2-x1+1)*(y2-y1+1)) cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;</span><br><span class="line">            else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>集训</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心与二分</title>
    <url>/posts/8fb3f0eb.html</url>
    <content><![CDATA[<blockquote>
<p>被虐惨了，各种调试与超时或者看不懂题🐷</p>
</blockquote>
<h2 id="Strange-fuction"><a href="#Strange-fuction" class="headerlink" title="Strange fuction"></a>Strange fuction</h2><blockquote>
<p>Now, here is a fuction:<br>F(x) = 6 <em> x^7+8</em>x^6+7<em>x^3+5</em>x^2-y*x (0 &lt;= x &lt;=100)<br>Can you find the minimum value when x is between 0 and 100.</p>
<p><strong>Input</strong></p>
<p>The first line of the input contains an integer T(1&lt;=T&lt;=100) which means the number of test cases. Then T lines follow, each line has only one real numbers Y.(0 &lt; Y &lt;1e10)</p>
<p><strong>Output</strong></p>
<p>Just the minimum value (accurate up to 4 decimal places),when x is between 0 and 100.</p>
<p><strong>Sample Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;2</span><br><span class="line">&gt;100</span><br><span class="line">&gt;200</span><br></pre></td></tr></table></figure>
<p><strong>Sample Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;-74.4291</span><br><span class="line">&gt;-178.8534</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>做了这道题我终于相信ACM和高中数学紧密相连，因为是打代码，我就没往导数的方向去想，一搜题解看到导数俩字我瞬间醍醐灌顶，行如流水代码出来🐶</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI acos(-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="type">double</span> y;</span><br><span class="line"><span class="type">double</span> <span class="title function_">dao</span><span class="params">(<span class="type">double</span> x)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">42</span>*<span class="built_in">pow</span>(x,<span class="number">6.0</span>)+<span class="number">48</span>*<span class="built_in">pow</span>(x,<span class="number">5.0</span>)+<span class="number">21</span>*<span class="built_in">pow</span>(x,<span class="number">2.0</span>)+<span class="number">10</span>*x-y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> <span class="title function_">f</span><span class="params">(<span class="type">double</span> x)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">6</span>*<span class="built_in">pow</span>(x,<span class="number">7</span>)+<span class="number">8</span>*<span class="built_in">pow</span>(x,<span class="number">6</span>)+<span class="number">7</span>*<span class="built_in">pow</span>(x,<span class="number">3</span>)+<span class="number">5</span>*<span class="built_in">pow</span>(x,<span class="number">2</span>)-x*y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;y);</span><br><span class="line">		<span class="type">double</span> l,r,mid;</span><br><span class="line">		l=<span class="number">0</span>; r=<span class="number">100</span>;</span><br><span class="line">		<span class="keyword">while</span>(r-l&gt;=eps)&#123;</span><br><span class="line">			mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span>(dao(mid)&gt;<span class="number">0</span>) r=mid;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(dao(mid)&lt;<span class="number">0</span>) l=mid;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%.4f\n&quot;</span>,f(mid));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Best-Cow-Line"><a href="#Best-Cow-Line" class="headerlink" title="Best Cow Line"></a>Best Cow Line</h2><p>读不懂题的一道题，其实很简单，但是我就是没读懂意思，它的顺序更换规则只能改变第一个和最后一个，其实是一道比较水的题目，我要吐槽的是刚开始我想锻炼一下数据结构，用双端队列来做了，还用了迭代器，最后交后直接给我来个编译错误，我<em>，喵的，我*</em>写了这么久你t喵的不能使用迭代器，k！最后还是换成了字符数组来做</p>
<h3 id="CODE-1"><a href="#CODE-1" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI acos(-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="type">int</span> n; <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="type">char</span> ch[n+<span class="number">10</span>];</span><br><span class="line">	<span class="built_in">string</span> ans;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;ch[i];</span><br><span class="line">	<span class="type">int</span> p1=<span class="number">1</span>,p2=n;</span><br><span class="line">	<span class="keyword">while</span>(p2&gt;=p1)&#123;</span><br><span class="line">		<span class="keyword">if</span>(ch[p1]&lt;ch[p2])&#123;</span><br><span class="line">			ans+=ch[p1];</span><br><span class="line">			p1++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(ch[p1]&gt;ch[p2])&#123;</span><br><span class="line">			ans+=ch[p2];</span><br><span class="line">			p2--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(ch[p1]==ch[p2])&#123;</span><br><span class="line">			<span class="type">int</span> it1=p1,it2=p2;</span><br><span class="line">			<span class="keyword">while</span>(ch[it1]==ch[it2]&amp;&amp;it2&gt;it1)&#123;</span><br><span class="line">				it1++; it2--;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(ch[it1]&gt;=ch[it2])&#123;</span><br><span class="line">				ans+=ch[p2];</span><br><span class="line">				p2--;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(ch[it1]&lt;ch[it2])&#123;</span><br><span class="line">				ans+=ch[p1];</span><br><span class="line">				p1++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> cnt=<span class="number">1</span>,len=ans.size();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(cnt%<span class="number">80</span>==<span class="number">0</span>) <span class="built_in">cout</span>&lt;&lt;ans[i]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;ans[i];</span><br><span class="line">		cnt++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="The-Frog’s-Games"><a href="#The-Frog’s-Games" class="headerlink" title="The Frog’s Games"></a>The Frog’s Games</h2><blockquote>
<p>The annual Games in frogs’ kingdom started again. The most famous game is the Ironfrog Triathlon. One test in the Ironfrog Triathlon is jumping. This project requires the frog athletes to jump over the river. The width of the river is L (1&lt;= L &lt;= 1000000000). There are n (0&lt;= n &lt;= 500000) stones lined up in a straight line from one side to the other side of the river. The frogs can only jump through the river, but they can land on the stones. If they fall into the river, they<br>are out. The frogs was asked to jump at most m (1&lt;= m &lt;= n+1) times. Now the frogs want to know if they want to jump across the river, at least what ability should they have. (That is the frog’s longest jump distance).</p>
<p><strong>Input</strong></p>
<p>The input contains several cases. The first line of each case contains three positive integer L, n, and m.<br>Then n lines follow. Each stands for the distance from the starting banks to the nth stone, two stone appear in one place is impossible.</p>
<p><strong>Output</strong></p>
<p>For each case, output a integer standing for the frog’s ability at least they should have.</p>
<p><strong>Sample Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;6 1 2</span><br><span class="line">&gt;2</span><br><span class="line">&gt;25 3 3</span><br><span class="line">&gt;11 </span><br><span class="line">&gt;2</span><br><span class="line">&gt;18</span><br></pre></td></tr></table></figure>
<p><strong>Sample Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;4</span><br><span class="line">&gt;11</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>青蛙过河，给你河宽，石头数以及每一个石头离河岸的距离，跳的步数，问青蛙每次最少跳几米才能不掉进河里且安全过岸，典型二分，大致估算复杂度NlogN，不会超时，这里难的其实是怎么判断当前检测的距离是否满足，说白了就是青蛙必须跳到最远能跳到的石头，这样才能保证可能能跳到对面，怎么解决跳到最远能跳到的石头呢？可以用一个pre记录上一次所在的石头位置，然后枚举石头距离，如果当前石头距离上一次位置距离小于等于你的最远弹跳距离的话，就把当前石头位置往后移一个，那么最后出来循环当前石头距离上次驻留位置距离一定是大于最远弹跳距离的，再把石头位置往前移动一个就达到了最远能跳到的距离，<code>二分检查经常碰到这种情况，一定要知道怎么解决</code>。</p>
<h3 id="CODE-2"><a href="#CODE-2" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI acos(-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> d[N];</span><br><span class="line"><span class="type">int</span> L,n,m;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> mid)</span>&#123;</span><br><span class="line">	<span class="type">int</span> pos=<span class="number">0</span>,pre=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="keyword">while</span>(pos&lt;=n+<span class="number">1</span>&amp;&amp;d[pos]-d[pre]&lt;=mid) pos++;</span><br><span class="line">		pos--;</span><br><span class="line">		pre=pos;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(pos&gt;=n+<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;L&gt;&gt;n&gt;&gt;m)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;d[i];</span><br><span class="line">		d[n+<span class="number">1</span>]=L;</span><br><span class="line">		sort(d+<span class="number">1</span>,d+<span class="number">1</span>+n);</span><br><span class="line">		<span class="type">int</span> l=<span class="number">0</span>,r=L,mid,ans;</span><br><span class="line">		<span class="keyword">while</span>(r&gt;=l)&#123;</span><br><span class="line">			mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(check(mid))&#123;</span><br><span class="line">				ans=mid;</span><br><span class="line">				r=mid<span class="number">-1</span>;</span><br><span class="line">			&#125; </span><br><span class="line">			<span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="湫湫系列故事——消灭兔子"><a href="#湫湫系列故事——消灭兔子" class="headerlink" title="湫湫系列故事——消灭兔子"></a>湫湫系列故事——消灭兔子</h2><blockquote>
<p>湫湫减肥<br>　　越减越肥！</p>
<p>最近，减肥失败的湫湫为发泄心中郁闷，在玩一个消灭免子的游戏。<br>　　游戏规则很简单，用箭杀死免子即可。<br>　　箭是一种消耗品，已知有M种不同类型的箭可以选择，并且每种箭都会对兔子造成伤害，对应的伤害值分别为Di（1 &lt;= i &lt;= M），每种箭需要一定的QQ币购买。<br>　　假设每种箭只能使用一次，每只免子也只能被射一次，请计算要消灭地图上的所有兔子最少需要的QQ币。</p>
<p><strong>Input</strong></p>
<p>输入数据有多组，每组数据有四行；<br>第一行有两个整数N，M（1 &lt;= N, M &lt;= 100000），分别表示兔子的个数和箭的种类；<br>第二行有N个正整数，分别表示兔子的血量Bi（1 &lt;= i &lt;= N）；<br>第三行有M个正整数，表示每把箭所能造成的伤害值Di（1 &lt;= i &lt;= M）；<br>第四行有M个正整数，表示每把箭需要花费的QQ币Pi（1 &lt;= i &lt;= M）。</p>
<p>特别说明：<br>1、当箭的伤害值大于等于兔子的血量时，就能将兔子杀死；<br>2、血量Bi，箭的伤害值Di，箭的价格Pi，均小于等于100000。</p>
<p><strong>Output</strong></p>
<p>如果不能杀死所有兔子，请输出”No”，否则，请输出最少的QQ币数，每组输出一行。</p>
<p><strong>Sample Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;3 3</span><br><span class="line">&gt;1 2 3</span><br><span class="line">&gt;2 3 4</span><br><span class="line">&gt;1 2 3</span><br><span class="line">&gt;3 4</span><br><span class="line">&gt;1 2 3</span><br><span class="line">&gt;1 2 3 4</span><br><span class="line">&gt;1 2 3 1</span><br></pre></td></tr></table></figure>
<p><strong>Sample Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;6</span><br><span class="line">&gt;4</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>做这道题就只需要知道一点，杀一只兔子，我们应该选择伤害足够的箭里面消耗最小的，我们把兔子按照血量从大到小排序，箭按伤害从大到小排序，然后枚举兔子血量，去箭里面找到能够杀死这只兔子的所有箭，去里面找到耗费最小的，然后累加耗费就行了，做着做着就发现这用到了优先队列<del>不用优先队列还超时</del>，优先队列用来装每次枚举兔子时可以杀死这只兔子的所有箭，然后给优先队列进行一次比较运算符重载就行了</p>
<h3 id="CODE-3"><a href="#CODE-3" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI acos(-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> d[N];</span><br><span class="line"><span class="type">int</span> L,n,m;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> mid)</span>&#123;</span><br><span class="line">	<span class="type">int</span> pos=<span class="number">0</span>,pre=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="keyword">while</span>(pos&lt;=n+<span class="number">1</span>&amp;&amp;d[pos]-d[pre]&lt;=mid) pos++;</span><br><span class="line">		pos--;</span><br><span class="line">		pre=pos;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(pos&gt;=n+<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;L&gt;&gt;n&gt;&gt;m)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;d[i];</span><br><span class="line">		d[n+<span class="number">1</span>]=L;</span><br><span class="line">		sort(d+<span class="number">1</span>,d+<span class="number">1</span>+n);</span><br><span class="line">		<span class="type">int</span> l=<span class="number">0</span>,r=L,mid,ans;</span><br><span class="line">		<span class="keyword">while</span>(r&gt;=l)&#123;</span><br><span class="line">			mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(check(mid))&#123;</span><br><span class="line">				ans=mid;</span><br><span class="line">				r=mid<span class="number">-1</span>;</span><br><span class="line">			&#125; </span><br><span class="line">			<span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Can-you-find-it"><a href="#Can-you-find-it" class="headerlink" title="Can you find it?"></a>Can you find it?</h2><blockquote>
<p>Give you three sequences of numbers A, B, C, then we give you a number X. Now you need to calculate if you can find the three numbers Ai, Bj, Ck, which satisfy the formula Ai+Bj+Ck = X.</p>
<p><strong>Input</strong></p>
<p>There are many cases. Every data case is described as followed: In the first line there are three integers L, N, M, in the second line there are L integers represent the sequence A, in the third line there are N integers represent the sequences B, in the forth line there are M integers represent the sequence C. In the fifth line there is an integer S represents there are S integers X to be calculated. 1&lt;=L, N, M&lt;=500, 1&lt;=S&lt;=1000. all the integers are 32-integers.</p>
<p><strong>Output</strong></p>
<p>For each case, firstly you have to print the case number as the form “Case d:”, then for the S queries, you calculate if the formula can be satisfied or not. If satisfied, you print “YES”, otherwise print “NO”.</p>
<p><strong>Sample Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;3 3 3</span><br><span class="line">&gt;1 2 3</span><br><span class="line">&gt;1 2 3</span><br><span class="line">&gt;1 2 3</span><br><span class="line">&gt;3</span><br><span class="line">&gt;1</span><br><span class="line">&gt;4</span><br><span class="line">&gt;10</span><br></pre></td></tr></table></figure>
<p><strong>Sample Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;Case 1:</span><br><span class="line">&gt;NO</span><br><span class="line">&gt;YES</span><br><span class="line">&gt;NO</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h2><p>题意比较好理解，给你三组序列数从这三组序列里随便挑三个数求满足式子所有做法数量，很好想到的是加俩序列，然后在第三组序列里二分找K-a[i]-b[i]，高高兴兴写好代码，交上去超时了。。。后来想了很久感觉没办法再优化了，没想到正解是二分K-c[i]，用一个新数组存ab数组的组合，再在新数组里面二分找K-c[i]，这样好处就是二分的数组变长了，复杂度虽然还是nlogn，但是n却变小了（logn虽然变大了，但是因为是log级别几乎没影响）。真是巧妙</p>
<h3 id="CODE-4"><a href="#CODE-4" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e3</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> a[MAXN],b[MAXN],c[MAXN],d[MAXN],x[<span class="number">250010</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> 	<span class="type">int</span> L,N,M,kase=<span class="number">0</span>;</span><br><span class="line"> 	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;L&gt;&gt;N&gt;&gt;M)&#123;</span><br><span class="line"> 		<span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">	 	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=L;i++) <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++) <span class="built_in">cin</span>&gt;&gt;b[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=M;i++) <span class="built_in">cin</span>&gt;&gt;c[i];</span><br><span class="line">		<span class="type">int</span> S; <span class="built_in">cin</span>&gt;&gt;S;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=S;i++) <span class="built_in">cin</span>&gt;&gt;d[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=L;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=N;j++)&#123;</span><br><span class="line">				x[++cnt]=a[i]+b[j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		sort(x+<span class="number">1</span>,x+<span class="number">1</span>+cnt);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Case &quot;</span>&lt;&lt;++kase&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=S;k++)&#123;</span><br><span class="line">			<span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=M;i++)&#123;</span><br><span class="line">				<span class="type">int</span> temp=d[k]-c[i];</span><br><span class="line"><span class="comment">//				cout&lt;&lt;temp&lt;&lt;endl;</span></span><br><span class="line">				<span class="type">int</span> id=lower_bound(x+<span class="number">1</span>,x+<span class="number">1</span>+cnt,temp)-x;</span><br><span class="line">				<span class="keyword">if</span>(id!=cnt+<span class="number">1</span>&amp;&amp;x[id]==temp)&#123;</span><br><span class="line">					flag=<span class="number">1</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(flag) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="Aggressive-cows"><a href="#Aggressive-cows" class="headerlink" title="Aggressive cows"></a>Aggressive cows</h2><blockquote>
<p>Farmer John has built a new long barn, with N (2 &lt;= N &lt;= 100,000) stalls. The stalls are located along a straight line at positions x1,…,xN (0 &lt;= xi &lt;= 1,000,000,000).</p>
<p>His C (2 &lt;= C &lt;= N) cows don’t like this barn layout and become aggressive towards each other once put into a stall. To prevent the cows from hurting each other, FJ want to assign the cows to the stalls, such that the minimum distance between any two of them is as large as possible. What is the largest minimum distance?</p>
<p><strong>Input</strong></p>
<p>* Line 1: Two space-separated integers: N and C</p>
<p>* Lines 2..N+1: Line i+1 contains an integer stall location, xi</p>
<p><strong>Output</strong></p>
<p>* Line 1: One integer: the largest minimum distance</p>
<p><strong>Sample Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;5 3</span><br><span class="line">&gt;1</span><br><span class="line">&gt;2</span><br><span class="line">&gt;8</span><br><span class="line">&gt;4</span><br><span class="line">&gt;9</span><br></pre></td></tr></table></figure>
<p><strong>Sample Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;3</span><br></pre></td></tr></table></figure>
<p><strong>Hint</strong></p>
<p>OUTPUT DETAILS:</p>
<p>FJ can put his 3 cows in the stalls at positions 1, 4 and 8, resulting in a minimum distance of 3.</p>
<p>Huge input data,scanf is recommended.</p>
</blockquote>
<h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>最简单的一道二分题，却放在了最后一题。。。</p>
<h3 id="CODE-5"><a href="#CODE-5" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI acos(-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> N,C;</span><br><span class="line"><span class="type">int</span> v[MAXN];</span><br><span class="line"><span class="type">int</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> mid)</span>&#123;</span><br><span class="line">	<span class="type">int</span> pre=<span class="number">1</span>,cnt=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=N;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(v[i]-v[pre]&gt;=mid)&#123;</span><br><span class="line">			pre=i;</span><br><span class="line">			cnt++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(cnt==C) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;N&gt;&gt;C;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++) <span class="built_in">cin</span>&gt;&gt;v[i];</span><br><span class="line">	sort(v+<span class="number">1</span>,v+<span class="number">1</span>+N);</span><br><span class="line">	<span class="type">int</span> l=<span class="number">0</span>,r=v[N],mid,ans;</span><br><span class="line">	<span class="keyword">while</span>(r&gt;=l)&#123;</span><br><span class="line">		mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(check(mid))&#123;</span><br><span class="line">			ans=mid;</span><br><span class="line">			l=mid+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Radar-Installation"><a href="#Radar-Installation" class="headerlink" title="Radar Installation"></a>Radar Installation</h2><blockquote>
<p>Assume the coasting is an infinite straight line. Land is in one side of coasting, sea in the other. Each small island is a point locating in the sea side. And any radar installation, locating on the coasting, can only cover d distance, so an island in the sea can be covered by a radius installation, if the distance between them is at most d.</p>
<p>We use Cartesian coordinate system, defining the coasting is the x-axis. The sea side is above x-axis, and the land side below. Given the position of each island in the sea, and given the distance of the coverage of the radar installation, your task is to write a program to find the minimal number of radar installations to cover all the islands. Note that the position of an island is represented by its x-y coordinates.</p>
</blockquote>
<p><img src="https://vj.z180.cn/f6ffe515205096387436c13c7449b0ed?v=1594806647" alt=""></p>
<blockquote>
<p><strong>Input</strong></p>
<p>The input consists of several test cases. The first line of each case contains two integers n (1&lt;=n&lt;=1000) and d, where n is the number of islands in the sea and d is the distance of coverage of the radar installation. This is followed by n lines each containing two integers representing the coordinate of the position of each island. Then a blank line follows to separate the cases.</p>
<p>The input is terminated by a line containing pair of zeros</p>
<p><strong>Output</strong></p>
<p>For each test case output one line consisting of the test case number followed by the minimal number of radar installations needed. “-1” installation means no solution for that case.</p>
<p><strong>Sample Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 2</span><br><span class="line">1 2</span><br><span class="line">-3 1</span><br><span class="line">2 1</span><br><span class="line"></span><br><span class="line">1 2</span><br><span class="line">0 2</span><br><span class="line"></span><br><span class="line">0 0</span><br></pre></td></tr></table></figure>
<p><strong>Sample Output</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Case <span class="number">1</span>: <span class="number">2</span></span><br><span class="line">Case <span class="number">2</span>: <span class="number">1</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>膜拜岑大佬</p>
<h3 id="CODE-6"><a href="#CODE-6" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> n,d,maxy,cnt,sum;</span><br><span class="line"><span class="type">double</span> lastx,newx;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span> </span><br><span class="line">	<span class="type">int</span> x,y; </span><br><span class="line">&#125;nod[maxn]; </span><br><span class="line"><span class="type">bool</span> <span class="title function_">cmp</span><span class="params">(node a,node b)</span>&#123; <span class="comment">//因为习惯是从左往右看，因此把横坐标小的放到前面（当然你想从右往左 看也可以，但是后面就需要改动一下，把能让点在边界上的左圆心作为推断的圆心就可以）  </span></span><br><span class="line">	<span class="keyword">if</span>(a.x!=b.x) <span class="keyword">return</span> a.x&lt;b.x;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> a.y&gt;b.y;<span class="comment">//这个让纵坐标小的在前面也可以，不写也可以。不写的话就需要把上 一条的if条件去掉，不然会RE。让不让纵坐标排序都是习惯问题，在此题中不是关键。 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123; </span><br><span class="line">	cnt=<span class="number">1</span>; </span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;d)&#123; <span class="comment">//有n个岛屿，雷达的半径为d </span></span><br><span class="line">		<span class="keyword">if</span>(n==<span class="number">0</span> &amp;&amp; d==<span class="number">0</span>) <span class="keyword">break</span>; </span><br><span class="line">		maxy=<span class="number">-1</span>; sum=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123; </span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;nod[i].x&gt;&gt;nod[i].y; </span><br><span class="line">			<span class="keyword">if</span>(nod[i].y&gt;maxy) maxy=nod[i].y;</span><br><span class="line">		&#125;</span><br><span class="line">		sort(nod,nod+n,cmp);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Case &quot;</span>&lt;&lt;cnt&lt;&lt;<span class="string">&quot;: &quot;</span>;</span><br><span class="line">		cnt++;</span><br><span class="line">		<span class="keyword">if</span>(maxy&gt;d) <span class="comment">//如果有岛屿到x轴的距离比d大，那么一定不能让所有岛屿都在雷达范围中</span></span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			lastx=nod[<span class="number">0</span>].x+<span class="built_in">sqrt</span>(d*d-nod[<span class="number">0</span>].y*nod[<span class="number">0</span>].y); <span class="comment">//老圆心的横坐标 </span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">				newx=nod[i].x+<span class="built_in">sqrt</span>(d*d-nod[i].y*nod[i].y); <span class="comment">//新圆心的横坐标 </span></span><br><span class="line">				<span class="keyword">if</span>(newx&lt;lastx) <span class="comment">//新圆心横坐标在老圆心横坐标左边 </span></span><br><span class="line">					lastx=newx; <span class="comment">//优化上一个圆的圆心坐标 </span></span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">sqrt</span>((nod[i].x-lastx)*(nod[i].x- lastx)+nod[i].y*nod[i].y)&gt;d)&#123;<span class="comment">//如果新圆心在老圆心右边，而且该岛屿到老圆心的距离比d还大，说 明需要增加一个雷达 </span></span><br><span class="line">					lastx=newx; <span class="comment">//更新老圆心的坐标 </span></span><br><span class="line">					sum++; <span class="comment">//雷达个数增加 </span></span><br><span class="line">				&#125; </span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>集训</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈矩阵快速幂</title>
    <url>/posts/a28e20bb.html</url>
    <content><![CDATA[<blockquote>
<p>集训开始了对矩阵快速幂的讲解，但是讲解的非常不好，基本没讲，这导致我这个之前就不知道矩阵快速幂的蒟蒻不得不自己乖乖的去网上查资料学习，找到了两个比较不错的视频讲解，具体可以看<strong>清单</strong>里面的<strong>转载</strong>，我来记录一下矩阵快速幂的基本用法🐷</p>
</blockquote>
<h2 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h2><p>学习过线性代数或者离散数学的应该都知道矩阵之间的乘法怎么做，知道的可以跳过，矩阵相乘有一个前提条件，就是前一个矩阵的列数必须等于后一个矩阵的行数两个矩阵才能做乘法运算，这是因为矩阵是不满足交换律的，他们相乘得到的矩阵的元素等于这个元素所在的行对应第一个矩阵的行元素依次乘以这个得到的矩阵元素列数对应第二个矩阵的列元素，很绕口，举个例子，假如两个矩阵相乘后得到了新的矩阵，这个矩阵的第一个元素是在第一行第一列对吧，那么这个元素就是第一个矩阵的第一行和第二个矩阵的第二列元素依次相乘再累加的结果，这样你就知道为什么第一个矩阵的列数必须和第二个矩阵行数相同了吧。</p>
<p>那在纸上你肯定会算了，怎么把它转化成代码呢？</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mat</span>&#123;</span></span><br><span class="line">	ll m[<span class="number">20</span>][<span class="number">20</span>]; <span class="comment">//定义了一个20*20的矩阵</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> n;<span class="comment">//n为相乘的矩阵的维数，一般长和宽是相同的</span></span><br><span class="line">mat operator * (mat a,mat b)&#123; <span class="comment">//重载了*运算符，使得两个结构体可以做乘法</span></span><br><span class="line">	mat ans;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">			ll x=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line">				x+=a.m[i][k]*b.m[k][j]%MOD;</span><br><span class="line">			&#125;</span><br><span class="line">			ans.m[i][j]=x;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans; <span class="comment">//ans储存结果</span></span><br><span class="line">&#125;</span><br><span class="line">mat <span class="title function_">mul</span><span class="params">(mat a,mat b)</span>&#123; <span class="comment">//也可以写一个相乘的函数和重载效果一样</span></span><br><span class="line">    mat ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">			ll x=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>; k&lt;n; k++)&#123;</span><br><span class="line">            	x=(x+a.m[i][k]*b.m[k][j]%MOD)%MOD;</span><br><span class="line">			&#125;</span><br><span class="line">			ans.m[i][j]=x;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h2><p>OK，知道了矩阵乘法，我们就可以开始矩阵快速幂的学习了，加入给你了一个矩阵让你算这个矩阵的N次幂，你怎么算呢？一个一个乘吗？那时间复杂度就是O(n)了，有没有办法降一下呢？学了快速幂的你一定会说可以的，快速幂不仅仅限制于实数上的乘法，它是广义的！来看看广义快速幂：</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/Sucai/9.png" alt=""></p>
<p>很明显矩阵的乘法也是满足广义快速幂的要求的，而矩阵快速幂的幺元其实就是单位矩阵也就是左对角线为1其他全为0的矩阵，这样的单位矩阵乘以任何矩阵都不会改变这个矩阵结果，其意义就相当于实数运算中的“1”。明白了这个就可以直接上代码了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mat <span class="title function_">mul</span><span class="params">(mat a,mat b)</span>&#123; <span class="comment">//自定义矩阵相乘函数</span></span><br><span class="line">    mat ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">			ll x=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>; k&lt;n; k++)&#123;</span><br><span class="line">            	x=(x+a.m[i][k]*b.m[k][j]%MOD)%MOD;</span><br><span class="line">			&#125;</span><br><span class="line">			ans.m[i][j]=x;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">mat <span class="title function_">ksm</span><span class="params">(mat a,ll b)</span>&#123; <span class="comment">//矩阵快速幂</span></span><br><span class="line">    mat ans;</span><br><span class="line">    <span class="built_in">memset</span>(ans.m,<span class="number">0</span>,<span class="keyword">sizeof</span> ans.m); <span class="comment">//定义矩阵快速幂的幺元</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) ans.m[i][i]=<span class="number">1</span>; <span class="comment">//左对角线都为1</span></span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">    	<span class="keyword">if</span>(n&amp;<span class="number">1</span>) ans=mul(a,ans);</span><br><span class="line">    	a=mul(a,a);</span><br><span class="line">    	b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> ans; <span class="comment">//ans即为这个a矩阵的n次幂</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上操作其实不难理解，仔细想一想很简单的，接下来重点来了！！！</p>
<font color="red" size=4>我学了这个有什么用呢？</font>

<p>难道只是为了解一下矩阵的乘法？当然不是的！！！它可以大大加快递推的速度</p>
<h2 id="加快递推"><a href="#加快递推" class="headerlink" title="加快递推"></a>加快递推</h2><p>什么叫递推？比如十分经典的斐波那契数列，我现在要求你算出第n项是多少，那你肯定要从前往后一步一步算，不可能跳步的，因为后面的结果必须由前面的元素决定！如果你不知道矩阵快速幂，那时间复杂度是O(N)的，假如我就很难为你，把数据量开到1e9，绝对不能单纯的递推了对吧，这时我们的矩阵快速幂就派上用场了，我们可以定义这样的一个矩阵：</p>
<p>|   f(n)  |</p>
<p>|  f(n-1)|                     为什么要这样定义呢？因为这一个矩阵包含了推出f(n+1)的所有元素，也就是包含了推出下一个矩阵的所有元素！而这个矩阵也等于：</p>
<p>| f(n-1)+f(n-2) |</p>
<p>|       f(n-1)      |                就是把上面的式子的第一项变成了f(n-1)+f(n-2)结果不变的对吧，而这个式子就等于</p>
<p>| 1 1 |             | f(n-1) |</p>
<p>| 1 0 |  乘上    | f(n-2) |  ，由此我们发现了矩阵前后的关系</p>
<p>|   f(n)  |          | 1 1 |          | f(n-1) |</p>
<p>|  f(n-1)|   =    | 1 0 |    <em>    | f(n-2) |  ，这像不像一个等比数列，an=x </em> an-1，那么我们就可以直接转换成</p>
<p>|   f(n)  |          | 1 1 |(n-2)   |  f(2)    |</p>
<p>|  f(n-1)| =      | 1  0|   *      |  f(1)    | ，式子的第二个矩阵就是需要套用快速幂的矩阵，其n-2次方乘以式子第三个矩阵就是式子第一个矩阵，OK，到这里我们就成功把递推式子转换成为了快速幂的式子，套一下快速幂的模板就解出来了</p>
<p>可以是试着做这道题目： <a href="https://vjudge.net/contest/383066#problem/A">题目链接</a> 密码：hpucam</p>
<h3 id="AC-CODE"><a href="#AC-CODE" class="headerlink" title="AC-CODE"></a>AC-CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD=<span class="number">10000</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mat</span>&#123;</span></span><br><span class="line">	ll m[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">mat operator * (mat a,mat b)&#123;</span><br><span class="line">	mat ans;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">2</span>;j++)&#123;</span><br><span class="line">			ll x=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">2</span>;k++)&#123;</span><br><span class="line">				x+=a.m[i][k]*b.m[k][j]%MOD;</span><br><span class="line">			&#125;</span><br><span class="line">			ans.m[i][j]=x;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">mat <span class="title function_">ksm</span><span class="params">(mat a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">	mat ans;</span><br><span class="line">	<span class="built_in">memset</span>(ans.m,<span class="number">0</span>,<span class="keyword">sizeof</span> ans.m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>;i++) ans.m[i][i]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(b)&#123;</span><br><span class="line">		<span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans=ans*a;</span><br><span class="line">		a=a*a;</span><br><span class="line">		b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n),n!=<span class="number">-1</span>)&#123;</span><br><span class="line">		mat a,ans;</span><br><span class="line">		a.m[<span class="number">1</span>][<span class="number">1</span>]=a.m[<span class="number">1</span>][<span class="number">2</span>]=a.m[<span class="number">2</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">		a.m[<span class="number">2</span>][<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line">		ans=ksm(a,n);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;ans.m[<span class="number">2</span>][<span class="number">1</span>]%MOD&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<font color="red" size=5>终于完了，帮助到您的话留下一句鼓励的话吧👍</font>

<font color="green" size=5>Ending</font>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title>快读快写</title>
    <url>/posts/e38e89eb.html</url>
    <content><![CDATA[<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>一些题目需要读取的数据量十分庞大，很可能读取数据次数高达几十万次，而这时用cin或者scanf时间上就有了一些差距（scanf比cin要快），当输入数据更加庞大，scanf时间上也有些乏力，毕竟有些题目就是考你会不会快读快写，C语言输入输出字符时是要比数字输出的快的，我们可以利用这一点来把数字转化成字符来输出</p>
<p>下面的inline是内联函数的意思，小伙伴可以看 <a href="https://blog.csdn.net/hyqsong/article/details/51857833">https://blog.csdn.net/hyqsong/article/details/51857833</a> 了解一下</p>
<h2 id="快读代码"><a href="#快读代码" class="headerlink" title="快读代码"></a>快读代码</h2><pre><code>inline int read()&#123;
    int x=1,y=0;
    char ch=getchar();
    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;)&#123;
        if(ch==&#39;-&#39;) x=-1; ch=getchar(); //这里的循环是为了避免输入数字之前的空格造成影响
    &#125;
    while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)&#123;
        y=y*10+ch-&#39;0&#39;;
        ch=getchar();
    &#125;
    return x*y;
&#125;
</code></pre><p>需要注意的是每次循环最后都要加一句getchar()</p>
<h2 id="快写代码"><a href="#快写代码" class="headerlink" title="快写代码"></a>快写代码</h2><pre><code>inline void write(int n)&#123;
    if(n&lt;0) putchar(&#39;-&#39;),n*=-1;
    if(n&gt;9) write(n/10);
    putchar(n%10+&#39;0&#39;);
&#125;
</code></pre><p>代码比较好理解，注意puchar()里面的n%10</p>
<blockquote>
<p>制作不易，您的赞助是我最大动力，点击下面的赏，快来赞助我吧</p>
</blockquote>
<p><img src="https://dss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=868635476,2104676212&amp;fm=111&amp;gp=0.jpg" alt=""></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm内存模型</title>
    <url>/posts/340c83dd.html</url>
    <content><![CDATA[<blockquote>
<p>原文链接：<a href="https://blog.csdn.net/m0_71777195/article/details/126247090">https://blog.csdn.net/m0_71777195/article/details/126247090</a></p>
</blockquote>
<p>jvm内存模型如下图所示：</p>
<p><strong>线程共有</strong>：堆和方法区</p>
<p><strong>线程私有</strong>：虚拟机栈、本地方法栈和程序计数器</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240919213836852.png" alt="jvm内存模型"></p>
<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><p>在 Java 中，堆被划分成两个不同的区域：新生代 ( Young )、老年代 ( Old )，新生代 ( Young ) 又被划分为三个区域：Eden、From Survivor、To Survivor。</p>
<p>下图中的Perm代表的是永久代，但是注意永久代并不属于堆内存中的一部分，同时jdk1.8之后永久代也将被移除。</p>
<blockquote>
<p>注意：虽然永久代不是堆内存的一部分，但这是从逻辑上讲的，永久代使用的内存空间依旧是堆提供的，只是我们通常讲的堆是用来存放新生对象的区域，而永久代是方法区的实现方式，方法区中存放的有类的元数据信息、常量池、静态变量等。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/b8e5f06c68cf5efcebfdcb4806f9a963.png" alt="堆空间"></p>
<p>堆是java虚拟机所管理的内存中最大的一块内存区域，也是被各个线程共享的内存区域，该内存区域存放了对象实例及数组（但不是所有的对象实例都在堆中）。</p>
<p>其大小通过-Xms(最小值)和-Xmx(最大值)参数设置（最大最小值都要小于1G），前者为启动时申请的最小内存，默认为操作系统物理内存的1/64，后者为JVM可申请的最大内存,默认为物理内存的1/4，默认当空余堆内存小于40%时，JVM会增大堆内存到-Xmx指定的大小，可通过-XX:MinHeapFreeRation=来指定这个比列。</p>
<p>当空余堆内存大于70%时，JVM会减小堆内存的大小到-Xms指定的大小，可通过XX:MaxHeapFreeRation=来指定这个比列，当然为了避免在运行时频繁调整Heap的大小，通常-Xms与-Xmx的值设成一样。堆内存 = 新生代+老生代+持久代。</p>
<p>在我们垃圾回收的时候，我们往往将堆内存分成新生代和老生代（大小比例1：2），新生代中由Eden和Survivor0，Survivor1组成，三者的比例是8：1：1，新生代的回收机制采用复制算法，在Minor GC的时候，我们都留一个存活区用来存放存活的对象，真正进行的区域是Eden+其中一个存活区，当我们的对象时长超过一定年龄时（默认15，可以通过参数设置），将会把对象放入老生代，当然大的对象会直接进入老生代，老生代采用的回收算法是标记整理算法。</p>
<h1 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h1><p>其实方法区是在JDK1.8以前的版本里存在的一块内存区域，主要就是存放从class文件里加载进来的类的，而且常量池也是在这块区域内的。</p>
<p>但是在JDK1.8之后，这块区域摇身一变，换了名字，叫做“Metaspace”，翻译过来就是“元数据空间”的意思，当然它只是改了个名，实现的功能是没变的。</p>
<p>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/7b5bd84a08eac6ae19c85f0c981ef3aa.png" alt="方法区域存放内容集合"></p>
<ol>
<li><p>类型信息</p>
<p>对每个加载的类型（类class、接口interface、枚举enum、注解annotation),JVM必须在方法区中存储以下类型信息:</p>
<ol>
<li><p>这个类型的完整有效名称（全名=包名.类名)</p>
</li>
<li><p>这个类型直接父类的完整有效名(对于interface或是java.lang.0bject，都没有父类)</p>
</li>
<li><p>这个类型的修饰符(public, abstract,final的某个子集)</p>
</li>
</ol>
</li>
</ol>
<ol>
<li>这个类型直接接口的一个有序列表</li>
</ol>
<ol>
<li>域信息(Field)成员变量</li>
</ol>
<p>JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。</p>
<p>域的相关信息包括:域名称、域类型、域修饰符(public, private,protected,static,final, volatile, transient的某个子集)</p>
<ol>
<li>方法(Method)信息</li>
</ol>
<p>JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序:</p>
<ul>
<li>方法名称</li>
<li>方法的返回类型(或void)·方法参数的数量和类型(按顺序)</li>
<li>方法的修饰符(public, private,protected,static, final,synchronized,native,abstract的一个子集)</li>
<li>方法的字节码(bytecodes)、操作数栈、局部变量表及大小(abstract和native方法除外)</li>
</ul>
<h1 id="虚拟机栈-JVM-Stack"><a href="#虚拟机栈-JVM-Stack" class="headerlink" title="虚拟机栈(JVM Stack)"></a>虚拟机栈(JVM Stack)</h1><p>虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈，每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用。</p>
<p>虚拟机栈的作用：主管Java程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。</p>
<p>每个方法被执行的时候都会创建一个”栈帧”,用于存储局部变量表(包括参数)、操作栈、方法出口等信息。</p>
<p>每个方法被调用到执行完的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p>
<p>栈帧（Stack Frame） 是用于虚拟机执行时方法调用和方法执行时的数据结构，它是虚拟栈的基本元素，栈帧由局部变量区、操作数栈等组成，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/e7a851f1896ea19949fb7b1bd136614a.png" alt="虚拟机栈"></p>
<p>每一个方法从调用到方法返回都对应着一个栈帧入栈出栈的过程。最顶部的栈帧称为当前栈帧，栈帧所关联的方法称为当前方法，定义这个方法的类称为当前类，该线程中，虚拟机有且也只会对当前栈帧进行操作。</p>
<p>栈帧的作用有存储数据，部分过程结果，处理动态链接，方法返回值和异常分派。</p>
<p>每一个栈帧包含的内容有局部变量表、操作数栈、动态链接、方法返回地址和一些额外的附加信息。在编译代码时，栈帧需要多大的局部变量表，多深的操作数栈都可以完全确定的，并写入到方法表的code属性中。</p>
<h1 id="本地方法栈-Native-Stack"><a href="#本地方法栈-Native-Stack" class="headerlink" title="本地方法栈(Native Stack)"></a>本地方法栈(Native Stack)</h1><p>本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java 方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native 方法服务。</p>
<p>虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。</p>
<p>甚至有的虚拟机（譬如Sun HotSpot 虚拟机）直接就把本地方法栈和虚拟机栈合二为一。</p>
<p>与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError 和OutOfMemoryError异常。</p>
<h1 id="程序计数器（PC-Register）"><a href="#程序计数器（PC-Register）" class="headerlink" title="程序计数器（PC Register）"></a>程序计数器（PC Register）</h1><p>在JVM的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</p>
<p>分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p>
<p>JVM的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，为了各条线程之间的切换后计数器能恢复到正确的执行位置，所以每条线程都会有一个独立的程序计数器。</p>
<p>当线程正在执行一个Java方法，程序计数器记录的是正在执行的JVM字节码指令的地址；如果正在执行的是一个Natvie（本地方法），那么这个计数器的值则为空（Underfined）。</p>
<p>程序计数器占用的内存空间很少，也是唯一一个在JVM规范中没有规定任何OutOfMemoryError（内存不足错误）的区域。</p>
]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>JVM内存模型</tag>
      </tags>
  </entry>
  <entry>
    <title>快速幂详解</title>
    <url>/posts/3fe565b1.html</url>
    <content><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>先举个例子，比如说算3^6^,你要怎么算，用6个6相乘对不对，那要是3^1000^呢？1000个3相乘，复杂度为O(N)，现在我们这样算，6的二进制是110，所以6=1(2^2^)+1(2^1^)+0(2^0^)，那么3^6^就变成了3^( 1(2^2^)+1(2^1^)+0(2^0^) )=3^(1<em>(2^2^)) </em> 3^(1<em>(2^1^))^ </em> 3^(0*(2^0^))^，这其实就是快速幂的原理，看起来麻烦了对吗？OK，先不看复杂度，先看用代码如何实现，我们可以用一个数来充当3^(1*(2^2^))^、3^(1*(2^1^))^、3^(0*(2^0^))^，在下面的代码中y就是这个变量，不是每一次都要算的，比如3^(0*(2^0^))^=1，乘不乘都一样，那怎么判断呢？我们每次取二进制数的最后一位，要么是0要么是1，如果是0，就不用不用乘，否则就乘，先看代码：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int p(int a,int b)&#123;</span><br><span class="line">  int t,y;  //定义两个变量，t起到类乘的作用，而y则就是每一次要乘的数</span><br><span class="line">  t=1; y=a;  //注意一定要初始化</span><br><span class="line">  while (b!=0)&#123;  //只要二进制位数还没有遍历完就还要循环</span><br><span class="line">    if (b&amp;1==1) t=t*y; //y就是幂的形式a^(2^0),a^(2^1),a^(2^2),a^(2^3)</span><br><span class="line">    y=y*y;  //</span><br><span class="line">    b=b&gt;&gt;1;  //每次要舍去二进制数的最后一位</span><br><span class="line">  &#125;</span><br><span class="line">  return t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这就是原理是不是很简单呢（qwq）</p>
<h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>也许你会疑惑明明步骤变多了怎么会快了呢？这只是你的直观感觉，代码是变长了，但次数确确实实变少了，我们来看上面的代码，复杂度主要就在于循环上，循环的条件是b!=0，而每次不都要除以2，设循环次数为x，那么2^x=b，x=log(2,b)，循环里面运算次数最多为3次，那么复杂度最大就是3log(2,N)，3是常数，当数值很大时，可以省略，复杂度为log(2,N)，那么假如算2^10000，常规需要10000次运算，而快速幂只需要14*3次运算，是不是很神奇呢？</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>学习了这个算法有什么用呢？实际上快速幂是一个非常常用的算法，它经常与其他算法一起混用，一般来说快速幂适用于求一个指数非常高的数对某个数的余数，例如：题目：<br>现在星期日，问：再过2^10000^天后星期几？学习了快速幂这种题就是送分题了，每次对7取余就行了</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>附上链接，有兴趣的小伙伴可以前往相关网站做一下</p>
<pre><code>Fermat&#39;s theorem states that for any prime number p and for any integer a &gt; 1, ap = a (mod p). That is, if we raise a to the pth power and divide by p, the remainder is a. Some (but not very many) non-prime values of p, known as base-a pseudoprimes, have this property for some a. (And some, known as Carmichael Numbers, are base-a pseudoprimes for all a.)

Given 2 &lt; p ≤ 1000000000 and 1 &lt; a &lt; p, determine whether or not p is a base-a pseudoprime.
</code></pre><p>Input</p>
<pre><code>Input contains several test cases followed by a line containing &quot;0 0&quot;. Each test case consists of a line containing p and a.
</code></pre><p>Output</p>
<pre><code>For each test case, output &quot;yes&quot; if p is a base-a pseudoprime; otherwise output &quot;no&quot;.
</code></pre><p>Sample Input</p>
<pre><code>3 2
10 3
341 2
341 3
1105 2
1105 3
0 0
</code></pre><p>Sample Output</p>
<pre><code>no
no
yes
no
yes
yes
</code></pre><p>AC代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
long long p(long long a,long long b)&#123;
    long long t,y,n=b;
    t=1; y=a;
    while (b!=0)&#123;
        if (b&amp;1==1) t=t*y%n;
        y=y*y%n;
        b=b&gt;&gt;1;
    &#125;    
    return t;
&#125;
int main()
&#123;
    long long m,n;
    while(scanf(&quot;%lld %lld&quot;,&amp;m,&amp;n)!=EOF)&#123;
        if(m==0&amp;&amp;n==0) break;
        int flag=0;
        for(int i=2;i*i&lt;=m;i++)&#123;
            if(m%i==0)&#123;
                flag=1;
                break;
            &#125;
        &#125;
        if(flag==0) cout&lt;&lt;&quot;no&quot;&lt;&lt;endl;
        else&#123;
            if(p(n,m)==n) cout&lt;&lt;&quot;yes&quot;&lt;&lt;endl;
            else cout&lt;&lt;&quot;no&quot;&lt;&lt;endl;
        &#125;
    &#125;
&#125;
</code></pre><p>地址：<a href="http://poj.org/problem?id=3641">http://poj.org/problem?id=3641</a></p>
<p>Rightmost Digit </p>
<p>Given a positive integer N, you should output the most right digit of N^N.</p>
<p>Input</p>
<pre><code>The input contains several test cases. The first line of the input is a single integer T which is the number of test cases. T test cases follow.
Each test case contains a single positive integer N(1&lt;=N&lt;=1,000,000,000).
</code></pre><p>Output<br>    For each test case, you should output the rightmost digit of N^N.<br>Sample Input</p>
<pre><code>2
3
4
</code></pre><p>Sample Output</p>
<pre><code>7
6
</code></pre><p>​<br>​      </p>
<p>Hint</p>
<pre><code>In the first case, 3 * 3 * 3 = 27, so the rightmost digit is 7.
In the second case, 4 * 4 * 4 * 4 = 256, so the rightmost digit is 6.
</code></pre><p>AC代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
long long p(long long a)&#123;
    long long t,y;
    t=1; y=a;
    while(a!=0)&#123;
        if (a&amp;1==1) t=t*y%10;
        y=y*y%10; 
        a=a&gt;&gt;1;
    &#125;
    return t;
&#125;
int main()
&#123;
    int t;
    cin&gt;&gt;t;
    while(t--)&#123;
        long long n;
        scanf(&quot;%lld&quot;,&amp;n);
        cout&lt;&lt;p(n)&lt;&lt;endl;
    &#125;
&#125;
</code></pre><p>地址：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1061">http://acm.hdu.edu.cn/showproblem.php?pid=1061</a></p>
<p>小蒜想知道：假设今天是星期日，那么过 aba^bab 天之后是星期几？</p>
<p>输入格式</p>
<p>两个正整数 aaa，bbb，中间用单个空格隔开。0&lt;a≤100,0&lt;b≤100000 &lt; a \le 100, 0 &lt; b \le 100000&lt;a≤100,0&lt;b≤10000。</p>
<p>输出格式</p>
<p>一个字符串，代表过 aba^bab ​天之后是星期几。</p>
<p>其中，Monday 是星期一，Tuesday 是星期二，Wednesday 是星期三，Thursday 是星期四，Friday 是星期五，Saturday 是星期六，Sunday 是星期日。</p>
<p>输出时每行末尾的多余空格，不影响答案正确性</p>
<p>样例输入</p>
<pre><code>3 2000
</code></pre><p>样例输出</p>
<pre><code>Tuesday
</code></pre><p>AC代码</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;math.h&gt;
#include&lt;string.h&gt;
using namespace std;
typedef long long ll;
ll p(ll a,ll b)&#123;
    int t,y;
    t=1; y=a;
    while (b!=0)&#123;
        if (b&amp;1==1) t=t*y%7;
        y=y*y%7; 
        b=b&gt;&gt;1;
    &#125;
    return t;
&#125;
int main()
&#123;
    int a,b;
    cin&gt;&gt;a&gt;&gt;b;
    switch(p(a,b))&#123;
        case 1: printf(&quot;Monday\n&quot;);break;
        case 2: printf(&quot;Tuesday\n&quot;);break;
        case 3: printf(&quot;Wednesday\n&quot;);break;
        case 4: printf(&quot;Thursday\n&quot;);break;
        case 5: printf(&quot;Friday\n&quot;);break;
        case 6: printf(&quot;Saturday \n&quot;);break;
        case 0: printf(&quot;Sunday\n&quot;);break;
    &#125;
&#125;
</code></pre><p>地址：<a href="https://nanti.jisuanke.com/t/T1234">https://nanti.jisuanke.com/t/T1234</a></p>
<blockquote>
<p>制作不易，您的赞助是我最大的动力，留下您的评论，有条件的小伙伴可以打赏2毛钱，谢谢各位老板（owo）</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>基础数学</tag>
      </tags>
  </entry>
  <entry>
    <title>离散化加差分求解</title>
    <url>/posts/aa71e9f5.html</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>Covered Points Count </p>
<p>You are given n</p>
<p>segments on a coordinate line; each endpoint of every segment has integer coordinates. Some segments can degenerate to points. Segments can intersect with each other, be nested in each other or even coincide.</p>
<p>Your task is the following: for every k∈[1..n]<br>, calculate the number of points with integer coordinates such that the number of segments that cover these points equals k. A segment with endpoints li and ri covers point x if and only if li≤x≤ri.</p>
<p>Input</p>
<p>The first line of the input contains one integer n (1≤n≤2⋅105</p>
<p>) — the number of segments.</p>
<p>The next n<br>lines contain segments. The i-th line contains a pair of integers li,ri (0≤li≤ri≤1018) — the endpoints of the i-th segment.</p>
<p>Output</p>
<p>Print n space separated integers cnt1,cnt2,…,cntn, where cnti is equal to the number of points such that the number of segments that cover these points equals to i.</p>
<p>Examples</p>
<p>Input</p>
<p>3</p>
<p>0 3</p>
<p>1 3</p>
<p>3 8</p>
<p>Output</p>
<p>6 2 1 </p>
<p>Input</p>
<p>3</p>
<p>1 3</p>
<p>2 4</p>
<p>5 7</p>
<p>Output</p>
<p>5 2 0 </p>
<p>note</p>
<p>The picture describing the first example:</p>
<p><img src="https://vj.z180.cn/9e2db93c851be80e4482c4512ded4d6b?v=1586670318" alt=""></p>
<p>Points with coordinates [0,4,5,6,7,8] are covered by one segment, points [1,2] are covered by two segments and point [3]</p>
<p>is covered by three segments.</p>
<p>The picture describing the second example:</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly92ai56MTgwLmNuLzllMmRiOTNjODUxYmU4MGU0NDgyYzQ1MTJkZWQ0ZDZi?x-oss-process=image/format,png" alt=""></p>
<p>Points [1,4,5,6,7] are covered by one segment, points [2,3] are covered by two segments and there are no points covered by three segments.</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>题目大意是给一个数n，接下来有n组输入，每次都给一个区间，区间上的每一个值都被覆盖一次，要你输出最后覆盖了1 2 3……次的数的数量</p>
<p>很典型的一道差分题，只不过这道题数据量很大(0≤li≤ri≤1018) ，开不了这么大的数组，但是数据量很小 (1≤n≤2⋅105)，可以使用离散化，用一个数组储存每一次输入的左段点和右端点，然后把该数组进行排序去重，再定义一个新的差分数组进行差分操作，最后对差分数组求前缀和</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxn=2e5+100;</span><br><span class="line">struct node&#123;</span><br><span class="line">	ll x,y;</span><br><span class="line">&#125;p[maxn];用一个数组储存端点值</span><br><span class="line">ll a[maxn&lt;&lt;1],b[maxn],c[maxn];//一个数组储存离散化后的值，一个数组储存差分的值,c数组用来存储最后结果 </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	ios::sync_with_stdio(false);</span><br><span class="line">	int n,tail=0; cin&gt;&gt;n;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;p[i].x&gt;&gt;p[i].y;  //输入左端点和右端点</span><br><span class="line">		a[++tail]=p[i].x;   //存入a数组用来离散化</span><br><span class="line">		a[++tail]=p[i].y+1; </span><br><span class="line">	&#125;</span><br><span class="line">	sort(a+1,a+1+tail);  //排序</span><br><span class="line">	int len=unique(a+1,a+1+tail)-a-1;  //去重</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		int x=lower_bound(a+1,a+1+len,p[i].x)-a;  //在a数组中找到每一组的左端点位置</span><br><span class="line">		int y=lower_bound(a+1,a+1+len,p[i].y+1)-a;  //找右端点的下一个位置</span><br><span class="line">		b[x]++;b[y]--;  //差分数组，左端点++，右端点的下一个位置--</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=1;i&lt;=len;i++)&#123;</span><br><span class="line">		b[i]+=b[i-1];  //求前缀和</span><br><span class="line">		c[b[i]]+=a[i+1]-a[i]; //c数组注意用long long，这里代表着从a[i]开始到a[i+1]都是被染色了b[i]次。</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=1;i&lt;=n;i++) printf(&quot;%lld%c&quot;,c[i],i==n?&#x27;\n&#x27;:&#x27; &#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ok，结束，刚接触真的感觉好抽象</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>离散化差分</tag>
      </tags>
  </entry>
  <entry>
    <title>解决Leancloud流控问题</title>
    <url>/posts/260e182.html</url>
    <content><![CDATA[<blockquote>
文章背景
<p>因为明天要考科目一了，本来是打算明天下午写这篇文章的，可是Acm训练要开始了，所以决定提前写了吧，明天考完直接投入复习算法的学习中🐷哎，魔鬼月要开始了！</p>
</blockquote>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前写过一篇给Leancloud添加自定义邮件回复的文章<a href="https://www.fezhu.top/2020/05/15/Valineyoujian/">Click me</a>，令我自责的是教程有一些问题，因为我也是看别人教程去做的，没想到她的那个教程错了，导致我也跟着错了。。<code>ADMIN_URL</code>这个值不是填博客地址，这个跟邮件回复没有半点关系，不加这个参数也行，这个参数是用来实行自唤醒任务用的，具体看文章吧，在这里跟我教错的网友说一声抱歉</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>Leancloud最近实行了流控: 自唤醒任务是无法唤醒已经休眠的机器的，所以要想任何时候都能收到邮件就需要早上手动唤醒一次机器，接下来交给自唤醒任务就行了，不过每天都手动唤醒也是挺烦的，所以就有大佬站出来了，<a href="https://www.antmoe.com/tags/LeanCloud%E6%B5%81%E6%8E%A7/">原作者</a>，这位大佬直接解决了这个问题，在短时间内众多网友纷纷效仿，Leancloud流控问题彻底解决</p>
<p>首先你要确保你的Leancloud是正常的，如果你的Leancloud是国内版本的，我劝你换成国际版本的，因为国内版本绑定Web域名是需要备案的，而备案有需要服务器，你总不可能一直续费服务器吧，而国际版本是不需要备案直接就能绑定的，而且Leancloud的数据是可以导入导出的，把久的数据导入到国际版本中，花不了多少时间，非常香🤗</p>
<h3 id="绑定Web域名"><a href="#绑定Web域名" class="headerlink" title="绑定Web域名"></a>绑定Web域名</h3><p><a href="https://www.93bok.com/Valine%E8%AF%84%E8%AE%BA%E7%9A%84Web%E7%AE%A1%E7%90%86%E7%95%8C%E9%9D%A2/">参考原文</a></p>
<p>点击<code>云引擎</code>-&gt;<code>设置</code>，找到Web主机域名，这里没有限制，你可以随便填写，一般都是自己博客的字母，比如我的就是fezhu，<code>注意不用加后缀和前面的www</code>！！！</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/20200702205200250.png" alt=""></p>
<blockquote>
改域名作用
<p>当机器休眠时，访问此地址能够唤醒机器</p>
</blockquote>

<p>然后点击上面的添加新变量，前面填ADMIN_URL，后面填Web主机域名，这个Web主机域名有什么用呢？你可以访问这个域名，这个网址就是你的评论后台地址</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/20200702205849784.png" alt=""></p>
<p>打开页面就是这个样子，接下来添加账户名和密码：</p>
<p><img src="https://s1.ax1x.com/2018/11/22/FP0mlQ.png" alt=""> </p>
<p><img src="https://s1.ax1x.com/2018/11/22/FP0uOs.png" alt=""></p>
<p>OK,现在我们使用<code>email</code>字段的邮箱去登陆即可</p>
<p><img src="https://s1.ax1x.com/2018/11/22/FP0lT0.png" alt=""></p>
<p>在这个后台你还能查看删除评论</p>
<h3 id="设置定时任务"><a href="#设置定时任务" class="headerlink" title="设置定时任务"></a>设置定时任务</h3><p>定时任务使用cron表达式设定的<br><br><a href="https://www.cnblogs.com/yanghj010/p/10875151.html">参考文章</a><br><br>首先应该明白UTC时间和北京时间区别：</p>
<blockquote>
<p>协调世界时,又称世界统一时间,世界标准时间,国际协调时间,简称UTC。<br>UTC时间比北京慢8个小时，UTC时间=北京时间-8小时，国际版本用的是UTC时间，所以定时任务要减去8小时，我是设定了三个定时任务，分别填写cron表达式如下：</p>
</blockquote>
<p><code>0 25/0 0-15 * * ?</code>&amp;&amp;<code>0 45/0 0-15 * * ?</code>&amp;&amp;<code>0 5/0 0-15 * * ?</code></p>
<p>这表示从北京时间早上八点开始一直到晚上11点，每小时的5分，25分，45分都执行一次自唤醒，之所以不设成整点是因为，从外部唤醒会有一定延迟</p>
<h3 id="从外部访问后台"><a href="#从外部访问后台" class="headerlink" title="从外部访问后台"></a>从外部访问后台</h3><font color="red" size=4>接下来就是重点内容了</font>

<ol>
<li>鼠标放在右上角，选择 setting</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/blogimg/picbed@latest/2020/05/14/a81f88e80fd7105d7cc3e1844970e8bd.png" alt=""></p>
<ol>
<li>点击 Developer settings。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/blogimg/picbed@latest/2020/05/14/66df62fbc0d51403fcdc8223c4b6ce52.png" alt=""></p>
<ol>
<li>选择<code>Personal access tokens</code>，添加一个新的<code>TOKEN</code>。<br>这个 <code>TOKEN</code> 主要使用来启动 <code>actions</code> 和上传结果用的。<br><br>设置名字为<code>GITHUB_TOKEN</code> , 然后勾选 <code>repo , admin:repo_hook , workflow</code> 等选项，最后点击 <code>Generate token</code> 即可。<br><b>名字请务必使用GITHUB_TOKEN。</b></li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/blogimg/picbed@latest/2020/05/15/23ee2808dce8dab17e06107d1ddaf5d6.png" alt=""></p>
<ol>
<li><p>接下来 FORK 项目。<a href="https://github.com/blogimg/WakeLeanCloud">点击我</a><br>如果觉得好用可以点个赞哦！</p>
</li>
<li><p>成功 FORK 后，进入项目的设置。添加你的 leancloud 的后台地址（也就是评论管理的后台地址）<br><img src="https://cdn.jsdelivr.net/gh/blogimg/picbed@latest/2020/05/14/d15b1fffb681f0dd3b9264ea878bf055.png" alt=""><br>选择 Secrets，添加你的评论后台地址，一定是 Leancloud 的后台地址（环境变量 ADMIN_URL），而不是你的博客地址。</p>
<p><img src="https://cdn.jsdelivr.net/gh/blogimg/picbed@latest/2020/05/14/6c2cd1845116e3d4e4147157d334be19.png" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/blogimg/picbed@latest/2020/05/14/caed66e8408e5a0c91fe446951180f8d.png" alt=""></p>
<div class="note danger">
注意
<p>SITE 的网址应填你的评论管理后台地址，而不是博客地址。</p>
</div>

<p>其中 Name 的名字必须为 SITE，Value 可以是多个后台地址（注意请求头也要写），用英文逗号分隔。不要中中文逗号，不要用中文逗号，不要用中文逗号</p>
</li>
<li><p>接下来对自己的项目点个 star 就能启动了，启动后请切换到 actions，看看是否运行成功。<br>成功那么你就可以关掉了，默认是每天 8:00-24:00 时每 20 分钟运行一次。(GitHub 时间稍有延迟，大概时 2-5 分钟。)</p>
<p><img src="https://cdn.jsdelivr.net/gh/blogimg/HexoStaticFile2@latest/2020/05/25/4736d5905066440617f4a63ecfc70cc1.png" alt=""></p>
</li>
</ol>
<ul>
<li><ul>
<li><p>失败<br>如果你的 GitHub 从来没有用过 actions，那么需要先 “了解”。方法很简单，点击绿色的按钮即可。</p>
<p><img src="https://cdn.jsdelivr.net/gh/blogimg/HexoStaticFile2@latest/2020/05/25/91a79177e21e2a49d28be09cc676ad7a.png" alt=""></p>
<blockquote>
<p>自己点自己的项目是手动执行一次 actions。是为了测试才设计这个功能的哦！<br>并不是不点星这个 actions 就不会运行。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<font color="red" size=4>以上是原作者文章原话，非常详细</font><br>

这里我推荐大家把cron表达式改成`0 0 * * *`，这表示每天八点从外部访问一次你的后台地址，之后就可以交给你的定时任务了，如果过按照默认的设置，每小时都会提交好几次，一天下来都几百个了，不建议用默认设置

>>修改cron方法：修改workflows文件夹中的autoWakeup.yml文件，找到里面的cron表达式改成上述即可

一小时过去了......
<font color="red" size=5>帮助到您就点个赞吧，富豪也可以赞赏我哦🙃</font>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>流控</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown语法</title>
    <url>/posts/f134a8e5.html</url>
    <content><![CDATA[<p><a href="https://www.jianshu.com/p/191d1e21f7ed/">文章链接</a></p>
<h1 id="总结如下"><a href="#总结如下" class="headerlink" title="总结如下"></a>总结如下</h1><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>在想要设置为标题的文字前面加#来表示<br>一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。</p>
<p>注：标准语法一般在#后跟个空格再写文字</p>
<h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><ul>
<li>加粗</li>
</ul>
<p>要加粗的文字左右分别用两个*号包起来</p>
<ul>
<li>斜体</li>
</ul>
<p>要倾斜的文字左右分别用一个*号包起来</p>
<ul>
<li>斜体加粗</li>
</ul>
<p>要倾斜和加粗的文字左右分别用三个*号包起来</p>
<ul>
<li>删除线</li>
</ul>
<p>要加删除线的文字左右分别用两个~~号包起来</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;<br>n个…<br>貌似可以一直加下去，但没神马卵用</p>
<p>效果如下：</p>
<blockquote>
<p>这是引用的内容</p>
<blockquote>
<p>这是引用的内容</p>
<blockquote>
<p>这是引用的内容</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>三个或者三个以上的 - 或者 * 都可以。</p>
<p>实例：</p>
<pre><code>---
----
***
*****
</code></pre><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>语法：</p>
<pre><code>![图片alt](图片地址 &#39;&#39;图片title&#39;&#39;)

图片alt就是显示在图片下面的文字，相当于对图片内容的解释。
图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加
</code></pre><p>上传本地图片直接点击导航栏的图片标志，选择图片即可<br>markdown格式追求的是简单、多平台统一。那么图片的存储就是一个问题，需要用图床，提供统一的外链，这样就不用在不同的平台去处理图片的问题了。才能做到书写一次，各处使用。<br>关于图床的选择我写了一篇文章，对网上存在的各种方法做了总结，需要的朋友可以看看。<br><a href="https://www.jianshu.com/p/ea1eb11db63f">mark图床</a></p>
<h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p>语法：</p>
<pre><code>[超链接名](超链接地址 &quot;超链接title&quot;)
title可加可不加
</code></pre><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>语法：<br>无序列表用 - + * 任何一种都可以</p>
<pre><code>- 列表内容
+ 列表内容
* 列表内容

注意：- + * 跟内容之间都要有一个空格
</code></pre><h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><p>语法：</p>
<p>数字加点</p>
<pre><code>1. 列表内容
2. 列表内容
3. 列表内容

注意：序号跟内容之间要有空格
</code></pre><h2 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h2><p>上一级和下一级之间敲三个空格即可</p>
<p>实例：</p>
<ul>
<li><p>第一级</p>
<ul>
<li><p>第二级</p>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>语法：</p>
<p>表头|表头|表头<br>—-|:—:|—-:<br>内容|内容|内容<br>内容|内容|内容</p>
<p>第二行分割表头和内容。</p>
</li>
<li>有一个就行，为了对齐，多加了几个<br>文字默认居左<br>-两边加：表示文字居中<br>-右边加：表示文字居右<br>注：原生的语法两边都要用 | 包起来。此处省略</li>
</ul>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>姓名</th>
<th style="text-align:center">技能</th>
<th style="text-align:right">排行</th>
</tr>
</thead>
<tbody>
<tr>
<td>刘备</td>
<td style="text-align:center">哭</td>
<td style="text-align:right">大哥</td>
</tr>
<tr>
<td>关羽</td>
<td style="text-align:center">打</td>
<td style="text-align:right">二哥</td>
</tr>
<tr>
<td>张飞</td>
<td style="text-align:center">骂</td>
<td style="text-align:right">三弟</td>
</tr>
</tbody>
</table>
</div>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>语法：</p>
<p>单行代码：代码之间分别用一个反引号包起来</p>
<pre><code>   `代码内容`
</code></pre><p>代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行</p>
<pre><code>(```)
代码...
代码...
代码...
(```)
</code></pre><blockquote>
<p>注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。</p>
<h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2></blockquote>
<pre><code>```flow
st=&gt;start: 开始
op=&gt;operation: My Operation
cond=&gt;condition: Yes or No?
e=&gt;end
st-&gt;op-&gt;cond
cond(yes)-&gt;e
cond(no)-&gt;op
&amp;```
</code></pre><p>实例：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/6860761-9d9524ba31047696.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/751" alt=""></p>
]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>我的第一篇博客</title>
    <url>/posts/d95d7e09.html</url>
    <content><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=38592976&auto=0&height=66"></iframe>

<h1 id="我的第一篇博客"><a href="#我的第一篇博客" class="headerlink" title="我的第一篇博客"></a>我的第一篇博客</h1><!--- more --->
<h2 id="我对博客的态度"><a href="#我对博客的态度" class="headerlink" title="我对博客的态度"></a>我对博客的态度</h2><ul>
<li>每次做题不会的时候上网查总是能看到一群大佬们发布的各种博客文章，布局十分漂亮，我</li>
</ul>
<p>就在想什么时候我也能有一个这样的博客，现在我的愿望实现了，在我看来博客不只是推送</p>
<p>一篇文章这么简单，它也是对生活的一种记录，我不想在我以后工作了或者给别人将述我的</p>
<p>成长经历时，没有实实在在的东西，因为我本人写字不太好看，所以我希望博客能代替日记</p>
<p>陪伴我走下去，希望我能在博客的陪伴下努力生长，虽然现在的我是一只蒟蒻，但几年后的</p>
<p>今天我相信我一定可以成为我想成为的人！  </p>
<h2 id="我对分享的看法"><a href="#我对分享的看法" class="headerlink" title="我对分享的看法"></a>我对分享的看法</h2><ul>
<li>我本人是希望与别人分享一些东西的，无论是知识或是一些平常琐事，虽然我只是一只蒟</li>
</ul>
<p>蒻，我会把一些自己认为有必要记录的东西都写下来，也是对知识的一种巩固吧。</p>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul>
<li>成为像马云那样的有钱人，呸呸！成为一个能养的起自己，照顾好家庭，服务好社会的好公</li>
</ul>
<p>民，顺便成为一个计算机大佬，哈哈！</p>
<h2 id="——"><a href="#——" class="headerlink" title="——"></a>——</h2><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p>【奋斗】(<a href="http://img.08087.cc/uploads/20190819/20/1566217745-WgQljednVf.jpg">http://img.08087.cc/uploads/20190819/20/1566217745-WgQljednVf.jpg</a>)</p>
<p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1585500060586&amp;di=d6ded2e6b4baee6259a036ead70d5111&amp;imgtype=0&amp;src=http%3A%2F%2Fimg.mp.itc.cn%2Fupload%2F20170515%2Fb519a0f765bb45c0b35a98c3f1df8bf1_th.jpg" alt=""></p>
<hr>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>miniob初体验</title>
    <url>/posts/be7a94ae.html</url>
    <content><![CDATA[<blockquote>
<p>Oceanbase数据库大赛是阿里旗下的Oceanbase数据库开发人员联合华中科技大学举办的针对数据库开发初学者的一场比赛，涉及到数据库的底层实现。miniob则是一个小型数据库，只实现了一小部分基础功能，有一个整体的代码框架，要求参赛选手拓展出其他的功能，每一个功能根据不同的难度得相应的分数。</p>
</blockquote>
<h1 id="项目文档"><a href="#项目文档" class="headerlink" title="项目文档"></a>项目文档</h1><p><a href="https://oceanbase.github.io/miniob">miniob介绍</a></p>
<p><a href="https://github.com/oceanbase/miniob/">项目源码</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/445201899">往年参赛选手心得</a></p>
<h1 id="项目总览"><a href="#项目总览" class="headerlink" title="项目总览"></a>项目总览</h1><p>（来源于官方文档，我觉得我写的没有文档好，所以不费笔墨了）</p>
<p>miniob作为一个具有“基本”功能的数据库，包含了需要的基本功能模块。包括</p>
<ul>
<li>网络模块：负责与客户端交互，收发客户端请求与应答；</li>
<li>SQL解析：将用户输入的SQL语句解析成语法树；</li>
<li>执行计划缓存：执行计划缓存模块会将该 SQL第一次生成的执行计划缓存在内存中，后续的执行可以反复执行这个计划，避免了重复查询优化的过程（未实现）。</li>
<li>语义解析模块：将生成的语法树，转换成数据库内部数据结构（部分实现）；</li>
<li>查询缓存：将执行的查询结果缓存在内存中，下次查询时，可以直接返回（未实现）；</li>
<li>查询优化：根据一定规则和统计数据，调整/重写语法树。当前实现为空，留作实验题目；</li>
<li>计划执行：根据语法树描述，执行并生成结果；</li>
<li>会话管理：管理用户连接、调整某个连接的参数；</li>
<li>元数据管理：记录当前的数据库、表、字段和索引元数据信息；</li>
<li>客户端：作为测试工具，接收用户请求，向服务端发起请求。</li>
</ul>
<p>SQL的执行流程可以参考</p>
<p><img src="https://oceanbase.github.io/miniob/images/miniob-introduction-sql-flow.png" alt="SQL 请求执行流程"></p>
<h1 id="参赛感受"><a href="#参赛感受" class="headerlink" title="参赛感受"></a>参赛感受</h1><p>虽然抄底拿奖，但还是收获了不少项目经验，例如利用WSL进行linux开发、git维护代码版本、vscode结合GDB、ssh remote远程开发调试等等，由于没有提前准备，只有两周的时间，刚上手感觉非常吃力，因为从来没有独立做过这么大的项目，配置环境就花了我两天的时间，主要是之前没有用vscode进行过项目开发，一直在用vs2019，怎么通过插件连接服务器，怎么结合GDB调试，怎么配置launch.json和task.json，还有sourtree如何连接到WSL，这些都是一点一点摸索出来的，在这个过程学习到了很多东西，例如launch.json和task.json中每个变量的含义，vscode运行代码的原理等。</p>
<p>环境配置好入手项目也不是一件易事，首先就是词法和语法解析，我没有学习过编译原理，第一次接触这样的概念，查阅各种flex和bison的资料，得知了两个文件的编写规范，由于是以得分为目的，并没有深究其原理，这两个工具确实很厉害，然后就是阅读源码中各种数据结构，把sql中各种东西都封装成对象，例如create、select这种语句，这些语句中可能涉及到哪些参数，这些参数就是成员变量，这些成员变量可能与其他什么数据结构产生联系，再通过成员函数进行连接，我越来越佩服开发人员，可以如此复杂的sql模块化，模块与模块直接耦合度还这么低，如何拓展代码的情况下不破坏原来的结构，这是每个参赛者都必须考虑的问题，显然我实力不够，我只能在他们的数据结构上添加冗余的东西，以快速拿分，<del>虽然也没拿到分</del>，重庆是个水区，60分就可以进省3，10月20号的时候重邮拿到了60分，之后就再也没动过，因此在我拿到50分的时候信心大增，感觉可以冲一波前三，但是很快就被打脸了，最后一题实现聚合函数确实很难，正常来说是要重新设计一个数据结构来存放聚合函数的参数的，但是我实力太弱，只能在属性数据结构上动手脚，效果也很明显，很快就写好解析了，但是问题就是后面resolver、executor、tuple等与属性相关的数据结构都要修改，从项目开发的角度来看，这真是糟糕透了，因为这违背了扩展原则，但是没办法我只会这么做，改出一版代码，测试各种数据都没有问题，交上去之后就错了，难受的是只能看到一部分测试数据，在我本地看来，反馈的错误数据是可以跑通的，不知道哪里出错，也就无从改之，无奈，我止步于此。</p>
<p>总体而言，虽然从比赛的角度看，我由于是solo，没有项目经验，所以特别吃力，还有最后有个名次，我也收获了许多项目经验，也不枉这两周的修行。</p>
]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>miniob</tag>
        <tag>Oceanbase</tag>
      </tags>
  </entry>
  <entry>
    <title>数状数组求逆序对&amp;&amp;二维树状数组</title>
    <url>/posts/142f8d42.html</url>
    <content><![CDATA[<p>参考原文：<a href="https://blog.csdn.net/GodJing007/article/details/81158288"></a></p>
<h1 id="二维树状数组"><a href="#二维树状数组" class="headerlink" title="二维树状数组"></a>二维树状数组</h1><p>我们先来讲讲怎么去表示。<br>数组A[][]的树状数组定义为：</p>
<p>C[x][y] = ∑ a[i][j], 其中，<br>x-lowbit(x) + 1 &lt;= i &lt;= x,<br>y-lowbit(y) + 1 &lt;= j &lt;= y.</p>
<p>例：举个例子来看看C[][]的组成。<br>设原始二维数组为：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A[][]=&#123;&#123;a11,a12,a13,a14,a15,a16,a17,a18,a19&#125;,   </span><br><span class="line">&#123;a21,a22,a23,a24,a25,a26,a27,a28,a29&#125;,   </span><br><span class="line">&#123;a31,a32,a33,a34,a35,a36,a37,a38,a39&#125;，   </span><br><span class="line">&#123;a41,a42,a43,a44,a45,a46,a47,a48,a49&#125;&#125;;</span><br></pre></td></tr></table></figure><br>那么它对应的二维树状数组C[][]呢？</p>
<p>记:<br>B[1]={a11,a11+a12,a13,a11+a12+a13+a14,a15,a15+a16,…} 这是第一行的一维树状数组<br>B[2]={a21,a21+a22,a23,a21+a22+a23+a24,a25,a25+a26,…} 这是第二行的一维树状数组<br>B[3]={a31,a31+a32,a33,a31+a32+a33+a34,a35,a35+a36,…} 这是第三行的一维树状数组<br>B[4]={a41,a41+a42,a43,a41+a42+a43+a44,a45,a45+a46,…} 这是第四行的一维树状数组<br>那么：<br>C[1][1]=a11,C[1][2]=a11+a12,C[1][3]=a13,C[1][4]=a11+a12+a13+a14,c[1][5]=a15,C[1][6]=a15+a16,…<br>这是A[][]第一行的一维树状数组</p>
<p>C[2][1]=a11+a21,C[2][2]=a11+a12+a21+a22,C[2][3]=a13+a23,C[2][4]=a11+a12+a13+a14+a21+a22+a23+a24,<br>C[2][5]=a15+a25,C[2][6]=a15+a16+a25+a26,…<br>这是A[][]数组第一行与第二行相加后的树状数组   </p>
<p>C[3][1]=a31,C[3][2]=a31+a32,C[3][3]=a33,C[3][4]=a31+a32+a33+a34,C[3][5]=a35,C[3][6]=a35+a36,…<br>这是A[][]第三行的一维树状数组   </p>
<p>C[4][1]=a11+a21+a31+a41,C[4][2]=a11+a12+a21+a22+a31+a32+a41+a42,C[4][3]=a13+a23+a33+a43,…<br>这是A[][]数组第一行+第二行+第三行+第四行后的树状数组</p>
<blockquote>
<p>就是每一行都是一个树状数组，以行为元素，整个列也是一个树状数组。<br>（这句话请记住，这个思想会贯穿始终）<br>既然如此，我相信代码也很快就出来了，接下来我就来给出代码，并进行简单的解释。</p>
<h2 id="单点修改"><a href="#单点修改" class="headerlink" title="单点修改"></a>单点修改</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void add(int x,int y,int p)&#123;  </span><br><span class="line">    while(x&lt;=n)&#123;</span><br><span class="line">        for(int i=y;i&lt;=m;i+=lowbit(i))&#123;</span><br><span class="line">            C[x][i]+=p;</span><br><span class="line">        &#125; </span><br><span class="line">        x+=lowbit(x);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>这个根据我刚刚说的两个树状数组（那句贯穿始终的话），就很容易理解了。<br>我们外围循环枚举每一行，内循环在行内进行一维树状数组的单点修改，从而实现二维树状数组的单点修改。</p>
<h2 id="以原点为一个端点的子矩阵和"><a href="#以原点为一个端点的子矩阵和" class="headerlink" title="以原点为一个端点的子矩阵和"></a>以原点为一个端点的子矩阵和</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int sum(int x,int y)&#123;  </span><br><span class="line">    int result = 0;  </span><br><span class="line">    while(x&gt;0)&#123;</span><br><span class="line">        for(int i=y;i&gt;0;i-=lowbit(i))&#123;</span><br><span class="line">            result+=C[x][i];</span><br><span class="line">        &#125;</span><br><span class="line">        x-=lowbit(x);</span><br><span class="line">    &#125;  </span><br><span class="line">    return result;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h2 id="以任意两点为左上和右下两个端点的子矩阵和"><a href="#以任意两点为左上和右下两个端点的子矩阵和" class="headerlink" title="以任意两点为左上和右下两个端点的子矩阵和"></a>以任意两点为左上和右下两个端点的子矩阵和</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int ask(int x1,int y1,int x2,int y2)&#123;</span><br><span class="line">    return sum(x2,y2)+sum(x1-1,y1-1)-sum(x2-1,y1)-sum(x1,y2-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="逆序对"><a href="#逆序对" class="headerlink" title="逆序对"></a>逆序对</h1><p>这个借助例题来讲解<br><a href="https://vjudge.net/contest/368993#problem/B">题目</a><br>求冒泡排序交换了多少次，分析一下，不难看出就是求逆序对的个数，首先明白逆序对的概念给定i,j满足i &lt; j &amp;&amp; a[ i ]&gt;a[ j ]则a[ i ]和a[ j ]就是一对逆序对。<br>求逆序对的做法，举个例子：<br>给定序列<br>9 6 4 8 7<br>遍历这个数组，每次遇到一个数，就把该数所在的树状数组的位置处的数加一：<br>1 2 3 4 5 6 7 8 9<br>0 0 0 0 0 0 0 0 0<br>初始数组值为0，代表插入0个数，sum(n)代表小于等于该数的个数，那么大于该数的个数就是i-sum(n) </p>
<ol>
<li>1 2 3 4 5 6 7 8 9<br>0 0 0 0 0 0 0 0 1<br> 此时插入了一个数，sum(9)=1,1-1=0</li>
<li>1 2 3 4 5 6 7 8 9<br>0 0 0 0 0 1 0 0 1<br>sum(6)=1 2-1=1</li>
<li>1 2 3 4 5 6 7 8 9<br>0 0 0 1 0 1 0 0 1<br>sum(4)=1 3-1=2</li>
<li>1 2 3 4 5 6 7 8 9<br>0 0 0 1 0 1 0 1 1<br>sum(8)=3 4-3=1   </li>
<li>1 2 3 4 5 6 7 8 9<br>0 0 0 1 0 1 1 1 1<br>sum(7)=3 5-3=2 </li>
</ol>
</blockquote>
<p>上面所有的得数相加就得到了最后结果：<br>0+1+2+1+2=6<br>这就是思路，思路清楚了就可以做题了，可是这道题数据很大，明显开不了这么大得树状数组，一个简单得离散化就行了，先对树状数组按照值的大小进行排序，新开一个从序号1开始的连续的数组，一一映射到树状数组，最后对序号求逆序对就行了。</p>
<p>建立一个结构体包含val和id， val就是输入的数，id表示输入的顺序。然后按照val从小到大排序，如果val相等，那么就按照id排序。</p>
<p>如果没有逆序的话，肯定id是跟i（表示拍好后的顺序）一直一样的，如果有逆序数，那么有的i和id是不一样的。所以，利用树状数组的特性，我们可以简单的算出逆序数的个数。</p>
<p>如果还是不明白的话举个例子。（输入4个数）</p>
<p>输入：9 -1 18 5</p>
<p>输出 3.</p>
<p>输入之后对应的结构体就会变成这样<br>val：9 -1 18 5<br>id：  1  2  3  4<br>排好序之后就变成了<br>val ：  -1 5 9 18<br>id：      2 4  1  3<br>2 4 1 3 的逆序数 也是3<br>之后再利用树状数组的特性就可以解决问题了<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;algorithm&gt; </span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=500001;</span><br><span class="line">int c[maxn];</span><br><span class="line">struct Node</span><br><span class="line">&#123;</span><br><span class="line">	int v,index;</span><br><span class="line">	bool operator &lt; (const Node &amp;b) const</span><br><span class="line">	&#123;</span><br><span class="line">		return v&lt;b.v; //从小到大排序 </span><br><span class="line">	&#125;</span><br><span class="line">&#125;node[maxn];</span><br><span class="line">int n;</span><br><span class="line">void add(int i)</span><br><span class="line">&#123;</span><br><span class="line">	while(i&lt;=n)</span><br><span class="line">	&#123;</span><br><span class="line">		c[i]++;</span><br><span class="line">		i+=i&amp;(-i);	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">long long getsum(int i)</span><br><span class="line">&#123;</span><br><span class="line">	long long res=0;</span><br><span class="line">	while(i&gt;0)</span><br><span class="line">	&#123;</span><br><span class="line">		res+=c[i];</span><br><span class="line">		i-=i&amp;(-i);</span><br><span class="line">	&#125;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		cin&gt;&gt;n;</span><br><span class="line">		if(n==0) break;</span><br><span class="line">		int a;</span><br><span class="line">		memset(node,0,sizeof node);</span><br><span class="line">		memset(c,0,sizeof c);</span><br><span class="line">		for(int i=1;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			scanf(&quot;%d&quot;,&amp;a);</span><br><span class="line">			node[i].index=i;</span><br><span class="line">			node[i].v=a;</span><br><span class="line">		&#125;</span><br><span class="line">		sort(node+1,node+1+n);</span><br><span class="line">		long long ans=0;</span><br><span class="line">		for(int i=1;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			add(node[i].index);  //离散化结果—— 下标等效于数值</span><br><span class="line">			ans+=i-getsum(node[i].index); //得到之前有多少个比你大的数（逆序对）</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>python_arrange</title>
    <url>/posts/cd2bd376.html</url>
    <content><![CDATA[<blockquote>
<p>写这个代码花了一个小时，因为刚学了一点点OS模块，还不是很熟悉，写完后功能也都有，但是！！！导出为exe文件时不小心误删了py文件，气死我了！又重新写了一遍。</p>
<p>新加了GUI界面的整理页面小程序，效果如下图所示</p>
<p>GitHub项目地址 <a href="https://github.com/uncleacc/Organize-documents">Here</a></p>
</blockquote>
<p><strong>效果图：</strong></p>
<p><img src="http://ww1.sinaimg.cn/large/007Y60soly1gilvhm4w0ij30oa0gn0to.jpg" alt="">{height=”400”,width=”400”}</p>
<p><img src="http://ww1.sinaimg.cn/large/007Y60soly1gijcql8z7pj30ln0bhgmc.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/007Y60soly1gijdfc5nb5j30sv084ab9.jpg" alt=""></p>
<h2 id="CODE1（不含有重命名）"><a href="#CODE1（不含有重命名）" class="headerlink" title="CODE1（不含有重命名）"></a>CODE1（不含有重命名）</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> shutil <span class="keyword">import</span> copyfile</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;------创建文件夹------&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> var_list:</span><br><span class="line">        Path_now = os.path.join(Path, i).replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">not</span> os.path.exists(Path_now)):</span><br><span class="line">            os.mkdir(Path_now)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;------创建完成------&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">move</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;------移动文件------&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> os.listdir(Path):</span><br><span class="line">        Path_src = os.path.join(Path, file).replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span>(os.path.isfile(Path_src)):</span><br><span class="line">            pos = file.find(<span class="string">&#x27;.&#x27;</span>) + <span class="number">1</span></span><br><span class="line">            postfix = file[pos:]</span><br><span class="line">            <span class="keyword">if</span>(postfix <span class="keyword">in</span> var_list):</span><br><span class="line">                Path_tar = os.path.join(Path, postfix, file).replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">                copyfile(Path_src, Path_tar)</span><br><span class="line">                os.remove(Path_src)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;------移动完成------&#x27;</span>)</span><br><span class="line"></span><br><span class="line">var_list = [<span class="string">&#x27;jpg&#x27;</span>, <span class="string">&#x27;jpeg&#x27;</span>, <span class="string">&#x27;png&#x27;</span>, <span class="string">&#x27;txt&#x27;</span>, <span class="string">&#x27;webp&#x27;</span>, <span class="string">&#x27;gif&#x27;</span>, <span class="string">&#x27;avi&#x27;</span>] <span class="comment">#改这里面的内容可以添加整理文件方式(只需要改这里)</span></span><br><span class="line">Path = <span class="built_in">input</span>(<span class="string">&#x27;请输入您要整理的文件夹目录位置： &#x27;</span>)</span><br><span class="line">name = <span class="built_in">input</span>(<span class="string">&#x27;请输入您要整理的文件夹名称： &#x27;</span>)</span><br><span class="line">Path = os.path.join(Path, name).replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(Path)</span><br><span class="line">sure = <span class="built_in">input</span>(<span class="string">&#x27;确认您要整理此文件夹吗？ y/n?&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span>(sure == <span class="string">&#x27;y&#x27;</span>):</span><br><span class="line">    flag = <span class="number">0</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        flag = os.path.isdir(Path)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;无法打开此文件夹！请确认你具有权限访问此文件夹！！！&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span>(flag):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;------开始整理------&#x27;</span>)</span><br><span class="line">        create()</span><br><span class="line">        move()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;请确认地址指向文件夹&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;------exit successfully------&#x27;</span>)</span><br><span class="line"></span><br><span class="line">os.system(<span class="string">&quot;pause&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="CODE2-（重命名）"><a href="#CODE2-（重命名）" class="headerlink" title="CODE2 （重命名）"></a>CODE2 （重命名）</h2><p>实现了移动文件的过程中从0开始往上迭代重命名的过程</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> shutil <span class="keyword">import</span> copyfile</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Any</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 全局变量</span></span><br><span class="line">cnt_jpg = cnt_gif = cnt_png = cnt_txt = cnt_avi = cnt_webp = cnt_pdf = cnt_doc = <span class="number">0</span></span><br><span class="line">fileFormat = [<span class="string">&#x27;jpg&#x27;</span>, <span class="string">&#x27;jpeg&#x27;</span>, <span class="string">&#x27;png&#x27;</span>, <span class="string">&#x27;txt&#x27;</span>, <span class="string">&#x27;webp&#x27;</span>, <span class="string">&#x27;gif&#x27;</span>, <span class="string">&#x27;avi&#x27;</span>] <span class="comment"># 分类的文件格式</span></span><br><span class="line">Path = <span class="string">&quot;&quot;</span></span><br><span class="line">name = <span class="string">&quot;&quot;</span></span><br><span class="line">prefix = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用户输入</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__input</span>():</span><br><span class="line">    <span class="keyword">global</span> Path, name, prefix</span><br><span class="line">    Path = <span class="built_in">input</span>(<span class="string">&#x27;请输入您要整理的文件夹目录位置： &#x27;</span>)</span><br><span class="line">    name = <span class="built_in">input</span>(<span class="string">&#x27;请输入您要整理的文件夹名称： &#x27;</span>)</span><br><span class="line">    prefix = <span class="built_in">input</span>(<span class="string">&#x27;请输入重命名后的文件前缀： &#x27;</span>)</span><br><span class="line">    Path = os.path.join(Path, name).replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建文件夹，如果文件夹中有文件则将这些文件夹移出来</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__create</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;------创建文件夹------&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> fileFormat:</span><br><span class="line">        Path_now = os.path.join(Path, i).replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">not</span> os.path.exists(Path_now)):</span><br><span class="line">            os.mkdir(Path_now)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> file <span class="keyword">in</span> os.listdir(Path_now):</span><br><span class="line">                Path_cur = os.path.join(Path_now, file).replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">                Path_tar = os.path.join(Path, file).replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">                copyfile(Path_cur, Path_tar)</span><br><span class="line">                os.remove(Path_cur)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;------创建完成------&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重命名</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__change</span>(<span class="params">name, var, pos</span>):</span><br><span class="line">    <span class="keyword">global</span> cnt_jpg, cnt_gif, cnt_png, cnt_txt, cnt_avi, cnt_webp, cnt_doc, cnt_pdf</span><br><span class="line">    <span class="keyword">if</span>(var == <span class="string">&#x27;jpg&#x27;</span>):</span><br><span class="line">        cnt_jpg += <span class="number">1</span></span><br><span class="line">        name = name.replace(name[<span class="number">0</span>:pos-<span class="number">1</span>], <span class="built_in">str</span>(cnt_jpg))</span><br><span class="line">    <span class="keyword">if</span>(var == <span class="string">&#x27;avi&#x27;</span>):</span><br><span class="line">        cnt_avi += <span class="number">1</span></span><br><span class="line">        name = name.replace(name[<span class="number">0</span>:pos - <span class="number">1</span>], <span class="built_in">str</span>(cnt_avi))</span><br><span class="line">    <span class="keyword">if</span>(var == <span class="string">&#x27;doc&#x27;</span>):</span><br><span class="line">        cnt_doc += <span class="number">1</span></span><br><span class="line">        name = name.replace(name[<span class="number">0</span>:pos - <span class="number">1</span>], <span class="built_in">str</span>(cnt_doc))</span><br><span class="line">    <span class="keyword">if</span>(var == <span class="string">&#x27;pdf&#x27;</span>):</span><br><span class="line">        cnt_pdf += <span class="number">1</span></span><br><span class="line">        name = name.replace(name[<span class="number">0</span>:pos - <span class="number">1</span>], <span class="built_in">str</span>(cnt_pdf))</span><br><span class="line">    <span class="keyword">if</span>(var == <span class="string">&#x27;webp&#x27;</span>):</span><br><span class="line">        cnt_webp += <span class="number">1</span></span><br><span class="line">        name = name.replace(name[<span class="number">0</span>:pos - <span class="number">1</span>], <span class="built_in">str</span>(cnt_webp))</span><br><span class="line">    <span class="keyword">if</span>(var == <span class="string">&#x27;png&#x27;</span>):</span><br><span class="line">        cnt_png += <span class="number">1</span></span><br><span class="line">        name = name.replace(name[<span class="number">0</span>:pos-<span class="number">1</span>], <span class="built_in">str</span>(cnt_png))</span><br><span class="line">    <span class="keyword">if</span>(var == <span class="string">&#x27;gif&#x27;</span>):</span><br><span class="line">        cnt_gif += <span class="number">1</span></span><br><span class="line">        name = name.replace(name[<span class="number">0</span>:pos - <span class="number">1</span>], <span class="built_in">str</span>(cnt_gif))</span><br><span class="line">    <span class="keyword">if</span>(var == <span class="string">&#x27;txt&#x27;</span>):</span><br><span class="line">        cnt_txt += <span class="number">1</span></span><br><span class="line">        name = name.replace(name[<span class="number">0</span>:pos - <span class="number">1</span>], <span class="built_in">str</span>(cnt_txt))</span><br><span class="line">    <span class="keyword">return</span> prefix + name</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__move</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;------移动文件------&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> os.listdir(Path):</span><br><span class="line">        Path_src = os.path.join(Path, file).replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span>(os.path.isfile(Path_src)):</span><br><span class="line">            pos = file.rfind(<span class="string">&#x27;.&#x27;</span>) + <span class="number">1</span></span><br><span class="line">            postfix = file[pos:]</span><br><span class="line">            <span class="keyword">if</span>(postfix <span class="keyword">in</span> fileFormat):</span><br><span class="line">                file = __change(file, postfix, pos)</span><br><span class="line">                Path_tar = os.path.join(Path, postfix, file).replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">                copyfile(Path_src, Path_tar)</span><br><span class="line">                os.remove(Path_src)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;------移动完成------&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    __<span class="built_in">input</span>()</span><br><span class="line">    <span class="built_in">print</span>(Path)</span><br><span class="line">    sure = <span class="built_in">input</span>(<span class="string">&#x27;确认您要整理此文件夹吗？ y/n?&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span>(sure == <span class="string">&#x27;y&#x27;</span>):</span><br><span class="line">        <span class="keyword">if</span>(os.path.isdir(Path)):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;------开始整理------&#x27;</span>)</span><br><span class="line">            __create()</span><br><span class="line">            __move()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;请确认地址指向文件夹，如果确实是文件夹则检查权限问题&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;------exit successfully------&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">os.system(<span class="string">&quot;pause&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="CODE3-（GUI界面）"><a href="#CODE3-（GUI界面）" class="headerlink" title="CODE3 （GUI界面）"></a>CODE3 （GUI界面）</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> tkinter <span class="keyword">as</span> tk</span><br><span class="line"><span class="keyword">import</span> tkinter.messagebox</span><br><span class="line"><span class="keyword">from</span> shutil <span class="keyword">import</span> copyfile</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Any</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#创建tk窗口</span></span><br><span class="line">window = tk.Tk()</span><br><span class="line">window.title(<span class="string">&#x27;文档整理器&#x27;</span>)</span><br><span class="line">window.geometry(<span class="string">&#x27;700x450&#x27;</span>)</span><br><span class="line"><span class="comment">#建立表单</span></span><br><span class="line">var_info = tk.StringVar()</span><br><span class="line">var_info.<span class="built_in">set</span>(<span class="string">&#x27;当前您还没有进行整理&#x27;</span>)</span><br><span class="line">tk.Label(window, font=(<span class="string">&#x27;Arial, 15&#x27;</span>), bg=<span class="string">&#x27;yellow&#x27;</span>, textvariable=var_info).place(x=<span class="number">250</span>, y=<span class="number">20</span>)</span><br><span class="line">tk.Label(window, font=(<span class="string">&#x27;Arial&#x27;</span>, <span class="number">15</span>), text=<span class="string">&#x27;请输入您要整理的文件夹的路径: &#x27;</span>).place(x=<span class="number">10</span>, y=<span class="number">100</span>)</span><br><span class="line">tk.Label(window, font=(<span class="string">&#x27;Arial&#x27;</span>, <span class="number">15</span>), text=<span class="string">&#x27;请输入该文件夹的名字: &#x27;</span>).place(x=<span class="number">10</span>, y=<span class="number">150</span>)</span><br><span class="line">tk.Label(window, font=(<span class="string">&#x27;Arial&#x27;</span>, <span class="number">15</span>), text=<span class="string">&#x27;请输入重命名后的文件前缀： &#x27;</span>).place(x=<span class="number">10</span>, y=<span class="number">200</span>)</span><br><span class="line"><span class="comment"># 创建输入框</span></span><br><span class="line"><span class="comment"># 文件夹路径</span></span><br><span class="line">var_Path = tk.StringVar()</span><br><span class="line">entry_Path = tk.Entry(window, font=(<span class="string">&#x27;Arial&#x27;</span>,<span class="number">15</span>), textvariable=var_Path, width=<span class="number">30</span>)</span><br><span class="line">entry_Path.place(x=<span class="number">300</span>, y=<span class="number">100</span>)</span><br><span class="line"><span class="comment"># 文件夹名称</span></span><br><span class="line">var_name = tk.StringVar()</span><br><span class="line">entry_Name = tk.Entry(window, font=(<span class="string">&#x27;Arial&#x27;</span>,<span class="number">15</span>), textvariable=var_name, width=<span class="number">30</span>)</span><br><span class="line">entry_Name.place(x=<span class="number">300</span>, y=<span class="number">150</span>)</span><br><span class="line"><span class="comment"># 重命名前缀</span></span><br><span class="line">var_prefix = tk.StringVar()</span><br><span class="line">entry_Prefix = tk.Entry(window, font=(<span class="string">&#x27;Arial&#x27;</span>,<span class="number">15</span>), textvariable=var_prefix, width=<span class="number">30</span>)</span><br><span class="line">entry_Prefix.place(x=<span class="number">300</span>, y=<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 全局变量</span></span><br><span class="line">cnt_jpg = cnt_gif = cnt_png = cnt_txt = cnt_avi = cnt_webp = cnt_pdf = cnt_doc = <span class="number">0</span></span><br><span class="line">fileFormat = [<span class="string">&#x27;jpg&#x27;</span>, <span class="string">&#x27;jpeg&#x27;</span>, <span class="string">&#x27;png&#x27;</span>, <span class="string">&#x27;txt&#x27;</span>, <span class="string">&#x27;webp&#x27;</span>, <span class="string">&#x27;gif&#x27;</span>, <span class="string">&#x27;avi&#x27;</span>] <span class="comment"># 分类的文件格式</span></span><br><span class="line">Path = <span class="string">&#x27;&#x27;</span></span><br><span class="line">name = <span class="string">&#x27;&#x27;</span></span><br><span class="line">prefix = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 创建文件夹，如果文件夹中有文件则将这些文件夹移出来</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__create</span>():</span><br><span class="line">    <span class="keyword">global</span> var_info</span><br><span class="line">    var_info.<span class="built_in">set</span>(<span class="string">&#x27;------创建文件夹------&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> fileFormat:</span><br><span class="line">        Path_now = os.path.join(Path, i).replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">not</span> os.path.exists(Path_now)):</span><br><span class="line">            os.mkdir(Path_now)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> file <span class="keyword">in</span> os.listdir(Path_now):</span><br><span class="line">                Path_cur = os.path.join(Path_now, file).replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">                Path_tar = os.path.join(Path, file).replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">                copyfile(Path_cur, Path_tar)</span><br><span class="line">                os.remove(Path_cur)</span><br><span class="line">    var_info.<span class="built_in">set</span>(<span class="string">&#x27;------创建完成------&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重命名</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__change</span>(<span class="params">name, var, pos</span>):</span><br><span class="line">    <span class="keyword">global</span> cnt_jpg, cnt_gif, cnt_png, cnt_txt, cnt_avi, cnt_webp, cnt_doc, cnt_pdf</span><br><span class="line">    <span class="keyword">if</span>(var == <span class="string">&#x27;jpg&#x27;</span>):</span><br><span class="line">        cnt_jpg += <span class="number">1</span></span><br><span class="line">        name = name.replace(name[<span class="number">0</span>:pos-<span class="number">1</span>], <span class="built_in">str</span>(cnt_jpg))</span><br><span class="line">    <span class="keyword">if</span>(var == <span class="string">&#x27;avi&#x27;</span>):</span><br><span class="line">        cnt_avi += <span class="number">1</span></span><br><span class="line">        name = name.replace(name[<span class="number">0</span>:pos - <span class="number">1</span>], <span class="built_in">str</span>(cnt_avi))</span><br><span class="line">    <span class="keyword">if</span>(var == <span class="string">&#x27;doc&#x27;</span>):</span><br><span class="line">        cnt_doc += <span class="number">1</span></span><br><span class="line">        name = name.replace(name[<span class="number">0</span>:pos - <span class="number">1</span>], <span class="built_in">str</span>(cnt_doc))</span><br><span class="line">    <span class="keyword">if</span>(var == <span class="string">&#x27;pdf&#x27;</span>):</span><br><span class="line">        cnt_pdf += <span class="number">1</span></span><br><span class="line">        name = name.replace(name[<span class="number">0</span>:pos - <span class="number">1</span>], <span class="built_in">str</span>(cnt_pdf))</span><br><span class="line">    <span class="keyword">if</span>(var == <span class="string">&#x27;webp&#x27;</span>):</span><br><span class="line">        cnt_webp += <span class="number">1</span></span><br><span class="line">        name = name.replace(name[<span class="number">0</span>:pos - <span class="number">1</span>], <span class="built_in">str</span>(cnt_webp))</span><br><span class="line">    <span class="keyword">if</span>(var == <span class="string">&#x27;png&#x27;</span>):</span><br><span class="line">        cnt_png += <span class="number">1</span></span><br><span class="line">        name = name.replace(name[<span class="number">0</span>:pos-<span class="number">1</span>], <span class="built_in">str</span>(cnt_png))</span><br><span class="line">    <span class="keyword">if</span>(var == <span class="string">&#x27;gif&#x27;</span>):</span><br><span class="line">        cnt_gif += <span class="number">1</span></span><br><span class="line">        name = name.replace(name[<span class="number">0</span>:pos - <span class="number">1</span>], <span class="built_in">str</span>(cnt_gif))</span><br><span class="line">    <span class="keyword">if</span>(var == <span class="string">&#x27;txt&#x27;</span>):</span><br><span class="line">        cnt_txt += <span class="number">1</span></span><br><span class="line">        name = name.replace(name[<span class="number">0</span>:pos - <span class="number">1</span>], <span class="built_in">str</span>(cnt_txt))</span><br><span class="line">    <span class="keyword">return</span> prefix + name</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__move</span>():</span><br><span class="line">    var_info.<span class="built_in">set</span>(<span class="string">&#x27;------移动文件------&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> os.listdir(Path):</span><br><span class="line">        Path_src = os.path.join(Path, file).replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span>(os.path.isfile(Path_src)):</span><br><span class="line">            pos = file.rfind(<span class="string">&#x27;.&#x27;</span>) + <span class="number">1</span></span><br><span class="line">            postfix = file[pos:]</span><br><span class="line">            <span class="keyword">if</span>(postfix <span class="keyword">in</span> fileFormat):</span><br><span class="line">                file = __change(file, postfix, pos)</span><br><span class="line">                Path_tar = os.path.join(Path, postfix, file).replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">                copyfile(Path_src, Path_tar)</span><br><span class="line">                os.remove(Path_src)</span><br><span class="line">    var_info.<span class="built_in">set</span>(<span class="string">&#x27;------移动完成------&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check</span>():</span><br><span class="line">    <span class="keyword">if</span>(var_Path.get() <span class="keyword">and</span> var_name.get()):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">if</span>(check()):</span><br><span class="line">        <span class="keyword">global</span> Path, prefix</span><br><span class="line">        Path = os.path.join(var_Path.get(), var_name.get()).replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">        prefix = var_prefix.get()</span><br><span class="line">        sure = tk.messagebox.askyesno(title=<span class="string">&#x27;Are you sure?&#x27;</span>, message=<span class="string">&#x27;请确定您要整理的文件夹路径是&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(Path))</span><br><span class="line">        <span class="keyword">if</span>(sure == <span class="literal">True</span>):</span><br><span class="line">            <span class="keyword">if</span>(os.path.isdir(Path)):</span><br><span class="line">                var_info.<span class="built_in">set</span>(<span class="string">&#x27;------开始整理------&#x27;</span>)</span><br><span class="line">                __create()</span><br><span class="line">                __move()</span><br><span class="line">                tk.messagebox.showinfo(title=<span class="string">&#x27;Success&#x27;</span>, message=<span class="string">&#x27;文件整理完毕&#x27;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tk.messagebox.showerror(title=<span class="string">&#x27;ERROR&#x27;</span>, message=<span class="string">&#x27;请确认该路径指向文件夹，如果确实是文件夹则检查权限问题&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        tk.messagebox.showwarning(title=<span class="string">&#x27;Warning&#x27;</span>, message=<span class="string">&#x27;请确保您的文件夹目录和名字进行了输入(前缀为空则默认全部数字)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">bt1 = tk.Button(window,font=(<span class="string">&#x27;Arial&#x27;</span>,<span class="number">15</span>), activebackground=<span class="string">&#x27;black&#x27;</span>, text=<span class="string">&#x27;开始整理&#x27;</span>, height=<span class="number">2</span>, width=<span class="number">30</span>, command=main)</span><br><span class="line">bt1.place(x=<span class="number">210</span>, y=<span class="number">260</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">window.mainloop()</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈哈希</title>
    <url>/posts/819591f7.html</url>
    <content><![CDATA[<blockquote>
<p><strong>前言</strong></p>
<p>趁着还没忘记录一下吧🐷</p>
</blockquote>
<h2 id="哈希能干些啥？"><a href="#哈希能干些啥？" class="headerlink" title="哈希能干些啥？"></a>哈希能干些啥？</h2><p>学一个新算法首先一定要知道学这个能干些啥对吧，我们是为了用某个东西而去学这个东西而不是盲目目的的学，现在假如给你两段字符串让你去比较他们是否相同，如果暴力做法就是从头到尾扫一遍，都相同则相同，复杂度为O(N)，假如数据量非常大，而且字符串长度很大，现在题目就变成了给你n个字符串，现在又给你t个字符串问你每一个字符串是否在这n个字符串中，平常做法时间复杂度O(t<em>t个字符串每一个字符串长度\</em>n)，若用哈希预处理时间复杂度降到O(t*字符串长度+n)，也就是把那n个字符串预先处理一下，使得接下来比较每一个字符串时时间复杂度变成O(1)，让我们来看一下具体怎么操作吧</p>
<h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>其实哈希和二进制思想是类似的，如果让你比较两个二进制串是否相同，你肯定会想到把二进制转成十进制比较起来会更方便，因为复杂度降低到了O(1)，不用你去逐位比较了，那字符串也是可以像二进制那样转换成为一个数字的，例如：abcd这个字符串可以转换成为a<em>p^3^+b\</em>p^2^+c*p^1^+d*p^0^，这里的p值是多少先不说，每一个字符都是有acall值的，我们可以直接利用这一点把每一个字符串转换成这样的数字，其中如果涉及到字符串子串问题，例如找一个字符串中是否含有某一段子串，我们就可用前缀的思想讲一个字符及之前的所有字符转换成数字存到数组里面，例如abcd我们就开一个Hash[5]，Hash[1]存a的哈希值，Hash[2]存ab的哈希值，Hash[3]存abc的哈希值，以此类推，这样假如我们要找其中一段子串的哈希值就可以前缀减一下也在O(1)的时间得出来，但是注意的是这里每一位权值不同不能简单做一下减法，具体实现继续看</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>这段代码就实现了哈希</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Hash[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) Hash[i]=(Hash[i<span class="number">-1</span>]*p+s[i])%mod;<span class="comment">//前i 个字符的 hash值</span></span><br></pre></td></tr></table></figure>
<p>是不是很简单呢？注意的是字符串转换的哈希值是特别特别大的，你想一想64位二进制都到了longlon的程度这里的p还比2大也就是说字符串不到64位都存不下了，因此但总归每一个字符串映射过来的数字基本都是不同的，因此我们可以取一下模，取模后数字依旧是不同的，需要注意的是虽然数字相同概率非常小，但是假如p和mod取得数字不对依旧是有很大几率两段不同字符串映射到相同数字的，因此这里的p和mod都应该是一个质数，以降低重复概率，，<code>p 一般取 131、13331 或者 2333，mod 一般取 1e9+7，1e9+9 或者 2^64^</code>。需要说明的是C语言的unsigned long long 无符号整数当存储数字超过范围后会自动取模，不会爆，所以hash数组可以用ull定义，只不过有的题目可能会卡内存，因此还是建议自己实现取模操作</p>
<p>到这里就实现了把字符串转换成为数字，接下来如何取子串的哈希值呢？</p>
<p>Hash[r]=s[1]*p^r-1^+s[2]*p^r-2^…s[r]*p^0^</p>
<p>Hash[l-1]=s[1]*p^l^+s[2]*p^l-1^…s[r]*p^0^</p>
<p>Hash[l~r]=s[l]<em>p^r-l^+s[l+1]\</em>p^r-l+1^…s[r]*p^0^</p>
<p>发现3式等于1式减去2式*p^r-l+1^，因此取字串哈希值代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">get_hash</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ((hash[r]-hash[l<span class="number">-1</span>]*<span class="built_in">pow</span>(p,r-l+<span class="number">1</span>))%mod+mod)%mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的pow函数当有多组数据时可以用po数组预先处理一下，存储p的i次方，这里的复杂度就降低为O(1)了，本来pow函数复杂度为O(N)的</p>
<p>po数组代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">po[i<span class="number">-1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) po[i]=po[i<span class="number">-1</span>]*p%MOD;</span><br></pre></td></tr></table></figure>
<p>这样整个就结束了</p>
<p><a href="https://vjudge.net/contest/388681#problem/A">来看一道例题吧</a></p>
<p>甚至可以直接看代码，知道实现的大致思路</p>
<h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 500005</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">400100</span>;</span><br><span class="line">ull ha[MAXN],po[MAXN];</span><br><span class="line"><span class="type">int</span> ans[MAXN];</span><br><span class="line"><span class="type">char</span> ch[MAXN];</span><br><span class="line"><span class="type">int</span> p=<span class="number">131</span>;</span><br><span class="line">ull <span class="title function_">get_ha</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ha[r]-ha[l<span class="number">-1</span>]*po[r-l+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;ch+<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="type">int</span> len=<span class="built_in">strlen</span>(ch+<span class="number">1</span>);</span><br><span class="line">		ha[<span class="number">0</span>]=<span class="number">0</span>; po[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++)&#123;</span><br><span class="line">			ha[i]=ha[i<span class="number">-1</span>]*p+ch[i]-<span class="string">&#x27;a&#x27;</span>+<span class="number">1</span>;</span><br><span class="line">			po[i]=po[i<span class="number">-1</span>]*p;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> tail =<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(get_ha(<span class="number">1</span>,i)==get_ha(len-i+<span class="number">1</span>,len)) ans[++tail]=i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tail;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(i!=tail) <span class="built_in">cout</span>&lt;&lt;ans[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;ans[i]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>哈希还可以后缀，利用后缀和前缀比较可以快速判断回文串</p>
<p><a href="https://vjudge.net/contest/388813#problem/D">例题</a></p>
<h2 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 500005</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">100100</span>;</span><br><span class="line">ull ha1[MAXN],ha2[MAXN],po[MAXN];</span><br><span class="line"><span class="type">char</span> ch[MAXN];</span><br><span class="line"><span class="type">int</span> p=<span class="number">131</span>;</span><br><span class="line">ull <span class="title function_">get_h1</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ha1[r]-ha1[l<span class="number">-1</span>]*po[r-l+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">ull <span class="title function_">get_h2</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ha2[l]-ha2[r+<span class="number">1</span>]*po[r-l+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	ios;</span><br><span class="line">	po[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;MAXN;i++) po[i]=p*po[i<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;ch+<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="type">int</span> len=<span class="built_in">strlen</span>(ch+<span class="number">1</span>);</span><br><span class="line">		ha1[<span class="number">0</span>]=ha2[len+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++)</span><br><span class="line">			ha1[i]=ha1[i<span class="number">-1</span>]*p+ch[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=len;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">			ha2[i]=ha2[i+<span class="number">1</span>]*p+ch[i];</span><br><span class="line">		<span class="type">int</span> pos;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(get_h1(i,len)==get_h2(i,len))&#123;</span><br><span class="line">				pos=i<span class="number">-1</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;ch+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=pos;i&gt;=<span class="number">1</span>;i--) <span class="built_in">cout</span>&lt;&lt;ch[i];</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="双哈希乃至多哈希"><a href="#双哈希乃至多哈希" class="headerlink" title="双哈希乃至多哈希"></a>双哈希乃至多哈希</h2><p>需要明白的一点是虽然错误率是极低的，但是依旧有错误率的，为了进一步降低错误率，我们可以用双哈希乃至多哈希降低错误率，也就是对一个字符串定义两个hash数组，分别对不同的p和mod操作，当两个字符串比较时，除非两个hash数组都一样才说两个字符串相同，<a href="https://vjudge.net/contest/388813#problem/F">例题</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> base 33</span></span><br><span class="line">LL p[<span class="number">1000100</span>];</span><br><span class="line">LL h1[<span class="number">1000100</span>],h2[<span class="number">1000100</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> LL <span class="title function_">gethash1</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span> &#123;</span><br><span class="line">    LL tp = l?h1[l<span class="number">-1</span>]:<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> h1[r] - tp*p[r-l+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> LL <span class="title function_">gethash2</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span> &#123;</span><br><span class="line">    LL tp = l?h2[l<span class="number">-1</span>]:<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> h2[r] - tp*p[r-l+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Is_palindrome</span><span class="params">(<span class="built_in">string</span> s)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.size()/<span class="number">2</span>; i++)</span><br><span class="line">        <span class="keyword">if</span> (s[i] != s[s.size()<span class="number">-1</span>-i]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> <span class="title function_">find</span><span class="params">(<span class="built_in">string</span> s)</span> &#123;</span><br><span class="line">    <span class="built_in">string</span> ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">int</span> len = s.size();</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">       <span class="keyword">if</span> (i == <span class="number">0</span>) h1[i] = s[i];</span><br><span class="line">       <span class="keyword">else</span> h1[i] = h1[i<span class="number">-1</span>]*base+s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) h2[i] = s[len-i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">else</span> h2[i] = h2[i<span class="number">-1</span>]*base+s[len-i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = len<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (gethash1(<span class="number">0</span>,i) == gethash2(len<span class="number">-1</span>-i,len<span class="number">-1</span>) &amp;&amp; Is_palindrome(s.substr(<span class="number">0</span>,i+<span class="number">1</span>))) <span class="keyword">return</span> s.substr(<span class="number">0</span>,i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">work</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    <span class="built_in">string</span> comm = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; s.size()/<span class="number">2</span>; i++)</span><br><span class="line">      <span class="keyword">if</span> (s[i] == s[s.size()<span class="number">-1</span>-i]) comm += s[i];</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    s = s.substr(i,s.size()-i-i);</span><br><span class="line">    <span class="built_in">string</span> ss = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = s.size()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) ss += s[i];</span><br><span class="line">    <span class="built_in">string</span> s1 = find(s),s2 = find(ss);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; comm  &lt;&lt; (s1.size()&gt;s2.size()?s1:s2);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = comm.size()<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; comm[i];</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1000000</span>; i++)</span><br><span class="line">       p[i] = p[i<span class="number">-1</span>]*base;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        work();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>集训</tag>
      </tags>
  </entry>
  <entry>
    <title>全排列问题</title>
    <url>/posts/543746.html</url>
    <content><![CDATA[<h1 id="STL-next-permutation函数实现"><a href="#STL-next-permutation函数实现" class="headerlink" title="STL next_permutation函数实现"></a>STL next_permutation函数实现</h1><p><a href="https://www.cnblogs.com/luruiyuan/p/5914909.html">原文链接</a><br>掌握了next_permutation函数的原理:smile:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void inline swap(char *s1,char *s2)&#123;</span><br><span class="line">    char t=*s1;</span><br><span class="line">    *s1=*s2;</span><br><span class="line">    *s2=t;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">*反转字符串函数,s,e分别执行字符串的开始和结尾，不能反转中文 </span><br><span class="line">**/</span><br><span class="line">void reverse(char *s,char* e)&#123;</span><br><span class="line">    for(e--;s&lt;e;s++,e--)swap(s,e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool next_permutation(char *start,char *end)&#123;</span><br><span class="line">    char *cur = end-1, *pre=cur-1;</span><br><span class="line">    while(cur&gt;start &amp;&amp; *pre&gt;=*cur)cur--,pre--;</span><br><span class="line">    if(cur&lt;=start)return false;</span><br><span class="line">    </span><br><span class="line">    for(cur=end-1;*cur&lt;=*pre;cur--);//找到逆序中大于*pre的元素的最小元素 </span><br><span class="line">    swap(cur,pre);</span><br><span class="line">    reverse(pre+1,end);//将尾部的逆序变成正序 </span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>prev_permutation只要将上面的cur和pre作比较的地方换一下位置就行了</code><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool prev_permutation(char *start,char *end)&#123;</span><br><span class="line">    char *cur = end-1, *pre=cur-1;</span><br><span class="line">    while(cur&gt;start &amp;&amp; *pre&lt;=*cur)cur--,pre--;//这里符号有变化 </span><br><span class="line">    if(cur&lt;=start)return false;</span><br><span class="line">    </span><br><span class="line">    for(cur=end-1;*cur&gt;=*pre;cur--);//这里符号有变化 </span><br><span class="line">    swap(*cur,*pre);</span><br><span class="line">    reverse(pre+1,end);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>给出一个字符串S（可能有重复的字符），按照字典序从小到大，输出S包括的字符组成的所有排列。例如：S = “1312”，</p>
<p>输出为：</p>
<p>1123<br>1132<br>1213<br>1231<br>1312<br>1321<br>2113<br>2131<br>2311<br>3112<br>3121<br>3211<br>Sample Input<br>1312<br>Sample Output<br>1123<br>1132<br>1213<br>1231<br>1312<br>1321<br>2113<br>2131<br>2311<br>3112<br>3121<br>3211   </p>
<h1 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">bool next_permutation(char *start,char *end)&#123;</span><br><span class="line">    char *cur = end-1, *pre=cur-1;</span><br><span class="line">    while(cur&gt;start &amp;&amp; *pre&gt;=*cur)cur--,pre--;</span><br><span class="line">    if(cur&lt;=start)return false;</span><br><span class="line">    </span><br><span class="line">    for(cur=end-1;*cur&lt;=*pre;cur--);//找到逆序中大于*pre的元素的最小元素 </span><br><span class="line">    swap(*cur,*pre);</span><br><span class="line">    reverse(pre+1,end);//将尾部的逆序变成正序 </span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    char s2[100];</span><br><span class="line">    scanf(&quot;%s&quot;,s2);</span><br><span class="line">    int n=strlen(s2);</span><br><span class="line">    sort(s2,s2+n);</span><br><span class="line">    do&#123;</span><br><span class="line">        puts(s2);</span><br><span class="line">//        cnt++;</span><br><span class="line">    &#125;while(next_permutation(s2,s2+n));</span><br><span class="line">//    printf(&quot;%d&quot;,cnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DFS</span><br><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">const int N = 10+5;</span><br><span class="line"> </span><br><span class="line">char ch[N];</span><br><span class="line">char ans[N];</span><br><span class="line">bool vis[N];</span><br><span class="line">int n;</span><br><span class="line"> </span><br><span class="line">void dfs(int x)&#123;</span><br><span class="line">	int i;</span><br><span class="line">	if(x == n)&#123; </span><br><span class="line">		printf(&quot;%s\n&quot;,ans);</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		for(int i = 0; i &lt; n;i++)&#123;</span><br><span class="line">			if(vis[i] == false)&#123;</span><br><span class="line">				vis[i] = true;</span><br><span class="line">				ans[x] = ch[i];</span><br><span class="line">				dfs(x+1);</span><br><span class="line">				vis[i]=false;</span><br><span class="line">				//筛除重复数据 </span><br><span class="line">				while(i &lt; n-1 &amp;&amp; ch[i+1]==ch[i]) i++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	scanf(&quot;%s&quot;,&amp;ch);</span><br><span class="line">	n = strlen(ch);</span><br><span class="line">	sort(ch,ch+n);</span><br><span class="line">	dfs(0);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>全排列</tag>
      </tags>
  </entry>
  <entry>
    <title>容斥原理</title>
    <url>/posts/bb1025ee.html</url>
    <content><![CDATA[<p>今天学习了容斥原理，感觉智商又一次遭到了蹂躏（eoe），百度了CSDN上面的讲解，感觉讲的都不是很详细（或许真的是我笨吧，哎~），还是结合题目来讲吧，上题：</p>
<p>I - Co-prime </p>
<p>Given a number N, you are asked to count the number of integers between A and B inclusive which are relatively prime to N.<br>Two integers are said to be co-prime or relatively prime if they have no common positive divisors other than 1 or, equivalently, if their greatest common divisor is 1. The number 1 is relatively prime to every integer. </p>
<p>Input</p>
<pre><code>The first line on input contains T (0 &lt; T &lt;= 100) the number of test cases, each of the next T lines contains three integers A, B, N where (1 &lt;= A &lt;= B &lt;= 10^15) and (1 &lt;=N &lt;= 10^9).
</code></pre><p>Output</p>
<pre><code>For each test case, print the number of integers between A and B inclusive which are relatively prime to N. Follow the output format below.
</code></pre><p>Sample Input</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">10</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">15</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>Sample Output</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Case #<span class="number">1</span>: <span class="number">5</span></span><br><span class="line">Case #<span class="number">2</span>: <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>Hint</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">In the first test <span class="keyword">case</span>, the five integers in range [<span class="number">1</span>,<span class="number">10</span>] which are relatively prime to <span class="number">2</span> are &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>&#125;. </span><br></pre></td></tr></table></figure>
<p>题目的意思给定一个区间的左端点和右端点，再给你一个数，求在这个区间里面和这个数互质的数的个数，只要您不是初学者就应该知道这么10^15如此大区间不可能去遍历它，这时候就要用到容斥原理了，接下来是重点（。。敲黑板。。），注意看！！</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>举个例子，如何把一个区间中2，3，5的的倍数全部筛掉，假如区间是1-20，我们先筛2的倍数，那么筛掉的数量就是20/2=10，同理筛3的倍数筛掉的数量就是20/3（注意向下取整），5同理，ok，筛完了，但是实际上答案是不对的，细心的你一定发现了，2和3的乘积6被多次筛选了，同理2和5，3和5也被多次筛选了，因此我们还要把6，10，15的倍数再减一遍，然后我们再去找2，3，5的乘积筛了几遍，上面我们单独筛2，3，5的时候我们是把2，3，5的乘积筛了3遍，之后又筛选两两乘积的时候又筛了三遍，因为单独筛选时用的是加法，而两两乘积的筛选用的是减法，这就导致了2，3，5的乘积实际上一次没有筛，所以我们最后还要加上2，3，5的乘积的筛选个数，什么？看不懂，行，给你画图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/20200703230236206.png" alt=""></p>
<p>其实就是求图形的面积，我们第一次加上了2，3，5的3个大圆面积，之后又减去了6，10，15的3个椭圆的面积，而最中间的小圆相当于一次没加，最后加上就行了，然后我们会发现，出现奇数个数，就用加法，偶数个数用减法。</p>
<p>最后的式子是这样的：k / 2 + k / 3 + k / 5 - k / (2 <em> 3) - k / (3 </em> 5) - k / (2 <em> 5) + k / (2 </em> 3 * 5)是不是很简单呢（qwq）</p>
<h2 id="分析题解"><a href="#分析题解" class="headerlink" title="分析题解"></a>分析题解</h2><p>ok，讲完了容斥的原理，接下来就能做题了，题目要求区间段内与k互质的个数，就是求区间段内与k不互质的个数，然后再用区间长度减去这个数就行了，求[l,r]中与k不互质的个数，就是求[1,r]-[1,l-1]（一定注意是l-1，因为包括l），理清了思路，就可以敲代码了</p>
<h2 id="分解质因子的代码"><a href="#分解质因子的代码" class="headerlink" title="分解质因子的代码"></a>分解质因子的代码</h2><p>上面忘了说要筛掉一个区间中与k不互质的个数，首先要把k分解成质因子，首先应该知道任何一个数要不是质数，要不是可以由多个质数相乘得到，例如：10=2 <em> 5, 30=2 </em> 3 <em> 5 , 50=2 </em> 5 * 5，利用这个性质，就可以分解了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i*i&lt;=k;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(k%i==<span class="number">0</span>)&#123;</span><br><span class="line">        p[++tail]=i;  <span class="comment">//p就是储存质因子的数组</span></span><br><span class="line">        <span class="keyword">while</span>(k%i==<span class="number">0</span>) k/=i;  <span class="comment">//把k中所有i的质因子全部除去</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(k&gt;<span class="number">1</span>) p[++tail]=k;  <span class="comment">//最后如果大于一，则最后一个数一定是质因子，这一步可能有一点难理解，可以多想想</span></span><br></pre></td></tr></table></figure>
<h2 id="实现容斥定理的代码"><a href="#实现容斥定理的代码" class="headerlink" title="实现容斥定理的代码"></a>实现容斥定理的代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">fun</span><span class="params">(<span class="type">long</span> <span class="type">long</span> x)</span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> res=<span class="number">0</span>;  <span class="comment">//res储存的是1-x中与K不互质的数量 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;(<span class="number">1</span>&lt;&lt;tail);i++)&#123;  <span class="comment">//这里的1&lt;&lt;tail是指2的tail次方，表示tail个质因子有多少种组合情况 </span></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> cur=<span class="number">1</span>,cnt=<span class="number">0</span>;  <span class="comment">//cur表示在当前选中的质因子中的乘积，cnt表示当前选中的数量是奇数还是偶数 </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;tail;j++)&#123;  <span class="comment">//这个循环是枚举tail的二进制形式 </span></span><br><span class="line">            <span class="keyword">if</span>((i&gt;&gt;j)&amp;<span class="number">1</span>)&#123;  <span class="comment">//这个是判断i的第j位是不是1，如果是则表示选中第j个数 </span></span><br><span class="line">                cnt++;  <span class="comment">//表示选中了几个数，每选中一个就加一 </span></span><br><span class="line">                cur*=p[j+<span class="number">1</span>];  <span class="comment">//选中第j个数就用cur乘以第j个质因子数，注意质因子数组是从1开始的，所以要加一 </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt&amp;<span class="number">1</span>) res+=x/cur;  <span class="comment">//如果cnt是偶数就相加 </span></span><br><span class="line">        <span class="keyword">else</span> res-=x/cur;  <span class="comment">//奇数就相减 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x-res;  <span class="comment">//res储存的是1-x中与K不互质的数量，所以要用x-res得到互质的数量 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一段代码我觉得好难理解，尤其是我在网上查资料感觉讲的不是很详细，想了一下午，才茅塞顿开，因此我希望广大网友在这里能够少花时间，代码里的（1&lt;&lt;tail）<br>实际上就是2^tail，表示n个质因子的组合情况数，需要说明这里面包括空集，所以循环从条件是小于而不是小于等于，然后每一个i的二进制形式每一位要不是1要不是0，而1&lt;&lt;tail<br>的二进制形式位数正好等于质因子数，我们就把每一位数字用1表示选中，0表示没有选中，那么我们遍历二进制的每一位数，如果是1，设这是第n位数（从左到右数），就类乘第n个质因子数，最后判断选中了多少位，如果是偶数就加，否则减，然后就完成了，二进制这一段代码确实比较难以理解，不过只要仔细想一想还是能想通的（加油）</p>
<p>然后就结束了，贴一下AC代码吧</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> p[<span class="number">1000000</span>];</span><br><span class="line"><span class="type">int</span> tail;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">fun</span><span class="params">(<span class="type">long</span> <span class="type">long</span> x)</span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;(<span class="number">1</span>&lt;&lt;tail);i++)&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> cur=<span class="number">1</span>,cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;tail;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((i&gt;&gt;j)&amp;<span class="number">1</span>)&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                cur*=p[j+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt&amp;<span class="number">1</span>) res+=x/cur;</span><br><span class="line">        <span class="keyword">else</span> res-=x/cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x-res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> t,times=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        tail=<span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> l,r,k;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r&gt;&gt;k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i*i&lt;=k;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(k%i==<span class="number">0</span>)&#123;</span><br><span class="line">                p[++tail]=i;</span><br><span class="line">                <span class="keyword">while</span>(k%i==<span class="number">0</span>) k/=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k&gt;<span class="number">1</span>) p[++tail]=k;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans=fun(r)-fun(l<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: %lld\n&quot;</span>,++times,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果有不懂的，留下评论，我会按时解答的哦</p>
<blockquote>
<p>告诉你一个小秘密，点击下方的赏字，就能够赞助我了哦（乖乖的说）</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>筛选素数的n种方法</title>
    <url>/posts/fe6d75ae.html</url>
    <content><![CDATA[<blockquote>
<h1 id="暴力筛选"><a href="#暴力筛选" class="headerlink" title="暴力筛选"></a>暴力筛选</h1><p>这种方法我就不多说了，一个数是素数则其只能被1和它本身整除，抓住这个特性，从2开始遍历到这个数减1，如果该数能整除其中任意一个数，则其都不是素数，如果想筛选某个范围内的，则遍历这个区间，从左端点遍历到右端点，该数是素数则将其标记为0，遍历完以后，数组中是0的就是合数，非0是素数，时间复杂度On^2</p>
</blockquote>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 判断一个数是不是质数</span><br><span class="line">    for(int i=2;i&lt;n;i++)&#123;</span><br><span class="line">        if(n%i==0)&#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">筛选一个区间的质数</span><br><span class="line">    memset(arr,1,sizeof arr);</span><br><span class="line">    for(int j=x;j&lt;=y;j++)&#123;</span><br><span class="line">        for(int i=2;i&lt;n;i++)&#123;</span><br><span class="line">            if(n%i==0)&#123;</span><br><span class="line">                arr[j]=0;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">arr[i]=1则是质数否则是合数</span><br></pre></td></tr></table></figure>
<ul>
<li><h2 id="稍加优化"><a href="#稍加优化" class="headerlink" title="稍加优化"></a>稍加优化</h2>对于一个数其因子一定是成对出现的，例如8的一对因子就是2和4，因此如果这个数能被2整除则不用判断能否被4整除了，对于一个合数来说这个性质没什么用，因为判断到能整除2就直接break了，但若该数是一个质数呢？那就会把该数从头到尾都遍历一遍，假若数据很大时，这是非常消耗时间的，我们就可以利用因子成对的性质，遍历到根号n，为什么是根号n，举个例子，25，一对因子对是5 5，5相当于一个分界线，其他的因子一定一个大一个小，这样就优化了这个算法，时间复杂度是On^3/2</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for(int i=2;i*i&lt;=n;i++)&#123; //注意这里判断条件是&lt;=</span><br><span class="line">    if(n%i==0)&#123;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h1 id="素筛"><a href="#素筛" class="headerlink" title="素筛"></a>素筛</h1><p>注意：素筛必须从1开始筛，实质上是一个打表</p>
</blockquote>
<ul>
<li><h2 id="埃式筛"><a href="#埃式筛" class="headerlink" title="埃式筛"></a>埃式筛</h2>学习素筛之前我们要知道一个任意一个合数都可以转换成为一个质数和某个数的乘积，例如25可以转换成5<em>5，偶数可以转换成2</em>a，这样我们其实可以利用这个性质将一个区间内的所有质数的倍数都标记一下，被标记的数就是合数，剩下的就是质数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int p[1000]; //p数组用来存储质数</span><br><span class="line">void prime()</span><br><span class="line">&#123;</span><br><span class="line">    vis[1]=1; //1不是质数</span><br><span class="line">    for(int i=2;i&lt;=n;i++)&#123; //n是筛选的范围</span><br><span class="line">        if(!vis[i])&#123;</span><br><span class="line">            p[++cnt]=i; //存储质数</span><br><span class="line">            for(int j=2*i;j&lt;=n;j+=i)&#123;  //这里可以有一个优化，j=2*i</span><br><span class="line">                vis[j]=1; //标记质数的倍数</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><h2 id="欧拉筛"><a href="#欧拉筛" class="headerlink" title="欧拉筛"></a>欧拉筛</h2>上面讲的埃式筛有一个非常大的缺陷，就是会重复标记，例如12，我们首先用2的6倍标记了它，之后又用了3的4倍再次标记，这样就造成了时间的浪费，而素筛本身就是因为时间上的优化才出现的，因此这点必须优化，因此出现了欧拉筛，欧拉筛就是为了解决重复标记的问题</li>
</ul>
<p>对于vis[i*p[j]] = 1 的解释： 这里不是用i的倍数来消去合数，而是把 p里面纪录的素数，升序来当做要消去合数的最小素因子。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int vis[maxn],p[maxn/10]; //质数密度不大，除以10可以减少空间浪费</span><br><span class="line">int cnt=0;</span><br><span class="line">void prime()</span><br><span class="line">&#123;</span><br><span class="line">    vis[1]=1;</span><br><span class="line">    for(int i=2;i&lt;=maxn;i++)&#123;</span><br><span class="line">        if(!vis[i]) p[++cnt]=i;</span><br><span class="line">        for(int j=1;j&lt;=cnt&amp;&amp;i&lt;=maxn/p[j];j++)&#123;</span><br><span class="line">            vis[i*p[j]]=1;</span><br><span class="line">            if(i%p[j]==0) break; //核心代码，如果i能整除这个质数则跳出循环</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">对于 i%p[j] == 0 就break的解释 ：当 i是[j]的倍数时，i = kp[j]，如果继续运算 j+1，i * p[j+1] = p[j] * k p[j+1]，这里p[j]是最小的素因子，当i = k * p[j+1]时会重复，所以才跳出循环。</span><br><span class="line">举个例子 ：i = 8 ，j = 1，p[j] = 2，如果不跳出循环，p[j+1] = 3，8 * 3 = 2 * 4 * 3 = 2 * 12，在i = 12时会计算。因为欧拉筛法的原理便是通过最小素因子来消除。</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>简单三维DFS搜索</title>
    <url>/posts/bfeaea3b.html</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2102">problem link</a><br>可怜的公主在一次次被魔王掳走一次次被骑士们救回来之后，而今，不幸的她再一次面临生命的考验。魔王已经发出消息说将在T时刻吃掉公主，因为他听信谣言说吃公主的肉也能长生不老。年迈的国王正是心急如焚，告招天下勇士来拯救公主。不过公主早已习以为常，她深信智勇的骑士LJ肯定能将她救出。<br>现据密探所报，公主被关在一个两层的迷宫里，迷宫的入口是S（0，0，0），公主的位置用P表示，时空传输机用#表示，墙用<em>表示，平地用.表示。骑士们一进入时空传输机就会被转到另一层的相对位置，但如果被转到的位置是墙的话，那骑士们就会被撞死。骑士们在一层中只能前后左右移动，每移动一格花1时刻。层间的移动只能通过时空传输机，且不需要任何时间。<br><code>Input</code><br>输入的第一行C表示共有C个测试数据，每个测试数据的前一行有三个整数N，M，T。 N，M迷宫的大小NM（1 &lt;= N,M &lt;=10)。T如上所意。接下去的前NM表示迷宫的第一层的布置情况，后NM表示迷宫第二层的布置情况。<br><code>Output</code><br>如果骑士们能够在T时刻能找到公主就输出“YES”，否则输出“NO”。<br><code>Sample Input</code><br>1<br>5 5 14<br>S#</em>.<br>.#…<br>…<br><em>**</em>.<br>…#.   </p>
<p>….P   </p>
<h1 id="…"><a href="#…" class="headerlink" title=".…"></a>.…</h1><p><em>*…<br>….   
</em>.#…<br><code>Sample Output</code><br>YES</p>
<p>解题思路：类似于三维空间，但完全可以用二维数组做，标记一下在哪一层就可以了。注意两层同一位置都是传输机的情况，可能会造成无限循环。</p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int ex,ey,ez;</span><br><span class="line">int n,m,t,flag,T;</span><br><span class="line">int d[4][2]=&#123;1,0,-1,0,0,-1,0,1&#125;;</span><br><span class="line">int vis[15][15][15];</span><br><span class="line">char a[15][15][15];</span><br><span class="line">void dfs(int x,int y,int z,int step)&#123;</span><br><span class="line">	if(flag) return ;</span><br><span class="line">	if(x==ex&amp;&amp;y==ey&amp;&amp;z==ez)&#123;</span><br><span class="line">		if(step&lt;=T)&#123;</span><br><span class="line">			flag=1;</span><br><span class="line">		&#125;</span><br><span class="line">		return ;</span><br><span class="line">	&#125;</span><br><span class="line">	if(step&gt;=T) return ;</span><br><span class="line">	for(int i=0;i&lt;4;i++)&#123;</span><br><span class="line">		int dx=x+d[i][0];</span><br><span class="line">		int dy=y+d[i][1];</span><br><span class="line">		int dz=z;</span><br><span class="line">		if(dx&gt;=0&amp;&amp;dx&lt;n&amp;&amp;dy&gt;=0&amp;&amp;dy&lt;m&amp;&amp;!vis[dz][dx][dy]&amp;&amp;a[dz][dx][dy]!=&#x27;*&#x27;)&#123;</span><br><span class="line">			vis[dz][dx][dy]=1;</span><br><span class="line">			if(a[dz][dx][dy]==&#x27;#&#x27;)&#123;</span><br><span class="line">				vis[abs(dz-1)][dx][dy]=1;</span><br><span class="line">				dfs(dx,dy,abs(dz-1),step+1);</span><br><span class="line">				vis[abs(dz-1)][dx][dy]=0;</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				dfs(dx,dy,dz,step+1);</span><br><span class="line">			&#125;</span><br><span class="line">			vis[dz][dx][dy]=0;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int t;</span><br><span class="line">	cin&gt;&gt;t;</span><br><span class="line">	while(t--)&#123;</span><br><span class="line">		memset(vis,0,sizeof(vis));</span><br><span class="line">		flag=0;</span><br><span class="line">		cin&gt;&gt;n&gt;&gt;m&gt;&gt;T;</span><br><span class="line">		for(int i=0;i&lt;2;i++)&#123;</span><br><span class="line">			for(int j=0;j&lt;n;j++)&#123;</span><br><span class="line">				for(int k=0;k&lt;m;k++)&#123;</span><br><span class="line">					cin&gt;&gt;a[i][j][k];</span><br><span class="line">					if(a[i][j][k]==&#x27;P&#x27;)&#123;</span><br><span class="line">						ex=j,ey=k,ez=i;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">			for(int j=0;j&lt;m;j++)&#123;</span><br><span class="line">				if(a[0][i][j]==&#x27;#&#x27;&amp;&amp;a[1][i][j]==&#x27;#&#x27;)&#123;//两边都是#的情况 ，会造成无限循环 </span><br><span class="line">					vis[0][i][j]=vis[1][i][j]=1;</span><br><span class="line">				&#125;</span><br><span class="line">				if(a[0][i][j]==&#x27;*&#x27;&amp;&amp;a[1][i][j]==&#x27;#&#x27;)&#123;</span><br><span class="line">					vis[0][i][j]=vis[1][i][j]=1;</span><br><span class="line">				&#125;</span><br><span class="line">				if(a[0][i][j]==&#x27;#&#x27;&amp;&amp;a[1][i][j]==&#x27;*&#x27;)&#123;</span><br><span class="line">					vis[0][i][j]=vis[1][i][j]=1;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		dfs(0,0,0,0);</span><br><span class="line">		if(flag) cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;</span><br><span class="line">		else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>十字链表存储稀疏矩阵</title>
    <url>/posts/f0a66312.html</url>
    <content><![CDATA[<blockquote>
<p>课程设计</p>
<p><strong>问题描述:</strong>    用十字链表存储稀疏矩阵，实现两个可进行矩阵之间的乘法运算。 </p>
<p><strong>基本要求:</strong> （1）要对两个矩阵能否进行乘法进行判断。（2）对能够进行乘法运算的稀疏矩阵进行乘法运算并输出正确的结果。</p>
</blockquote>
<p><a href="https://blog.csdn.net/zhuyi2654715/article/details/6729783"><strong>参考博客</strong></a></p>
<h2 id="大致思路"><a href="#大致思路" class="headerlink" title="大致思路"></a>大致思路</h2><p>一般矩阵中会有很多值为0的元素，十字链表把这些值给忽略掉了，只存有值不为0的元素，每一行都是一个链表，每一列也是一个链表，用一个行指针、一个列指针指向它们，形成矩阵形式</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">OLNode</span>&#123;</span>  <span class="comment">//元素类型</span></span><br><span class="line">	<span class="type">int</span> row,col;  <span class="comment">//行列</span></span><br><span class="line">	ElemType val;  <span class="comment">//数值</span></span><br><span class="line">	OLNode *right,*down;  <span class="comment">//行指针、列指针</span></span><br><span class="line">&#125;*OLink; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CrossList</span>&#123;</span>  <span class="comment">//矩阵结构</span></span><br><span class="line">	<span class="type">int</span> n,m,num;</span><br><span class="line">	OLink *Rhead,*Chead;  <span class="comment">//指向行链表、列链表的指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="初始化指针"><a href="#初始化指针" class="headerlink" title="初始化指针"></a>初始化指针</h2><p>每次都要先把矩阵指针置为空</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitCrossList</span><span class="params">(CrossList &amp;CL)</span>&#123;</span><br><span class="line">	CL.n=CL.m=CL.num=<span class="number">0</span>;</span><br><span class="line">	CL.Rhead=CL.Chead=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="销毁链表"><a href="#销毁链表" class="headerlink" title="销毁链表"></a>销毁链表</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DestroyCrossList</span><span class="params">(CrossList CL)</span>&#123;</span><br><span class="line">	<span class="type">int</span> n=CL.n,m=CL.m;</span><br><span class="line">	OLink temp;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		OLink p=CL.Rhead[i];</span><br><span class="line">		<span class="keyword">while</span>(p)&#123;</span><br><span class="line">			temp=p;</span><br><span class="line">			delete temp;</span><br><span class="line">			p=p-&gt;right;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	delete CL.Rhead;</span><br><span class="line">	delete CL.Chead;</span><br><span class="line">	CL.Rhead=<span class="literal">NULL</span>;</span><br><span class="line">	CL.Chead=<span class="literal">NULL</span>;</span><br><span class="line">	CL.n=CL.m=CL.num=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建链表"><a href="#创建链表" class="headerlink" title="创建链表"></a>创建链表</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CreateCrossList</span><span class="params">(CrossList &amp;CL)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(CL.Rhead) DestroyCrossList(CL);  <span class="comment">//矩阵不为空先销毁</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入十字链表的行数、列数、非零元个数(空格隔开):\n&quot;</span>;</span><br><span class="line">	<span class="type">int</span> n,m,num;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;num)&#123;  </span><br><span class="line">		<span class="keyword">if</span>(n&gt;=<span class="number">1</span> &amp;&amp; m&gt;=<span class="number">1</span> &amp;&amp; num&gt;=<span class="number">1</span> &amp;&amp; num&lt;=n*m) <span class="keyword">break</span>;  <span class="comment">//行数列数不能小于1，非零元个数不能大于矩阵最大容纳量</span></span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;输入有误，请重新输入:\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	CL.n=n; CL.m=m; CL.num=num;  <span class="comment">//矩阵行数，列数，非零元个数</span></span><br><span class="line">	CL.Rhead=new OLink[m+<span class="number">1</span>];  <span class="comment">//给每一行分配链表</span></span><br><span class="line">	<span class="keyword">if</span>(!CL.Rhead)&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;内存不足\n&quot;</span>;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	CL.Chead=new OLink[n+<span class="number">1</span>];  <span class="comment">//给每一列分配链表</span></span><br><span class="line">	<span class="keyword">if</span>(!CL.Chead) &#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;内存不足\n&quot;</span>;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) CL.Rhead[i]=<span class="literal">NULL</span>;  <span class="comment">//初始化为空</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) CL.Chead[i]=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">		<span class="type">int</span> row,col,val;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入第&quot;</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot;个非零元的横坐标、纵坐标、不为0的值(空格隔开):\n&quot;</span>;</span><br><span class="line">		<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;row&gt;&gt;col&gt;&gt;val)&#123;</span><br><span class="line">			<span class="keyword">if</span>(row&gt;=<span class="number">1</span> &amp;&amp; row&lt;=n &amp;&amp; col&gt;=<span class="number">1</span> &amp;&amp; col&lt;=m &amp;&amp; val) <span class="keyword">break</span>;  <span class="comment">//坐标不能超出矩阵，值不能为0</span></span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;输入有误，请重新输入:\n&quot;</span>;</span><br><span class="line">		&#125; </span><br><span class="line">		OLink p=new OLNode;</span><br><span class="line">		<span class="keyword">if</span>(!p)&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;内存不足\n&quot;</span>;</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		p-&gt;row=row; p-&gt;col=col; p-&gt;val=val;</span><br><span class="line">		<span class="keyword">if</span>(CL.Rhead[row]==<span class="literal">NULL</span> || CL.Rhead[row]-&gt;col&gt;col)&#123;</span><br><span class="line">			p-&gt;right=CL.Rhead[row];</span><br><span class="line">			CL.Rhead[row]=p;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			OLink j;</span><br><span class="line">			<span class="keyword">for</span>(j=CL.Rhead[row];j-&gt;right &amp;&amp; j-&gt;right-&gt;col&lt;=col;j=j-&gt;right);  <span class="comment">//找到插入位置</span></span><br><span class="line">			<span class="keyword">if</span>(j-&gt;col==col)&#123;  <span class="comment">//当当前坐标有值时覆盖它</span></span><br><span class="line">				j-&gt;val=val;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			p-&gt;right=j-&gt;right;</span><br><span class="line">			j-&gt;right=p;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(CL.Chead[col]==<span class="literal">NULL</span> || CL.Chead[col]-&gt;row&gt;row)&#123;</span><br><span class="line">			p-&gt;down=CL.Chead[col];</span><br><span class="line">			CL.Chead[col]=p;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			OLink j;</span><br><span class="line">			<span class="keyword">for</span>(j=CL.Chead[col];j-&gt;down &amp;&amp; j-&gt;down-&gt;row&lt;row;j=j-&gt;down);  <span class="comment">//找到插入位置</span></span><br><span class="line">			p-&gt;down=j-&gt;down;</span><br><span class="line">			j-&gt;down=p;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="打印链表"><a href="#打印链表" class="headerlink" title="打印链表"></a>打印链表</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PrintCrossList</span><span class="params">(CrossList CL)</span>&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;------------------------\n&quot;</span>;</span><br><span class="line">	<span class="type">int</span> n=CL.n,m=CL.m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;第&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;行元素:  &quot;</span>;</span><br><span class="line">		OLink p=CL.Rhead[i];</span><br><span class="line">		<span class="keyword">if</span>(p)&#123;</span><br><span class="line">			<span class="keyword">while</span>(p)&#123;</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;p-&gt;val&lt;&lt;<span class="string">&quot;(&quot;</span>&lt;&lt;p-&gt;row&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;p-&gt;col&lt;&lt;<span class="string">&quot;)&quot;</span>&lt;&lt;<span class="string">&quot;  &quot;</span>;</span><br><span class="line">				p=p-&gt;right;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;空&quot;</span>;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;第&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;列元素:  &quot;</span>;</span><br><span class="line">		OLink p=CL.Chead[i];</span><br><span class="line">		<span class="keyword">if</span>(p)&#123;</span><br><span class="line">			<span class="keyword">while</span>(p)&#123;</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;p-&gt;val&lt;&lt;<span class="string">&quot;(&quot;</span>&lt;&lt;p-&gt;row&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;p-&gt;col&lt;&lt;<span class="string">&quot;)&quot;</span>&lt;&lt;<span class="string">&quot;  &quot;</span>;</span><br><span class="line">				p=p-&gt;down;</span><br><span class="line">			&#125;	</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;空&quot;</span>;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;------------------------\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="矩阵相乘"><a href="#矩阵相乘" class="headerlink" title="矩阵相乘"></a>矩阵相乘</h2><p>这里用一个二维数组去存了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">multiCrossList</span><span class="params">(CrossList CL1,CrossList CL2)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(CL1.m!=CL2.n)&#123;</span><br><span class="line">    	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;矩阵无法相乘\n&quot;</span>;</span><br><span class="line">    	<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=CL1.n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=CL2.m;j++)&#123;</span><br><span class="line">			<span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">			OLink p=CL1.Rhead[i];</span><br><span class="line">			<span class="keyword">while</span>(p)&#123;</span><br><span class="line">				OLink q=CL2.Chead[j];</span><br><span class="line">				<span class="keyword">while</span>(q &amp;&amp; q-&gt;row&lt;p-&gt;col)&#123;</span><br><span class="line">					q=q-&gt;down;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span>(q &amp;&amp; q-&gt;row==p-&gt;col)&#123;</span><br><span class="line">					<span class="built_in">cout</span>&lt;&lt;p-&gt;val&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;q-&gt;val&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">					num+=p-&gt;val*q-&gt;val;</span><br><span class="line">				&#125;</span><br><span class="line">				p=p-&gt;right;</span><br><span class="line">			&#125; </span><br><span class="line">			mat[i][j]=num;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	CrossList CL1,CL2;</span><br><span class="line">	InitCrossList(CL1);</span><br><span class="line">	InitCrossList(CL2);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;创建矩阵1:\n&quot;</span>;</span><br><span class="line">	CreateCrossList(CL1); </span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;创建矩阵2:\n&quot;</span>;</span><br><span class="line">	CreateCrossList(CL2);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\n创建矩阵1如下:\n&quot;</span>;</span><br><span class="line">	PrintCrossList(CL1);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\n创建矩阵2如下:\n&quot;</span>;</span><br><span class="line">	PrintCrossList(CL2);</span><br><span class="line">	multiCrossList(CL1,CL2);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\n相乘后矩阵:\n&quot;</span>;</span><br><span class="line">	PrintResult();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试数据"><a href="#测试数据" class="headerlink" title="测试数据"></a>测试数据</h2><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">2 2 2</span><br><span class="line">1 1 1</span><br><span class="line">2 2 2</span><br><span class="line">2 3 5</span><br><span class="line">1 1 1</span><br><span class="line">1 2 2</span><br><span class="line">1 3 1</span><br><span class="line">2 1 3</span><br><span class="line">2 3 -1</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">2</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">1</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">0</td>
<td style="text-align:center">-1</td>
</tr>
</tbody>
</table>
</div>
<p>结果</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">1</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数独</title>
    <url>/posts/def1d7a0.html</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>题目描述</p>
<p>数独是根据9×9盘面上的已知数字，推理出所有剩余空格的数字，并满足每一行、每一列、每一个粗线宫内的数字均含1-9，不重复。每一道合格的数独谜题都有且仅有唯一答案，推理方法也以此为基础，任何无解或多解的题目都是不合格的。</p>
<p>芬兰一位数学家号称设计出全球最难的“数独游戏”，并刊登在报纸上，让大家去挑战。</p>
<p>这位数学家说，他相信只有“智慧最顶尖”的人才有可能破解这个“数独之谜”。</p>
<p>据介绍，目前数独游戏的难度的等级有一道五级，一是入门等级，五则比较难。不过这位数学家说，他所设计的数独游戏难度等级是十一，可以说是所以数独游戏中，难度最高的等级他还表示，他目前还没遇到解不出来的数独游戏，因此他认为“最具挑战性”的数独游戏并没有出现。<br>输入格式</p>
<p>一个未填的数独</p>
<p>输出格式</p>
<p>填好的数独</p>
<p>输入输出样例</p>
<p>输入 #1</p>
<p>8 0 0 0 0 0 0 0 0 </p>
<p>0 0 3 6 0 0 0 0 0 </p>
<p>0 7 0 0 9 0 2 0 0 </p>
<p>0 5 0 0 0 7 0 0 0 </p>
<p>0 0 0 0 4 5 7 0 0 </p>
<p>0 0 0 1 0 0 0 3 0 </p>
<p>0 0 1 0 0 0 0 6 8 </p>
<p>0 0 8 5 0 0 0 1 0 </p>
<p>0 9 0 0 0 0 4 0 0</p>
<p>输出 #1</p>
<p>8 1 2 7 5 3 6 4 9 </p>
<p>9 4 3 6 8 2 1 7 5 </p>
<p>6 7 5 4 9 1 2 8 3 </p>
<p>1 5 4 2 3 7 8 9 6 </p>
<p>3 6 9 8 4 5 7 2 1 </p>
<p>2 8 7 1 6 9 5 3 4 </p>
<p>5 2 1 9 7 4 3 6 8 </p>
<p>4 3 8 5 2 6 9 1 7 </p>
<p>7 9 6 3 1 8 4 5 2</p>
<h2 id="Code："><a href="#Code：" class="headerlink" title="Code："></a>Code：</h2><pre><code>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cstdlib&gt;
#include&lt;iostream&gt;
using namespace std;
int map[10][10];
bool row[10][10],col[10][10],g[10][10];//行，列，第几个格子
void print()
&#123;
    for(int i=1;i&lt;=9;i++)
    &#123;
        for(int j=1;j&lt;=9;j++)
            printf(&quot;%d &quot;,map[i][j]);
        printf(&quot;\n&quot;);
    &#125;
    exit(0);
&#125;
void dfs(int x,int y)//深搜 
&#123;
  if(map[x][y]!=0)//9*9中不为零的数直接跳过 
  &#123;
      if(x==9&amp;&amp;y==9) 
          print();//搜索结束后输出 
      if(y==9) //行到顶端后搜索列 
          dfs(x+1,1); 
      else //搜索行 
          dfs(x,y+1);
  &#125;
  if(map[x][y]==0)//等于零时 
  &#123;
      for(int i=1;i&lt;=9;i++)
      &#123; 
          if(!row[x][i]&amp;&amp;!col[y][i]&amp;&amp;!g[(x-1)/3*3+(y-1)/3+1][i])
          &#123;
              map[x][y]=i;
              row[x][i]=1;
              col[y][i]=1;
              g[(x-1)/3*3+(y-1)/3+1][i]=1;
              if(x==9&amp;&amp;y==9)                 
                  print();
              if(y==9) dfs(x+1,1); else dfs(x,y+1);
              map[x][y]=0;
              row[x][i]=0;
              col[y][i]=0;
              g[(x-1)/3*3+(y-1)/3+1][i]=0;
          &#125;
      &#125; 
  &#125;
&#125;
int main()
&#123;
    for(int i=1;i&lt;=9;i++)
    &#123;
        for(int j=1;j&lt;=9;j++)
        &#123;
            scanf(&quot;%d&quot;,&amp;map[i][j]);
            if(map[i][j]&gt;0)
            &#123;
                row[i][map[i][j]]=1;
                col[j][map[i][j]]=1; 
                g[(i-1)/3*3+(j-1)/3+1][map[i][j]]=1;
            &#125;
        &#125;
    &#125; 
    dfs(1,1);
    return 0;
&#125;
</code></pre><h2 id="教训"><a href="#教训" class="headerlink" title="教训"></a>教训</h2><p>一定明白一个概念递归不是之后的代码就不执行了，在dfs函数中调用dfs之后后面的代码还是会执行的！dfs输出一定要写在出口那里，不能写在main函数中，注意3*3的格子中也要符合1到9唯一性</p>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>水果</title>
    <url>/posts/481c5c0c.html</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><font color="red" size=4>

F - 水果

夏天来了~好开心啊,呵呵,好多好多水果~
Joe经营着一个不大的水果店.他认为生存之道就是经营最受顾客欢迎的水果.现在他想要一份水果销售情况的明细表,这样Joe就可以很容易掌握所有水果的销售情况了.

Input

第一行正整数N(0<N<=10)表示有N组测试数据.
每组测试数据的第一行是一个整数M(0<M<=100),表示工有M次成功的交易.其后有M行数据,每行表示一次交易,由水果名称(小写字母组成,长度不超过80),水果产地(小写字母组成,长度不超过80)和交易的水果数目(正整数,不超过100)组成.

Output

对于每一组测试数据,请你输出一份排版格式正确(请分析样本输出)的水果销售情况明细表.  这份明细表包括所有水果的产地,名称和销售数目的信息.水果先按产地分类,产地按字母顺序排列;同一产地的水果按照名称排序,名称按字母顺序排序.   
两组测试数据之间有一个空行.最后一组测试数据之后没有空行.

Sample Input

1  
5  
apple shandong 3  
pineapple guangdong 1  
sugarcane guangdong 1  
pineapple guangdong 3  
pineapple guangdong 1  

Sample Output

guangdong  
   |----pineapple(5)  
   |----sugarcane(1)  
shandong  
   |----apple(3)  
</font>

<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>map&lt;（1）,（2）&gt;，1，2不只可以是基础数据类型，还是可以自定义类型，经常用自己定义的结构体，在结构体里面还可以再定义一个map，类似循环嵌套一样，map里面是有序排列的，这样的话就是最外面的map排列优先级最高，里面也是这样，这样就可以实现排列的优先级问题，而且map有一个特点就是它的键值是唯一的，天然去重，这道题正好可能会出现同名的水果，用一般数组写的话里面的数据关系很复杂，而用map比较清晰<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxn=2e5+100;</span><br><span class="line">struct node&#123;</span><br><span class="line">	map&lt;string,int&gt; mp;  //名字（优先级低），数量</span><br><span class="line">&#125;f[110];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	map&lt;string,node&gt; mm; //地点（优先级高），第二个是一个自定义结构体，实际上是一个小map</span><br><span class="line">	map&lt;string,int&gt;::iterator mpit;</span><br><span class="line">	map&lt;string,node&gt;::iterator mmit;</span><br><span class="line">	int t; cin&gt;&gt;t;</span><br><span class="line">	while(t--)&#123;</span><br><span class="line">		mm.clear();</span><br><span class="line">		int n; cin&gt;&gt;n;</span><br><span class="line">		for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">			string name,place;</span><br><span class="line">			int cnt;</span><br><span class="line">			cin&gt;&gt;name&gt;&gt;place&gt;&gt;cnt;</span><br><span class="line">			mm[place].mp[name]+=cnt;  //这里map实现了去重操作省去了很多麻烦，直接累加就行了</span><br><span class="line">		&#125;</span><br><span class="line">		for(mmit=mm.begin();mmit!=mm.end();mmit++)&#123;</span><br><span class="line">			cout&lt;&lt;mmit-&gt;first&lt;&lt;endl;</span><br><span class="line">			for(mpit=mmit-&gt;second.mp.begin();mpit!=mmit-&gt;second.mp.end();mpit++)&#123;</span><br><span class="line">				cout&lt;&lt;&quot;   |----&quot;&lt;&lt;mpit-&gt;first&lt;&lt;&quot;(&quot;&lt;&lt;mpit-&gt;second&lt;&lt;&quot;)&quot;&lt;&lt;endl;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if(t!=0) cout&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>数论的一些基本定理</title>
    <url>/posts/5f67ec8b.html</url>
    <content><![CDATA[<h2 id="欧几里得定理"><a href="#欧几里得定理" class="headerlink" title="欧几里得定理"></a>欧几里得定理</h2><p>其实就是求gcd的辗转相除法，gcd(a,b)==gcd(a-b,b)，由此可以把a中的b全部拿掉，gcd(a,b)==gcd(a%b,b)， ~a是大于b的~<br>gcd(a,b)==gcd(b,a%b)</p>
<h2 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h2><p><a href="https://blog.csdn.net/qq_37493070/article/details/81988725">具体证明点击我</a><br>X(N)==N <em> (1/p1) </em> (1/p2) <em> (1/p3) </em>… *(1/pn)(pi为N的质因子)   </p>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ol>
<li><p><strong>对于任意一个质数 p ,φ(n)=n−1</strong></p>
<font color="red">因为n为质数,与他互质的个数就是 n-1</font>
</li>
<li><p><strong>当 gcd(n,m)=1时,φ(nm)=φ(n)φ(m)</strong></p>
<font color="red">因为φ(n)是积性函数。 积性函数指对于所有互质的整数a和b有性质f(ab)=f(a)f(b)的数论函数。</font>
</li>
<li><p><strong>若 n=p^k^ 其中p为质数,则φ(n)=p^k^−p^k−1^=(p−1)p^k−1^</strong></p>
<font color="red">1→n中除了p的倍数，都与p^k^互质,1→n中p倍数的个数为 p^k^÷p=p^k−1^</font>
</li>
<li><p><strong>所有小于n与n互质个数的和sum=n × φ(n)/2</strong></p>
<p><a href="https://www.cnblogs.com/justPassBy/p/4489351.html">推导点击我</a></p>
</li>
<li><p><strong>如果 i mod p=0,其中p为质数,则 φ(i ∗ p)=p ∗ φ(i),否则φ(i ∗ p)=(p−1)φ(i)</strong></p>
</li>
<li><p><strong>n=∑d|nφ(d) (d|n)指n是d的倍数</strong></p>
</li>
<li><p><strong>当 N &gt; 2 时，φ( N )是偶数</strong></p>
<h2 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h2></li>
</ol>
<p><strong>对于互质的整数a,m,有 a^φ(m)^≡1 (mod m)。</strong></p>
<h2 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h2><p><strong>费马小定理(Fermat’s little theorem)是数论中的一个重要定理，在1636年提出。如果p是一个质数，而整数a不是p的倍数，则有a^（p-1）≡1（mod p）</strong></p>
<p>主要应用于求高阶次幂对某个数求余数，<a href="https://baike.baidu.com/item/%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86/4776158?fr=aladdin">点击我</a></p>
<h2 id="逆元"><a href="#逆元" class="headerlink" title="逆元"></a>逆元</h2><p><strong>a^(m-1)^=1(mod m), a * a^(m-2)^=1(mod m)，所以a的逆元是：a^(m-2)^ ,当m与a互质时。</strong></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>数论题目集(协会)</title>
    <url>/posts/816bcb91.html</url>
    <content><![CDATA[<blockquote>
<p>以下题目涉及知识有 欧拉函数、素数筛、算数基本定理（唯一分解定理）</p>
<p>因为数论之前没咋学，欧拉函数还是这两天补的，又要考试，时间不够，所以大多数都是直接搜题解做的，本来信誓旦旦好好写一些题解巩固一下的，发现越写越累，索性直接搬来别人的优质题解算了🤔</p>
</blockquote>
<font color="red">一定记得素数筛时isp数组要用bool，bool只占用一个字节，int4个会爆内存，卡死我了，我说咋一直爆内存</font>

<h2 id="Bi-shoe-and-Phi-shoe"><a href="#Bi-shoe-and-Phi-shoe" class="headerlink" title="Bi-shoe and Phi-shoe"></a>Bi-shoe and Phi-shoe</h2><p><strong>题意</strong>：<br>给定N个数，让你求欧拉函数值大于等于这N个数的的那个数的最小数值之和（这里1的欧拉函数值很特殊，设置为0，因为小于1且与1互质的数量为0）<br>例如：<br>N==2<br>1 2<br>则答案为4 == 1+3<br><strong>思路</strong><br>要求的是欧拉函数值大于等于给定数的最小数，那么我们就要让这个数对应的欧拉函数值尽可能大一点，什么情况下一个数的欧拉函数值最大呢？很明显是素数时！一个素数的欧拉函数值就等于这个数减一，从这里我们就能推出来最小的那个对应欧拉函数值~大于等于~给定数的那个数最小就是这个给定数后面的那个素数，例如： 10对应的就是11 ，12对应13 ，14对应17，11，13，17就是所要求的最小的三个数，由此思路就明确了<br><strong>思路2</strong><br>还可以用筛法求1~N的欧拉函数，然后打表每个欧拉函数值的最优解，再取和最小</p>
<h3 id="CODE-1"><a href="#CODE-1" class="headerlink" title="CODE-1"></a>CODE-1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span><br><span class="line">#define debug freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin); freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout)</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int MAXN = 1e7+10;</span><br><span class="line">const int MOD = 1e9;</span><br><span class="line">int pr[MAXN/10], tail = 0; </span><br><span class="line">bool isp[MAXN];</span><br><span class="line">void prime() &#123;  //一个素数筛</span><br><span class="line">    isp[1] = 1;</span><br><span class="line">    for (int i = 2; i &lt; MAXN; i++) &#123;</span><br><span class="line">        if (!isp[i]) pr[++tail] = i;</span><br><span class="line">        for (int j = 1; i &lt;= MAXN/pr[j]; j++) &#123;</span><br><span class="line">            isp[i * pr[j]] = 1;</span><br><span class="line">            if (i % pr[j] == 0) break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	prime();</span><br><span class="line">  int t,kase=0; cin&gt;&gt;t;</span><br><span class="line">  while(t--)&#123;</span><br><span class="line">    int n; cin&gt;&gt;n;</span><br><span class="line">    ll sum=0;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">      int x; cin&gt;&gt;x;</span><br><span class="line">      for(int j=x+1; ;j++)&#123; //找到给定数字后面的那个素数累加到sum里面</span><br><span class="line">        if(!isp[j])&#123;</span><br><span class="line">          sum+=j;</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;&quot;Case &quot;&lt;&lt;++kase&lt;&lt;&quot;: &quot;&lt;&lt;sum&lt;&lt;&quot; Xukha&quot;&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CODE-2"><a href="#CODE-2" class="headerlink" title="CODE-2"></a>CODE-2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int MAXN = 1e6+100;</span><br><span class="line">const int MOD = 1e9;</span><br><span class="line">int pr[MAXN/10],tail;</span><br><span class="line">int phi[MAXN],ans[MAXN];</span><br><span class="line">bool isp[MAXN]; </span><br><span class="line">void euler()</span><br><span class="line">&#123;</span><br><span class="line">	phi[1]=0;</span><br><span class="line">	for(int i=2;i&lt;MAXN;i++)&#123;</span><br><span class="line">		if(!isp[i])&#123;</span><br><span class="line">			pr[++tail]=i;</span><br><span class="line">			phi[i]=i-1;</span><br><span class="line">		&#125;</span><br><span class="line">		for(int j=1;j&lt;=tail&amp;&amp;i*pr[j]&lt;MAXN;j++)&#123;</span><br><span class="line">			isp[i*pr[j]]=1;</span><br><span class="line">			if(i%pr[j]==0)&#123;</span><br><span class="line">				phi[i*pr[j]]=phi[i]*pr[j];</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			else phi[i*pr[j]]=phi[i]*phi[pr[j]];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	int cur=0;</span><br><span class="line">	for(int i=2;i&lt;MAXN;i++)&#123;  //核心代码，这里一定要保证ans是递增的，因为要往后走找更大的欧拉函数值</span><br><span class="line">		if(phi[i]&gt;cur&amp;&amp;ans[phi[i]]==0)&#123; //ans下标代表欧拉函数值，储存的是该欧拉函数值对应的数字，ans[]==0起到防止相同欧拉函数值的两个数后面那个数把前面的覆盖了</span><br><span class="line">			ans[phi[i]]=i;</span><br><span class="line">			cur=phi[i]; //记得更新cur 因为要求最小的那个数字</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	ios; ll n;</span><br><span class="line">	euler();</span><br><span class="line">	int t,kase=0;</span><br><span class="line">	cin&gt;&gt;t;</span><br><span class="line">	while(t--)&#123;</span><br><span class="line">		ll sum=0;</span><br><span class="line">		int n; cin&gt;&gt;n;</span><br><span class="line">		for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">			int x; cin&gt;&gt;x;</span><br><span class="line">			for(int j=x; ;j++)&#123;</span><br><span class="line">				if(ans[j]&gt;0)&#123;</span><br><span class="line">					sum+=ans[j];</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;	</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;&quot;Case &quot;&lt;&lt;++kase&lt;&lt;&quot;: &quot;&lt;&lt;sum&lt;&lt;&quot; Xukha&quot;&lt;&lt;&#x27;\n&#x27;;</span><br><span class="line">	&#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Aladdin-and-the-Flying-Carpet"><a href="#Aladdin-and-the-Flying-Carpet" class="headerlink" title="Aladdin and the Flying Carpet"></a>Aladdin and the Flying Carpet</h2><p><strong>题意</strong><br>给出矩形面积S，和组成该矩形的边的最小值，问这种面积为S的矩形有几种<br>比如样例12 2，矩形面积为12，组成这样矩形的最小边为2，共有2种这样的矩形（2， 6），（3， 4）(这些边都大于或等于2，其中（2,6）和（6,2）是同一种)<br><strong>思路</strong><br>这道题用到了唯一分解定理：N = p1^a1^  p2^a2^ <em> p3^a3^ </em> … <em>pn^an^(其中p1、p2、… pn为N的因子，a1、a2、… 、an分别为因子的指数)<br>N的因子个数公式：     M = (1 + a1)</em> (1 + a2)<em> (1 + a3)</em> …<em>(1 + an);<br>用唯一分解定理求出ab的因子个数，但题要求的是满足条件的因子对数，所以最终所求的因子个数需要除以2，然后再将不满足的减去<br>该题要用到筛选素数来缩短时间（减少循环次数）来防止TLE<br><em>*疑问</em></em><br>两个因子可以一样啊，25 ==5 ，5，那num不是应该=(num+1)/2吗？这道题自动排除了1和数本身的情况？</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int MAXN = 1e6+5;</span><br><span class="line">bool isp[MAXN];</span><br><span class="line">int pr[MAXN/10],tail;</span><br><span class="line">int prime()&#123;</span><br><span class="line">	isp[1]=1;</span><br><span class="line">	for(int i=2;i&lt;MAXN;i++)&#123;</span><br><span class="line">		if(!isp[i]) pr[++tail]=i;</span><br><span class="line">		for(int j=1;j&lt;=tail&amp;&amp;i*pr[j]&lt;MAXN;j++)&#123;</span><br><span class="line">			isp[i*pr[j]]=1;</span><br><span class="line">			if(i%pr[j]==0) break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">ll fun(ll n)&#123; //找出n的因子数量</span><br><span class="line">	ll ans=1;</span><br><span class="line">	for(ll i=1;i&lt;=tail&amp;&amp;pr[i]*pr[i]&lt;=n;i++)&#123;</span><br><span class="line">		if(n%pr[i]==0)&#123;</span><br><span class="line">			ll e=0;</span><br><span class="line">			while(n%pr[i]==0)&#123;</span><br><span class="line">				e++;</span><br><span class="line">				n/=pr[i];</span><br><span class="line">			&#125;</span><br><span class="line">			ans*=(1+e);//算数基本定理的经典问题：求一个数的因子数量</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if(n&gt;1) ans*=2;</span><br><span class="line">	return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	prime();</span><br><span class="line">  int t,kase=0;</span><br><span class="line">  scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">  while(t--)&#123;</span><br><span class="line">    kase++;</span><br><span class="line">    ll s,a;</span><br><span class="line">    scanf(&quot;%lld%lld&quot;,&amp;s,&amp;a);</span><br><span class="line">    if(a*a&gt;s)&#123;</span><br><span class="line">        printf(&quot;Case %d: 0\n&quot;, kase);</span><br><span class="line">        continue;</span><br><span class="line">    &#125;</span><br><span class="line">    ll num=fun(s);</span><br><span class="line">    num/=2; //两个因子为一对，除2</span><br><span class="line">    for(ll i=1;i&lt;a;i++)&#123;</span><br><span class="line">      if(s%i==0) num--;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;Case %d: %lld\n&quot;, kase, num);</span><br><span class="line">	&#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Goldbach-s-Conjecture"><a href="#Goldbach-s-Conjecture" class="headerlink" title="Goldbach`s Conjecture"></a>Goldbach`s Conjecture</h2><p><strong>题意</strong><br>给出几组测试数据，每组给出一个n，问n能被分成几对素数的和。<br><strong>思路</strong><br>少有的水题，素数筛一下，遍历素数，然后每次查看sum-该素数是不是素数是的话答案加一，遍历过半就可以退出了</p>
<h3 id="CODE-1"><a href="#CODE-1" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int MAXN=1e7+20;</span><br><span class="line">bool isp[MAXN];</span><br><span class="line">int pr[700000];</span><br><span class="line">int t,k=0;</span><br><span class="line">void prime()</span><br><span class="line">&#123;</span><br><span class="line">    isp[1]=1;</span><br><span class="line">    for(int i=2;i&lt;=MAXN;i++)&#123;</span><br><span class="line">        if(!isp[i])&#123;</span><br><span class="line">            pr[++k]=i;</span><br><span class="line">            for(int j=i+i;j&lt;=MAXN;j+=i)&#123;</span><br><span class="line">                isp[j]=1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	prime();</span><br><span class="line">    int t,kase=0;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">    	int n,cnt=0;</span><br><span class="line">    	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    	for(int i=1;i&lt;=n/2;i++)&#123;</span><br><span class="line">    		if(pr[i]&gt;=n/2+1) break;</span><br><span class="line">    		if(!isp[n-pr[i]]) cnt++;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;Case %d: &quot;,++kase);</span><br><span class="line">		cout&lt;&lt;cnt&lt;&lt;&#x27;\n&#x27;;</span><br><span class="line">	&#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Pairs-Forming-LCM"><a href="#Pairs-Forming-LCM" class="headerlink" title="Pairs Forming LCM"></a>Pairs Forming LCM</h2><p><strong>题意</strong><br>在1~n中有多少对数满足lcm(a,b)==n<br><strong>思路</strong><br>gcd(a,b)=p1 ^min(a1,b1)^ <em> p2^min(a2,b2)^ </em> ………. <em>pn^min(an,bn)^<br>lcm(a,b)=p1 ^max(a1,b1)^ </em> p2^max(a2,b2)^ <em> ………. </em>pn^max(an,bn)^<br>先对n素因子分解，n = p1^e1^ <em> p2^e2^ </em> ………. <em>pk^ek^，<br>lcm(a,b)=p1 ^max(a1,b1)^ </em> p2^max(a2,b2^ <em> ………. </em>pk^max(ak,bk)^  </p>
<p>所以，当lcm(a,b)==n时，max(a1,b1)==e1,max(a2,b2)==e2,…max(ak,bk)==ek<br>当ai == ei时，bi可取 [0, ei] 中的所有数  有 ei+1 种情况，bi==ei时同理。<br>那么就有2(ei+1)种取法,但是当ai = bi = ei 时有重复，所以取法数为2(ei+1)-1=2<em>ei+1。<br>除了 (n, n) 所有的情况都出现了两次  那么满足a&lt;=b的有 (2</em>ei + 1)) / 2 + 1 个   </p>
<h3 id="CODE-2"><a href="#CODE-2" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span><br><span class="line">#define debug freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin); freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout)</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int MAXN = 1e7+10;</span><br><span class="line">const int MOD = 1e9;</span><br><span class="line">int pr[MAXN/10], tail = 0;</span><br><span class="line">bool isp[MAXN];</span><br><span class="line">void prime() &#123;</span><br><span class="line">    isp[1] = 1;</span><br><span class="line">    for (int i = 2; i &lt;= MAXN; i++) &#123;</span><br><span class="line">        if (!isp[i]) pr[++tail] = i;</span><br><span class="line">        for (int j = 1; j&lt;=tail &amp;&amp;i * pr[j] &lt;= MAXN; j++) &#123;</span><br><span class="line">            isp[i * pr[j]] = 1;</span><br><span class="line">            if (i % pr[j] == 0) break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	prime();</span><br><span class="line">    int t,kase=1;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    for( ;kase&lt;=t;kase++)&#123;</span><br><span class="line">    	ll n; cin&gt;&gt;n;</span><br><span class="line">    	int ans=1;</span><br><span class="line">    	for(int i=1;i&lt;=tail&amp;&amp;pr[i]*pr[i]&lt;=n;i++)&#123;</span><br><span class="line">    		if(n%pr[i]==0)&#123;</span><br><span class="line">    			int e=0;</span><br><span class="line">    			while(n%pr[i]==0)&#123;</span><br><span class="line">    				e++;</span><br><span class="line">    				n/=pr[i];</span><br><span class="line">				&#125;</span><br><span class="line">				ans*=(2*e+1);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if(n&gt;1) ans*=(2*1+1);</span><br><span class="line">		printf(&quot;Case %d: %d\n&quot;,kase,(ans+1)/2);</span><br><span class="line">	&#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Mysterious-Bacteria"><a href="#Mysterious-Bacteria" class="headerlink" title="Mysterious Bacteria"></a>Mysterious Bacteria</h2><p><strong>题意</strong><br>给你一个数x = b^p^,求p的最大值<br><strong>思路</strong><br>p = gcd(x1, x2, x3, … , xs) xi是拆分后的指数<br>比如： 24 = 2^3^<em>3^1^，p应该是gcd(3, 1) = 1,即24 = 24^1^<br>      324 = 3^4^</em>2^2^,p应该是gcd(4, 2) = 2,即324 = 18^2^<br><del>注意：</del>本题有一个坑，就是x可能为负数，如果x为负数的话，x = b^q, q必须使奇数，所以将x转化为正数求得的解如果是偶数的话必须将其一直除2转化为奇数<br><strong>疑问</strong><br>为什么代码标记的地方的那个n不开ll会超时呢？ll转换成负数快？</p>
<h3 id="CODE-3"><a href="#CODE-3" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int MAXN = 1e5+10;</span><br><span class="line">const int MOD = 1e9;</span><br><span class="line">int pr[MAXN/10], tail = 0;</span><br><span class="line">bool isp[MAXN];</span><br><span class="line">void prime() &#123;</span><br><span class="line">    isp[1] = 1;</span><br><span class="line">    for (int i = 2; i &lt; MAXN; i++) &#123;</span><br><span class="line">        if (!isp[i]) pr[++tail] = i;</span><br><span class="line">        for (int j = 1; i &lt;= MAXN/pr[j]; j++) &#123;</span><br><span class="line">            isp[i * pr[j]] = 1;</span><br><span class="line">            if (i % pr[j] == 0) break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int gcd(int a,int b)&#123;</span><br><span class="line">	if(a%b==0) return b;</span><br><span class="line">	else return gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	prime();</span><br><span class="line">    int t,kase=0; cin&gt;&gt;t;</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">    	ll n; cin&gt;&gt;n;  //这里n必须开成ll否则会超时</span><br><span class="line">    	int flag=0,ans=0;</span><br><span class="line">    	if(n&lt;0)&#123;</span><br><span class="line">    		n=-n;  //n如果不开成ll的话这里会卡住</span><br><span class="line">    		flag=1;</span><br><span class="line">		&#125;</span><br><span class="line">    	for(int i=1;i&lt;=tail&amp;&amp;pr[i]*pr[i]&lt;=n;i++)&#123;</span><br><span class="line">    		if(n%pr[i]==0)&#123;</span><br><span class="line">				int e=0;</span><br><span class="line">    			while(n%pr[i]==0)&#123;</span><br><span class="line">    				e++;</span><br><span class="line">    				n/=pr[i];</span><br><span class="line">				&#125;</span><br><span class="line">				if(ans==0) ans=e;</span><br><span class="line">				else ans=gcd(ans,e);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">    	if(n&gt;1) ans=gcd(ans,1);</span><br><span class="line">    	if(flag==1)&#123;</span><br><span class="line">    		while(ans%2==0)&#123;</span><br><span class="line">    			ans/=2;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">    	cout&lt;&lt;&quot;Case &quot;&lt;&lt;++kase&lt;&lt;&quot;: &quot;&lt;&lt;ans&lt;&lt;&#x27;\n&#x27;;</span><br><span class="line">	&#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Large-Division"><a href="#Large-Division" class="headerlink" title="Large Division"></a>Large Division</h2><p><strong>题意</strong><br>给你两个数a，b，让你求出来a是否能够被b整除。<br><strong>思路</strong><br>需要注意的是数字a太大了，所以要用数组来存储，同时还要注意数字b可能超出了int范围，要用long long int，考的其实就是除法的模拟   </p>
<h3 id="CODE-4"><a href="#CODE-4" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int MAXN=1e6+10;</span><br><span class="line">char a[MAXN];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int t,kase=0;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">    	memset(a,0,sizeof a);</span><br><span class="line">    	ll b;</span><br><span class="line">    	scanf(&quot;%s&quot;,a);</span><br><span class="line">    	scanf(&quot;%lld&quot;,&amp;b);</span><br><span class="line">    	if(b&lt;0) b=-b;</span><br><span class="line">    	ll x=0,len=strlen(a);</span><br><span class="line">    	for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">    		if(a[i]==&#x27;-&#x27;) continue;</span><br><span class="line">    		x=(x*10+a[i]-&#x27;0&#x27;)%b;</span><br><span class="line">		&#125;</span><br><span class="line">		if(x==0) printf(&quot;Case %d: divisible\n&quot;,++kase);</span><br><span class="line">    	else printf(&quot;Case %d: not divisible\n&quot;,++kase);</span><br><span class="line">    	</span><br><span class="line">	&#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Help-Hanzo"><a href="#Help-Hanzo" class="headerlink" title="Help Hanzo"></a>Help Hanzo</h2><p><strong>题意</strong><br>求区间a,b内素数的数量<br><strong>思路</strong><br>由于b极大，所以打表会爆内存。但并不意味着放弃打表，我们可以先打一个小点的素数表出来，如果b在这个表内直接二分找一下a,b就可以了。否则利用到b-a&lt;=100000这个性质，可以开一个这么大的桶下标表示为j-a来筛选a-b内的素数，这样就用到我们之前的小素数表来筛选了。</p>
<h3 id="CODE-5"><a href="#CODE-5" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN=1e6+10;</span><br><span class="line">bool vis1[MAXN],vis2[MAXN];</span><br><span class="line">int pr[MAXN],cnt;</span><br><span class="line">int prime()&#123;</span><br><span class="line">	for(int i=2;i&lt;MAXN;i++)&#123;</span><br><span class="line">		if(vis1[i]==0)&#123;</span><br><span class="line">			pr[cnt++]=i;</span><br><span class="line">			vis1[i]=1;</span><br><span class="line">		&#125;</span><br><span class="line">		for(int j=0;j&lt;cnt&amp;&amp;pr[j]*i&lt;MAXN;j++)&#123;</span><br><span class="line">	  		vis1[i*pr[j]]=1;</span><br><span class="line">	  		if(i%pr[j]==0) break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	prime();</span><br><span class="line">  	int t,kase=1;</span><br><span class="line">  	cin&gt;&gt;t;</span><br><span class="line">  	while(t--)&#123;</span><br><span class="line">		ll a,b,ans=0;</span><br><span class="line">		cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">		if(b&lt;=MAXN)&#123;</span><br><span class="line">		    int loab=lower_bound(pr,pr+cnt,b)-pr; </span><br><span class="line">		    if(pr[loab]&gt;b) loab-=1;</span><br><span class="line">		    int loaa=lower_bound(pr,pr+cnt,a)-pr;</span><br><span class="line">		    ans=loab-loaa+1;</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">		    memset(vis2,0,sizeof(vis2));</span><br><span class="line">		    for(int i=0;i&lt;cnt;i++)&#123;</span><br><span class="line">		        ll k=(a%pr[i]==0)?a/pr[i]:a/pr[i]+1;  </span><br><span class="line">		        for(ll j=k*pr[i];j&lt;=b;j+=pr[i]) vis2[j-a]=1;</span><br><span class="line">		    &#125;</span><br><span class="line">		    for(ll i=a;i&lt;=b;i++)&#123;</span><br><span class="line">		        if(!vis2[i-a]) ans++;</span><br><span class="line">		    &#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;&quot;Case &quot;&lt;&lt;kase++&lt;&lt;&quot;: &quot;&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="GCD-Extreme-II"><a href="#GCD-Extreme-II" class="headerlink" title="GCD - Extreme (II)"></a>GCD - Extreme (II)</h2><p><strong>题意</strong><br>求在1-n之间所有任意两个数的的最大公因数的和。<br><strong>题解</strong><br>因为让求的1-n区间里任两个数的最大公因数之和，所以假设gcd(n,m)=z，在这里，因为n和m的范围都是超级大，所以，不能枚举n，m，但是可以枚举m，z，或者n，z。<br>具体思路是：假设gcd(x,y)=1,那么当执行到x，y的时候，最后的和都要加1，那么相应的，执行到2x，2y时，最后的和都要加2，以此类推，执行到kx，ky的时候最后的和都要加k，那么这些一切的根源都归咎于gcd(x,y)=1，所以才有了上面那一句话，枚举n，z（n，m选其一，无所谓的），这里的z就是上面的1，2，。。k。枚举z的问题解决了，那么轮到n了，枚举n，假设一个值为num，那么num代表与n的最大公因数是z（1，2，3，，，，k）的个数，这里的z有好多值，但是任何的z（大于1）都可以有最根本的gcd（x，y）推出，所以算出只需要算出z=1时num的值就可以了，这个时候，就会想到欧拉函数值（小于n的数里与n互质的个数）。然后，这道题算是结束了。</p>
<h3 id="CODE-6"><a href="#CODE-6" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int MAXN = 4e6+10;</span><br><span class="line">const int MOD = 1e9;</span><br><span class="line">int pr[MAXN/10],tail;</span><br><span class="line">ll a[MAXN],phi[MAXN];</span><br><span class="line">bool isp[MAXN]; </span><br><span class="line">void euler()</span><br><span class="line">&#123;</span><br><span class="line">	phi[1]=1;</span><br><span class="line">	for(int i=2;i&lt;MAXN;i++)&#123;</span><br><span class="line">		if(!isp[i])&#123;</span><br><span class="line">			pr[++tail]=i;</span><br><span class="line">			phi[i]=i-1;</span><br><span class="line">		&#125;</span><br><span class="line">		for(int j=1;j&lt;=tail&amp;&amp;i*pr[j]&lt;MAXN;j++)&#123;</span><br><span class="line">			isp[i*pr[j]]=1;</span><br><span class="line">			if(i%pr[j]==0)&#123;</span><br><span class="line">				phi[i*pr[j]]=phi[i]*pr[j];</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			else phi[i*pr[j]]=phi[i]*phi[pr[j]];</span><br><span class="line">		&#125;</span><br><span class="line">		for(int j=1;i*j&lt;MAXN;j++)&#123;</span><br><span class="line">			a[i*j]+=phi[i]*j;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int fun(int n)&#123;</span><br><span class="line">	int ans=n;</span><br><span class="line">	if(n==1) return 1;</span><br><span class="line">	for(int i=2;i*i&lt;=n;i++)&#123;</span><br><span class="line">		if(n%i==0)&#123;</span><br><span class="line">			ans=ans/i*(i-1);</span><br><span class="line">			while(n%i==0) n/=i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if(n&gt;1) ans=ans/n*(n-1);</span><br><span class="line">	return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	ios; ll n;</span><br><span class="line">	euler();</span><br><span class="line">	for(int i=1;i&lt;MAXN;i++)&#123;</span><br><span class="line">		a[i]+=a[i-1];</span><br><span class="line">	&#125;</span><br><span class="line">	while(~scanf(&quot;%lld&quot;,&amp;n)&amp;&amp;n)&#123;</span><br><span class="line">		printf(&quot;%lld\n&quot;,a[n]);</span><br><span class="line">	&#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Farey-Sequence"><a href="#Farey-Sequence" class="headerlink" title="Farey Sequence"></a>Farey Sequence</h2><p><strong>题意</strong><br>给出式子F F中分子分母互质，且分子小于分母<br>例：  </p>
<p>F2 = {1/2}<br>F3 = {1/3, 1/2, 2/3}<br>F4 = {1/4, 1/3, 1/2, 2/3, 3/4}<br>F5 = {1/5, 1/4, 1/3, 2/5, 1/2, 3/5, 2/3, 3/4, 4/5}<br>求解 fn的元素个数<br><strong>题解</strong><br>本题就是求解欧拉函数值的前n项和，模板题，筛一下就行了  </p>
<h3 id="CODE-7"><a href="#CODE-7" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int MAXN = 1e6+100;</span><br><span class="line">const int MOD = 1e9;</span><br><span class="line">int pr[MAXN/10],tail;</span><br><span class="line">ll phi[MAXN];</span><br><span class="line">bool isp[MAXN]; </span><br><span class="line">void euler()</span><br><span class="line">&#123;</span><br><span class="line">	phi[1]=0;</span><br><span class="line">	for(int i=2;i&lt;MAXN;i++)&#123;</span><br><span class="line">		if(!isp[i])&#123;</span><br><span class="line">			pr[++tail]=i;</span><br><span class="line">			phi[i]=i-1;</span><br><span class="line">		&#125;</span><br><span class="line">		for(int j=1;j&lt;=tail&amp;&amp;i*pr[j]&lt;MAXN;j++)&#123;</span><br><span class="line">			isp[i*pr[j]]=1;</span><br><span class="line">			if(i%pr[j]==0)&#123;</span><br><span class="line">				phi[i*pr[j]]=phi[i]*pr[j];</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			else phi[i*pr[j]]=phi[i]*phi[pr[j]];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	ios; ll n;</span><br><span class="line">	euler();</span><br><span class="line">	for(int i=1;i&lt;MAXN;i++)&#123;</span><br><span class="line">		phi[i]+=phi[i-1];</span><br><span class="line">	&#125;</span><br><span class="line">	while(cin&gt;&gt;n)&#123;</span><br><span class="line">		if(n==0) break;</span><br><span class="line">		cout&lt;&lt;phi[n]&lt;&lt;&#x27;\n&#x27;;</span><br><span class="line">	&#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Maximum-GCD"><a href="#Maximum-GCD" class="headerlink" title="Maximum GCD"></a>Maximum GCD</h2><p><strong>题意</strong><br>给定一串数，求两两gcd最大值<br><strong>思路</strong><br>这道题考的其实是读入，两个数之间空格可以有多个！！！  </p>
<h3 id="CODE-8"><a href="#CODE-8" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span><br><span class="line">#define debug freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin); freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout)</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int MAXN = 1e5;</span><br><span class="line">const int MOD = 1e9;</span><br><span class="line">int pr[MAXN], isp[MAXN], tail = 0;</span><br><span class="line">void prime() &#123;</span><br><span class="line">    isp[1] = 1;</span><br><span class="line">    for (int i = 2; i &lt;= 17000; i++) &#123;</span><br><span class="line">        if (!isp[i]) pr[++tail] = i;</span><br><span class="line">        for (int j = 1; i * pr[j] &lt;= 17000; j++) &#123;</span><br><span class="line">            isp[i * pr[j]] = 1;</span><br><span class="line">            if (i % pr[j] == 0) break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int a[110];</span><br><span class="line">char c[100000];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,tail=0;</span><br><span class="line">    scanf(&quot;%d\n&quot;,&amp;n);</span><br><span class="line">    while(n--)&#123;</span><br><span class="line">    	gets(c); tail=0;</span><br><span class="line">    	int len=strlen(c);</span><br><span class="line">        for(int i=0; i&lt;len; i++)&#123;</span><br><span class="line">            int sum=0;</span><br><span class="line">            while(i&lt;len&amp;&amp;c[i]!=&#x27; &#x27;)&#123;</span><br><span class="line">                sum=sum*10+c[i]-&#x27;0&#x27;;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            a[++tail]=sum;</span><br><span class="line">        &#125;</span><br><span class="line">        int maxx=-1e9;</span><br><span class="line">		for(int i=1;i&lt;tail;i++)&#123;</span><br><span class="line">			for(int j=i+1;j&lt;=tail;j++)&#123;</span><br><span class="line">				maxx=max(maxx,__gcd(a[i],a[j]));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;maxx&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Primes"><a href="#Primes" class="headerlink" title="Primes"></a>Primes</h2><p><strong>题意</strong><br>给定一个数判断是不是素数<br><strong>思路</strong><br>这个就太水了，坑我的就是题目最多有250组数据，我说咋一直超时。。</p>
<h3 id="CODE-9"><a href="#CODE-9" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span><br><span class="line">#define debug freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin); freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout)</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int MAXN = 1e5;</span><br><span class="line">const int MOD = 1e9;</span><br><span class="line">int pr[MAXN], isp[MAXN], tail = 0;</span><br><span class="line">void prime() &#123;</span><br><span class="line">    isp[1] = 1;</span><br><span class="line">    for (int i = 2; i &lt;= 17000; i++) &#123;</span><br><span class="line">        if (!isp[i]) pr[++tail] = i;</span><br><span class="line">        for (int j = 1; i * pr[j] &lt;= 17000; j++) &#123;</span><br><span class="line">            isp[i * pr[j]] = 1;</span><br><span class="line">            if (i % pr[j] == 0) break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	prime(); </span><br><span class="line">    int n, kase = 0;</span><br><span class="line">    for(int k=1;k&lt;=250;k++)&#123;</span><br><span class="line">    	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">        if (n &lt;= 0) break;</span><br><span class="line">        if (n &lt;= 2) &#123;</span><br><span class="line">            printf(&quot;%d: %s\n&quot;, ++kase, &quot;no&quot;);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d: &quot;,++kase);</span><br><span class="line">        if (isp[n]) printf(&quot;%s\n&quot;, &quot;no&quot;);</span><br><span class="line">        else printf(&quot;%s\n&quot;, &quot;yes&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>如何给Hexo博客添加说说页面</title>
    <url>/posts/fa2b1812.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>本文已经过期，说说已经更名为artitalk具体百度</p>
</blockquote>
<p>最近看了许多大佬的博客，终于明白了我到底有多弱:weary:,不过虽然我菜，但是Chinese还是能看懂的:grin:,直接按照教程往下走，感谢把我教会的<a href="https://cungudafa.gitee.io/post/ec85.html">原文1</a>和<a href="https://cndrew.cn/2019/09/11/shuoshuo/">原文2</a></p>
<blockquote>
<p>看看效果吧:</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/20200703225932343.png" alt=""><br>这个和QQ空间里面的说说类似，用来记录自己的生活以及心情都挺好的，请忽略内容里面的表情符号:sleeping:我太菜了，这些原本是要被转成表情的，但说说页面好像不支持，/手动流汗/，如果哪位大佬看到了这篇文章，祈求您留言指教我</p>
<p>好了，废话少说，正文开始：</p>
<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><p>1.在<strong>themes\sakura\languages\zh-cn.yml</strong>中增添定义：</p>
<pre><code>shuoshuo: 说说
</code></pre><p>2.修改导航栏，位置：themes\sakura_config.yml增添：</p>
<pre><code>说说: &#123;path: /shuoshuo/, fa: fa-commenting-o fa-commenting &#125;
</code></pre><p>这里需要注意的是如果你的说说是添加在导航栏的子页面的，比如说在归档里面，那么需要在最后添加逗号( , )</p>
<p>3.在博客主目录下新建目录：</p>
<pre><code>hexo new page shuoshuo
</code></pre><p>路径<strong>Users/用户名/博客文件夹/source</strong>文件夹里就会出现刚刚新建的文件夹shuoshuo，打开文件shuoshuo，删除index文件夹，还有一个index.md文件,待会再来修改它。</p>
<p>4.Myblog\source\shuoshuo\ ，新建文件夹 <strong>shuoshuo.css</strong></p>
<p><strong>shuoshuo.css</strong>样式文件：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#shuoshuo_content &#123;</span><br><span class="line">    background-color: #fff;</span><br><span class="line">    padding: 10px;</span><br><span class="line">    min-height: 500px;</span><br><span class="line">&#125;</span><br><span class="line">/* shuo */</span><br><span class="line"> </span><br><span class="line">body.theme-dark .cbp_tmtimeline::before &#123;</span><br><span class="line">    background: RGBA(255, 255, 255, 0.06);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">ul.cbp_tmtimeline &#123;</span><br><span class="line">    padding: 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">div class.cdp_tmlabel &gt; li .cbp_tmlabel &#123;</span><br><span class="line">    margin-bottom: 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">.cbp_tmtimeline &#123;</span><br><span class="line">    margin: 30px 0 0 0;</span><br><span class="line">    padding: 0;</span><br><span class="line">    list-style: none;</span><br><span class="line">    position: relative;</span><br><span class="line">&#125;</span><br><span class="line">/* The line */</span><br><span class="line"> </span><br><span class="line">.cbp_tmtimeline:before &#123;</span><br><span class="line">    content: &#x27;&#x27;;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 0;</span><br><span class="line">    bottom: 0;</span><br><span class="line">    width: 4px;</span><br><span class="line">    background: RGBA(0, 0, 0, 0.02);</span><br><span class="line">    left: 80px;</span><br><span class="line">    margin-left: 10px;</span><br><span class="line">&#125;</span><br><span class="line">/* The date/time */</span><br><span class="line"> </span><br><span class="line">.cbp_tmtimeline &gt; li .cbp_tmtime &#123;</span><br><span class="line">    display: block;</span><br><span class="line">    /* width: 29%; */</span><br><span class="line">    /* padding-right: 110px; */</span><br><span class="line">    max-width: 70px;</span><br><span class="line">    position: absolute;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">.cbp_tmtimeline &gt; li .cbp_tmtime span &#123;</span><br><span class="line">    display: block;</span><br><span class="line">    text-align: right;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">.cbp_tmtimeline &gt; li .cbp_tmtime span:first-child &#123;</span><br><span class="line">    font-size: 0.9em;</span><br><span class="line">    color: #bdd0db;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">.cbp_tmtimeline &gt; li .cbp_tmtime span:last-child &#123;</span><br><span class="line">    font-size: 1.2em;</span><br><span class="line">    color: #9BCD9B;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">.cbp_tmtimeline &gt; li:nth-child(odd) .cbp_tmtime span:last-child &#123;</span><br><span class="line">    color: RGBA(255, 125, 73, 0.75);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">div.cbp_tmlabel &gt; p &#123;</span><br><span class="line">    margin-bottom: 0;</span><br><span class="line">&#125;</span><br><span class="line">/* Right content */</span><br><span class="line"> </span><br><span class="line">.cbp_tmtimeline &gt; li .cbp_tmlabel &#123;</span><br><span class="line">    margin: 0 0 45px 65px;</span><br><span class="line">    background: #9BCD9B;</span><br><span class="line">    color: #fff;</span><br><span class="line">    padding: .8em 1.2em .4em 1.2em;</span><br><span class="line">    /* font-size: 1.2em; */</span><br><span class="line">    font-weight: 300;</span><br><span class="line">    line-height: 1.4;</span><br><span class="line">    position: relative;</span><br><span class="line">    border-radius: 5px;</span><br><span class="line">    transition: all 0.3s ease 0s;</span><br><span class="line">    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.15);</span><br><span class="line">    cursor: pointer;</span><br><span class="line">    display: block;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">.cbp_tmlabel:hover &#123;</span><br><span class="line">    /* transform:scale(1.05); */</span><br><span class="line">    transform: translateY(-3px);</span><br><span class="line">    z-index: 1;</span><br><span class="line">    box-shadow: 0 15px 32px rgba(0, 0, 0, 0.15) !important</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">.cbp_tmtimeline &gt; li:nth-child(odd) .cbp_tmlabel &#123;</span><br><span class="line">    background: RGBA(255, 125, 73, 0.75);</span><br><span class="line">&#125;</span><br><span class="line">/* The triangle */</span><br><span class="line"> </span><br><span class="line">.cbp_tmtimeline &gt; li .cbp_tmlabel:after &#123;</span><br><span class="line">    right: 100%;</span><br><span class="line">    border: solid transparent;</span><br><span class="line">    content: &quot; &quot;;</span><br><span class="line">    height: 0;</span><br><span class="line">    width: 0;</span><br><span class="line">    position: absolute;</span><br><span class="line">    pointer-events: none;</span><br><span class="line">    border-right-color: #9BCD9B;</span><br><span class="line">    border-width: 10px;</span><br><span class="line">    top: 4px;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">.cbp_tmtimeline &gt; li:nth-child(odd) .cbp_tmlabel:after &#123;</span><br><span class="line">    border-right-color: RGBA(255, 125, 73, 0.75);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">p.shuoshuo_time &#123;</span><br><span class="line">    margin-top: 10px;</span><br><span class="line">    border-top: 1px dashed #fff;</span><br><span class="line">    padding-top: 5px;</span><br><span class="line">&#125;</span><br><span class="line">/* Media */</span><br><span class="line"> </span><br><span class="line">@media screen and (max-width: 65.375em) &#123;</span><br><span class="line">    .cbp_tmtimeline &gt; li .cbp_tmtime span:last-child &#123;</span><br><span class="line">        font-size: 1.2em;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">.shuoshuo_author_img img &#123;</span><br><span class="line">    border: 1px solid #ddd;</span><br><span class="line">    padding: 2px;</span><br><span class="line">    float: left;</span><br><span class="line">    border-radius: 64px;</span><br><span class="line">    transition: all 1.0s;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">.avatar &#123;</span><br><span class="line">    border-radius: 100% !important;</span><br><span class="line">    -moz-border-radius: 100% !important;</span><br><span class="line">    box-shadow: inset 0 -1px 0 3333sf;</span><br><span class="line">    -webkit-box-shadow: inset 0 -1px 0 3333sf;</span><br><span class="line">    -webkit-transition: 0.4s;</span><br><span class="line">    -webkit-transition: -webkit-transform 0.4s ease-out;</span><br><span class="line">    transition: transform 0.4s ease-out;</span><br><span class="line">    -moz-transition: -moz-transform 0.4s ease-out;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">.zhuan &#123;</span><br><span class="line">    transform: rotateZ(720deg);</span><br><span class="line">    -webkit-transform: rotateZ(720deg);</span><br><span class="line">    -moz-transform: rotateZ(720deg);</span><br><span class="line">&#125;</span><br><span class="line">/* end */</span><br></pre></td></tr></table></figure></p>
<p>主页面：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: shuoshuo</span><br><span class="line">type: shuoshuo</span><br><span class="line">noDate: &#x27;true&#x27;</span><br><span class="line">comments: &#x27;false&#x27;</span><br><span class="line">---</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;./shuoshuo.css&quot;&gt;</span><br><span class="line"> </span><br><span class="line">&lt;div id=&quot;primary&quot; class=&quot;content-area&quot; style=&quot;&quot;&gt;</span><br><span class="line">    &lt;main id=&quot;main&quot; class=&quot;site-main&quot; role=&quot;main&quot;&gt;</span><br><span class="line">        &lt;div id=&quot;shuoshuo_content&quot;&gt;</span><br><span class="line">            &lt;ul class=&quot;cbp_tmtimeline&quot;&gt;</span><br><span class="line">                &lt;li&gt; &lt;span class=&quot;shuoshuo_author_img&quot;&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/cungudafa/cdn/img/custom/cungudafa.jpg&quot; class=&quot;avatar avatar-48 zhuan&quot; width=&quot;48&quot; height=&quot;48&quot;&gt;&lt;/span&gt;</span><br><span class="line">                    &lt;a class=&quot;cbp_tmlabel&quot; href=&quot;&quot;&gt;</span><br><span class="line">                        &lt;p&gt;&lt;/p&gt;</span><br><span class="line">                        &lt;p&gt;想要开学，想吃火锅，想吃烧烤，想吃蟹肉煲，想吃鸡脚米线，想喝奶茶~&lt;/p&gt;</span><br><span class="line">                        &lt;iframe frameborder=&quot;no&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=86 src=&quot;//music.163.com/outchain/player?type=2&amp;id=1338809890&amp;auto=1&amp;height=66&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">                        &lt;p&gt;&lt;/p&gt;</span><br><span class="line">                        &lt;p class=&quot;shuoshuo_time&quot;&gt;&lt;i class=&quot;fa fa-clock-o&quot;&gt;&lt;/i&gt;</span><br><span class="line">                            2020年2月25日</span><br><span class="line">                        &lt;/p&gt;</span><br><span class="line">                    &lt;/a&gt;</span><br><span class="line">                &lt;/li&gt;</span><br><span class="line">                 &lt;li&gt; &lt;span class=&quot;shuoshuo_author_img&quot;&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/cungudafa/cdn/img/custom/cungudafa.jpg&quot; class=&quot;avatar avatar-48 zhuan&quot; width=&quot;48&quot; height=&quot;48&quot;&gt;&lt;/span&gt;</span><br><span class="line">                    &lt;a class=&quot;cbp_tmlabel&quot; href=&quot;&quot;&gt;</span><br><span class="line">                        &lt;p&gt;&lt;/p&gt;</span><br><span class="line">                        &lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1582636990314&amp;di=2421dcd34e1cc519b7f7f9559afbe7b1&amp;imgtype=0&amp;src=http%3A%2F%2Fpics1.baidu.com%2Ffeed%2Fb17eca8065380cd7531865282a19873258828151.jpeg%3Ftoken%3Dce6f76a2b9dc38c02c91acfc2a4bb8d8%26s%3D3C79EF14C510746516F547E003007036&quot; height=&quot;200&quot; width=&quot;100&quot; /&gt;</span><br><span class="line">                        &lt;p&gt;武汉加油！中国加油！&lt;/p&gt;</span><br><span class="line">                        &lt;p&gt;&lt;/p&gt;</span><br><span class="line">                        &lt;p class=&quot;shuoshuo_time&quot;&gt;&lt;i class=&quot;fa fa-clock-o&quot;&gt;&lt;/i&gt;</span><br><span class="line">                            2020年2月25日</span><br><span class="line">                        &lt;/p&gt;</span><br><span class="line">                    &lt;/a&gt;</span><br><span class="line">                &lt;/li&gt;</span><br><span class="line">                &lt;li&gt; &lt;span class=&quot;shuoshuo_author_img&quot;&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/cungudafa/cdn/img/custom/cungudafa.jpg&quot; class=&quot;avatar avatar-48 zhuan&quot; width=&quot;48&quot; height=&quot;48&quot;&gt;&lt;/span&gt;</span><br><span class="line">                    &lt;a class=&quot;cbp_tmlabel&quot; href=&quot;&quot;&gt;</span><br><span class="line">                        &lt;p&gt;&lt;/p&gt;</span><br><span class="line">                        &lt;p&gt;第一个说说&lt;/p&gt;</span><br><span class="line">                        &lt;p&gt;&lt;/p&gt;</span><br><span class="line">                        &lt;p class=&quot;shuoshuo_time&quot;&gt;&lt;i class=&quot;fa fa-clock-o&quot;&gt;&lt;/i&gt;</span><br><span class="line">                            2020年2月25日</span><br><span class="line">                        &lt;/p&gt;</span><br><span class="line">                    &lt;/a&gt;</span><br><span class="line">                &lt;/li&gt;</span><br><span class="line">            &lt;/ul&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    (function () &#123;</span><br><span class="line">        var oldClass = &quot;&quot;;</span><br><span class="line">        var Obj = &quot;&quot;;</span><br><span class="line">        $(&quot;.cbp_tmtimeline li&quot;).hover(function () &#123;</span><br><span class="line">            Obj = $(this).children(&quot;.shuoshuo_author_img&quot;);</span><br><span class="line">            Obj = Obj.children(&quot;img&quot;);</span><br><span class="line">            oldClass = Obj.attr(&quot;class&quot;);</span><br><span class="line">            var newClass = oldClass + &quot; zhuan&quot;;</span><br><span class="line">            Obj.attr(&quot;class&quot;, newClass);</span><br><span class="line">        &#125;, function () &#123;</span><br><span class="line">            Obj.attr(&quot;class&quot;, oldClass);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><br>只会报别人代码的我再次像大佬们深深鞠一躬(orz)</p>
]]></content>
  </entry>
  <entry>
    <title>数学问题模板</title>
    <url>/posts/d6ebbabc.html</url>
    <content><![CDATA[<h2 id="筛选质因子"><a href="#筛选质因子" class="headerlink" title="筛选质因子"></a>筛选质因子</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i*i&lt;=k;i++)&#123;</span><br><span class="line">     <span class="keyword">if</span>(k%i==<span class="number">0</span>)&#123;</span><br><span class="line">         p[++tail]=i;  <span class="comment">//p就是储存质因子的数组</span></span><br><span class="line">         <span class="keyword">while</span>(k%i==<span class="number">0</span>) k/=i;  <span class="comment">//把k中所有i的质因子全部除去</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">   <span class="keyword">if</span>(k&gt;<span class="number">1</span>) p[++tail]=k;</span><br></pre></td></tr></table></figure>
<h2 id="判断是否为质数"><a href="#判断是否为质数" class="headerlink" title="判断是否为质数"></a>判断是否为质数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isp</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">1</span>||n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">2</span>||n==<span class="number">3</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(n%<span class="number">6</span>!=<span class="number">1</span>&amp;&amp;n%<span class="number">6</span>!=<span class="number">5</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">5</span>;i*i&lt;=n;i+=<span class="number">6</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(n%i==<span class="number">0</span>||n%(i+<span class="number">2</span>)==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="容斥原理"><a href="#容斥原理" class="headerlink" title="容斥原理"></a>容斥原理</h2><p>前言：</p>
<ol>
<li>计算1-n中m的的倍数的数量时，直接n/m</li>
<li>容斥原理是在互质的数的基础上实现的<br>公式：</li>
</ol>
<p>(A+B+C+D+E……)-(A<em>B+A</em>C+A<em>D……+B</em>C+B<em>D)+(A</em>B<em>C+B</em>C<em>D……)-(A</em>B<em>C</em>D+B<em>C</em>D*E……)……</p>
<p>规律： 奇数相加，偶数相减</p>
<p>代码：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p数组储存的是筛选的质因子</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">fun</span><span class="params">(<span class="type">long</span> <span class="type">long</span> x)</span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> res=<span class="number">0</span>;  <span class="comment">//res储存的是1-x中与K不互质的数量 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;(<span class="number">1</span>&lt;&lt;tail);i++)&#123;  <span class="comment">//这里的1&lt;&lt;tail是指2的tail次方，表示tail个质因子有多少种组合情况 </span></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> cur=<span class="number">1</span>,cnt=<span class="number">0</span>;  <span class="comment">//cur表示在当前选中的质因子中的乘积，cnt表示当前选中的数量是奇数还是偶数 </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;tail;j++)&#123;  <span class="comment">//这个循环是枚举tail的二进制形式 </span></span><br><span class="line">            <span class="keyword">if</span>((i&gt;&gt;j)&amp;<span class="number">1</span>)&#123;  <span class="comment">//这个是判断i的第j位是不是1，如果是则表示选中第j个数 </span></span><br><span class="line">                cnt++;  <span class="comment">//表示选中了几个数，每选中一个就加一 </span></span><br><span class="line">                cur*=p[j+<span class="number">1</span>];  <span class="comment">//选中第j个数就用cur乘以第j个质因子数，注意质因子数组是从1开始的，所以要加一 </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt&amp;<span class="number">1</span>) res+=x/cur;  <span class="comment">//如果cnt是偶数就相加 </span></span><br><span class="line">        <span class="keyword">else</span> res-=x/cur;  <span class="comment">//奇数就相减 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x-res;  <span class="comment">//res储存的是1-x中与K不互质的数量，所以要用x-res得到互质的数量 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="欧拉筛"><a href="#欧拉筛" class="headerlink" title="欧拉筛"></a>欧拉筛</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> vis[maxn],p[maxn/<span class="number">10</span>]; <span class="comment">//质数密度不大，除以10可以减少空间浪费</span></span><br><span class="line"><span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">prime</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    vis[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=maxn;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i]) p[++cnt]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=cnt&amp;&amp;i&lt;=maxn/p[j];j++)&#123;</span><br><span class="line">            vis[i*p[j]]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%p[j]==<span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">//核心代码，如果i能整除这个质数则跳出循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="埃式筛"><a href="#埃式筛" class="headerlink" title="埃式筛"></a>埃式筛</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> p[<span class="number">1000</span>]; <span class="comment">//p数组用来存储质数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">prime</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    vis[<span class="number">1</span>]=<span class="number">1</span>; <span class="comment">//1不是质数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123; <span class="comment">//n是筛选的范围</span></span><br><span class="line">        <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">            p[++cnt]=i; <span class="comment">//存储质数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>*i;j&lt;=n;j+=i)&#123;  <span class="comment">//这里可以有一个优化，j=2*i</span></span><br><span class="line">                vis[j]=<span class="number">1</span>; <span class="comment">//标记质数的倍数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h2><ul>
<li>海伦公式<br>S=sqrt(p <em> (p-a) </em> (p-b) * (p-c))<h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><font color="red">
非递归版本
</font>

</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int p(int a,int b)&#123;</span><br><span class="line">  int t,y;</span><br><span class="line">  t=1; y=a;</span><br><span class="line">  while (b!=0)&#123;</span><br><span class="line">    if (b&amp;1==1) t=t*y%MOD;</span><br><span class="line">    y=y*y%MOD;</span><br><span class="line">    b=b&gt;&gt;1;</span><br><span class="line">  &#125;</span><br><span class="line">  return t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<font color="red">
递归版本
</font>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ll <span class="title function_">pow</span><span class="params">(ll a,ll i)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (i==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  ll temp=<span class="built_in">pow</span>(a,i&gt;&gt;<span class="number">1</span>)%MOD;</span><br><span class="line">  temp=temp*temp%MOD;</span><br><span class="line">  <span class="keyword">if</span> (i&amp;<span class="number">1</span>) temp=temp*a%MOD;</span><br><span class="line">  <span class="keyword">return</span> temp%MOD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="龟速乘-快速幂BUG"><a href="#龟速乘-快速幂BUG" class="headerlink" title="龟速乘(快速幂BUG)"></a>龟速乘(快速幂BUG)</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ll <span class="title function_">gsc</span><span class="params">(ll a,ll b)</span>&#123;</span><br><span class="line">	ll ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(b)&#123;</span><br><span class="line">		<span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans=(ans+a)%MOD;</span><br><span class="line">		a=a*<span class="number">2</span>%MOD;</span><br><span class="line">		b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="快速乘-有误差"><a href="#快速乘-有误差" class="headerlink" title="快速乘(有误差)"></a>快速乘(有误差)</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;mod;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;((a*b-(<span class="type">long</span> <span class="type">long</span>)((<span class="type">long</span> <span class="type">double</span>)a*b/mod)*mod+mod)%mod);</span><br></pre></td></tr></table></figure>
<h2 id="树状数组模板"><a href="#树状数组模板" class="headerlink" title="树状数组模板"></a>树状数组模板</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">lowbit</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n&amp;-n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x;i&lt;=n;i+=lowbit(i))</span><br><span class="line">        c[i] += y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getsum</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x;i;i-=lowbit(i))</span><br><span class="line">        ans += c[i];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查并集"><a href="#查并集" class="headerlink" title="查并集"></a>查并集</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        f[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getFriend</span><span class="params">(<span class="type">int</span> v)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span>(f[v] == v) &#123;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[v] = getFriend(f[v]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> t1 = getFriend(a);</span><br><span class="line">    <span class="type">int</span> t2 = getFriend(b);</span><br><span class="line">    <span class="keyword">if</span>(t1 != t2) &#123;  </span><br><span class="line">        f[t2] = t1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//左右都是闭区间 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">qsort</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> *v)</span>&#123;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> i=l,j=r;</span><br><span class="line">	<span class="type">int</span> temp=v[mid];<span class="comment">//基准值是会被交换的，必须备份 </span></span><br><span class="line">	<span class="keyword">while</span>(i&lt;=j)&#123;<span class="comment">//这里小于等于都行 </span></span><br><span class="line">		<span class="keyword">while</span>(v[j]&gt;temp) j--;<span class="comment">//找到第一个小于等于基准值的 </span></span><br><span class="line">		<span class="keyword">while</span>(v[i]&lt;temp) i++;</span><br><span class="line">		<span class="keyword">if</span>(i&lt;=j)&#123; <span class="comment">//这里必须是小于等于,因为当只有两个数时，两个指针一定会重合 </span></span><br><span class="line">			swap(v[i],v[j]);</span><br><span class="line">			i++; j--;<span class="comment">//这里必须，因为当交换的两个数有基准值时，若没有这一步，两个指针必然重合，然后会无限重复 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//i一定比j大，排序过后i左面都小于基准值，j右面都大于基准值就找到了基准值的位置  </span></span><br><span class="line">	<span class="keyword">if</span>(i&lt;r) qsort(i,r,v);<span class="comment">//再排基准值右面 </span></span><br><span class="line">	<span class="keyword">if</span>(j&gt;l) qsort(l,j,v);<span class="comment">//再排基准值左面 </span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="组合数打表-杨辉三角"><a href="#组合数打表-杨辉三角" class="headerlink" title="组合数打表(杨辉三角)"></a>组合数打表(杨辉三角)</h2><font color="red">
int类型最多到33层，34层开始爆int，ll最多50层左右，打表最多1e3的量
</font>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> c[<span class="number">50</span>][<span class="number">50</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">zuhe</span><span class="params">()</span>&#123;<span class="comment">//下标从0开始</span></span><br><span class="line">	c[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	c[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">1</span>;c[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">33</span>;i++)&#123;</span><br><span class="line">		c[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">			c[i][j]=c[i<span class="number">-1</span>][j<span class="number">-1</span>]+c[i<span class="number">-1</span>][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>持续更新中……</p>
</blockquote>
]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>数学问题记录</tag>
      </tags>
  </entry>
  <entry>
    <title>sql语法</title>
    <url>/posts/56483af3.html</url>
    <content><![CDATA[<h1 id="Sql语句执行顺序"><a href="#Sql语句执行顺序" class="headerlink" title="Sql语句执行顺序"></a>Sql语句执行顺序</h1><ol>
<li>from</li>
<li>join</li>
<li>where</li>
<li>group by</li>
<li>having</li>
<li>select</li>
<li>distinct</li>
<li>order by</li>
<li>limit/offset</li>
</ol>
<h1 id="Case和If"><a href="#Case和If" class="headerlink" title="Case和If"></a>Case和If</h1><p><code>CASE</code> 表达式有两种形式：简单 <code>CASE</code> 表达式和搜索式 <code>CASE</code> 表达式。</p>
<ul>
<li><strong>简单 <code>CASE</code> 表达式</strong>：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CASE</span> 表达式</span><br><span class="line">    <span class="keyword">WHEN</span> 值<span class="number">1</span> <span class="keyword">THEN</span> 结果<span class="number">1</span></span><br><span class="line">    <span class="keyword">WHEN</span> 值<span class="number">2</span> <span class="keyword">THEN</span> 结果<span class="number">2</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">ELSE</span> 结果N</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>
<p>它将一个表达式与多个值进行比较，根据匹配情况返回相应的结果。</p>
<ul>
<li><strong>搜索式 <code>CASE</code> 表达式</strong>：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CASE</span></span><br><span class="line">    <span class="keyword">WHEN</span> 条件<span class="number">1</span> <span class="keyword">THEN</span> 结果<span class="number">1</span></span><br><span class="line">    <span class="keyword">WHEN</span> 条件<span class="number">2</span> <span class="keyword">THEN</span> 结果<span class="number">2</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">ELSE</span> 结果N</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>
<p>可以使用更复杂的条件进行判断，依次检查每个 <code>WHEN</code> 子句中的条件，当某个条件为 <code>TRUE</code> 时，返回对应的结果。</p>
<p><code>IF</code> 函数接受三个参数，当条件为 <code>TRUE</code> 时返回 <code>结果1</code>，当条件为 <code>FALSE</code> 时返回 <code>结果2</code>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">IF(条件, 结果<span class="number">1</span>, 结果<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><h1 id="Group-by"><a href="#Group-by" class="headerlink" title="Group by"></a>Group by</h1></li>
<li><p><strong>核心作用</strong>：将数据按指定列分组，每组返回一行结果。</p>
</li>
<li><strong>关键规则</strong>：<code>SELECT</code> 中的非聚合字段必须出现在 <code>GROUP BY</code> 中。</li>
</ul>
<hr>
<h2 id="单字段分组"><a href="#单字段分组" class="headerlink" title="单字段分组"></a>单字段分组</h2><p>示例表 <code>Sales</code></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>order_id</th>
<th>product</th>
<th>category</th>
<th>amount</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>A</td>
<td>Electronics</td>
<td>100</td>
</tr>
<tr>
<td>2</td>
<td>B</td>
<td>Books</td>
<td>50</td>
</tr>
<tr>
<td>3</td>
<td>A</td>
<td>Electronics</td>
<td>200</td>
</tr>
<tr>
<td>4</td>
<td>C</td>
<td>Books</td>
<td>30</td>
</tr>
</tbody>
</table>
</div>
<p>按 <code>category</code> 统计销售额</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> category, <span class="built_in">SUM</span>(amount) <span class="keyword">AS</span> total_sales</span><br><span class="line"><span class="keyword">FROM</span> Sales</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> category;</span><br></pre></td></tr></table></figure>
<p>结果</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>category</th>
<th>total_sales</th>
</tr>
</thead>
<tbody>
<tr>
<td>Electronics</td>
<td>300</td>
</tr>
<tr>
<td>Books</td>
<td>80</td>
</tr>
</tbody>
</table>
</div>
<hr>
<h2 id="多字段分组"><a href="#多字段分组" class="headerlink" title="多字段分组"></a>多字段分组</h2><p>按 <code>category</code> 和 <code>product</code> 统计销量</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> category, product, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> sales_count</span><br><span class="line"><span class="keyword">FROM</span> Sales</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> category, product;</span><br></pre></td></tr></table></figure>
<p>结果</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>category</th>
<th>product</th>
<th>sales_count</th>
</tr>
</thead>
<tbody>
<tr>
<td>Electronics</td>
<td>A</td>
<td>2</td>
</tr>
<tr>
<td>Books</td>
<td>B</td>
<td>1</td>
</tr>
<tr>
<td>Books</td>
<td>C</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<hr>
<h2 id="结合聚合函数"><a href="#结合聚合函数" class="headerlink" title="结合聚合函数"></a>结合聚合函数</h2><p>常用聚合函数：</p>
<ul>
<li><code>SUM()</code>：求和</li>
<li><code>AVG()</code>：平均值</li>
<li><code>COUNT()</code>：计数</li>
<li><code>MAX()/MIN()</code>：最大/最小值</li>
</ul>
<p>示例：计算每个产品的平均销售额</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> product, <span class="built_in">AVG</span>(amount) <span class="keyword">AS</span> avg_amount</span><br><span class="line"><span class="keyword">FROM</span> Sales</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> product;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="过滤分组结果（HAVING）"><a href="#过滤分组结果（HAVING）" class="headerlink" title="过滤分组结果（HAVING）"></a>过滤分组结果（HAVING）</h2><p>筛选总销售额 &gt; 100 的类别</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> category, <span class="built_in">SUM</span>(amount) <span class="keyword">AS</span> total_sales</span><br><span class="line"><span class="keyword">FROM</span> Sales</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> category</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">SUM</span>(amount) <span class="operator">&gt;</span> <span class="number">100</span>;</span><br></pre></td></tr></table></figure>
<p>结果</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>category</th>
<th>total_sales</th>
</tr>
</thead>
<tbody>
<tr>
<td>Electronics</td>
<td>300</td>
</tr>
</tbody>
</table>
</div>
<hr>
<h2 id="常见错误与注意事项"><a href="#常见错误与注意事项" class="headerlink" title="常见错误与注意事项"></a>常见错误与注意事项</h2><p>错误1：选择未聚合的字段</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 错误写法（product 未在 GROUP BY 中）</span></span><br><span class="line"><span class="keyword">SELECT</span> category, product, <span class="built_in">SUM</span>(amount)</span><br><span class="line"><span class="keyword">FROM</span> Sales</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> category;</span><br></pre></td></tr></table></figure>
<p><strong>报错</strong>：<code>Column &#39;product&#39; is invalid in the select list...</code></p>
<p>错误2：WHERE 与 HAVING 混淆</p>
<ul>
<li><strong><code>WHERE</code></strong>：在分组前过滤行。</li>
<li><strong><code>HAVING</code></strong>：在分组后过滤组。</li>
</ul>
<p>其他注意事项：</p>
<ol>
<li><strong>NULL 值处理</strong>：<code>GROUP BY</code> 将 <code>NULL</code> 视为同一分组。</li>
<li><strong>性能优化</strong>：大表分组时，确保分组字段有索引。</li>
<li><strong>结果顺序</strong>：分组结果默认无序，需用 <code>ORDER BY</code> 明确排序。</li>
</ol>
<hr>
<h2 id="综合示例"><a href="#综合示例" class="headerlink" title="综合示例"></a>综合示例</h2><p>统计每个类别下销量超过1次的商品</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    category, </span><br><span class="line">    product, </span><br><span class="line">    <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> sales_count,</span><br><span class="line">    <span class="built_in">SUM</span>(amount) <span class="keyword">AS</span> total_sales</span><br><span class="line"><span class="keyword">FROM</span> Sales</span><br><span class="line"><span class="keyword">WHERE</span> amount <span class="operator">&gt;</span> <span class="number">0</span>  <span class="comment">-- 先过滤无效金额</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> category, product</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> total_sales <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>
<h1 id="DISTINCT"><a href="#DISTINCT" class="headerlink" title="DISTINCT"></a>DISTINCT</h1><p>对单列数据去重：假设有一个 <code>Employees</code> 表，包含 <code>employee_id</code>、<code>employee_name</code> 和 <code>department</code> 列，现在要查询不同的部门名称。</p>
<p>对多列数据组合去重：若要查询不同的员工姓名和部门的组合。</p>
<p>与聚合函数一起使用：<code>DISTINCT</code> 可以与聚合函数（如 <code>COUNT</code>、<code>SUM</code> 等）一起使用，用于统计不同值的数量或对不同值进行求和。</p>
<h1 id="UNION"><a href="#UNION" class="headerlink" title="UNION"></a>UNION</h1><blockquote>
<p> 注意：使用 <code>union</code> 组合查询时，只能使用一条 <code>order by</code> 字句，他必须位于最后一条 <code>select</code> 语句之后</p>
</blockquote>
<p><code>UNION</code> 运算符将两个或更多查询的结果组合起来，并生成一个结果集，其中包含来自 <code>UNION</code> 中参与查询的提取行。</p>
<p><code>UNION</code> 基本规则：</p>
<ul>
<li>所有查询的列数和列顺序必须相同。</li>
<li>每个查询中涉及表的列的数据类型必须相同或兼容。</li>
<li>通常返回的列名取自第一个查询。</li>
</ul>
<p>默认地，<code>UNION</code> 操作符选取不同的值。如果允许重复的值，请使用 <code>UNION ALL</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT column_name(s) FROM table1</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT column_name(s) FROM table2;</span><br></pre></td></tr></table></figure>
<p><code>UNION</code> 结果集中的列名总是等于 <code>UNION</code> 中第一个 <code>SELECT</code> 语句中的列名。</p>
<p><code>JOIN</code> vs <code>UNION</code>：</p>
<ul>
<li><code>JOIN</code> 中连接表的列可能不同，但在 <code>UNION</code> 中，所有查询的列数和列顺序必须相同。</li>
<li><code>UNION</code> 将查询之后的行放在一起（垂直放置），但 <code>JOIN</code> 将查询之后的列放在一起（水平放置），即它构成一个笛卡尔积。</li>
</ul>
<p><code>UNION</code> 运算符将两个或更多查询的结果组合起来，并生成一个结果集，其中包含来自 <code>UNION</code> 中参与查询的提取行。</p>
<p><code>UNION</code> 基本规则：</p>
<ul>
<li>所有查询的列数和列顺序必须相同。</li>
<li>每个查询中涉及表的列的数据类型必须相同或兼容。</li>
<li>通常返回的列名取自第一个查询。</li>
</ul>
<p>默认地，<code>UNION</code> 操作符选取不同的值。如果允许重复的值，请使用 <code>UNION ALL</code>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s) <span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> column_name(s) <span class="keyword">FROM</span> table2;</span><br></pre></td></tr></table></figure>
<p><code>UNION</code> 结果集中的列名总是等于 <code>UNION</code> 中第一个 <code>SELECT</code> 语句中的列名。</p>
<p><code>JOIN</code> vs <code>UNION</code>：</p>
<ul>
<li><code>JOIN</code> 中连接表的列可能不同，但在 <code>UNION</code> 中，所有查询的列数和列顺序必须相同。</li>
<li><code>UNION</code> 将查询之后的行放在一起（垂直放置），但 <code>JOIN</code> 将查询之后的列放在一起（水平放置），即它构成一个笛卡尔积。</li>
</ul>
<h1 id="Replace"><a href="#Replace" class="headerlink" title="Replace"></a>Replace</h1><ol>
<li>Replace 函数</li>
</ol>
<p><code>REPLACE</code> 函数用于在字符串中替换指定的子字符串。它会将字符串中所有出现的指定旧子字符串替换为新的子字符串。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">REPLACE(str, old_substr, new_substr)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>str</code>：要进行替换操作的原始字符串。</li>
<li><code>old_substr</code>：需要被替换的旧子字符串。</li>
<li><code>new_substr</code>：用于替换旧子字符串的新子字符串。</li>
</ul>
<ol>
<li>Replace into</li>
</ol>
<p><code>REPLACE INTO</code> 语句用于向表中插入数据，如果插入的数据对应的主键或唯一索引已经存在，则先删除原有的记录，然后再插入新的记录；如果不存在，则直接插入新记录。</p>
<ol>
<li><strong>示例</strong></li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建一个示例表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Users (</span><br><span class="line">    user_id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    user_name <span class="type">VARCHAR</span>(<span class="number">50</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入示例数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Users (user_id, user_name)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;Alice&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用 REPLACE INTO 语句更新已存在的记录</span></span><br><span class="line">REPLACE <span class="keyword">INTO</span> Users (user_id, user_name)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;Bob&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询更新后的记录</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Users;</span><br></pre></td></tr></table></figure>
<p>在上述示例中，由于 <code>user_id</code> 为 1 的记录已经存在，<code>REPLACE INTO</code> 语句会先删除原有的记录，然后插入新的记录，将 <code>user_name</code> 更新为 <code>&#39;Bob&#39;</code>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> examination_info</span><br><span class="line"><span class="keyword">SET</span> tag <span class="operator">=</span> REPLACE(tag,<span class="string">&#x27;PYTHON&#x27;</span>,<span class="string">&#x27;Python&#x27;</span>)</span><br><span class="line"></span><br><span class="line"># REPLACE (目标字段，&quot;查找内容&quot;,&quot;替换内容&quot;)</span><br></pre></td></tr></table></figure>
<p>把<strong>examination_info</strong>表中<code>tag</code>为<code>PYTHON</code>的<code>tag</code>字段全部修改为<code>Python</code>。</p>
<h1 id="USING"><a href="#USING" class="headerlink" title="USING"></a>USING</h1><p><code>USING</code> 关键字主要用于简化表连接操作，特别是在进行 <code>JOIN</code> 操作时，它可以让代码更加简洁。</p>
<p>假设有两个表：<code>Orders</code> 表和 <code>Customers</code> 表，它们都有一个名为 <code>customer_id</code> 的列，用于关联订单和客户信息。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建 Customers 表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Customers (</span><br><span class="line">    customer_id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    customer_name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    customer_email <span class="type">VARCHAR</span>(<span class="number">100</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建 Orders 表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Orders (</span><br><span class="line">    order_id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    customer_id <span class="type">INT</span>,</span><br><span class="line">    order_date <span class="type">DATE</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入示例数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Customers (customer_id, customer_name, customer_email)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;alice@example.com&#x27;</span>),</span><br><span class="line">       (<span class="number">2</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;bob@example.com&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Orders (order_id, customer_id, order_date)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">101</span>, <span class="number">1</span>, <span class="string">&#x27;2024-10-01&#x27;</span>),</span><br><span class="line">       (<span class="number">102</span>, <span class="number">2</span>, <span class="string">&#x27;2024-10-02&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用 USING 进行连接查询</span></span><br><span class="line"><span class="keyword">SELECT</span> order_id, customer_name, order_date</span><br><span class="line"><span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">JOIN</span> Customers</span><br><span class="line"><span class="keyword">USING</span> (customer_id);</span><br></pre></td></tr></table></figure>
<p>在这个示例中，<code>USING (customer_id)</code> 表示根据 <code>Orders</code> 表和 <code>Customers</code> 表中的 <code>customer_id</code> 列进行连接。与使用传统的 <code>ON</code> 子句（<code>ON Orders.customer_id = Customers.customer_id</code>）相比，<code>USING</code> 语法更加简洁。</p>
<p><code>USING</code> 也可以用于多列连接，只需在括号中列出多个列名，用逗号分隔即可。</p>
<h1 id="AFTER"><a href="#AFTER" class="headerlink" title="AFTER"></a>AFTER</h1><p>在 SQL 中，当使用 <code>ALTER TABLE</code> 语句向表中添加新列时，<code>AFTER</code> 关键字可以指定新增列在表中的位置，即让新增列位于指定列之后。如果不使用 <code>AFTER</code> 关键字，新增列通常会被添加到表的最后一列。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> user_info</span><br><span class="line">    <span class="keyword">ADD</span> school <span class="type">VARCHAR</span>(<span class="number">15</span>) AFTER level,</span><br><span class="line">    CHANGE job profession <span class="type">VARCHAR</span>(<span class="number">10</span>),</span><br><span class="line">    MODIFY achievement <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h1 id="EXIST"><a href="#EXIST" class="headerlink" title="EXIST"></a>EXIST</h1><p><code>EXISTS</code> 运算符不关注子查询返回的具体数据内容，仅在乎子查询是否能返回至少一行结果。若子查询返回了至少一行，<code>EXISTS</code> 就会返回布尔值 <code>TRUE</code>，此时主查询会包含满足该条件的记录；若子查询没有返回任何行，<code>EXISTS</code> 则返回 <code>FALSE</code>，主查询会排除满足该条件的记录。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customer_name</span><br><span class="line"><span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">FROM</span> Orders</span><br><span class="line">    <span class="keyword">WHERE</span> Orders.customer_id <span class="operator">=</span> Customers.customer_id</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>这里，对于 <code>Customers</code> 表中的每一行记录，子查询会检查 <code>Orders</code> 表中是否存在 <code>customer_id</code> 与之匹配的订单记录。若存在，<code>EXISTS</code> 返回 <code>TRUE</code>，该行客户记录会被包含在主查询结果中；若不存在，<code>EXISTS</code> 返回 <code>FALSE</code>，该行客户记录会被排除。</p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#文本处理">文本处理</a></h2><div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>LEFT()</code>、<code>RIGHT()</code></td>
<td>左边或者右边的字符</td>
</tr>
<tr>
<td><code>LOWER()</code>、<code>UPPER()</code></td>
<td>转换为小写或者大写</td>
</tr>
<tr>
<td><code>LTRIM()</code>、<code>RTRIM()</code></td>
<td>去除左边或者右边的空格</td>
</tr>
<tr>
<td><code>LENGTH()</code></td>
<td>长度，以字节为单位</td>
</tr>
<tr>
<td><code>SOUNDEX()</code></td>
<td>转换为语音值</td>
</tr>
</tbody>
</table>
</div>
<p>其中， <strong><code>SOUNDEX()</code></strong> 可以将一个字符串转换为描述其语音表示的字母数字模式。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> SOUNDEX(col1) <span class="operator">=</span> SOUNDEX(<span class="string">&#x27;apple&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="日期和时间处理"><a href="#日期和时间处理" class="headerlink" title="日期和时间处理"></a><a href="#日期和时间处理">日期和时间处理</a></h2><ul>
<li><p>日期格式：<code>YYYY-MM-DD</code></p>
</li>
<li><p>时间格式：<code>HH:MM:SS</code></p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>函 数</th>
<th>说 明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>AddDate()</code></td>
<td>增加一个日期（天、周等）</td>
</tr>
<tr>
<td><code>AddTime()</code></td>
<td>增加一个时间（时、分等）</td>
</tr>
<tr>
<td><code>CurDate()</code></td>
<td>返回当前日期</td>
</tr>
<tr>
<td><code>CurTime()</code></td>
<td>返回当前时间</td>
</tr>
<tr>
<td><code>Date()</code></td>
<td>返回日期时间的日期部分</td>
</tr>
<tr>
<td><code>DateDiff()</code></td>
<td>计算两个日期之差</td>
</tr>
<tr>
<td><code>Date_Add()</code></td>
<td>高度灵活的日期运算函数</td>
</tr>
<tr>
<td><code>Date_Format()</code></td>
<td>返回一个格式化的日期或时间串</td>
</tr>
<tr>
<td><code>Day()</code></td>
<td>返回一个日期的天数部分</td>
</tr>
<tr>
<td><code>DayOfWeek()</code></td>
<td>对于一个日期，返回对应的星期几</td>
</tr>
<tr>
<td><code>Hour()</code></td>
<td>返回一个时间的小时部分</td>
</tr>
<tr>
<td><code>Minute()</code></td>
<td>返回一个时间的分钟部分</td>
</tr>
<tr>
<td><code>Month()</code></td>
<td>返回一个日期的月份部分</td>
</tr>
<tr>
<td><code>Now()</code></td>
<td>返回当前日期和时间</td>
</tr>
<tr>
<td><code>Second()</code></td>
<td>返回一个时间的秒部分</td>
</tr>
<tr>
<td><code>Time()</code></td>
<td>返回一个日期时间的时间部分</td>
</tr>
<tr>
<td><code>Year()</code></td>
<td>返回一个日期的年份部分</td>
</tr>
</tbody>
</table>
</div>
<h2 id="数值处理"><a href="#数值处理" class="headerlink" title="数值处理"></a><a href="#数值处理">数值处理</a></h2><div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>SIN()</td>
<td>正弦</td>
</tr>
<tr>
<td>COS()</td>
<td>余弦</td>
</tr>
<tr>
<td>TAN()</td>
<td>正切</td>
</tr>
<tr>
<td>ABS()</td>
<td>绝对值</td>
</tr>
<tr>
<td>SQRT()</td>
<td>平方根</td>
</tr>
<tr>
<td>MOD()</td>
<td>余数</td>
</tr>
<tr>
<td>EXP()</td>
<td>指数</td>
</tr>
<tr>
<td>PI()</td>
<td>圆周率</td>
</tr>
<tr>
<td>RAND()</td>
<td>随机数</td>
</tr>
</tbody>
</table>
</div>
<h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a><a href="#汇总">汇总</a></h2><div class="table-container">
<table>
<thead>
<tr>
<th>函 数</th>
<th>说 明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>AVG()</code></td>
<td>返回某列的平均值</td>
</tr>
<tr>
<td><code>COUNT()</code></td>
<td>返回某列的行数</td>
</tr>
<tr>
<td><code>MAX()</code></td>
<td>返回某列的最大值</td>
</tr>
<tr>
<td><code>MIN()</code></td>
<td>返回某列的最小值</td>
</tr>
<tr>
<td><code>SUM()</code></td>
<td>返回某列值之和</td>
</tr>
</tbody>
</table>
</div>
<p><code>AVG()</code> 会忽略 NULL 行。</p>
<p>使用 <code>DISTINCT</code> 可以让汇总函数值汇总不同的值。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(<span class="keyword">DISTINCT</span> col1) <span class="keyword">AS</span> avg_col</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br></pre></td></tr></table></figure>
<h2 id="COUNT的用法"><a href="#COUNT的用法" class="headerlink" title="COUNT的用法"></a>COUNT的用法</h2><ol>
<li>COUNT(*): 统计表中所有行的数量，包括NULL值。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure>
<ol>
<li>COUNT(column): 统计指定列中非NULL值的数量。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(column_name) <span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure>
<ol>
<li>COUNT(DISTINCT column): 统计指定列中不重复的非NULL值的数量。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> column_name) <span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure>
<ol>
<li>COUNT(CASE WHEN action = ‘confirmed’ THEN 1 END)：统计列名是confirmed的行数量，count里面的参数是NULL不会+1，不是NULL就+1.</li>
</ol>
<h2 id="AVG的用法"><a href="#AVG的用法" class="headerlink" title="AVG的用法"></a>AVG的用法</h2><p>功能是计算一组数值的平均值。它在数据统计和分析方面非常实用，能够帮助我们快速获取数据的平均水平。需要注意的是，<code>AVG</code> 函数会自动忽略 <code>NULL</code> 值，仅对非 <code>NULL</code> 的数值进行计算。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">AVG</span>([<span class="keyword">DISTINCT</span>] 列名)</span><br></pre></td></tr></table></figure>
<p>参数解释</p>
<ul>
<li><strong><code>DISTINCT</code>（可选）</strong>：使用该关键字时，<code>AVG</code> 函数会先去除重复值，再计算平均值。若省略 <code>DISTINCT</code>，则会对所有非 <code>NULL</code> 值进行计算。</li>
<li><strong>列名</strong>：指定要计算平均值的列，该列的数据类型通常为数值类型，如 <code>INT</code>、<code>DECIMAL</code> 等。</li>
</ul>
<p>（一）计算单列的平均值</p>
<p>假设存在一个 <code>Employees</code> 表，记录了员工的薪资信息，表结构和示例数据如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建 Employees 表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Employees (</span><br><span class="line">    employee_id <span class="type">INT</span>,</span><br><span class="line">    employee_name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    salary <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入示例数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Employees (employee_id, employee_name, salary)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;Alice&#x27;</span>, <span class="number">5000.00</span>),</span><br><span class="line">       (<span class="number">2</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="number">6000.00</span>),</span><br><span class="line">       (<span class="number">3</span>, <span class="string">&#x27;Charlie&#x27;</span>, <span class="number">7000.00</span>);</span><br></pre></td></tr></table></figure>
<p>要计算所有员工的平均薪资，可以使用以下查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) <span class="keyword">AS</span> average_salary</span><br><span class="line"><span class="keyword">FROM</span> Employees;</span><br></pre></td></tr></table></figure>
<p><strong>结果解释</strong>：此查询会计算 <code>Employees</code> 表中 <code>salary</code> 列的平均值，并将结果命名为 <code>average_salary</code>。</p>
<p>（二）使用 <code>DISTINCT</code> 计算不同值的平均值</p>
<p>假设 <code>Employees</code> 表中有一些重复的薪资值，现在要计算不同薪资值的平均值。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(<span class="keyword">DISTINCT</span> salary) <span class="keyword">AS</span> distinct_average_salary</span><br><span class="line"><span class="keyword">FROM</span> Employees;</span><br></pre></td></tr></table></figure>
<p><strong>结果解释</strong>：<code>DISTINCT</code> 关键字会先去除 <code>salary</code> 列中的重复值，然后 <code>AVG</code> 函数对这些不同的值计算平均值。</p>
<p>（三）结合 <code>GROUP BY</code> 子句按分组计算平均值</p>
<p>假设 <code>Employees</code> 表中还有一个 <code>department_id</code> 列，用于表示员工所属的部门，现在要计算每个部门的平均薪资。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 修改 Employees 表，添加 department_id 列</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Employees <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> department_id <span class="type">INT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 更新示例数据</span></span><br><span class="line"><span class="keyword">UPDATE</span> Employees <span class="keyword">SET</span> department_id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">WHERE</span> employee_id <span class="keyword">IN</span> (<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">UPDATE</span> Employees <span class="keyword">SET</span> department_id <span class="operator">=</span> <span class="number">2</span> <span class="keyword">WHERE</span> employee_id <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 按部门计算平均薪资</span></span><br><span class="line"><span class="keyword">SELECT</span> department_id, <span class="built_in">AVG</span>(salary) <span class="keyword">AS</span> average_salary</span><br><span class="line"><span class="keyword">FROM</span> Employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id;</span><br></pre></td></tr></table></figure>
<p><strong>结果解释</strong>：<code>GROUP BY</code> 子句会将员工按 <code>department_id</code> 分组，然后 <code>AVG</code> 函数分别计算每个组内 <code>salary</code> 列的平均值。</p>
<p>（四）结合 <code>WHERE</code> 子句计算满足条件的平均值</p>
<p>若要计算薪资大于 5500 的员工的平均薪资，可以使用 <code>WHERE</code> 子句进行筛选。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) <span class="keyword">AS</span> high_salary_average</span><br><span class="line"><span class="keyword">FROM</span> Employees</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> <span class="number">5500</span>;</span><br></pre></td></tr></table></figure>
<p><strong>结果解释</strong>：<code>WHERE</code> 子句会筛选出 <code>salary</code> 大于 5500 的员工记录，然后 <code>AVG</code> 函数对这些记录的 <code>salary</code> 列计算平均值。</p>
<p>注意事项</p>
<ol>
<li><strong><code>NULL</code> 值处理</strong>：<code>AVG</code> 函数会自动忽略 <code>NULL</code> 值。若要计算包含 <code>NULL</code> 值的列的平均值，需要先对 <code>NULL</code> 值进行处理，例如使用 <code>COALESCE</code> 函数将 <code>NULL</code> 值替换为合适的默认值。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(<span class="built_in">COALESCE</span>(salary, <span class="number">0</span>)) <span class="keyword">AS</span> average_salary</span><br><span class="line"><span class="keyword">FROM</span> Employees;</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>数据类型</strong>：<code>AVG</code> 函数只能用于数值类型的列。若对非数值类型的列使用 <code>AVG</code> 函数，会导致错误。</li>
<li><strong>性能考虑</strong>：在处理大量数据时，频繁使用 <code>AVG</code> 函数可能会影响性能。可以考虑在合适的列上创建索引，以提高查询效率。</li>
</ol>
<p>问题: <code>avg(case when rating &lt; 3 then 1 else 0 end)</code> 和 <code>avg(case when rating &lt; 3 then 1  end)</code> 有什么区别?</p>
<p><code>AVG(case when rating &lt; 3 then 1 else 0 end)</code></p>
<ul>
<li>这里的 <code>CASE</code> 表达式是一个完整的条件判断，对于每一行记录，当 <code>rating</code> 小于 3 时，表达式返回 1；当 <code>rating</code> 大于等于 3 时，表达式返回 0。</li>
<li><code>AVG</code> 函数会对这些 1 和 0 进行求平均值的操作。实际上，这个平均值代表的是 <code>rating</code> 小于 3 的记录在所有记录中所占的比例。</li>
</ul>
<p><code>AVG(case when rating &lt; 3 then 1 end)</code></p>
<ul>
<li><p>此 <code>CASE</code> 表达式没有 <code>ELSE</code> 部分，当 <code>rating</code> 小于 3 时，表达式返回 1；当 <code>rating</code> 大于等于 3 时，表达式返回 <code>NULL</code>。</p>
</li>
<li><h2 id="AVG-函数会忽略-NULL-值，只对返回-1-的记录进行计数，然后计算平均值。最终结果是-rating-小于-3-的记录数量除以-rating-小于-3-的记录数量，结果始终为-1。"><a href="#AVG-函数会忽略-NULL-值，只对返回-1-的记录进行计数，然后计算平均值。最终结果是-rating-小于-3-的记录数量除以-rating-小于-3-的记录数量，结果始终为-1。" class="headerlink" title="AVG 函数会忽略 NULL 值，只对返回 1 的记录进行计数，然后计算平均值。最终结果是 rating 小于 3 的记录数量除以 rating 小于 3 的记录数量，结果始终为 1。"></a><code>AVG</code> 函数会忽略 <code>NULL</code> 值，只对返回 1 的记录进行计数，然后计算平均值。最终结果是 <code>rating</code> 小于 3 的记录数量除以 <code>rating</code> 小于 3 的记录数量，结果始终为 1。</h2></li>
</ul>
<h2 id="Date-format"><a href="#Date-format" class="headerlink" title="Date_format"></a>Date_format</h2><p>基本语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DATE_FORMAT(<span class="type">date</span>, format)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>date</code></strong>：这是需要进行格式化的日期或日期时间表达式，可以是日期类型的列名，也可以是具体的日期值，例如 <code>&#39;2024-10-01&#39;</code> 。</li>
<li><strong><code>format</code></strong>：用于指定输出格式的字符串，其中包含各种格式说明符，这些说明符决定了日期和时间的显示方式。</li>
</ul>
<p>常用格式说明符</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>说明符</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>%Y</code></td>
<td>四位数的年份</td>
<td>2024</td>
</tr>
<tr>
<td><code>%y</code></td>
<td>两位数的年份</td>
<td>24</td>
</tr>
<tr>
<td><code>%m</code></td>
<td>两位数的月份（01 - 12）</td>
<td>03</td>
</tr>
<tr>
<td><code>%c</code></td>
<td>月份（1 - 12）</td>
<td>3</td>
</tr>
<tr>
<td><code>%d</code></td>
<td>两位数的日（01 - 31）</td>
<td>05</td>
</tr>
<tr>
<td><code>%e</code></td>
<td>日（1 - 31）</td>
<td>5</td>
</tr>
<tr>
<td><code>%H</code></td>
<td>24 小时制的小时数（00 - 23）</td>
<td>15</td>
</tr>
<tr>
<td><code>%h</code></td>
<td>12 小时制的小时数（01 - 12）</td>
<td>03</td>
</tr>
<tr>
<td><code>%i</code></td>
<td>分钟数（00 - 59）</td>
<td>30</td>
</tr>
<tr>
<td><code>%s</code></td>
<td>秒数（00 - 59）</td>
<td>45</td>
</tr>
<tr>
<td><code>%p</code></td>
<td>AM 或 PM</td>
<td>PM</td>
</tr>
</tbody>
</table>
</div>
<h1 id=""><a href="#" class="headerlink" title=" "></a> </h1><h1 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h1><p>约束可以在创建表时规定（通过 CREATE TABLE 语句），或者在表创建之后规定（通过 ALTER TABLE 语句）。</p>
<p>约束类型：</p>
<ul>
<li><code>NOT NULL</code> - 指示某列不能存储 NULL 值。</li>
<li><code>UNIQUE</code> - 保证某列的每行必须有唯一的值。</li>
<li><code>PRIMARY KEY</code> - NOT NULL 和 UNIQUE 的结合。确保某列（或两个列多个列的结合）有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。</li>
<li><code>FOREIGN KEY</code> - 保证一个表中的数据匹配另一个表中的值的参照完整性。</li>
<li><code>CHECK</code> - 保证列中的值符合指定的条件。</li>
<li><code>DEFAULT</code> - 规定没有给列赋值时的默认值。</li>
</ul>
<h1 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a><a href="#事务处理">事务处理</a></h1><p>不能回退 <code>SELECT</code> 语句，回退 <code>SELECT</code> 语句也没意义；也不能回退 <code>CREATE</code> 和 <code>DROP</code> 语句。</p>
<p><strong>MySQL 默认是隐式提交</strong>，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 <code>START TRANSACTION</code> 语句时，会关闭隐式提交；当 <code>COMMIT</code> 或 <code>ROLLBACK</code> 语句执行后，事务会自动关闭，重新恢复隐式提交。</p>
<p>通过 <code>set autocommit=0</code> 可以取消自动提交，直到 <code>set autocommit=1</code> 才会提交；<code>autocommit</code> 标记是针对每个连接而不是针对服务器的。</p>
<p>指令：</p>
<ul>
<li><p><code>START TRANSACTION</code> - 指令用于标记事务的起始点。</p>
</li>
<li><p><code>SAVEPOINT</code> - 指令用于创建保留点。</p>
</li>
<li><p><code>ROLLBACK TO</code> - 指令用于回滚到指定的保留点；如果没有设置保留点，则回退到 <code>START TRANSACTION</code> 语句处。</p>
</li>
<li><p><code>COMMIT</code> - 提交事务。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>sql语法</tag>
      </tags>
  </entry>
  <entry>
    <title>targan缩点</title>
    <url>/posts/3905b42d.html</url>
    <content><![CDATA[<p> &gt;</p>
<blockquote>
<p>用途：用来缩点（实际是用来缩强连通分量）</p>
<p>强连通分量：在有向图G中，如果两个顶点u，ｖ间有一条从ｕ到ｖ的有向路径，同时还有一条从ｖ到ｕ的有向路径，则称两个顶点强连通。如果有向图G的每两个顶点都强连通，称G是一个强连通图。有向非强连通图的极大强连通子图，称为强连通分量。</p>
</blockquote>
<h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><p>首先需要引入几个数组：</p>
<p>dfn[i]: 表示刚遍历到i号节点的时间戳</p>
<p>low[i]: 设以i为根的子树为Subtree(i)，low[i]定义为以下节点的dfn最小值：subtree(i)中的节点、从Subtree中连出一条不指向子树的边</p>
<p>idx[i]: 缩完强连通分量后i号节点后所在的缩点编号</p>
<p>siz[i]: 缩点的子树大小</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/image-20210909213353438.png" alt="image-20210909213353438"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/image-20210909213427976.png" alt="image-20210909213427976"></p>
<p>那么代码就可以写了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">targan</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">	dfn[x]=low[x]=++tim;</span><br><span class="line">	stk.push(x);</span><br><span class="line">	instk[x]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=h[x];~i;i=e[i].next)&#123;</span><br><span class="line">		<span class="type">int</span> v=e[i].to;</span><br><span class="line">		<span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line">			targan(v);</span><br><span class="line">			low[x]=min(low[v],low[x]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(instk[v]) low[x]=min(low[x],dfn[v]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(low[x]==dfn[x])&#123;</span><br><span class="line">		cnt++;</span><br><span class="line">		<span class="keyword">while</span>(stk.top()!=x)&#123;</span><br><span class="line">			siz[cnt]++;</span><br><span class="line">			idx[stk.top()]=cnt;</span><br><span class="line">			instk[stk.top()]=<span class="number">0</span>;</span><br><span class="line">			stk.pop();</span><br><span class="line">		&#125;</span><br><span class="line">		siz[cnt]++;</span><br><span class="line">		idx[stk.top()]=cnt;</span><br><span class="line">		instk[stk.top()]=<span class="number">0</span>;</span><br><span class="line">		stk.pop();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="受欢迎的牛"><a href="#受欢迎的牛" class="headerlink" title="受欢迎的牛"></a><a href="https://www.acwing.com/problem/content/1176/">受欢迎的牛</a></h2><p>本质就是求一个图上有多少个点可以被其他所有点到达</p>
<p>那么就可以先缩点，缩点后变成了一个有向无环图DAG，之后遍历所有边，如果这条边两端的点不属于一个强连通分量，那么这个边就是外部的边，则缩点出度加一，最后看一下如果出度为0的缩点数量&gt;=2，则不存在这样的牛，答案为0；如果只有一个出度为0的缩点，则这个缩点里面的点数就是答案。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0) </span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e4</span>+<span class="number">100</span>,M=<span class="number">5e4</span>+<span class="number">100</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> to,next;</span><br><span class="line">&#125;e[M];</span><br><span class="line"><span class="type">int</span> h[N],idx[N],dfn[N],out[N],low[N];</span><br><span class="line"><span class="type">int</span> siz[N];</span><br><span class="line"><span class="type">bool</span> instk[N];</span><br><span class="line"><span class="type">int</span> tot,n,m,cnt;</span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span>&#123;</span><br><span class="line">	e[tot]=&#123;v,h[u]&#125;;</span><br><span class="line">	h[u]=tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> tim;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line"><span class="type">void</span> <span class="title function_">targan</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">	dfn[x]=low[x]=++tim;</span><br><span class="line">	stk.push(x);</span><br><span class="line">	instk[x]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=h[x];~i;i=e[i].next)&#123;</span><br><span class="line">		<span class="type">int</span> v=e[i].to;</span><br><span class="line">		<span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line">			targan(v);</span><br><span class="line">			low[x]=min(low[v],low[x]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(instk[v]) low[x]=min(low[x],dfn[v]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(low[x]==dfn[x])&#123;</span><br><span class="line">		cnt++;</span><br><span class="line">		<span class="keyword">while</span>(stk.top()!=x)&#123;</span><br><span class="line">			siz[cnt]++;</span><br><span class="line">			idx[stk.top()]=cnt;</span><br><span class="line">			instk[stk.top()]=<span class="number">0</span>;</span><br><span class="line">			stk.pop();</span><br><span class="line">		&#125;</span><br><span class="line">		siz[cnt]++;</span><br><span class="line">		idx[stk.top()]=cnt;</span><br><span class="line">		instk[stk.top()]=<span class="number">0</span>;</span><br><span class="line">		stk.pop();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="type">int</span> u,v;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">		add(u,v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!dfn[i]) targan(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=h[i];~j;j=e[j].next)&#123;</span><br><span class="line">			<span class="keyword">if</span>(idx[i]!=idx[e[j].to]) out[idx[i]]++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>,js=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(out[i]==<span class="number">0</span>)&#123;</span><br><span class="line">			++js;</span><br><span class="line">			<span class="keyword">if</span>(js==<span class="number">2</span>)&#123;</span><br><span class="line">				ans=<span class="number">0</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			ans=siz[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>targan</tag>
      </tags>
  </entry>
  <entry>
    <title>凸包讲解</title>
    <url>/posts/4d10af4f.html</url>
    <content><![CDATA[<blockquote>
<p>凸包（百度百科）:</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/Sucai/20210208174637.png" style="zoom: 67%;" /></p>
</blockquote>
<p>讲解凸包之前先讲解一下极角排序、叉积</p>
<h2 id="叉积"><a href="#叉积" class="headerlink" title="叉积"></a>叉积</h2><p>就是数学上的叉乘，两个向量叉乘，有正有负，相乘的两个向量前后顺序颠倒符号相反，乘出来的的结果也是一个向量，值等于以这两个向量作为平行四边形的两条边长的面积，方向指向与两个向量垂直的方向，右手定则，拇指指向x轴弯向y轴大拇指指向方向就是叉积的方向</p>
<p>数学上叉积非常重要，利用它可以计算出来不规则图形的面积，只需要知道不规则图形的顶点坐标。</p>
<p><code>利用叉积求多边形面积</code></p>
<blockquote>
<p>两个向量的叉积值等于以这两个向量作边的平行四边形的面积</p>
<p>求多边形面积，就可以把多边形分解成许多三角形，求各个三角形面积加起来即可，从原点到各个点做向量，逆时针或者顺时针依次作叉积/2求和即可，顺时针和逆时针求出来的叉积方向不同，正负不同逆时针为正，顺时针为负</p>
<p>例题：HDU2036</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">&gt;<span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line">&gt;<span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)</span></span><br><span class="line">&gt;using namespace <span class="built_in">std</span>;</span><br><span class="line">&gt;<span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">&gt;<span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line">&gt;<span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">100</span>;</span><br><span class="line">&gt;<span class="type">const</span> <span class="type">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">&gt;<span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">&gt;<span class="type">const</span> <span class="type">int</span> SUB=<span class="number">-0x3f3f3f3f</span>;</span><br><span class="line">&gt;<span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-4</span>;</span><br><span class="line">&gt;<span class="type">const</span> <span class="type">double</span> E=<span class="built_in">exp</span>(<span class="number">1</span>);</span><br><span class="line">&gt;<span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line">&gt;<span class="type">int</span> n;</span><br><span class="line">&gt;<span class="type">double</span> ans;</span><br><span class="line">&gt;<span class="type">double</span> x[MAXN],y[MAXN];</span><br><span class="line">&gt;<span class="type">double</span> <span class="title function_">calc</span><span class="params">(<span class="type">double</span> x1,<span class="type">double</span> y1,<span class="type">double</span> x2,<span class="type">double</span> y2)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> x1*y2-x2*y1;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">ios;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">	ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;x[i]&gt;&gt;y[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">		ans+=calc(x[i+<span class="number">1</span>],y[i+<span class="number">1</span>],x[i],y[i])/<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ans+=calc(x[<span class="number">1</span>],y[<span class="number">1</span>],x[n],y[n])/<span class="number">2</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;fixed&lt;&lt;setprecision(<span class="number">1</span>)&lt;&lt;-ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="极角排序"><a href="#极角排序" class="headerlink" title="极角排序"></a>极角排序</h2><p>将一系列的点相对于一个基准点顺时针或者逆时针排序</p>
<p>两种方法</p>
<ol>
<li><p>利用叉积排序，叉积有正有负，两个向量交换顺序符号就会相反</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cross</span><span class="params">(point a,point b,point c)</span>&#123;</span><br><span class="line">	<span class="type">int</span> x1=b.x-a.x;</span><br><span class="line">	<span class="type">int</span> y1=b.y-a.y;</span><br><span class="line">	<span class="type">int</span> x2=c.x-a.x;</span><br><span class="line">	<span class="type">int</span> y2=c.y-a.y;</span><br><span class="line">	<span class="keyword">return</span> x1*y2-x2*y1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getxx</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;<span class="number">0</span> &amp;&amp; y&gt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(x&gt;<span class="number">0</span> &amp;&amp; y&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(x&lt;<span class="number">0</span> &amp;&amp; y&gt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(x&lt;<span class="number">0</span> &amp;&amp; y&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">cmp1</span><span class="params">(point a,point b)</span>&#123;</span><br><span class="line">	point c=&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="type">int</span> x1=a.x-c.x, y1=a.y-c.y;</span><br><span class="line">	<span class="type">int</span> x2=b.x-c.x, y2=b.y-c.y;</span><br><span class="line">	<span class="keyword">if</span>(getxx(x1,y1)!=getxx(x2,y2)) <span class="keyword">return</span> getxx(x1,y1)&lt;getxx(x2,y2);</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(cross(c,a,b)==<span class="number">0</span>) <span class="keyword">return</span> a.x&lt;b.x;</span><br><span class="line">		<span class="keyword">return</span> cross(c,a,b)&gt;<span class="number">0</span>;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>atan2，接受一个坐标，返回一个角度值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getxx</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;<span class="number">0</span> &amp;&amp; y&gt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(x&gt;<span class="number">0</span> &amp;&amp; y&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(x&lt;<span class="number">0</span> &amp;&amp; y&gt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(x&lt;<span class="number">0</span> &amp;&amp; y&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">cmp2</span><span class="params">(point a,point b)</span>&#123;	<span class="comment">//atan2排序</span></span><br><span class="line">	point c=&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="type">int</span> x1=a.x-c.x, y1=a.y-c.y;</span><br><span class="line">	<span class="type">int</span> x2=b.x-c.x, y2=b.y-c.y;</span><br><span class="line">	<span class="keyword">if</span>(getxx(x1,y1)!=getxx(x2,y2)) <span class="keyword">return</span> getxx(x1,y1)&lt;getxx(x2,y2);</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(getxx(x1,y1)==<span class="number">3</span> || getxx(x1,y1)==<span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">atan2</span>(-x1,-y1)!=<span class="built_in">atan2</span>(-x2,-y2)) <span class="keyword">return</span> <span class="built_in">atan2</span>(-y1,-x1)&gt;<span class="built_in">atan2</span>(-y2,-x2);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> a.x&gt;b.x; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">atan2</span>(x1,y1)!=<span class="built_in">atan2</span>(x2,y2)) <span class="keyword">return</span> <span class="built_in">atan2</span>(y1,x1)&lt;<span class="built_in">atan2</span>(y2,x2);</span><br><span class="line">	        <span class="keyword">else</span> <span class="keyword">return</span> a.x&lt;b.x;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>atan()和atan2是两个不同的函数</p>
<blockquote>
<p>atan(): 接受的是一个正切值（直线的斜率）得到夹角，但是由于正切的规律性本可以有两个角度的但它却只返回一个，因此值域是从-90~90 也就是它只处理一四象限，所以一般不用它。</p>
<p>atan2(double y,double x) 其中y代表已知点的Y坐标，同理x ,返回值是此点与远点连线与x轴正方向的夹角，这样它就可以处理四个象限的任意情况了，<code>它的值域相应的也就是-180~180了</code></p>
</blockquote>
<p>叉积速度慢，但是没有精度问题，atan2速度快，精度可能出现问题</p>
<p>:::warn</p>
<p>这里求凸包，极角排序最好根据y值最小的点为基准点，不要以原点为基准点，因为atan2的值域是[-pi,pi]，当点出现在x轴下面时，返回角度就是负的了，所以最好把所有点的向量都算成x轴上方！而且y值最小的点一定在凸包上的</p>
<p>:::</p>
<h2 id="凸包"><a href="#凸包" class="headerlink" title="凸包"></a>凸包</h2><p>找出所有点中最靠下且最靠左的坐标点，以这个点作为基准点进行极角排序，之后把前两个点放进去栈中(注意这里的栈不能用stl中的栈实现，因为还要取出倒数第二个元素)，从第三个点开始往后遍历，每次取出栈中前两个点和这个点做叉积，为负数表明内凹，就弹出栈顶元素再做叉积，直到叉积大于0就把这个点入栈，最后栈中元素就是凸包，算出栈中相邻两点的距离就是凸包距离。</p>
<p>例题: POJ1113</p>
<h2 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SUP=<span class="number">0x800000</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-4</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">&#125;p[MAXN],d[MAXN];</span><br><span class="line"><span class="type">int</span> n,m,top;</span><br><span class="line">node mi;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">cmp</span><span class="params">(node a,node b)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">atan2</span>(a.y-mi.y,a.x-mi.x)==<span class="built_in">atan2</span>(b.y-mi.y,b.x-mi.x)) <span class="keyword">return</span> a.x&lt;b.x;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">atan2</span>(a.y-mi.y,a.x-mi.x)&lt;<span class="built_in">atan2</span>(b.y-mi.y,b.x-mi.x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> <span class="title function_">getdis</span><span class="params">(node a,node b)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sqrt</span>((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">cross</span><span class="params">(node a,node b,node c)</span>&#123;</span><br><span class="line">	<span class="type">int</span> x1=b.x-a.x,y1=b.y-a.y;</span><br><span class="line">	<span class="type">int</span> x2=c.x-b.x,y2=c.y-b.y;</span><br><span class="line">	<span class="keyword">return</span> x1*y2-x2*y1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;fixed&lt;&lt;setprecision(<span class="number">0</span>)&lt;&lt;<span class="number">2</span>*pi*m&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	mi=&#123;INF,INF&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;p[i].x&gt;&gt;p[i].y;</span><br><span class="line">		<span class="keyword">if</span>(p[i].y&lt;mi.y || (p[i].y==mi.y &amp;&amp; p[i].x&lt;mi.x)) mi=p[i];</span><br><span class="line">	&#125;</span><br><span class="line">	sort(p+<span class="number">1</span>,p+<span class="number">1</span>+n,cmp);</span><br><span class="line">	d[<span class="number">0</span>]=p[<span class="number">1</span>];</span><br><span class="line">	d[<span class="number">1</span>]=p[<span class="number">2</span>];</span><br><span class="line">	top=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">while</span>(top&gt;=<span class="number">1</span> &amp;&amp; cross(d[top<span class="number">-1</span>],d[top],p[i])&lt;=<span class="number">0</span>) top--;  <span class="comment">//注意这里&lt;=可以减少凸包上的点，比较好的优化</span></span><br><span class="line">		d[++top]=p[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(top&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(top==<span class="number">2</span>) ans+=getdis(st[<span class="number">1</span>],st[<span class="number">2</span>]);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;fixed&lt;&lt;setprecision(<span class="number">0</span>)&lt;&lt;ans*<span class="number">2</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">double</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=top;i++) ans+=getdis(d[i<span class="number">-1</span>],d[i]);</span><br><span class="line">	ans+=getdis(d[<span class="number">0</span>],d[top])+<span class="number">2</span>*pi*m;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;fixed&lt;&lt;setprecision(<span class="number">0</span>)&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="最小外接圆"><a href="#最小外接圆" class="headerlink" title="最小外接圆"></a>最小外接圆</h2><p><a href="">POJ-2215</a></p>
<p>给定n个点坐标，求最小外接圆</p>
<p>求一个凸包，枚举凸包上的3个点，3个点确定一个⚪，当三个点组成钝角三角形，半径就是最长边的一半，否则面积就是a*b*c/(4*S)，S通过叉积求即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SUB=<span class="number">-0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-4</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> E=<span class="built_in">exp</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="type">double</span> x,y;</span><br><span class="line">&#125;p[MAXN],st[MAXN];</span><br><span class="line">node bas;</span><br><span class="line"><span class="type">int</span> n,top; </span><br><span class="line"><span class="type">bool</span> <span class="title function_">cmp</span><span class="params">(node a,node b)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">atan2</span>(a.y-bas.y,a.x-bas.x)==<span class="built_in">atan2</span>(b.y-bas.y,b.x-bas.x)) <span class="keyword">return</span> a.x&lt;b.x;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">atan2</span>(a.y-bas.y,a.x-bas.x)&lt;<span class="built_in">atan2</span>(b.y-bas.y,b.x-bas.x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> <span class="title function_">cross</span><span class="params">(node a,node b,node c)</span>&#123;</span><br><span class="line">	<span class="type">double</span> x1=b.x-a.x,y1=b.y-a.y;</span><br><span class="line">	<span class="type">double</span> x2=c.x-b.x,y2=c.y-b.y;</span><br><span class="line">	<span class="keyword">return</span> x1*y2-x2*y1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> <span class="title function_">getdis</span><span class="params">(node a,node b)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sqrt</span>((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isdun</span><span class="params">(<span class="type">double</span> a,<span class="type">double</span> b,<span class="type">double</span> c)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(a*a+b*b&lt;c*c || a*a+c*c&lt;b*b || b*b+c*c&lt;a*a)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//是钝角三角形</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n &amp;&amp; n)&#123;</span><br><span class="line">		top=<span class="number">0</span>;</span><br><span class="line">		bas=&#123;INF,INF&#125;;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;p[i].x&gt;&gt;p[i].y;</span><br><span class="line">			<span class="keyword">if</span>(p[i].y&lt;bas.y || (p[i].y==bas.y &amp;&amp; p[i].x&lt;bas.x)) bas=p[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;0.50&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		sort(p+<span class="number">1</span>,p+<span class="number">1</span>+n,cmp);</span><br><span class="line">		st[++top]=p[<span class="number">1</span>];</span><br><span class="line">		st[++top]=p[<span class="number">2</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="keyword">while</span>(top&gt;<span class="number">1</span> &amp;&amp; cross(st[top<span class="number">-1</span>],st[top],p[i])&lt;=<span class="number">0</span>) --top;</span><br><span class="line">			st[++top]=p[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(top==<span class="number">2</span>)&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;fixed&lt;&lt;setprecision(<span class="number">2</span>)&lt;&lt;getdis(st[<span class="number">1</span>],st[<span class="number">2</span>])/<span class="number">2</span>+<span class="number">0.5</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">double</span> ans=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=top;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=top;j++)&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> k=j+<span class="number">1</span>;k&lt;=top;k++)&#123;</span><br><span class="line">					<span class="type">double</span> dis1=getdis(st[i],st[j]);</span><br><span class="line">					<span class="type">double</span> dis2=getdis(st[j],st[k]);</span><br><span class="line">					<span class="type">double</span> dis3=getdis(st[i],st[k]);</span><br><span class="line">					<span class="keyword">if</span>(isdun(dis1,dis2,dis3))&#123;</span><br><span class="line">						<span class="type">double</span> len=max(max(dis1,dis2),dis3);</span><br><span class="line">						ans=max(len/<span class="number">2</span>,ans);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span>&#123;</span><br><span class="line">						<span class="type">double</span> S=<span class="built_in">fabs</span>(cross(st[i],st[j],st[k]))/<span class="number">2</span>;</span><br><span class="line">						ans=max(ans,dis1*dis2*dis3/(<span class="number">4</span>*S));</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;fixed&lt;&lt;setprecision(<span class="number">2</span>)&lt;&lt;ans+<span class="number">0.5</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>凸包</tag>
      </tags>
  </entry>
  <entry>
    <title>主席树</title>
    <url>/posts/fbeda914.html</url>
    <content><![CDATA[<h1 id="主席树-可持续化权值线段树"><a href="#主席树-可持续化权值线段树" class="headerlink" title="主席树(可持续化权值线段树)"></a>主席树(可持续化权值线段树)</h1><blockquote>
<p>可持续化系列的一种数据结构，可以保存修改的版本，本质上是一种可持续化权值线段树</p>
</blockquote>
<h2 id="区间第k小"><a href="#区间第k小" class="headerlink" title="区间第k小"></a>区间第k小</h2><p>倘若不是区间，而是每次求所有值的第k小，一个权值线段树就搞定了，将所有数离散化一下，将数值作为插入位置建树，之后查询第k小时，如果左子树插入点数量大于k就在右子树上，否则就在左子树上，这样就能第k小的数在排好序的数组中排第几个了，每次修改花费logn时间，查询也花费logn时间</p>
<p>而如果现在变成了区间第k小，单纯的线段树就维护不了了，因为无法保存过去的信息，如果可以保存过去没有修改过的信息就好了，（<del>每次修改都建一颗新树，空间炸不炸呀</del>），其实容易想到修改一个点后，变动的点只是这个点的所有祖宗节点（包括父亲节点），只有logn个（n个点的树深度最多是logn），所以可以拉出来一条链来保存修改过的信息</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/20210410213132.png" alt="image-20210410213123576" style="zoom:50%;" /></p>
<p>如图，红色的链就是修改过的信息</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/20210410213507.png" alt="image-20210410213503619" style="zoom:50%;" /></p>
<p>主席树因为要保存版本信息，无法用2*id表示左孩子那种方式建树，要用朴素的lson和rson数组表示左右孩子</p>
<h2 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h2><p>主席树本质就是前缀权值线段树，权值线段树保存的是每一个区间的值的个数，而主席树就是对每一个前缀都建了一棵树，只不过是优化了空间，并没有真的建出一棵树，在一棵树上拉出了几条链，查询区间第k小时，就用r版本的树减去l-1版本的树，得到的就是这个区间的树</p>
<h2 id="洛谷P3834"><a href="#洛谷P3834" class="headerlink" title="洛谷P3834"></a><a href="https://www.luogu.com.cn/problem/P3834">洛谷P3834</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#pragma G++ optimize(2)</span></span><br><span class="line"><span class="comment">//#pragma G++ optimize(3,&quot;Ofast&quot;,&quot;inline&quot;)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SUB=<span class="number">-0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-4</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> E=<span class="built_in">exp</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> lson,rson,sum;</span><br><span class="line">&#125;hjt[MAXN*<span class="number">5</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">name</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> id,val,fak;</span><br><span class="line">&#125;arr[MAXN];</span><br><span class="line"><span class="type">int</span> bak[MAXN];</span><br><span class="line"><span class="type">int</span> root[MAXN*<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> n,m,k,cnt,mid;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">cmp1</span><span class="params">(name a,name b)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.val&lt;b.val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">cmp2</span><span class="params">(name a,name b)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.id&lt;b.id;</span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">	<span class="type">int</span> rt=++cnt;  <span class="comment">//分配空间 </span></span><br><span class="line">	<span class="keyword">if</span>(l==r) <span class="keyword">return</span> rt;  <span class="comment">//如果这个节点是叶子节点(不是管理员)就返回这个节点的编号 </span></span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	hjt[rt].lson=build(l,mid);  <span class="comment">//建立这个节点的左子树 </span></span><br><span class="line">	hjt[rt].rson=build(mid+<span class="number">1</span>,r);</span><br><span class="line">	<span class="keyword">return</span> rt;  <span class="comment">//返回根节点 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> pre,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> pos)</span>&#123;</span><br><span class="line">	<span class="type">int</span> rt=++cnt;  <span class="comment">//分配空间</span></span><br><span class="line">	hjt[rt]=hjt[pre];  <span class="comment">//在前一个版本的基础上建树</span></span><br><span class="line">	hjt[rt].sum++;  <span class="comment">//当前版本多了一个值 </span></span><br><span class="line">	<span class="keyword">if</span>(l==r)  <span class="keyword">return</span> rt;  <span class="comment">//叶子节点直接返回，表示已经建好当前版本了</span></span><br><span class="line">	mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(pos&lt;=mid) hjt[rt].lson=insert(hjt[pre].lson,l,mid,pos);</span><br><span class="line">	<span class="keyword">else</span> hjt[rt].rson=insert(hjt[pre].rson,mid+<span class="number">1</span>,r,pos); </span><br><span class="line">	<span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r) <span class="keyword">return</span> l;</span><br><span class="line">	<span class="type">int</span> cha=hjt[hjt[v].lson].sum-hjt[hjt[u].lson].sum;</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(cha&gt;=k) <span class="keyword">return</span> query(hjt[u].lson,hjt[v].lson,l,mid,k);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> query(hjt[u].rson,hjt[v].rson,mid+<span class="number">1</span>,r,k-cha);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;arr[i].val;</span><br><span class="line">		bak[i]=arr[i].val;</span><br><span class="line">		arr[i].id=i;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(bak+<span class="number">1</span>,bak+<span class="number">1</span>+n);</span><br><span class="line">	sort(arr+<span class="number">1</span>,arr+<span class="number">1</span>+n,cmp1);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) arr[i].fak=i;</span><br><span class="line">	sort(arr+<span class="number">1</span>,arr+<span class="number">1</span>+n,cmp2);</span><br><span class="line">	root[<span class="number">0</span>]=build(<span class="number">1</span>,n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) root[i]=insert(root[i<span class="number">-1</span>],<span class="number">1</span>,n,arr[i].fak);</span><br><span class="line"><span class="comment">//	for(int i=0;i&lt;=n;i++) cout&lt;&lt;hjt[root[i]].sum&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line"><span class="comment">//	cout&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="type">int</span> l,r;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r&gt;&gt;k;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;bak[query(root[l<span class="number">-1</span>],root[r],<span class="number">1</span>,n,k)]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title>三分</title>
    <url>/posts/d459644e.html</url>
    <content><![CDATA[<h2 id="POJ2420"><a href="#POJ2420" class="headerlink" title="POJ2420"></a>POJ2420</h2><p>三分和二分输出答案是l还是r就看中间的判断条件，不满足条件更新的那个值就是要输出的值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-5</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N],b[N];</span><br><span class="line"><span class="type">double</span> <span class="title function_">getdis</span><span class="params">(<span class="type">double</span> x,<span class="type">double</span> y)</span>&#123;</span><br><span class="line">	<span class="type">double</span> res=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) res+=<span class="built_in">sqrt</span>(<span class="built_in">pow</span>(x-a[i],<span class="number">2</span>)+<span class="built_in">pow</span>(y-b[i],<span class="number">2</span>));</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> <span class="title function_">work</span><span class="params">(<span class="type">double</span> x)</span>&#123;</span><br><span class="line">	<span class="type">double</span> l=<span class="number">0</span>,r=<span class="number">10000</span>,lmid,rmid;</span><br><span class="line">	<span class="keyword">while</span>(r-l&gt;eps)&#123;</span><br><span class="line">		lmid=l+(r-l)/<span class="number">3</span>;</span><br><span class="line">		rmid=r-(r-l)/<span class="number">3</span>;</span><br><span class="line">		<span class="keyword">if</span>(getdis(x,lmid)&gt;getdis(x,rmid)) l=lmid;</span><br><span class="line">		<span class="keyword">else</span> r=rmid;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> getdis(x,lmid);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;a[i]&gt;&gt;b[i];</span><br><span class="line">	<span class="type">double</span> l=<span class="number">0</span>,r=<span class="number">10000</span>,lmid,rmid;</span><br><span class="line">	<span class="keyword">while</span>(r-l&gt;eps)&#123;</span><br><span class="line">		lmid=l+(r-l)/<span class="number">3</span>;</span><br><span class="line">		rmid=r-(r-l)/<span class="number">3</span>;</span><br><span class="line">		<span class="keyword">if</span>(work(lmid)&gt;work(rmid)) l=lmid;</span><br><span class="line">		<span class="keyword">else</span> r=rmid;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;fixed&lt;&lt;setprecision(<span class="number">0</span>)&lt;&lt;work(l)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>三分</tag>
      </tags>
  </entry>
  <entry>
    <title>事务隔离级别及实现方式</title>
    <url>/posts/3db80a64.html</url>
    <content><![CDATA[<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h2 id="按锁的粒度分类"><a href="#按锁的粒度分类" class="headerlink" title="按锁的粒度分类"></a>按锁的粒度分类</h2><ul>
<li><p><strong>记录锁（Record Lock）</strong>：属于单个行记录上的锁。</p>
</li>
<li><p><strong>间隙锁（Gap Lock）</strong>：锁定一个范围，不包括记录本身，间隙锁之间不冲突，不分排他和共享。</p>
</li>
<li><p><strong>临键锁（Next-Key Lock）</strong>：Record Lock+Gap Lock，锁定一个范围，包含记录本身，主要目的是为了解决幻读问题（MySQL 事务部分提到过）。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁，左开右闭。</p>
<p>在 InnoDB 默认的隔离级别 REPEATABLE-READ 下，行锁默认使用的是 Next-Key Lock。但是，如果操作的索引是唯一索引或主键，InnoDB 会对 Next-Key Lock 进行优化，将其降级为 Record Lock，即仅锁住索引本身，而不是范围。</p>
</li>
<li><p><strong>表级锁</strong>：锁定整张表。</p>
</li>
</ul>
<p>这里只提一点，行级锁锁住的是索引字段，而表级锁才是在物理存储上锁住了表，没有命中唯一索引或者索引失效的话，就会导致扫描全表对表中的所有行记录进行加锁。不过，很多时候即使用了索引也有可能会走全表扫描，这是因为 MySQL 优化器的原因，一些情况下全表扫描更快，比如<strong>索引碎片化严重</strong>。</p>
<h2 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h2><p><strong>意向共享锁（Intention Shared Lock，IS 锁）</strong>：事务有意向对表中的某些记录加共享锁（S 锁），加共享锁前必须先取得该表的 IS 锁。</p>
<p><strong>意向排他锁（Intention Exclusive Lock，IX 锁）</strong>：事务有意向对表中的某些记录加排他锁（X 锁），加排他锁之前必须先取得该表的 IX 锁。</p>
<p><strong>意向锁是由数据引擎自己维护的，用户无法手动操作意向锁，在为数据行加共享/排他锁之前，InnoDB 会先获取该数据行所在在数据表的对应意向锁。</strong></p>
<p>意向锁之间是互相兼容的。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>IS 锁</th>
<th>IX 锁</th>
</tr>
</thead>
<tbody>
<tr>
<td>IS 锁</td>
<td>兼容</td>
<td>兼容</td>
</tr>
<tr>
<td>IX 锁</td>
<td>兼容</td>
<td>兼容</td>
</tr>
</tbody>
</table>
</div>
<p>意向锁和共享锁和排它锁互斥（这里指的是表级别的共享锁和排他锁，意向锁不会与行级的共享锁和排他锁互斥）。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>IS 锁</th>
<th>IX 锁</th>
</tr>
</thead>
<tbody>
<tr>
<td>S 锁</td>
<td>兼容</td>
<td>互斥</td>
</tr>
<tr>
<td>X 锁</td>
<td>互斥</td>
<td>互斥</td>
</tr>
</tbody>
</table>
</div>
<h3 id="协调表级锁和行级锁的操作"><a href="#协调表级锁和行级锁的操作" class="headerlink" title="协调表级锁和行级锁的操作"></a>协调表级锁和行级锁的操作</h3><p>在数据库中，存在表级锁和行级锁两种不同粒度的锁。当一个事务想要对表加表级锁时，需要知道表中是否有行已经被其他事务加了行级锁；反之，当一个事务想要对行加行级锁时，也需要知道表是否已经被其他事务加了表级锁。意向锁的引入就是为了协调这两种不同粒度锁之间的操作。</p>
<ul>
<li><strong>示例</strong>：假设事务 A 想要对表 <code>employees</code> 中的某一行加行级排他锁。在加锁之前，InnoDB 会先在表级别上加一个意向排他锁（IX 锁），表示事务 A 意图在表中的某些行上加排他锁。如果此时另一个事务 B 想要对整个 <code>employees</code> 表加表级排他锁，它会检查到表上已经有了意向排他锁，就知道表中可能有行已经被加了行级锁，从而避免直接加表级锁导致的冲突。</li>
</ul>
<h3 id="提高加锁效率"><a href="#提高加锁效率" class="headerlink" title="提高加锁效率"></a>提高加锁效率</h3><p>如果没有意向锁，当一个事务要对表加表级锁时，需要遍历表中的每一行，检查是否有行被加了行级锁，这会带来很大的开销。而意向锁的存在可以让事务快速判断表中是否有行被加了锁。</p>
<ul>
<li><strong>示例</strong>：事务 C 要对 <code>orders</code> 表加表级共享锁（S 锁），如果表上没有意向排他锁（IX 锁），事务 C 可以直接加表级共享锁，无需逐行检查。因为意向排他锁表示有事务意图在表中的行上加排他锁，若没有该意向锁，就说明当前不太可能存在行级排他锁，从而提高了加锁的效率。</li>
</ul>
<h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h3><p>意向锁可以帮助数据库提前检测到潜在的锁冲突，从而避免死锁的发生。当一个事务请求的锁与当前表上的意向锁不兼容时，数据库可以及时拒绝该请求，避免事务进入等待状态，进而减少死锁的可能性。</p>
<ul>
<li><strong>示例</strong>：事务 D 想要对 <code>products</code> 表加表级排他锁，而此时表上已经有了意向共享锁（IS 锁），这表明有其他事务可能已经在表中的某些行上加了行级共享锁。数据库检测到这种不兼容性后，会拒绝事务 D 的请求，避免事务 D 等待行级锁释放而与其他事务形成死锁。</li>
</ul>
<h3 id="保证事务隔离性"><a href="#保证事务隔离性" class="headerlink" title="保证事务隔离性"></a>保证事务隔离性</h3><p>意向锁有助于维护不同事务之间的隔离性。通过明确表示事务对表和行的锁定意图，不同事务可以根据这些信息来决定是否可以安全地访问数据，从而保证了事务的隔离级别。</p>
<ul>
<li><strong>示例</strong>：在可重复读隔离级别下，事务 E 对 <code>customers</code> 表中的某些行加了行级排他锁，并在表级别上加了意向排他锁。其他事务在看到表上的意向排他锁后，会根据自身的隔离级别和操作需求，决定是否等待或者放弃对该表的操作，从而保证了事务之间的数据隔离。</li>
</ul>
<h2 id="自增锁"><a href="#自增锁" class="headerlink" title="自增锁"></a>自增锁</h2><p>自增锁有以下三种模式：</p>
<ul>
<li>传统模式：使用表级锁，确保只有一个事务在插入数据。</li>
<li>连续模式：如果可以确定插入的数据数量，就可以提前将这部分的自增ID留出来，在自增时使用mutex互斥锁保证生成的ID不重复，例如insert 10条数据，如今ID为10，就会把10~19这10条ID预留出来，其他事务从20开始自增；如果不确定插入的数据数量，则只能加表锁，退化为传统模式。</li>
<li>无锁模式：只对自增ID的过程加上mutex轻量级锁，其他过程一概不管，会造成多个事务的insert语句交替执行，导致一个事务内的多条连续插入数据ID不连续，<strong>这种模式与Binlog的statement模式冲突，因为相同的statement，在主从服务器插入的ID顺序是不一样的，如果采用statement模式，必须使用连续模式或者传统模式。</strong></li>
</ul>
<p>分别对应配置项 <code>innodb_autoinc_lock_mode</code> 的值0、1、2.</p>
<h2 id="元数据锁"><a href="#元数据锁" class="headerlink" title="元数据锁"></a>元数据锁</h2><p>再来说说<strong>元数据锁</strong>（MDL）。</p>
<p>我们不需要显示的使用 MDL，因为当我们对数据库表进行操作时，会自动给这个表加上 MDL：</p>
<ul>
<li>对一张表进行 CRUD 操作时，加的是 <strong>MDL 读锁</strong>；</li>
<li>对一张表做结构变更操作的时候，加的是 <strong>MDL 写锁</strong>；</li>
</ul>
<p>MDL 是为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更。</p>
<p>当有线程在执行 select 语句（ 加 MDL 读锁）的期间，如果有其他线程要更改该表的结构（ 申请 MDL 写锁），那么将会被阻塞，直到执行完 select 语句（ 释放 MDL 读锁）。</p>
<p>反之，当有线程对表结构进行变更（ 加 MDL 写锁）的期间，如果有其他线程执行了 CRUD 操作（ 申请 MDL 读锁），那么就会被阻塞，直到表结构变更完成（ 释放 MDL 写锁）。</p>
<blockquote>
<p>MDL 不需要显示调用，那它是在什么时候释放的?</p>
</blockquote>
<p>MDL 是在事务提交后才会释放，这意味着<strong>事务执行期间，MDL 是一直持有的</strong>。</p>
<p>那如果数据库有一个长事务（所谓的长事务，就是开启了事务，但是一直还没提交），那在对表结构做变更操作的时候，可能会发生意想不到的事情，比如下面这个顺序的场景：</p>
<ol>
<li>首先，线程 A 先启用了事务（但是一直不提交），然后执行一条 select 语句，此时就先对该表加上 MDL 读锁；</li>
<li>然后，线程 B 也执行了同样的 select 语句，此时并不会阻塞，因为「读读」并不冲突；</li>
<li>接着，线程 C 修改了表字段，此时由于线程 A 的事务并没有提交，也就是 MDL 读锁还在占用着，这时线程 C 就无法申请到 MDL 写锁，就会被阻塞，</li>
</ol>
<p>那么在线程 C 阻塞后，后续有对该表的 select 语句，就都会被阻塞，如果此时有大量该表的 select 语句的请求到来，就会有大量的线程被阻塞住，这时数据库的线程很快就会爆满了。</p>
<blockquote>
<p>为什么线程 C 因为申请不到 MDL 写锁，而导致后续的申请读锁的查询操作也会被阻塞？</p>
</blockquote>
<p>这是因为申请 MDL 锁的操作会形成一个队列，队列中<strong>写锁获取优先级高于读锁</strong>，一旦出现 MDL 写锁等待，会阻塞后续该表的所有 CRUD 操作。</p>
<p>所以为了能安全的对表结构进行变更，在对表结构变更前，先要看看数据库中的长事务，是否有事务已经对表加上了 MDL 读锁，如果可以考虑 kill 掉这个长事务，然后再做表结构的变更。</p>
<h1 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h1><div class="table-container">
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>解决的问题</th>
<th>未解决的问题/副作用</th>
<th>典型应用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>读未提交</strong><br>(Read Uncommitted)</td>
<td>- 无明确解决的问题<br>- 允许读取其他未提交事务的修改（最低隔离性）</td>
<td>- 脏读（Dirty Read）<br>- 不可重复读（Non-Repeatable Read）<br>- 幻读（Phantom Read）</td>
<td>对数据一致性要求极低，追求最高并发性能的场景</td>
</tr>
<tr>
<td><strong>读已提交</strong><br>(Read Committed)</td>
<td>- 解决<strong>脏读</strong><br>（只能读取已提交的数据）</td>
<td>- 不可重复读<br>- 幻读</td>
<td>多数 OLTP 系统的默认级别（如 Oracle）</td>
</tr>
<tr>
<td><strong>可重复读</strong><br>(Repeatable Read)</td>
<td>- 解决<strong>脏读</strong>和<strong>不可重复读</strong><br>（事务期间多次读取同一数据结果一致）</td>
<td>- 幻读（标准 SQL 定义允许，但 MySQL 通过 MVCC 规避）</td>
<td>需要保证事务内数据稳定的场景（如 MySQL 默认级别）</td>
</tr>
<tr>
<td><strong>串行化</strong><br>(Serializable)</td>
<td>- 解决<strong>脏读</strong>、<strong>不可重复读</strong>和<strong>幻读</strong><br>（通过完全锁表实现最高隔离性）</td>
<td>- 并发性能极低<br>- 可能引发死锁</td>
<td>对数据一致性要求极高，可接受低并发的场景</td>
</tr>
</tbody>
</table>
</div>
<p>在 <strong>读已提交（Read Committed）</strong> 和 <strong>可重复读（Repeatable Read）</strong> 隔离级别下，行级锁的行为因具体数据库实现（如 MySQL、PostgreSQL）和是否使用 MVCC（多版本并发控制）而有所不同，但核心逻辑如下：</p>
<hr>
<h2 id="1-读已提交（Read-Committed）"><a href="#1-读已提交（Read-Committed）" class="headerlink" title="1. 读已提交（Read Committed）"></a><strong>1. 读已提交（Read Committed）</strong></h2><p><strong>锁机制</strong>：</p>
<ul>
<li><strong>写操作（UPDATE/DELETE）</strong>：对修改的行加<strong>排他锁（X 锁）</strong>，其他事务无法修改或加排他锁，但允许读取（取决于是否用 MVCC）。</li>
<li><strong>读操作（SELECT）</strong>：  <ul>
<li><strong>无锁</strong>：若数据库使用 MVCC（如 PostgreSQL），读操作直接读取已提交的快照，不加锁。</li>
<li><strong>共享锁（S 锁）</strong>：若数据库不加 MVCC（如旧版本 SQL Server），读操作会对行加共享锁，但共享锁在语句执行后立即释放。</li>
</ul>
</li>
</ul>
<p><strong>并发行为</strong>：</p>
<ul>
<li><strong>写阻塞写</strong>：事务 A 对行加排他锁后，事务 B 的写操作会被阻塞，直到锁释放。</li>
<li><strong>读不阻塞读</strong>：共享锁允许多个事务同时读取同一行。</li>
<li><strong>读可能读到最新提交</strong>：MVCC 下读操作不会阻塞写，但可能读到其他事务已提交的新数据。</li>
</ul>
<hr>
<h2 id="2-可重复读（Repeatable-Read）"><a href="#2-可重复读（Repeatable-Read）" class="headerlink" title="2. 可重复读（Repeatable Read）"></a><strong>2. 可重复读（Repeatable Read）</strong></h2><p><strong>锁机制</strong>：</p>
<ul>
<li><strong>写操作（UPDATE/DELETE）</strong>：对修改的行加<strong>排他锁（X 锁）</strong>，直到事务结束。</li>
<li><strong>读操作（SELECT）</strong>：  <ul>
<li><strong>快照读（MVCC 实现）</strong>：如 MySQL InnoDB，通过版本快照实现可重复读，不加锁。</li>
<li><strong>当前读（临键 S 锁）</strong>：若数据库强制加锁（如某些场景下的 <code>SELECT ... FOR SHARE/UPDATE</code>），共享锁会持续到事务结束，临键锁可以用来解决幻读问题。</li>
</ul>
</li>
</ul>
<p><strong>并发行为</strong>：</p>
<ul>
<li><strong>写阻塞写</strong>：排他锁会阻塞其他事务的写操作。</li>
<li><strong>读不阻塞读</strong>：MVCC 下读操作无锁，直接读取快照；若强制加共享锁，共享锁允许多个事务同时读。</li>
<li><strong>避免幻读</strong>：通过范围锁（如 MySQL 的间隙锁）或 MVCC 快照保证事务内多次读取结果一致。</li>
</ul>
<h2 id="3-串行化（Serializable）"><a href="#3-串行化（Serializable）" class="headerlink" title="3. 串行化（Serializable）"></a>3. 串行化（Serializable）</h2><p><strong>锁机制</strong></p>
<ul>
<li><p><strong>写操作（UPDATE/DELETE/INSERT）</strong>： </p>
<ul>
<li>会对涉及的数据（如表、行或索引范围）加 <strong>排他锁（X锁，Exclusive Lock）</strong>，不仅锁住数据行，还用间隙锁锁住了间隙，阻止其他事务读取或修改这些数据。</li>
<li>如果操作涉及全表扫描（例如无索引的更新），可能会直接加 <strong>表级排他锁</strong>。</li>
</ul>
</li>
<li><p><strong>读操作（SELECT）</strong>：  </p>
<ul>
<li>会对涉及的数据加 <strong>共享锁（S锁，Shared Lock）</strong>，允许其他事务读取同一数据，但阻止其他事务加排他锁（X锁）进行修改。</li>
<li>如果查询涉及全表扫描（例如无索引的 <code>SELECT *</code>），为了防止幻读（Phantom Read），可能会加 <strong>表级共享锁</strong> 或 <strong>范围锁（Range Lock）</strong>，从而阻止其他事务插入、删除或修改相关数据</li>
</ul>
</li>
</ul>
<p><strong>并发行为</strong></p>
<ol>
<li><strong>写阻塞一切</strong>：<br>表级锁阻塞其他一切操作。</li>
<li><strong>读可能阻塞写</strong>：<br>若读操作显式加锁（如 <code>SELECT ... FOR SHARE</code>），会阻止其他事务对该行加排他锁。</li>
<li><strong>全隔离性</strong>：<br>通过锁或事务序列化彻底避免脏读、不可重复读和幻读，但并发性能显著下降。</li>
</ol>
<h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><h3 id="问题定义"><a href="#问题定义" class="headerlink" title="问题定义"></a>问题定义</h3><div class="table-container">
<table>
<thead>
<tr>
<th>问题名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>脏读</strong></td>
<td>读取到其他事务未提交的修改（若事务回滚则数据无效）</td>
</tr>
<tr>
<td><strong>不可重复读</strong></td>
<td>同一事务内多次读取同一行数据，结果不一致（因其他事务提交了修改）</td>
</tr>
<tr>
<td><strong>幻读</strong></td>
<td>同一事务内多次查询同一范围数据，结果集行数变化（因其他事务提交了新增/删除）</td>
</tr>
</tbody>
</table>
</div>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">特性</th>
<th>读未提交</th>
<th>读已提交</th>
<th>可重复读</th>
<th>串行化</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>并发性能</strong></td>
<td>最高</td>
<td>高</td>
<td>中</td>
<td>最低</td>
</tr>
<tr>
<td style="text-align:center"><strong>数据一致性</strong></td>
<td>最低</td>
<td>中等</td>
<td>高</td>
<td>最高</td>
</tr>
<tr>
<td style="text-align:center"><strong>锁粒度</strong></td>
<td>无锁</td>
<td>行级锁</td>
<td>行级锁</td>
<td>表级锁</td>
</tr>
</tbody>
</table>
</div>
<h3 id="行锁升级为表锁的情况"><a href="#行锁升级为表锁的情况" class="headerlink" title="行锁升级为表锁的情况"></a>行锁升级为表锁的情况</h3><div class="table-container">
<table>
<thead>
<tr>
<th>情况</th>
<th>描述</th>
<th>原因</th>
</tr>
</thead>
<tbody>
<tr>
<td>未使用索引</td>
<td>UPDATE 语句的 WHERE 子句中没有使用索引，导致全表扫描</td>
<td>name 列上没有索引，导致全表扫描</td>
</tr>
<tr>
<td>类型转换</td>
<td>WHERE 子句中的条件涉及到数据类型转换，MySQL 无法使用索引</td>
<td>name 列的数据类型是 VARCHAR，查询条件使用了数字类型</td>
</tr>
<tr>
<td>索引选择</td>
<td>即使 WHERE 子句中使用了索引，MySQL 的查询优化器也可能选择不使用索引，而是进行全表扫描</td>
<td>age 列上有索引，但匹配了表中大部分行</td>
</tr>
<tr>
<td>并发更新大量数据</td>
<td>当 UPDATE 语句影响表中大部分数据（通常是超过 80% 的数据）时，MySQL 可能会选择使用表锁</td>
<td>影响了表中大部分行</td>
</tr>
<tr>
<td>DDL 操作</td>
<td>在执行数据定义语言（DDL）操作时，如 ALTER TABLE 、TRUNCATE TABLE 等，MySQL 会自动对表进行锁定</td>
<td>DDL 操作需要确保操作的一致性和完整性</td>
</tr>
<tr>
<td>手动锁定表</td>
<td>使用 LOCK TABLES 语句手动锁定表时，MySQL 会直接对整个表进行锁定</td>
<td>LOCK TABLES 语句直接对表进行写锁定</td>
</tr>
<tr>
<td>意向锁</td>
<td>在某些情况下，即使 UPDATE 语句使用了索引，InnoDB 也可能因为意向锁（Intention Locks）的存在而升级行锁为表锁</td>
<td>事务中的 SELECT … FOR UPDATE 语句可能影响大量行</td>
</tr>
</tbody>
</table>
</div>
<h1 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h1><p>读未提交和串行化比较极端，一个是什么也不管，放任各个事务执行，一个是强制只能一个事务读和写，在串行化的隔离级别下，上的都是表锁，读数据的时候上共享锁，写数据的时候上排他锁，支持多个事务同时读数据，不支持读写并发和写写并发。</p>
<p>以上两种方式方案很简单，而RC和RR是比较复杂的，如果只靠锁实现这两种隔离级别，实现方案如下：</p>
<p>读的时候给数据加上行级共享锁，写的时候加上行级排他锁，可以看出和串行化的区别就是锁的粒度从表级缩小到了行级，但是缺点就是读的时候没办法写，写的时候也没办法读，为了解决这个问题，引入了MVCC多版本控制的方案，这是一种<strong>在读的时候不加锁</strong>的方案，<strong>写的时候还是要加排他锁</strong>。因为读的时候不加共享锁，所以可以写；读的时候不需要加共享锁，所以可以读加了排他锁的数据。</p>
<p>但是MVCC有一个缺点就是可能读取的数据不是最新的版本，但是用户如果使用<code>SELECT ... FOR UPDATE</code>、<code>SELECT ... LOCK IN SHARE MODE</code>也会造成当前读，<code>SELECT ... FOR UPDATE</code>会对查询到的数据加排他锁，其他事务无法对这些数据进行修改；<code>SELECT ... LOCK IN SHARE MODE</code> 会对查询到的数据加共享锁，其他事务可以读取这些数据，但不能修改。</p>
<p>MVCC具体实现细节如下：</p>
<p><img src="事务隔离级别及实现方式.assets/image-20250227191543018.png" alt="image-20250227191543018"></p>
<p><code>InnoDB</code> 存储引擎为每行数据添加了三个隐藏字段：</p>
<ul>
<li><p><code>DB_TRX_ID（6字节）</code>：表示最后一次插入或更新该行的事务 id。此外，<code>delete</code> 操作在内部被视为更新，只不过会在记录头 <code>Record header</code> 中的 <code>deleted_flag</code> 字段将其标记为已删除</p>
</li>
<li><p><code>DB_ROLL_PTR（7字节）</code> 回滚指针，指向该行的 <code>undo log</code> 。如果该行未被更新，则为空</p>
</li>
<li><p><code>DB_ROW_ID（6字节）(可选)</code>：如果没有设置主键且该表没有唯一非空索引时，<code>InnoDB</code> 会使用该 id 来生成聚簇索引</p>
</li>
</ul>
<p>当事务进行读操作时，会创建一个快照读ReadView，其中维护了四个值：</p>
<ul>
<li><code>m_low_limit_id</code>：目前出现过的最大的事务 ID+1，即下一个将被分配的事务 ID。大于等于这个 ID 的数据版本均不可见</li>
<li><code>m_up_limit_id</code>：活跃事务列表 <code>m_ids</code> 中最小的事务 ID，如果 <code>m_ids</code> 为空，则 <code>m_up_limit_id</code> 为 <code>m_low_limit_id</code>。小于这个 ID 的数据版本均可见</li>
<li><code>m_ids</code>：<code>Read View</code> 创建时其他未提交的活跃事务 ID 列表。创建 <code>Read View</code>时，将当前未提交事务 ID 记录下来，后续即使它们修改了记录行的值，对于当前事务也是不可见的。<code>m_ids</code> 不包括当前事务自己和已提交的事务（正在内存中）</li>
<li><code>m_creator_trx_id</code>：创建该 <code>Read View</code> 的事务 ID</li>
</ul>
<p>通过ReadViw和DB_TRX_ID就可以知道读取哪一个版本。</p>
<p>从undolog从后往前找（从新往旧），对每一个版本按顺序进行下面四个条件的判断：</p>
<ol>
<li>如果被访问的记录版本号 DB_TRXID 等于 Read View 中的 creator_trx_id ，表明当前事务访问的是自己修改的记录，可以被访问;</li>
<li>如果被访问的记录版本号 DB_TRXID 小于 m_up_limit_id，表明该版本的数据在当前事务生成 Read View 之前已经提交，可以被访问;</li>
<li>如果被访问的记录版本号 DB_TRX_ID 大于或等于 m_low_limit_id值，表明生成该版本数据的事务在当前事务生成 Read View 后才开启，不可以被访问，需要沿着回滚指针寻找该记录的历史版本继续判断;</li>
<li>如果被访问的记录版本号 DB_TRX_ID 介于 m_up_limit_id和 m_low_limit_id之间，需要进一步判断 DB_TRX_ID 是不是在活跃事务列表m_ids 中:<ul>
<li>如果在:说明创建 Read View 时生成该版本的事务尚未提交，该版本数据不可以被访问，需要沿着回滚指针寻找该记录的历史0版本继续判断;</li>
<li>如果不在:说明创建 Read View 时生成该版本的事务已经被提交，可以被访问，直接返回。</li>
</ul>
</li>
</ol>
<p><img src="https://javaguide.cn/assets/trans_visible-ekj9bMvL.png" alt="trans_visible"></p>
<blockquote>
<p>图片纠错：大于等于m_low_limit_id</p>
</blockquote>
<p>快照读：MVCC解决了RR下的幻读问题，但是无法解决RC下的幻读问题，因为RC下每次读取数据都会创建一个快照读，即使是在一个事务里面，而RR下一个事务里面用的是一个快照读。</p>
<p>当前读：无法解决幻读问题，因为只能加行级共享锁，必须升级为表级锁才可以解决。</p>
<h1 id="可重复读完全解决幻读问题了吗？"><a href="#可重复读完全解决幻读问题了吗？" class="headerlink" title="可重复读完全解决幻读问题了吗？"></a>可重复读完全解决幻读问题了吗？</h1><p><strong>可重复读隔离级别下虽然很大程度上避免了幻读，但是还是没有能完全解决幻读</strong>。</p>
<p>下面是一个出现幻读的例子：</p>
<p>在可重复读隔离级别下，事务 A 第一次执行普通的 select 语句时生成了一个 ReadView，之后事务 B 向表中新插入了一条 id = 5 的记录并提交。接着，事务 A 对 id = 5 这条记录进行了更新操作，在这个时刻，这条新记录的 trx_id 隐藏列的值就变成了事务 A 的事务 id，之后事务 A 再使用普通 select 语句去查询这条记录时就可以看到这条记录了，于是就发生了幻读。</p>
<p><img src="https://pic4.zhimg.com/v2-ffc2603a076a4775aaa8555f14763a59_1440w.jpg" alt="img"></p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://www.cnblogs.com/detectiveHLH/p/14832940.html">深入剖析 MySQL 自增锁 - detectiveHLH - 博客园</a></p>
]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>事务隔离</tag>
        <tag>MVCC</tag>
      </tags>
  </entry>
  <entry>
    <title>信息安全复习</title>
    <url>/posts/662ab05b.html</url>
    <content><![CDATA[<blockquote>
<p>本文记录了博主复习信息安全课程的一些资料，抛出了一些问题，并给出回答</p>
</blockquote>
<h1 id="Q1：三种安全目标的定义及其对应的攻击类型？"><a href="#Q1：三种安全目标的定义及其对应的攻击类型？" class="headerlink" title="Q1：三种安全目标的定义及其对应的攻击类型？"></a>Q1：三种安全目标的定义及其对应的攻击类型？</h1><p><strong>保密性：</strong>确保信息仅对授权用户可见和访问，防止未经授权的访问和泄露。</p>
<p><strong>完整性：</strong>确保信息在传输、存储和处理过程中不被未经授权的修改或破坏。</p>
<p><strong>可用性：</strong>确保信息和系统在需要时可以被合法用户访问和使用。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707152354261.png" alt="image-20240707152354261"></p>
<p><strong>攻击类型：</strong></p>
<p><strong>窃听</strong>：窥探是指未经授权访问或拦截数据。</p>
<p><strong>流量分析</strong>：通过监测在线流量获得一些其他类型的信息</p>
<p><strong>篡改：</strong>篡改是指未经授权的修改数据。</p>
<p><strong>伪装：</strong>指攻击者假冒合法用户的身份，以进行未经授权的操作。</p>
<p><strong>重放</strong>：攻击者截获信息并再次发送。尽管数据本身是合法的，但重复使用会导致未授权的操作。</p>
<p><strong>否认</strong>：由通信双方中的一方执行：发送方或接收方。 信息的发送者后来可能会否认她发送了该信息；信息的接收者后来可能会否认他收到了该信息。</p>
<p><strong>拒绝服务（DoS）</strong>：它可能减慢或完全中断系统的服务。攻击者可以使用几种策略来实现这一目标。她可能会向一个服务器发送大量的虚假请求，以至于服务器因负载过重而崩溃。</p>
<h1 id="Q2：如何辨别主动攻击和被动攻击，并列举出几种具体的例子？"><a href="#Q2：如何辨别主动攻击和被动攻击，并列举出几种具体的例子？" class="headerlink" title="Q2：如何辨别主动攻击和被动攻击，并列举出几种具体的例子？"></a>Q2：如何辨别主动攻击和被动攻击，并列举出几种具体的例子？</h1><p><strong>被动攻击</strong>：攻击者的目标只是为了获取信息，威胁机密性目标，但不修改信息，因此这种攻击的检查比较困难，可通过信息加密防止被动攻击。</p>
<p><strong>主动攻击：</strong>可能改变数据或损害系统。主动攻击可能会改变信息或损害系统，威胁完整性和可用性目标，但比较容易检测和防护。</p>
<p> <img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707152603258.png" alt="image-20240707152603258">                              </p>
<h1 id="Q3：解释现代加密系统的基本原则-Kerckhoff原理"><a href="#Q3：解释现代加密系统的基本原则-Kerckhoff原理" class="headerlink" title="Q3：解释现代加密系统的基本原则-Kerckhoff原理"></a>Q3：解释现代加密系统的基本原则-Kerckhoff原理</h1><p>基于<strong>Kerckhoff</strong>的原则<strong>，我们应该始终假设对手知道加密/解密算法。 密码对攻击的抵抗力必须</strong>只基于密钥的保密性。换句话说，猜测钥匙应该是非常困难的，以至于没有必要隐藏加密/解密算法。 </p>
<h1 id="Q4：解释四种密码分析类型"><a href="#Q4：解释四种密码分析类型" class="headerlink" title="Q4：解释四种密码分析类型"></a>Q4：解释四种密码分析类型</h1><h3 id="仅限密码文本"><a href="#仅限密码文本" class="headerlink" title="仅限密码文本"></a>仅限密码文本</h3><p>假设夏娃知道该算法并能截获密码文本。</p>
<p> <img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707152737032.png" alt="image-20240707152737032"></p>
<p><strong>类型：</strong></p>
<p><strong>蛮力攻击：</strong>试图使用所有可能的密钥</p>
<p><strong>统计攻击：</strong>利用语言的特点，即e是最常见的字母。</p>
<p><strong>模式攻击：</strong>在密码文本中寻找模式</p>
<h3 id="已知明文攻击"><a href="#已知明文攻击" class="headerlink" title="已知明文攻击"></a>已知明文攻击</h3><p>明文/密文对已在前面收集。 </p>
<p><strong>例如</strong>，爱丽丝向鲍勃发送了一条秘密信息，但她后来公开了信息的内容。夏娃同时保留了密码文本和明文，以使用它们来破解爱丽丝发给鲍勃的下一个秘密信息，<strong>假设爱丽丝没有改变她的密钥</strong>。夏娃<strong>利用前一对之间的关系来分析当前的密码文本。</strong>在这里可以应用在仅有密码文本的攻击中使用的相同方法。</p>
<p>这种攻击更容易实现，因为Eve<strong>有更多的信息</strong>可用于分析。然而，它不太可能发生，因为爱丽丝可能已经改变了她的密钥或可能没有披露任何以前的信息内容。</p>
<p> <img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707152751457.png" alt="image-20240707152751457"></p>
<h3 id="选择明文攻击（chosen-plaintext-attack）"><a href="#选择明文攻击（chosen-plaintext-attack）" class="headerlink" title="选择明文攻击（chosen-plaintext attack）"></a>选择明文攻击（chosen-plaintext attack）</h3><p>选择的明文攻击与已知明文攻击类似，但明文/密码文本对是由攻击者自己选择的。 </p>
<p> <img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707152812598.png" alt="image-20240707152812598"></p>
<p>例如，如果<strong>Eve</strong>能够进入Alice的电脑，<strong>这就可能发生。</strong>她可以选择一些明文并截获创建的密码文本。当然，她没有钥匙，因为钥匙通常被嵌入发件人使用的软件中。这种类型的攻击更容易实现，但发生的可能性更小。</p>
<h3 id="选定密文攻击"><a href="#选定密文攻击" class="headerlink" title="选定密文攻击"></a>选定密文攻击</h3><p> 选择的密文攻击与选择的明文攻击类似，只是夏娃选择一些密文并解密，形成一对密文明文。如果夏娃能够访问鲍勃的计算机，这就可能发生。 </p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707152819900.png" alt="image-20240707152819900"></p>
<h1 id="Q5：经典代换密码算法的基本原理"><a href="#Q5：经典代换密码算法的基本原理" class="headerlink" title="Q5：经典代换密码算法的基本原理"></a>Q5：经典代换密码算法的基本原理</h1><p><strong>替换式密码是用一个符号替换另一个符号。</strong></p>
<p>替换密码可分为<strong>单字母</strong>密码和<strong>多字母</strong>密码。</p>
<h3 id="单字母替代"><a href="#单字母替代" class="headerlink" title="单字母替代"></a>单字母替代</h3><p>在单字母替换中，明文中的一个符号与密码文中的一个符号之间的关系总是一对一的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707153135529.png" alt="image-20240707153135529"></p>
<h4 id="加法密码"><a href="#加法密码" class="headerlink" title="加法密码"></a>加法密码</h4><p>为每个字母分配数值（小写或大写）。</p>
<p> <img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707153147718.png" alt="image-20240707153147718"></p>
<p>密码分析：加法密码容易受到使用详尽密钥的仅有密码文本的攻击。搜索（暴力攻击）。加法密码的密钥域非常小；只有26把钥匙。然而，其中的一个密钥，即零，是无用的（密码文本是  与明文相同）。这就只剩下25个可能的密钥。</p>
<h4 id="乘法密码"><a href="#乘法密码" class="headerlink" title="乘法密码"></a>乘法密码</h4><p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707153301933.png" alt="image-20240707153301933"></p>
<h4 id="Affine-Cipher（仿射密码）"><a href="#Affine-Cipher（仿射密码）" class="headerlink" title="Affine Cipher（仿射密码）"></a>Affine Cipher（仿射密码）</h4><p>我们可以将加法密码和乘法密码结合起来，得到所谓的 “阿凡提密码”，这是两种密码与一对钥匙的结合。<strong>第一把钥匙用于乘法密码；第二把钥匙用于加法密码。</strong></p>
<p> <img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707153322572.png" alt="image-20240707153322572"></p>
<h3 id="多字母密码器"><a href="#多字母密码器" class="headerlink" title="多字母密码器"></a>多字母密码器</h3><p>在多字母替换中，一个字符的每一次出现都可能有不同的替换。明文中的一个字符与密文中的一个字符之间的关系是<strong>一对多的。</strong> </p>
<p>为了创建一个多字母密码，我们需要使每个密码文本字符同时依赖于<strong>相应的明文字符</strong>和<strong>明文字符</strong>在信息中的<strong>位置。</strong> 因此，关键在<strong>关键流的形式。</strong></p>
<h4 id="Autokey-Cipher"><a href="#Autokey-Cipher" class="headerlink" title="Autokey Cipher"></a>Autokey Cipher</h4><p> <img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707153329014.png" alt="image-20240707153329014"></p>
<h4 id="Vigenere-Cipher（维吉尼亚）"><a href="#Vigenere-Cipher（维吉尼亚）" class="headerlink" title="Vigenere Cipher（维吉尼亚）"></a>Vigenere Cipher（维吉尼亚）</h4><p> <img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707153406911.png" alt="image-20240707153406911"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707153417054.png" alt="image-20240707153417054"></p>
<p> Vigenere密码使用一种不同的策略来创建密钥流。<strong>密钥流</strong>是一个长度为m的初始秘密密钥流的重复，其中我们有1≤m≤26<strong>。</strong>该密码可以描述如下 其中(k1, k 2, …, km)是Alice和Bob同意的初始秘钥。  </p>
<p> Vigenere密钥流不依赖于明文字符</p>
<h4 id="Hill-Cipher（希尔密码）"><a href="#Hill-Cipher（希尔密码）" class="headerlink" title="Hill Cipher（希尔密码）"></a>Hill Cipher（希尔密码）</h4><p>明文被划分为同等大小的块。这些区块以这样一种方式被逐一加密，即<strong>区块中的每个字符都有助于对区块中的其他字符进行加密。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707153440386.png" alt="image-20240707153440386"></p>
<h1 id="Q6：关于P盒、S盒的计算问题"><a href="#Q6：关于P盒、S盒的计算问题" class="headerlink" title="Q6：关于P盒、S盒的计算问题"></a>Q6：关于P盒、S盒的计算问题</h1><p><strong>P盒</strong>是一个换位单元(transposition unit)。三种类型的P盒：<strong>直P盒、扩展P盒和压缩P盒</strong>。</p>
<p><strong>Straight P-boxes</strong>：n位输入映射n位输出，输出结果共有n！中可能性，最终根据P-boxes的设定规则输出其中一种。</p>
<p><strong>压缩P-boxes</strong>：n位输入映射m位输出，其中m﹤n。m位的输出指n位输入(1~n)中有若干位丢失的结果。压缩P-boxes用于我们需要排列n位结果并且在下一阶段减少位数的情况中。</p>
<p><strong>expansion P-boxes</strong>：n位输入映射m位输出，其中m＞n。m位的输出指n位输入(1~n)中有若干位重复出现的结果。expansion P-boxes 用于我们需要排列n位结果并且在下一阶段增加位数的情况中。</p>
<p><strong>S盒</strong>是一个换字单元(substitution unit)。两种类型的S-boxes：<strong>linear S-box</strong>和<strong>nonlinear S-box</strong>。S-box有n位输入(X0,X1,…,Xn)映射m位输出(Y1,Y2,…,Ym)，n和m的值不需要相同。</p>
<p>linear S-box中输入与输出的关系：</p>
<p>Y1 = a1,1x1⊕a1,2x2⊕…⊕a1,nxn</p>
<p>Y2 = a2,1x1⊕a2,2x2⊕…⊕a2,nxn</p>
<p>Yn = an,1x1⊕an,2x2⊕…⊕an,nxn</p>
<p>其中ai,j属于矩阵Amxn</p>
<p>nonlinear S-box中输入的n位与m位输出之间通过非线性函数计算得到。</p>
<h1 id="Q7：混淆和扩散"><a href="#Q7：混淆和扩散" class="headerlink" title="Q7：混淆和扩散"></a>Q7：混淆和扩散</h1><p>扩散和混乱是由Shannon提出的设计密码系统的两个基本方法，目的是抵抗攻击者对密码的统计分析。</p>
<p><strong>扩散：</strong>扩散(diffusion)是为了隐藏明文和密文之间的联系，将明文的统计特性散布到密文中去。</p>
<p><strong>混淆：</strong>混淆(Confusion)是为了隐藏密文和密钥之间的联系，使密文和密钥之间的统计关系变得尽可能复杂。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707153651661.png" alt="image-20240707153651661">        </p>
<h1 id="Q8：简单的差分分析原理"><a href="#Q8：简单的差分分析原理" class="headerlink" title="Q8：简单的差分分析原理"></a>Q8：简单的差分分析原理</h1><p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707153723330.png" alt="image-20240707153723330"></p>
<h1 id="Q9：关于LFSR的计算问题"><a href="#Q9：关于LFSR的计算问题" class="headerlink" title="Q9：关于LFSR的计算问题"></a>Q9：关于LFSR的计算问题</h1><p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707153801795.png" alt="image-20240707153801795"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707153807215.png" alt="image-20240707153807215"></p>
<h1 id="Q10：DES算法每轮由哪几部分组成"><a href="#Q10：DES算法每轮由哪几部分组成" class="headerlink" title="Q10：DES算法每轮由哪几部分组成"></a>Q10：DES算法每轮由哪几部分组成</h1><p>1.首先把明文分成若干个64-bit的分组，算法以一个分组作为输入，通过一个初始置换（IP）将明文分组分成左半部分（L0）和右半部分（R0），各为32-bit。</p>
<p>2.然后进行16轮完全相同的运算，这些运算我们称为函数f，在运算过程中数据与密钥相结合。</p>
<p>3.经过16轮运算后，左、右两部分合在一起经过一个末转换（初始转换的逆置换IP-1），输出一个64-bit的密文分组。</p>
<p><strong>Feistel</strong>密码：</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707153835398.png" alt="image-20240707153835398"></p>
<p>DES的每一轮都是一个Feistel密码，如图6.4所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707153846103.png" alt="image-20240707153846103"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707153855056.png" alt="image-20240707153855056"></p>
<h1 id="Q11：双重DES和中途相遇攻击"><a href="#Q11：双重DES和中途相遇攻击" class="headerlink" title="Q11：双重DES和中途相遇攻击"></a>Q11：双重DES和中途相遇攻击</h1><p><strong>双重DES</strong>：使用两个加密秘钥，用第一个加密秘钥加密后，再用另一个秘钥进行二次加密，解密则先用第二次加密的秘钥解密，然后再用第一次加密的秘钥进行解密。密钥复杂度由2^56 增加到2^112</p>
<p><strong>中途相遇攻击：</strong>尝试密钥一个加密一个解密，结果相同即为正确密钥，强度降为2^57。</p>
<h1 id="Q12：电子密码本（Electronic-Codebook-ECB）模式"><a href="#Q12：电子密码本（Electronic-Codebook-ECB）模式" class="headerlink" title="Q12：电子密码本（Electronic Codebook, ECB）模式"></a>Q12：电子密码本（Electronic Codebook, ECB）模式</h1><p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707154000342.png" alt="image-20240707154000342"></p>
<h1 id="Q13：CBC（密码块链（CBC）模式）"><a href="#Q13：CBC（密码块链（CBC）模式）" class="headerlink" title="Q13：CBC（密码块链（CBC）模式）"></a>Q13：CBC（密码块链（CBC）模式）</h1><p>在CBC模式下，每个明文块在被加密前都会与前一个密码块进行排他性交换。</p>
<p>当一个区块被加密后，该区块被发送，但它的一个副本被保存在内存中，用于下一个区块的加密。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707154021385.png" alt="image-20240707154021385"></p>
<p><strong>误差传播</strong>：在CBC模式下，传输过程中密码文本块Cj的一个比特错误可能会在解密过程中在<strong>明文块</strong>Pj的大多数比特中产生错误。然而，这个单一的错误只在明文块Pj+1中切换一个位（同一位置的位）。这一事实的证明留作练习。明文块Pj+2至PN不受这个单一比特错误的影响。密码文本中的单比特错误是可以自我恢复的。</p>
<h1 id="Q14：为什么需要操作模式"><a href="#Q14：为什么需要操作模式" class="headerlink" title="Q14：为什么需要操作模式"></a>Q14：为什么需要操作模式</h1><p>DES加密的分组大小为64，而在实际应用中要加密的文本大小是可变的，通常都要远远大于由现代分组密码确定的分组大小。操作模式就是设计用来对现代分组密码的任意大小的文本进行加密。</p>
<h1 id="Q15：CFB和OFB模式的定义式，它们分别创建的是一个同步还是非同步流密码"><a href="#Q15：CFB和OFB模式的定义式，它们分别创建的是一个同步还是非同步流密码" class="headerlink" title="Q15：CFB和OFB模式的定义式，它们分别创建的是一个同步还是非同步流密码"></a>Q15：CFB和OFB模式的定义式，它们分别创建的是一个同步还是非同步流密码</h1><p>同步流密码（Synchronous Stream Cipher）是指在加密和解密过程中，密钥流的生成仅依赖于密钥和初始化向量（IV），与明文和密文无关。加密和解密双方独立生成相同的密钥流，并将其与明文或密文进行异或操作。</p>
<p><strong>非同步</strong>流密码，其中的密钥流取决于密码文本。 </p>
<h2 id="密码反馈CFB"><a href="#密码反馈CFB" class="headerlink" title="密码反馈CFB"></a>密码反馈CFB</h2><p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707154205639.png" alt="image-20240707154205639"></p>
<h2 id="输出反馈OFB"><a href="#输出反馈OFB" class="headerlink" title="输出反馈OFB"></a>输出反馈OFB</h2><p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707154228251.png" alt="image-20240707154228251"></p>
<h1 id="Q16：cfb和ofb模式的基本原理，并分析它们各自的错误传播性能"><a href="#Q16：cfb和ofb模式的基本原理，并分析它们各自的错误传播性能" class="headerlink" title="Q16：cfb和ofb模式的基本原理，并分析它们各自的错误传播性能"></a>Q16：cfb和ofb模式的基本原理，并分析它们各自的错误传播性能</h1><p>在CFB中，传输过程中密文块Cj的一个比特错误会在明文块Pj中产生一个比特错误（在同一位置）。然而，只要Cj的一些位仍在移位寄存器中，下面的明文块中的大多数位都有错误。 </p>
<p>在OFB中，<strong>密码文本中的一个错误只影响到明文中的相应位。</strong> </p>
<h1 id="Q17：CTR模式的基本原理"><a href="#Q17：CTR模式的基本原理" class="headerlink" title="Q17：CTR模式的基本原理"></a>Q17：CTR模式的基本原理</h1><p>在计数器（CTR）模式下，没有反馈。密钥流中的伪随机性是通过一个计数器实现的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707154341557.png" alt="image-20240707154341557"></p>
<h1 id="Q18：RSA的原理和证明"><a href="#Q18：RSA的原理和证明" class="headerlink" title="Q18：RSA的原理和证明"></a>Q18：RSA的原理和证明</h1><p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707154504381.png" alt="image-20240707154504381"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707154512783.png" alt="image-20240707154512783"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707154523627.png" alt="image-20240707154523627"></p>
<h1 id="Q19：Hash函数的三个标准"><a href="#Q19：Hash函数的三个标准" class="headerlink" title="Q19：Hash函数的三个标准"></a>Q19：Hash函数的三个标准</h1><p>一个加密哈希函数必须满足三个标准：<strong>抗预象性、抗第二预象性</strong>和<strong>抗碰撞性</strong></p>
<p><strong>抗预象性：</strong>加密哈希函数必须具有抗预像性。给定一个哈希函数h和y=h(M)，对于Eve来说，要找到任何消息M′，使y=h(M′)，一定是非常困难的。 </p>
<p><strong>第二个预像阻力</strong>：如果Alice创建了一个信息和一个摘要，并将两者都发送给Bob，这个标准确保Eve不能轻易地创建另一个信息，而这个信息的摘要是完全相同的。换句话说，给定一个特定的信息和它的摘要，不可能（或至少非常困难）创造另一个具有相同摘要的信息。</p>
<p><strong>抗碰撞性：</strong>确保Eve不能找到两个散列到相同摘要的信息。 </p>
<h1 id="Q20：RSA数字签名方案的原理"><a href="#Q20：RSA数字签名方案的原理" class="headerlink" title="Q20：RSA数字签名方案的原理"></a>Q20：RSA数字签名方案的原理</h1><p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707154741308.png" alt="image-20240707154741308"></p>
<h1 id="Q21：分别用于数字签名和用于保障机密性时，私钥和公钥的区别"><a href="#Q21：分别用于数字签名和用于保障机密性时，私钥和公钥的区别" class="headerlink" title="Q21：分别用于数字签名和用于保障机密性时，私钥和公钥的区别"></a>Q21：分别用于数字签名和用于保障机密性时，私钥和公钥的区别</h1><p>公钥是公开的，私钥是私有的，所以Alice给Bob发消息，就要用Bob公开的公钥来做加密，Bob再用自己的私钥进行解密即可。简单来说，公钥加密，私钥解密。</p>
<p>数字签名：数字签名刚好相反，比如大家想对Alice的签名进行验证，那么大家能获取的就是Alice公开的公钥，而签名则由Alice用自己的私钥进行签名。 简单来说，私钥签名，公钥验证。</p>
<h2 id="Q22：用数字签名提供不可否认性服务。"><a href="#Q22：用数字签名提供不可否认性服务。" class="headerlink" title="Q22：用数字签名提供不可否认性服务。"></a>Q22：用数字签名提供不可否认性服务。</h2><p>如何通过使用可信中心和签名来提供不可抵赖服务？</p>
<p>可以<strong>使用受信任的一方</strong>提供不可抵赖性。</p>
<p>人们可以在他们之间建立一个既定的可信方。在未来的章节中，我们将看到受信方可以解决许多其他有关安全服务和密钥交换的问题。图13.4显示了受信方如何防止Alice否认她发送了信息。</p>
<p>爱丽丝从她的信息中创建一个签名并将信息、她的身份、Bob的身份和签名发送到中心。中心在检查了Alice的公钥是否有效后，通过Alice的公钥验证了该消息来自Alice。然后，中心在其档案中保存了一份带有发件人身份、收件人身份和时间戳的信息副本。中心使用它的私钥从信息中创建另一个签名。然后中心将信息、新签名、Alice的身份和Bob的身份发送给Bob。Bob使用受信任的中心的公钥验证该消息。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707154857307.png" alt="image-20240707154857307"></p>
<p>如果将来Alice否认是她发送的信息，中心可以出示保存的信息的副本。如果鲍勃的信息与中心保存的信息是重复的，那么爱丽丝将失去争议。</p>
<h1 id="Q23：固定口令的一种方法—盐化口令方法"><a href="#Q23：固定口令的一种方法—盐化口令方法" class="headerlink" title="Q23：固定口令的一种方法—盐化口令方法"></a>Q23：固定口令的一种方法—盐化口令方法</h1><p>第三种方法被称为对密码加盐。<strong>当密码字符串被创建时，一个随机字符串，称为盐，被连接到密码</strong>。然后对加盐的密码进行哈希。然后，ID、盐和哈希值被存储在文件中。现在，当用户要求访问时，系统提取盐，将其与收到的密码连接起来，对结果进行哈希，并将其与存储在文件中的哈希进行比较。如果有匹配的，就允许访问；否则，就拒绝访问。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707155005505.png" alt="image-20240707155005505"></p>
<p>加盐使字典攻击更加困难。如果原始密码是6位数，盐是4位数，那么哈希就在10位数的数值上进行。这意味着，Eve现在需要做一个1000万个项目的列表，并为每个项目创建一个哈希值。哈希值的列表有1000万个条目，比较的时间要长得多。如果盐是一个很长的随机数，盐化是非常有效的。UNIX操作系统使用这种方法的一个变种。</p>
<h1 id="Q24：解释用Hash链实现一次性口令"><a href="#Q24：解释用Hash链实现一次性口令" class="headerlink" title="Q24：解释用Hash链实现一次性口令"></a>Q24：解释用Hash链实现一次性口令</h1><p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20240707155041742.png" alt="image-20240707155041742"></p>
<p>当系统收到用户在第三条信息中的响应时，它将哈希函数应用于收到的值，看它是否与存储在条目中的值相匹配。如果匹配，则允许访问；否则，拒绝访问。然后，系统将条目中的n值递减，并将密码的旧值替换为$h^{n-1}(P_0)$  . </p>
<p>当用户试图第二次访问系统时，它收到的计数器的值是n-1，现在，该用户的第三条信息是$h^{n-2}(P_0)$ 。当系统收到这个消息时，它应用哈希函数得到$h^{n-1}(P_0)$，可以与更新的条目进行比较。</p>
<p>条目中n的值在每次访问时都会被递减。当该值变为0时，用户就不能再访问系统；一切都必须重新设置。由于这个原因，n的值通常被选为一个大数字，如1000。</p>
<h1 id="Q25：用对称密钥密码技术实现挑战-应答认证"><a href="#Q25：用对称密钥密码技术实现挑战-应答认证" class="headerlink" title="Q25：用对称密钥密码技术实现挑战-应答认证"></a>Q25：用对称密钥密码技术实现挑战-应答认证</h1><p>第一种：在第一种方法中，验证者发送一个<strong>nonce</strong>，一个只使用一次的随机数，来质疑索赔者。一个nonce必须是时间变化的；每次它被创建时都是不同的。声明者使用声明者和验证者之间共享的秘密密钥对挑战作出回应。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707155344383.png" alt="image-20240707155344383"></p>
<p>第二种：在第二种方法中，时间变化的值是一个时间戳，它显然是随时间变化的。在这种方法中，挑战信息是由验证人向申请人发送的当前时间。然而，这假定客户端和服务器的时钟是同步的；申请人知道当前的时间。这意味着不需要挑战信息。三条信息可以合并。其结果是，可以使用一个消息进行认证，即对隐含挑战的响应，即当前时间。图14.6显示了这种方法。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707155353089.png" alt="image-20240707155353089"></p>
<p>第三种方法：第一种和第二种方法是用于单向认证。Alice对Bob进行了认证，但不是反过来。如果Alice也需要确定Bob的身份，我们需要双向认证。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707155432397.png" alt="image-20240707155432397"></p>
<h1 id="Q26：基于KDC实现对称密钥分配的协议过程"><a href="#Q26：基于KDC实现对称密钥分配的协议过程" class="headerlink" title="Q26：基于KDC实现对称密钥分配的协议过程"></a>Q26：基于KDC实现对称密钥分配的协议过程</h1><p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707155502556.png" alt="image-20240707155502556"></p>
<h1 id="Q27：Kerberos的操作过程"><a href="#Q27：Kerberos的操作过程" class="headerlink" title="Q27：Kerberos的操作过程"></a>Q27：Kerberos的操作过程</h1><p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707155537882.png" alt="image-20240707155537882"></p>
<h1 id="Q28：Diffie-Hellman密钥协商协议的基本原理"><a href="#Q28：Diffie-Hellman密钥协商协议的基本原理" class="headerlink" title="Q28：Diffie-Hellman密钥协商协议的基本原理"></a>Q28：Diffie-Hellman密钥协商协议的基本原理</h1><p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707155602124.png" alt="image-20240707155602124"></p>
<h1 id="Q29：认证结构的基本原理"><a href="#Q29：认证结构的基本原理" class="headerlink" title="Q29：认证结构的基本原理"></a>Q29：认证结构的基本原理</h1><p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707155633990.png" alt="image-20240707155633990"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20240707155640391.png" alt="image-20240707155640391"></p>
]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>信息安全</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式 ID 的生成方案</title>
    <url>/posts/fd251b3f.html</url>
    <content><![CDATA[<h2 id="为什么需要分布式-ID？"><a href="#为什么需要分布式-ID？" class="headerlink" title="为什么需要分布式 ID？"></a>为什么需要分布式 ID？</h2><p>拿MySQL数据库举个栗子：</p>
<p>在我们业务数据量不大的时候，单库单表完全可以支撑现有业务，数据再大一点搞个MySQL主从同步读写分离也能对付。</p>
<p>但随着数据日渐增长，主从同步也扛不住了，就需要对数据库进行分库分表，但分库分表后需要有一个唯一ID来标识一条数据，数据库的自增ID显然不能满足需求，例如 user0 和 user1 两张表生成的 userid 如果采用自增 ID，会导致重复；特别一点的如订单、优惠券也都需要有<code>唯一ID</code>做标识。此时一个能够生成<code>全局唯一ID</code>的系统是非常必要的。那么这个<code>全局唯一ID</code>就叫<code>分布式ID</code>。</p>
<p><strong>那么分布式ID需要满足那些条件？</strong></p>
<ul>
<li>全局唯一：必须保证ID是全局性唯一的，基本要求。</li>
<li>高性能：高可用低延时，ID生成响应要块，否则反倒会成为业务瓶颈。</li>
<li>高可用：100%的可用性是骗人的，但是也要无限接近于100%的可用性。</li>
<li>好接入：要秉着拿来即用的设计原则，在系统设计和实现上要尽可能的简单。</li>
<li>趋势递增：最好趋势递增，这个要求就得看具体业务场景了，一般不严格要求。</li>
</ul>
<h2 id="分布式-ID-的生成方案"><a href="#分布式-ID-的生成方案" class="headerlink" title="分布式 ID 的生成方案"></a>分布式 ID 的生成方案</h2><ul>
<li>UUID</li>
<li>数据库自增ID</li>
<li>数据库多主模式</li>
<li>号段模式</li>
<li>Redis</li>
<li>雪花算法（SnowFlake）</li>
</ul>
<h3 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h3><p>存在 3 个版本：V1、V4、V7：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>UUID 版本</th>
<th>生成方式</th>
<th>是否有序</th>
<th>典型用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>v1</td>
<td>时间戳 + 节点 + 序列</td>
<td>部分有序</td>
<td>系统日志、追踪 ID</td>
</tr>
<tr>
<td>v4</td>
<td>随机数</td>
<td>否</td>
<td>分布式唯一标识、traceId</td>
</tr>
<tr>
<td>v7</td>
<td>时间戳 + 随机数</td>
<td>部分有序</td>
<td>数据库主键、可排序 ID</td>
</tr>
</tbody>
</table>
</div>
<p><strong>为什么说 UUID V1 和 V7是部分有序？</strong></p>
<p>因为高位是时间戳，这代表着不同时间生成的 UUID 是严格递增的，同一时间生成的 UUID 则是乱序的。</p>
<p><code>UUID</code>的生成简单到只有一行代码，输出结果 <code>c2b8c2b9e46c47e3b30dca3b0d447718</code>，但UUID却并不适用于实际的业务需求。像用作订单号<code>UUID</code>这样的字符串没有丝毫的意义，看不出和订单相关的有用信息；而对于数据库来说用作业务<code>主键ID</code>，它不仅是太长还是字符串，存储性能差查询也很耗时，所以不推荐用作<code>分布式ID</code>。</p>
<h3 id="数据库自增-ID"><a href="#数据库自增-ID" class="headerlink" title="数据库自增 ID"></a>数据库自增 ID</h3><p>基于数据库的<code>auto_increment</code>自增ID完全可以充当<code>分布式ID</code>，具体实现：需要一个单独的MySQL实例用来生成ID，建表结构如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE `SEQ_ID`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> SEQID.SEQUENCE_ID (</span><br><span class="line">    id <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> auto_increment, </span><br><span class="line">    <span class="keyword">value</span> <span class="type">char</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">default</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id),</span><br><span class="line">) ENGINE<span class="operator">=</span>MyISAM;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SEQUENCE_ID(<span class="keyword">value</span>)  <span class="keyword">VALUES</span> (<span class="string">&#x27;values&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>当我们需要一个ID的时候，向表中插入一条记录返回<code>主键ID</code>，但这种方式有一个比较致命的缺点，访问量激增时MySQL本身就是系统的瓶颈，用它来实现分布式服务风险比较大，不推荐！</p>
<h3 id="基于数据库集群模式"><a href="#基于数据库集群模式" class="headerlink" title="基于数据库集群模式"></a>基于数据库集群模式</h3><p>害怕一个主节点挂掉没法用，那就做多主模式集群，也就是多个Mysql实例都能单独的生产自增ID。</p>
<p>那这样还会有个问题，两个MySQL实例的自增ID都从1开始，<strong>会生成重复的ID怎么办？</strong></p>
<p><strong>解决方案</strong>：设置<code>起始值</code>和<code>自增步长</code>。</p>
<p><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/1460000021759476.png" alt="在这里插入图片描述"></p>
<p>但这样会有一个致命的问题，怎么扩容？</p>
<p>增加第三台<code>MySQL</code>实例需要人工修改一、二两台<code>MySQL实例</code>的起始值和步长，把<code>第三台机器的ID</code>起始生成位置设定在比现有<code>最大自增ID</code>的位置远一些，但必须在一、二两台<code>MySQL实例</code>ID还没有增长到<code>第三台MySQL实例</code>的<code>起始ID</code>值的时候，否则<code>自增ID</code>就要出现重复了，<strong>必要时可能还需要停机修改</strong>。</p>
<h3 id="号段模式"><a href="#号段模式" class="headerlink" title="号段模式"></a>号段模式</h3><p>号段模式是当下分布式ID生成器的主流实现方式之一，号段模式可以理解为从数据库批量的获取自增ID，每次从数据库取出一个号段范围，例如 (1,1000] 代表1000个ID，具体的业务服务将本号段，生成1~1000的自增ID并加载到内存。表结构如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">CREATE</span> <span class="variable constant_">TABLE</span> id_generator (</span><br><span class="line">  id <span class="title function_">int</span>(<span class="number">10</span>) <span class="variable constant_">NOT</span> <span class="variable constant_">NULL</span>,</span><br><span class="line">  max_id <span class="title function_">bigint</span>(<span class="number">20</span>) <span class="variable constant_">NOT</span> <span class="variable constant_">NULL</span> <span class="variable constant_">COMMENT</span> <span class="string">&#x27;当前最大id&#x27;</span>,</span><br><span class="line">  step <span class="title function_">int</span>(<span class="number">20</span>) <span class="variable constant_">NOT</span> <span class="variable constant_">NULL</span> <span class="variable constant_">COMMENT</span> <span class="string">&#x27;号段的布长&#x27;</span>,</span><br><span class="line">  biz_type    <span class="title function_">int</span>(<span class="number">20</span>) <span class="variable constant_">NOT</span> <span class="variable constant_">NULL</span> <span class="variable constant_">COMMENT</span> <span class="string">&#x27;业务类型&#x27;</span>,</span><br><span class="line">  version <span class="title function_">int</span>(<span class="number">20</span>) <span class="variable constant_">NOT</span> <span class="variable constant_">NULL</span> <span class="variable constant_">COMMENT</span> <span class="string">&#x27;版本号&#x27;</span>,</span><br><span class="line">  <span class="variable constant_">PRIMARY</span> <span class="variable constant_">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) </span><br></pre></td></tr></table></figure>
<p>biz_type ：代表不同业务类型</p>
<p>max_id ：当前最大的可用id</p>
<p>step ：代表号段的长度</p>
<p>version ：是一个乐观锁，每次都更新version，保证并发时数据的正确性</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>id</th>
<th>biz_type</th>
<th>max_id</th>
<th>step</th>
<th>version</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>101</td>
<td>1000</td>
<td>2000</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<p>等这批号段ID用完，再次向数据库申请新号段，对<code>max_id</code>字段做一次<code>update</code>操作，<code>update max_id= max_id + step</code>，update成功则说明新号段获取成功，新的号段范围是<code>(max_id ,max_id +step]</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">update id_generator set max_id = #&#123;max_id+step&#125;, version = version + <span class="number">1</span> where version = # &#123;version&#125; and biz_type = <span class="variable constant_">XXX</span></span><br></pre></td></tr></table></figure>
<p>由于多业务端可能同时操作，所以采用版本号<code>version</code>乐观锁方式更新，这种<code>分布式ID</code>生成方式不强依赖于数据库，不会频繁的访问数据库，对数据库的压力小很多。</p>
<h3 id="基于Redis模式"><a href="#基于Redis模式" class="headerlink" title="基于Redis模式"></a>基于Redis模式</h3><p><code>Redis</code>也同样可以实现，原理就是利用<code>redis</code>的 <code>incr</code>命令实现ID的原子性自增。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; set seq_id <span class="number">1</span>     <span class="comment">// 初始化自增ID为1</span></span><br><span class="line"><span class="variable constant_">OK</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; incr seq_id      <span class="comment">// 增加1，并返回递增后的数值</span></span><br><span class="line">(integer) <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>用<code>redis</code>实现需要注意一点，要考虑到redis持久化的问题。<code>redis</code>有两种持久化方式<code>RDB</code>和<code>AOF</code>：</p>
<ul>
<li><code>RDB</code>会定时打一个快照进行持久化，假如连续自增但<code>redis</code>没及时持久化，而这会Redis挂掉了，重启Redis后会出现ID重复的情况。</li>
<li><code>AOF</code>会对每条写命令进行持久化，即使<code>Redis</code>挂掉了也不会出现ID重复的情况，但由于incr命令的特殊性，会导致<code>Redis</code>重启恢复的数据时间过长。</li>
</ul>
<h3 id="基于雪花算法（Snowflake）模式"><a href="#基于雪花算法（Snowflake）模式" class="headerlink" title="基于雪花算法（Snowflake）模式"></a>基于雪花算法（Snowflake）模式</h3><p>雪花算法（Snowflake）是twitter公司内部分布式项目采用的ID生成算法，开源后广受国内大厂的好评，在该算法影响下各大公司相继开发出各具特色的分布式生成器。</p>
<p><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/1460000021759479.png" alt="在这里插入图片描述"></p>
<p><code>Snowflake</code>生成的是Long类型的ID，一个Long类型占8个字节，每个字节占8比特，也就是说一个Long类型占64个比特。</p>
<p>Snowflake ID组成结构：<code>正数位</code>（占1比特）+ <code>时间戳</code>（占41比特）+ <code>机器ID</code>（占5比特）+ <code>数据中心</code>（占5比特）+ <code>自增值</code>（占12比特），总共64比特组成的一个Long类型。</p>
<ul>
<li>第一个bit位（1bit）：Java中long的最高位是符号位代表正负，正数是0，负数是1，一般生成ID都为正数，所以默认为0。</li>
<li>时间戳部分（41bit）：毫秒级的时间，不建议存当前时间戳，而是用（当前时间戳 - 固定开始时间戳）的差值，可以使产生的ID从更小的值开始；41位的时间戳可以使用69年，(1L &lt;&lt; 41) / (1000L <em>60</em> 60 <em>24</em> 365) = 69年</li>
<li>工作机器id（10bit）：也被叫做<code>workId</code>，这个可以灵活配置，机房或者机器号组合都可以。</li>
<li>序列号部分（12bit），自增值支持同一毫秒内同一个节点可以生成4096个ID</li>
</ul>
<p>根据这个算法的逻辑，只需要将这个算法用Java语言实现出来，封装为一个工具方法，那么各个业务应用可以直接使用该工具方法来获取分布式ID，只需保证每个业务应用有自己的工作机器id即可，而不需要单独去搭建一个获取分布式ID的应用。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://segmentfault.com/a/1190000022717820">https://segmentfault.com/a/1190000022717820</a></p>
]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>分布式 ID</tag>
        <tag>雪花算法</tag>
        <tag>UUID</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>京东笔试0817第3题</title>
    <url>/posts/82d9abca.html</url>
    <content><![CDATA[<blockquote>
<p>这是一道京东笔试题目，属于动态规划中等难度题目</p>
</blockquote>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>第一行三个整数n,m,a(1≤n≤100,1≤m≤1000,1≤a≤1000)，含义如题面所示。 接下来m行，第i行三个整数 $u_i$,$v_i$, $w_i(1 ≤ u_i,v_i \le n,1≤ w_i ≤ a)$，描述了一条道路。</p>
<h1 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h1><p>如果牛牛回家的方家数大于等于 20220201种，请你在第一行输出All roads lead to Home!，然后在第二行输出回家的方案数对 20220201 取模的结里</p>
<p>否则只需要输出一行一个整数，表示牛牛回家的方案数。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><p>输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 6 2</span><br><span class="line">1 2 1</span><br><span class="line">1 2 1</span><br><span class="line">1 2 1</span><br><span class="line">2 3 1</span><br><span class="line">2 3 1</span><br><span class="line">2 3 1</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure>
<p>说明</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">从城市一到城市二有3种不同的走法，从城市二到城市三也有3种不同的走法，根据乘法原理我们可以知道，一共有3x3=9种不同的回家方法。</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>状态：</p>
<ul>
<li>dp[i][j]表示从1到i花费j的方案数量</li>
<li>st[i][j]表示从1到i花费为j的方案数量是否超出20220201</li>
</ul>
<p>转移方程：</p>
<p>dp[u][i + w] = (dp[u][i + w] + dp[v][i]) % INF;</p>
<p>其中更新路径由v到u，i是终点为v的花费</p>
<p>难点是为什么要把for (int i = 0; i &lt; a; ++i) 写在外层？</p>
<p>假如写在内层，那就是算完一个节点的状态再算下一个节点的状态，同时已经算出的节点状态不会再次更新，但是如果题目的路径存在环，就导致节点状态会被反复更新，通过循环的方式不行，采用拓扑的遍历的方式同样也不行，因为拓扑遍历不能有环。<br>所以必须写在外层，写在外层为什么可以？写在外层是按花费更新的，花费每增加1就更新所有节点，这样必须保证如果是v更新u：</p>
<ul>
<li>那么v的状态一定是最终的正确状态，以后不会被其他节点再次更新</li>
<li>u被更新后不能在本次花费下作为v去更新其他节点</li>
</ul>
<p>第一个条件是满足的，先看初始状态，dp[1][0]=1，只有1号节点初始花费为0有一种方案，其他节点花费为0的情况下是0。每个花费只能由花费小的来更新，所以如果遍历到m，那么所有节点小于m的花费状态一定作为v去更新了，那么m就是最终状态。</p>
<p>由于边权&gt;0，所以dp[v][i]更新dp[u][j]，j&gt;i，那dp[v][j]不可能在本次花费下去更新别的节点了，因为本次花费是i。</p>
<p>然后就是如果最终的答案大于20220201就输出“所有路线均可”，由于计算的过程涉及取模，所以还需要定义一个st[i][j]表示从1到i花费为j的方案数量是否超出20220201，如果v更新了u，那么v是否超出模数的状态就会继承到u，这个还是比较好想的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">20220201</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, a;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; a;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; <span class="built_in">graph</span>(n + <span class="number">1</span>); </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> vi, ui, wi;</span><br><span class="line">        cin &gt;&gt; vi &gt;&gt; ui &gt;&gt; wi;</span><br><span class="line">        graph[vi].<span class="built_in">emplace_back</span>(ui, wi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(a + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">st</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(a + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>; </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">1</span>; v &lt;= n; ++v) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[v][i] &gt; <span class="number">0</span> || st[v][i]) &#123;  </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[u, w] : graph[v]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i + w &lt;= a) &#123;</span><br><span class="line">                        dp[u][i + w] = (dp[u][i + w] + dp[v][i]) % INF;</span><br><span class="line">                        <span class="keyword">if</span>(dp[u][i + w] + dp[v][i] &gt;= INF) st[u][i + w] = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">if</span>(st[v][i]) st[u][i + w] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(st[n][a]) cout &lt;&lt; <span class="string">&quot;All roads lead to Home!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; dp[n][a] &lt;&lt; endl; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>刷题日记</tag>
        <tag>笔试</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式事务</title>
    <url>/posts/cdcc4eae.html</url>
    <content><![CDATA[<h2 id="解决什么问题？"><a href="#解决什么问题？" class="headerlink" title="解决什么问题？"></a>解决什么问题？</h2><p>我们都知道数据库可以通过事务来保证原子性操作，但实际场景中存在多个 DB实例或者微服务，例如扣减余额和扣减库存，如果余额和库存不在同一个 DB 实例中我们又该如何保证原子性操作？这就是分布式事务的概念。</p>
<p>首先需要铺垫一些理论：</p>
<h3 id="CAP-理论"><a href="#CAP-理论" class="headerlink" title="CAP 理论"></a>CAP 理论</h3><p>CAP 定理是分布式系统中的一个重要定理，它指出在一个分布式系统中，一致性（Consistency）、可用性（Availability）和分区容错性（Partition Tolerance）这三个特性不能同时满足，最多只能满足其中两个。以下是对这三个特性的详细解释：</p>
<ul>
<li><strong>一致性（Consistency）</strong>：在分布式系统中，一致性指的是所有节点在同一时间具有相同的数据。也就是说，当一个数据在某个节点上被更新后，这个更新能够迅速传播到其他节点，使得所有节点都能看到最新的数据，就好像整个系统只有一个数据副本一样。例如，在一个分布式数据库中，如果一个用户在节点 A 上修改了一条记录，那么其他节点在查询该记录时，应该能够立即看到修改后的结果。</li>
<li><strong>可用性（Availability）</strong>：可用性意味着系统中的每个请求都能得到响应，而不会出现长时间的等待或系统崩溃导致无法响应的情况。无论系统中是否发生了故障，只要客户端发送请求，系统都应该能够在一定的时间内给出响应，保证服务的正常运行。例如，一个在线购物网站，无论何时用户进行访问、下单等操作，都能得到相应的反馈，而不是出现页面长时间加载或无法访问的情况。</li>
<li><strong>分区容错性（Partition Tolerance）</strong>：分布式系统通常由多个节点组成，这些节点通过网络进行通信。分区容错性是指当网络出现分区（即部分节点之间无法进行通信）时，系统仍然能够继续运行。也就是说，即使系统中的某些节点之间失去了联系，整个系统也不会因此而崩溃，仍然能够在其他可用的节点上提供服务。例如，在一个跨数据中心的分布式系统中，由于网络故障导致两个数据中心之间的通信中断，但每个数据中心内部的节点仍然能够正常工作，继续为用户提供服务。</li>
</ul>
<p>⚠️ <strong>在分布式系统中，网络分区（P）一定可能发生</strong>（链路抖动、网络设备故障等无法避免），所以 <strong>P 是必选项</strong>。</p>
<h3 id="BASE-理论"><a href="#BASE-理论" class="headerlink" title="BASE 理论"></a>BASE 理论</h3><p>BASE 理论指的是基本可用 Basically Available，软状态 Soft State，最终一致性 Eventual Consistency，核心思想是即便无法做到强一致性，但应该采用适合的方式保证最终一致性。</p>
<p>BASE，Basically Available Soft State Eventual Consistency 的简写：<br>BA：Basically Available 基本可用，分布式系统在出现故障的时候，允许损失部分可用性，即保证核心可用。<br>S：Soft State 软状态，允许系统存在中间状态，而该中间状态不会影响系统整体可用性。<br>E：Consistency 最终一致性，系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。<br>BASE 理论本质上是对 CAP 理论的延伸，是对 CAP 中 AP 方案的一个补充。</p>
<h3 id="柔性事务"><a href="#柔性事务" class="headerlink" title="柔性事务"></a>柔性事务</h3><p>不同于 ACID 的刚性事务，在分布式场景下基于 BASE 理论，就出现了柔性事务的概念。要想通过柔性事务来达到最终的一致性，就需要依赖于一些特性，这些特性在具体的方案中不一定都要满足，因为不同的方案要求不一样；但是都不满足的话，是不可能做柔性事务的。</p>
<h3 id="幂等操作"><a href="#幂等操作" class="headerlink" title="幂等操作"></a>幂等操作</h3><p>在编程中一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。例如，支付流程中第三方支付系统告知系统中某个订单支付成功，接收该支付回调接口在网络正常的情况下无论操作多少次都应该返回成功。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/v2-84c272f5b9370ac87d9c02a6ec0b51d8_r.jpg" alt="分布式事务"></p>
<p><u>2PC 和 3PC</u> 在理想情况下可以保证<strong>强一致性</strong>，但存在全局阻塞的情况，性能受到影响。</p>
<p><u>TCC 、 Saga 、本地消息表和事务消息</u> 保证的是<strong>最终一致性</strong>，性能较好，但代码侵入性很高。</p>
<h2 id="两阶段提交-2PC"><a href="#两阶段提交-2PC" class="headerlink" title="两阶段提交 2PC"></a>两阶段提交 2PC</h2><p><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/image-20250919154431052.png" alt="2PC 流程" style="zoom:50%;" /></p>
<p><strong>两种参与者：</strong>协调者和参与者。</p>
<ul>
<li><p>第一阶段，协调者让所有参与者执行事务，参与者把执行结果返回给协调者，如果某一个参与者执行失败，协调者会发送回滚事务给所有参与者。</p>
</li>
<li><p>第二阶段：如果所有参与者执行成功，协调者就让所有参与者提交事务。适用于对数据一致性要求高、并发度低的场景，如金融系统转账业务。</p>
</li>
</ul>
<p><strong>优点：</strong>理想情况下可以保证分布式节点的<strong>强一致性</strong>。</p>
<p><strong>缺点：</strong></p>
<ol>
<li>如果参与者初始就故障，其他参与者会白白执行事务，存在资源浪费。</li>
<li>协调者挂掉，参与者执行事务后阻塞等待协调者的通知。</li>
<li>参与者等待协调者时阻塞，会导致其他访问数据库的事务可能被阻塞。</li>
</ol>
<p><strong>数据不一致的情况</strong>：第二阶段，如果部分参与者收到提交命令，<u>部分参与者因为网络原因没有收到提交命令</u>，就会导致数据不一致。</p>
<h2 id="三阶段提交-3PC"><a href="#三阶段提交-3PC" class="headerlink" title="三阶段提交 3PC"></a>三阶段提交 3PC</h2><p><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/image-20250919155850345.png" alt="3PC 流程" style="zoom:50%;" /></p>
<p>为了解决 2PC 的两个问题，引入了3PC，在开头增加了询问是否故障的 canCommit 阶段，就是询问机器是否可以正常运行。其他两个阶段与 2PC 一致。</p>
<p>引入了<strong>超时机制</strong>。第二阶段，如果协调者超时没有收到参与者的回复，协调者就会认为执行异常，通知参与者回滚。第三阶段，如果参与者超时没有收到协调者的提交命令，则自动进行提交。</p>
<p><strong>三阶段提交也不能完全保证数据一致性</strong>，如果存在网络丢包或者阻塞问题，比如由于网络阻塞导致协调者发送的回滚命令未按时到达，就会导致错误提交。</p>
<p><u>2PC 偏向于牺牲可用性（阻塞），3PC 尝试改善可用性，但牺牲了一致性。</u></p>
<p>现代分布式系统往往不用 2PC/3PC 来追求强一致性，而是采用：</p>
<ul>
<li><strong>共识协议</strong>：Paxos、Raft（强一致性，适合元数据、配置管理）。</li>
<li><strong>补偿机制</strong>：TCC（Try-Confirm-Cancel）、Saga（长事务补偿，保证最终一致性）。</li>
<li><strong>幂等操作 + 消息重试</strong>：保证即使失败重试，也不会导致数据错误。</li>
</ul>
<h2 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a>TCC</h2><p>TCC 是一种 <strong>柔性事务（最终一致性）方案</strong>，它不是数据库级事务，而是<strong>应用层事务控制</strong>，由于它对代码侵入性很强，一般不用。</p>
<p>它把一个完整业务拆成三步：</p>
<ol>
<li><strong>Try（预留）</strong>：检查并预留资源（不真正扣减）。</li>
<li><strong>Confirm（确认）</strong>：真正执行业务操作（提交）。</li>
<li><strong>Cancel（取消）</strong>：如果失败则回滚，把预留的资源释放掉。</li>
</ol>
<p>举个例子：转账 100 元（A → B）</p>
<p>假设要实现从 <strong>账户 A 转账 100 元给账户 B</strong>。<br> 在分布式场景下，A 和 B 可能不在同一个数据库/服务里，需要跨服务保证一致性。</p>
<p><strong>如果用 2PC：</strong></p>
<ul>
<li>第一步锁定 A、B 的账户行 → 可能阻塞很久。</li>
<li>如果协调者宕机，A 和 B 状态可能不一致。</li>
</ul>
<p><strong>如果用 TCC 来做，我们把业务拆成 Try、Confirm、Cancel 三步：</strong></p>
<p>Step 1: Try（预留资源）</p>
<ul>
<li>A 账户服务：检查余额是否足够，预留 100 元（冻结）。</li>
<li>B 账户服务：检查账户是否正常，预留可接收额度。</li>
</ul>
<p>👉 此时并没有真正扣减 A 的钱，也没有加到 B 上，只是把资源锁定。</p>
<p>Step 2: Confirm（确认提交）</p>
<ul>
<li>如果所有服务的 Try 都成功：<ul>
<li>A 账户服务：真正扣减余额（-100）。</li>
<li>B 账户服务：真正加钱（+100）。</li>
</ul>
</li>
</ul>
<p>👉 这一步才是业务生效。</p>
<p>Step 3: Cancel（取消操作）</p>
<ul>
<li>如果在 Try 过程中发现问题（比如 A 余额不足、B 账户异常），或者 Confirm 阶段某个服务执行失败：<ul>
<li>A 账户服务：解冻预留的 100 元。</li>
<li>B 账户服务：撤销接收额度。</li>
</ul>
</li>
</ul>
<p>👉 确保即使失败，也能回滚到初始状态。</p>
<p><strong>TCC 的优缺点：</strong></p>
<p>优点：</p>
<ul>
<li>灵活：业务逻辑由应用自己控制，而不是强依赖数据库。</li>
<li>避免了长时间锁表/行，提高性能。</li>
<li>明确的补偿机制（Cancel）。</li>
</ul>
<p>缺点：</p>
<ul>
<li>开发复杂：每个操作都要实现 Try/Confirm/Cancel 三个接口。</li>
<li>补偿要考虑幂等性（Cancel 可能被调用多次）。</li>
<li>对<strong><u>业务侵入性强</u></strong>：应用层要设计好冻结、解冻逻辑。</li>
</ul>
<h2 id="Saga"><a href="#Saga" class="headerlink" title="Saga"></a>Saga</h2><p>Saga 也是一种 <strong>柔性事务</strong> 模型，和 TCC 一样，目标是解决分布式系统里的事务一致性问题。不同点在于：</p>
<ul>
<li><strong>TCC</strong>：每个步骤都有 <strong>Try / Confirm / Cancel</strong> 三个接口。</li>
<li><strong>Saga</strong>：把一个大事务拆分成一系列 <strong>有序的子事务</strong>（Tx1, Tx2, …），每个子事务都有一个 <strong>补偿操作</strong>（Cx1, Cx2, …）。</li>
<li>如果中途有步骤失败，就执行前面已完成步骤的 <strong>补偿操作</strong>，保证最终一致性。</li>
</ul>
<p>👉 可以理解为：Saga 是一串“正向操作 + 对应补偿”的链条。</p>
<p>举个例子：电商下单</p>
<p>用户下单，流程包括：</p>
<ol>
<li>扣减库存（Tx1）</li>
<li>扣减余额（Tx2）</li>
<li>生成订单（Tx3）</li>
</ol>
<p>Saga 正常执行</p>
<ul>
<li>Tx1：库存服务扣减库存</li>
<li>Tx2：支付服务扣减余额</li>
<li>Tx3：订单服务生成订单</li>
</ul>
<p>执行完成 → 事务结束。</p>
<p>Saga 出现失败（比如余额不足）</p>
<p>假设 Tx2（扣减余额）失败了：</p>
<ul>
<li>执行补偿操作：<ul>
<li>Cx1：库存服务回滚（加回库存）</li>
</ul>
</li>
<li>Saga 结束，保证最终一致性。</li>
</ul>
<p>Saga 出现失败（比如生成订单失败）</p>
<p>如果 Tx3（生成订单）失败：</p>
<ul>
<li>执行补偿操作：<ul>
<li>Cx2：支付服务回滚（退回余额）</li>
<li>Cx1：库存服务回滚（加回库存）</li>
</ul>
</li>
<li>Saga 结束。</li>
</ul>
<p><strong>Saga 的特点</strong>：</p>
<p>优点</p>
<ul>
<li><strong>实现相对简单</strong>：只需要正向操作 + 补偿操作，不像 TCC 需要 Try/Confirm/Cancel 三套接口。</li>
<li><strong>长事务友好</strong>：适合跨多个系统、耗时长的业务（比如机票预订、酒店预订、支付组合场景）。</li>
<li><strong>最终一致性</strong>：保证系统最终达到一致状态。</li>
</ul>
<p>缺点</p>
<ul>
<li><strong>中间状态可见</strong>：补偿之前，部分子事务已经生效（比如库存已扣减，但订单失败了 → 瞬间用户看到库存减少）。</li>
<li><strong>补偿可能失败</strong>：必须保证补偿操作的幂等性和可靠性。</li>
<li><strong>业务侵入性</strong>：每个子事务都需要设计对应的补偿逻辑。</li>
</ul>
<h2 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h2><p><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAYyYweGZmMDA=,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="RocketMq事务消息"></p>
<p>事务消息通常分两阶段：</p>
<ol>
<li><strong>半消息（Prepared Message）</strong><br> 生产者先把消息投递到 MQ，但标记为“半消息”，消费者看不到。</li>
<li><strong>本地事务执行</strong><br> 生产者执行数据库事务，比如扣减库存、更新订单状态。</li>
<li><strong>确认或回滚消息</strong><ul>
<li>如果数据库事务成功，生产者向 MQ <strong>提交确认</strong>，半消息转为真正的消息，消费者可以消费。</li>
<li>如果数据库事务失败，生产者通知 MQ <strong>回滚消息</strong>，半消息被丢弃。</li>
</ul>
</li>
<li><strong>补偿机制（事务回查）</strong><br> 如果 MQ 在一段时间内没有收到生产者的确认，MQ 会回查生产者，询问本地事务到底是成功还是失败，然后根据结果决定提交或回滚。</li>
</ol>
<p><strong>举个例子：电商下单扣库存</strong></p>
<p>假设用户在电商系统里下单，需要执行两个动作：</p>
<ol>
<li><strong>订单服务</strong>：生成订单记录（写数据库）。</li>
<li><strong>库存服务</strong>：扣减商品库存（异步消费 MQ 消息）。</li>
</ol>
<p>如果用事务消息，流程是这样的：</p>
<ol>
<li>订单服务发送一条“扣库存”的 <strong>半消息</strong> 到 MQ，消费者看不到。</li>
<li>订单服务开启本地事务：<ul>
<li>在订单数据库里插入一条“待支付”的订单。</li>
<li>本地事务提交成功。</li>
</ul>
</li>
<li>本地事务成功后，订单服务再告诉 MQ：确认提交半消息。<ul>
<li>MQ 将这条“扣库存”的消息变为可见。</li>
<li>库存服务消费到消息，减少库存。</li>
</ul>
</li>
<li>如果订单数据库事务失败（比如插入订单出错），则通知 MQ 回滚半消息，消息直接被删除。</li>
<li>如果网络抖动，确认消息丢失，MQ 会主动回查订单服务：<ul>
<li>如果发现订单已创建，则重新提交半消息。</li>
<li>如果发现订单不存在，则回滚半消息。</li>
</ul>
</li>
</ol>
<p>这样，保证了 <strong>订单和扣库存消息的一致性</strong>。</p>
<h2 id="本地消息表"><a href="#本地消息表" class="headerlink" title="本地消息表"></a>本地消息表</h2><p><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/b86a17506e4919e57349def060e885c5.jpeg" alt="本地消息表"></p>
<ol>
<li>当系统 A 被其他系统调用发生数据库表更操作，首先会更新数据库的业务表，其次会往相同数据库的消息表中插入一条数据，两个操作发生在同一个事务中</li>
<li>系统 A 的脚本定期轮询本地消息往 mq 中写入一条消息，如果消息发送失败会进行重试</li>
<li>系统 B 消费 mq 中的消息，并处理业务逻辑。如果本地事务处理失败，会在继续消费 mq 中的消息进行重试，如果业务上的失败，可以通知系统 A 进行回滚操作</li>
</ol>
<p>本地消息表实现的条件：</p>
<ol>
<li>消费者与生成者的接口都要支持幂等</li>
<li>生产者需要额外的创建消息表</li>
<li>需要提供补偿逻辑，如果消费者业务失败，需要生产者支持回滚操作</li>
</ol>
<p>容错机制：</p>
<ol>
<li>步骤 1 失败时，事务直接回滚</li>
<li>步骤 2、3 写 mq 与消费 mq 失败会进行重试</li>
<li>步骤 3 业务失败系统 B 向系统 A 发起事务回滚操作</li>
</ol>
<p>此方案的核心是将需要分布式处理的任务通过消息日志的方式来异步执行。消息日志可以存储到本地文本、数据库或消息队列，再通过业务规则自动或人工发起重试。人工重试更多的是应用于支付场景，通过对账系统对事后问题的处理。</p>
]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>分布式事务</tag>
        <tag>数据一致性</tag>
      </tags>
  </entry>
  <entry>
    <title>分组背包变体</title>
    <url>/posts/60b2b548.html</url>
    <content><![CDATA[<blockquote>
<p>分组背包问题的3种形式：每组最多选1个（模板），必须选1个，至少选1个</p>
</blockquote>
<h1 id="每组最多选1个"><a href="#每组最多选1个" class="headerlink" title="每组最多选1个"></a>每组最多选1个</h1><p>有 N 组物品和一个容量是 V 的背包。</p>
<p>每组物品有若干个，同一组内的物品最多只能选一个。<br>每件物品的体积是 vij，价值是 wij，其中 i 是组号，j 是组内编号。</p>
<p>求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。</p>
<p>输出最大价值。</p>
<p><strong>输入格式</strong></p>
<p>第一行有两个整数 N，V，用空格隔开，分别表示物品组数和背包容量。接下来有 N 组数据：每组数据第一行有一个整数 $S<em>i$，表示第 i 个物品组的物品数量；每组数据接下来有 $S_i$ 行，每行有两个整数 $v</em>{ij},w_{ij}$，用空格隔开，分别表示第 i 个物品组的第 j 个物品的体积和价值；<br><strong>输出格式</strong></p>
<p>输出一个整数，表示最大价值。</p>
<p><strong>数据范围</strong></p>
<p>$0&lt;N,V≤100$,<br>$0&lt;S<em>i≤100$,<br>$0&lt;v</em>{ij}, w_{ij}≤100$,</p>
<p><strong>代码</strong></p>
<p>没有优化一维数组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> v[N][N],w[N][N],s[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">        cin&gt;&gt;s[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;s[i];j++)</span><br><span class="line">		&#123;</span><br><span class="line">            cin&gt;&gt;v[i][j]&gt;&gt;w[i][j];  <span class="comment">//读入</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m;j++)</span><br><span class="line">		&#123;</span><br><span class="line">            f[i][j]=f[i<span class="number">-1</span>][j];  <span class="comment">//不选</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;s[i];k++)</span><br><span class="line">			&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=v[i][k])     f[i][j]=<span class="built_in">max</span>(f[i][j],f[i<span class="number">-1</span>][j-v[i][k]]+w[i][k]);  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[n][m]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用逆序更新优化一维数组，由于可以不选，才可以优化掉一维数组，f[i][j]=f[i-1][j]，只有一维数组就不需要继承上一次的状态了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> v[N][N],w[N][N],s[N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">        cin&gt;&gt;s[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;s[i];j++)</span><br><span class="line">		&#123;</span><br><span class="line">            cin&gt;&gt;v[i][j]&gt;&gt;w[i][j];  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=m;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=s[i];k++) </span><br><span class="line">                <span class="keyword">if</span>(j&gt;=v[i][k]) f[j]=<span class="built_in">max</span>(f[j],f[j-v[i][k]]+w[i][k]);  </span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">    cout&lt;&lt;f[m]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="每组必须选1个"><a href="#每组必须选1个" class="headerlink" title="每组必须选1个"></a>每组必须选1个</h1><p>小红希望出一场题目，但是他的实力又不够，所以他想到可以从以前的比赛中各抽一题，来组成一场比赛。不过一场比赛的难度应该是有限制的，所以所以这一场比赛会给一个目标难度分数 $target$。</p>
<p>小红选 $n$ 场比赛，每场 $m$ 个题，小红会从每一场选一道题，使其组成的题的难度分数尽量接近 $target$。小红想知道挑选的题的难度分数与  $target$ 相差的最小值是多少。</p>
<p><strong>输入描述:</strong></p>
<p>第一行输入两个整数 $n,m (1≤n≤100,1≤m≤20)$代表小红选了 $n$ 场比赛，每场比赛有 $m$ 道题。<br>此后 $n$ 行，第 $i$ 行输入 $m$ 个整数 $a<em>{i,j} (1≤a</em>{i,j}≤50)$代表第 $i$ 场比赛的第 $j$ 道题的难度分数。<br>最后一行输入一个整数 $target (1≤target≤5000) $代表小红希望这一场比赛的难度分数。</p>
<p><strong>输出描述:</strong></p>
<p>在一行上输出一个整数，表示挑选的题的难度分数与 $target$ 相差的最小值。</p>
<p><strong>示例1</strong></p>
<p>输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 4 7</span><br><span class="line">2 5 8</span><br><span class="line">3 6 9</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>
<p>说明</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">小红可以选第一场比赛的第一道题，第二场比赛的第一道题，第三场比赛的第二道题，这样挑选的题的难度分数为 1+2+6=9，与target 相差的最小值为 1。</span><br></pre></td></tr></table></figure>
<p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, target;</span><br><span class="line"><span class="type">int</span> a[<span class="number">105</span>][<span class="number">25</span>];</span><br><span class="line"><span class="type">bool</span> f[<span class="number">2</span>][<span class="number">5005</span>]; <span class="comment">// f[i][j]表示前i场比赛能否凑出总分为j的题目</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">			cin &gt;&gt; a[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	f[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(f[(i+<span class="number">1</span>)%<span class="number">2</span>], <span class="literal">false</span>, <span class="keyword">sizeof</span> f[(i+<span class="number">1</span>)%<span class="number">2</span>]);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">5000</span>; j++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; m; k++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (j - a[i][k] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">					f[(i+<span class="number">1</span>)%<span class="number">2</span>][j] |= f[i%<span class="number">2</span>][j-a[i][k]];</span><br><span class="line">					<span class="keyword">if</span> (f[(i+<span class="number">1</span>)%<span class="number">2</span>][j]) &#123;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cin &gt;&gt; target;</span><br><span class="line">	<span class="type">int</span> ans = INT_MAX;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">5000</span>; j++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (f[n%<span class="number">2</span>][j]) ans = <span class="built_in">min</span>(ans, <span class="built_in">abs</span>(target - j));</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2 2</span></span><br><span class="line"><span class="comment">3 6</span></span><br><span class="line"><span class="comment">3 6</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h1 id="每组至少选1个"><a href="#每组至少选1个" class="headerlink" title="每组至少选1个"></a>每组至少选1个</h1><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=3033">hdu3033</a></p>
<p>注意循环嵌套顺序变了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">105</span>;</span><br><span class="line"><span class="type">int</span> num[<span class="number">11</span>],cost[<span class="number">11</span>][maxn],value[<span class="number">11</span>][maxn];</span><br><span class="line"><span class="type">int</span> n,m,k,dp[<span class="number">11</span>][<span class="number">10005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a,b,c;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k)!=EOF) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="built_in">sizeof</span>(num));</span><br><span class="line">		<span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">			num[a]++;</span><br><span class="line">			cost[a][num[a]] = b;</span><br><span class="line">			value[a][num[a]] = c;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">memset</span>(dp[<span class="number">0</span>],<span class="number">0</span>,<span class="built_in">sizeof</span>(dp[<span class="number">0</span>]));</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= num[i]; j++) &#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> v = m; v &gt;= cost[i][j]; v--) &#123;</span><br><span class="line">					<span class="keyword">if</span>(dp[i][v-cost[i][j]] != <span class="number">-1</span>)	<span class="comment">//从本组里面取，之前可能抽取了多个</span></span><br><span class="line">						dp[i][v] = <span class="built_in">max</span>(dp[i][v],dp[i][v-cost[i][j]]+value[i][j]);</span><br><span class="line">					<span class="keyword">if</span>(dp[i<span class="number">-1</span>][v-cost[i][j]] != <span class="number">-1</span>)	<span class="comment">//从本组中抽取的第一个</span></span><br><span class="line">						dp[i][v] = <span class="built_in">max</span>(dp[i][v],dp[i<span class="number">-1</span>][v-cost[i][j]]+value[i][j]);</span><br><span class="line">					<span class="comment">/*</span></span><br><span class="line"><span class="comment">					顺序不能调转，因为如果代价为0，调转的话，有可能出现先有dp[i][v] = dp[i-1][v-0]+w，再有</span></span><br><span class="line"><span class="comment">					dp[i][v] = dp[i][v-0]+w = dp[i-1][v-0]+w+w,所以物品取了两次</span></span><br><span class="line"><span class="comment">					*/</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(dp[k][m] == <span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">&quot;Impossible\n&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dp[k][m]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>分组背包</tag>
      </tags>
  </entry>
  <entry>
    <title>判断是否存在一条线经过所有线段</title>
    <url>/posts/bd16ef6a.html</url>
    <content><![CDATA[<h1 id="ACWING"><a href="#ACWING" class="headerlink" title="ACWING"></a><a href="https://www.acwing.com/problem/content/2987/">ACWING</a></h1><p><img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/ef4eb9ca60b54de5814e0442fae75655.png" alt="ef4eb9ca60b54de5814e0442fae75655"></p>
<p>如果一条直线经过了所有线段，那么把这条直线旋转之后，边界就是卡在两个线段的端点处</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/773f3b29fcdd40be885f42432645b139.png" alt="773f3b29fcdd40be885f42432645b139"></p>
<p>那么就可以遍历每两个端点，判断这两个端点组成的直线是否穿过了所有的线段，如果是，则存在，不是继续找，找不到就不存在</p>
<p>如何判断一条直线是否经过了所有点呢？挨个判断这条线是否穿过线段</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#pragma G++ optimize(2)</span></span><br><span class="line"><span class="comment">//#pragma G++ optimize(3,&quot;Ofast&quot;,&quot;inline&quot;)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SUB=<span class="number">-0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-8</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> E=<span class="built_in">exp</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">int</span> t,n,tail;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line">	<span class="type">double</span> x,y;</span><br><span class="line">&#125;pt[MAXN];	<span class="comment">//点</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">cross</span><span class="params">(point a,point b,point c)</span>&#123;	<span class="comment">//叉积</span></span><br><span class="line">	<span class="keyword">return</span> (b.x-a.x)*(c.y-a.y)-(c.x-a.x)*(b.y-a.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fcmp</span><span class="params">(<span class="type">double</span> x,<span class="type">double</span> y)</span>&#123;	<span class="comment">//误差比较</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">fabs</span>(x-y)&lt;eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(x&gt;y) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sign</span><span class="params">(<span class="type">double</span> x)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">fabs</span>(x)&lt;=eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(x&gt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">check</span><span class="params">(<span class="type">double</span> x1,<span class="type">double</span> y1,<span class="type">double</span> x2,<span class="type">double</span> y2)</span>&#123;</span><br><span class="line">	point q1=&#123;x1,y1&#125;,q2=&#123;x2,y2&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=tail;k+=<span class="number">2</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(sign(cross(q1,q2,pt[k]))*sign(cross(q1,q2,pt[k+<span class="number">1</span>]))&gt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; 	<span class="comment">//在直线的同一侧</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		tail=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="type">double</span> x1,y1,x2,y2;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;</span><br><span class="line">			pt[++tail]=&#123;x1,y1&#125;;</span><br><span class="line">			pt[++tail]=&#123;x2,y2&#125;;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;tail;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=tail;j++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(!fcmp(pt[i].x,pt[j].x) &amp;&amp; !fcmp(pt[i].y,pt[j].y)) <span class="keyword">continue</span>;</span><br><span class="line">				<span class="keyword">if</span>(check(pt[i].x,pt[i].y,pt[j].x,pt[j].y)) flag=<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span>(flag) <span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(flag) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(flag) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Yes!\n&quot;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;No!\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title>初探强化学习</title>
    <url>/posts/3ff4588e.html</url>
    <content><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>本文介绍了强化学习的思想和适应性从弱到强的几种强化学习算法，包括Sarsa、QLearning、DQN、DDPG。并利用这些算法在OpenAI的gym实验室中解决了实际的问题，可以帮助小白入门强化学习。</p>
<h1 id="强化学习思想"><a href="#强化学习思想" class="headerlink" title="强化学习思想"></a>强化学习思想</h1><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><p><img src="https://pic2.zhimg.com/v2-ccf370a53e34d7f07c9f8a0baa081f0d_1440w.jpg" alt="img"></p>
<p><strong>智能体（Agent）</strong>：智能体是与环境交互的主体，通过观察环境状态、采取动作并根据奖励信号学习策略。</p>
<p><strong>环境（Environment）</strong>：智能体所处的外部世界，它根据智能体的动作提供新的状态和奖励。</p>
<p><strong>状态(State)/观察值(Observation)</strong>：环境的一个描述，包含智能体当前所处的所有信息。可以是观测到的部分状态（部分可观测环境）或完整状态。</p>
<p><strong>动作（Action）</strong>：智能体在某一状态下可以执行的行为，影响环境的转变。动作空间可以是<strong>离散的</strong>或<strong>连续的</strong>。例如，走迷宫机器人如果只有东南西北这 4 种移动方式，则其为离散动作空间;如果机器人向 360◦ 中的任意角度都可以移动，则为连续动作空间。</p>
<p><strong>奖励（Reward）</strong>：智能体每执行一个动作后，环境反馈的数值信号，用来表示该动作的好坏。奖励可以是<strong>即时奖励</strong>或<strong>累积奖励</strong>。</p>
<p><strong>策略（Policy）</strong>：定义智能体在某一状态下选择动作的行为规则。策略可以是：</p>
<ul>
<li><strong>随机策略（Stochastic Policy）</strong>：输出动作的概率分布。</li>
<li><strong>确定性策略（Deterministic Policy）</strong>：直接输出具体动作。</li>
</ul>
<p><strong>价值函数（Value Function）</strong>：描述一个状态或状态-动作对的好坏，衡量长期回报的期望值。</p>
<ul>
<li><p><strong>状态价值函数 V(s)</strong>：用来度量给定策略π的情况下，当前状态st的好坏程度。</p>
</li>
<li><p><strong>动作价值函数 Q(s,a)</strong>：用来度量给定状态$s_t$和策略$π$的情况下，采用动作$a_t$的好坏程度。</p>
</li>
</ul>
<p><strong>折扣因子（Discount Factor）</strong>：衡量未来奖励的重要性，取值范围 $0 \leq \gamma \leq 1$。较低的 $\gamma$ 更关注短期奖励，较高的 $\gamma$ 更关注长期奖励。</p>
<h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>强化学习（Reinforcement learning，RL）讨论的问题是一个<strong>智能体(agent)</strong> 怎么在一个复杂不确定的 <strong>环境(environment)</strong> 里面去极大化它能获得的奖励。通过感知所处环境的 <strong>状态(state)</strong> 对 <strong>动作(action)</strong> 的 <strong>反应(reward)</strong>， 来指导更好的动作，从而获得最大的 <strong>收益(return)</strong>，这被称为在交互中学习，这样的学习方法就被称作强化学习</p>
<p><img src="https://picx.zhimg.com/v2-8bbe0cc23c0c0b104aa44089111b6e8b_1440w.jpg" alt="img"></p>
<p>在强化学习过程中，智能体跟环境一直在交互。智能体在环境里面获取到状态，智能体会利用这个状态输出一个动作，一个决策。然后这个决策会放到环境之中去，环境会根据智能体采取的决策，输出下一个状态以及当前的这个决策得到的奖励。智能体的目的就是为了尽可能多地从环境中获取奖励。</p>
<p>强化学习是除了监督学习和非监督学习之外的第三种基本的机器学习方法。</p>
<ul>
<li><strong>监督学习</strong> 是从外部监督者提供的带标注训练集中进行学习。 <strong>(任务驱动型)</strong></li>
<li><strong>非监督学习</strong> 是一个典型的寻找未标注数据中隐含结构的过程。 <strong>(数据驱动型)</strong></li>
<li><strong>强化学习</strong> 更偏重于智能体与环境的交互， 这带来了一个独有的挑战 ——“<strong>试错（exploration）</strong>”与“<strong>开发（exploitation）</strong>”之间的折中权衡，智能体必须开发已有的经验来获取收益，同时也要进行试探，使得未来可以获得更好的动作选择空间。 <strong>(从错误中学习)</strong></li>
</ul>
<p>强化学习主要有以下几个特点：</p>
<ul>
<li><strong>试错学习</strong>：强化学习一般没有直接的指导信息，Agent 要以不断与 Environment 进行交互，通过试错的方式来获得最佳策略(Policy)。</li>
<li><strong>延迟回报</strong>：强化学习的指导信息很少，而且往往是在事后（最后一个状态(State)）才给出的。比如 围棋中只有到了最后才能知道胜负。</li>
</ul>
<p><strong>按照学习目标划分：基于策略（Policy-Based）和基于价值（Value-Based）。</strong></p>
<p><img src="https://pic1.zhimg.com/v2-00c43d39fee17d31da576e6e0a7df99e_1440w.jpg" alt="img"></p>
<ul>
<li><strong>Policy-Based</strong>的方法直接输出下一步动作的概率，根据概率来选取动作。但不一定概率最高就会选择该动作，还是会从整体进行考虑。适用于非连续和连续的动作。常见的方法有Policy gradients。</li>
<li><strong>Value-Based</strong>的方法输出的是动作的价值，选择价值最高的动作。适用于非连续的动作。常见的方法有Q-learning、Deep Q Network和Sarsa。</li>
<li>更为厉害的方法是二者的结合：Actor-Critic，Actor根据概率做出动作，Critic根据动作给出价值，从而加速学习过程，常见的有A2C，A3C，DDPG等。</li>
</ul>
<h1 id="经典算法"><a href="#经典算法" class="headerlink" title="经典算法"></a>经典算法</h1><h2 id="Sarsa-悬崖问题"><a href="#Sarsa-悬崖问题" class="headerlink" title="Sarsa (悬崖问题)"></a>Sarsa (悬崖问题)</h2><p><img src="初探强化学习.assets/image-20250111221018607.png" alt="image-20250111221018607"></p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> gym</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SarsaAgent</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, obs_n, act_n, learning_rate=<span class="number">0.01</span>, gamma=<span class="number">0.9</span>, e_greed=<span class="number">0.1</span></span>):</span><br><span class="line">        self.act_n = act_n</span><br><span class="line">        self.lr = learning_rate</span><br><span class="line">        self.gamma = gamma</span><br><span class="line">        self.epsilon = e_greed</span><br><span class="line">        self.Q = np.zeros((obs_n, act_n))</span><br><span class="line">    <span class="comment"># e_greed:根据s_t,选择a_t</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sample</span>(<span class="params">self,obs</span>):</span><br><span class="line">        <span class="keyword">if</span> np.random.uniform(<span class="number">0</span>,<span class="number">1</span>) &lt; (<span class="number">1.0</span> - self.epsilon):</span><br><span class="line">            action = self.predict(obs)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            action = np.random.choice(self.act_n) <span class="comment"># 0,1,2,3</span></span><br><span class="line">        <span class="keyword">return</span> action</span><br><span class="line">    <span class="comment"># a_t = argmax Q(s)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">self, obs</span>):</span><br><span class="line">        Q_list = self.Q[obs, :] <span class="comment">#当前s下所有a对应的Q值</span></span><br><span class="line">        maxQ = np.<span class="built_in">max</span>(Q_list)</span><br><span class="line">        action_list = np.where(Q_list == maxQ)[<span class="number">0</span>] <span class="comment"># action_list=所有=Qmax的索引</span></span><br><span class="line">        action = np.random.choice(action_list)</span><br><span class="line">        <span class="keyword">return</span> action</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">learn</span>(<span class="params">self, obs, action, reward, next_obs, next_action, done</span>): <span class="comment"># (S,A,R,S,A)</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        done: episode是否结束</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        predict_Q = self.Q[obs,action]</span><br><span class="line">        <span class="keyword">if</span> done:</span><br><span class="line">            target_Q = reward</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            target_Q = reward + self.gamma * self.Q[next_obs,next_action]</span><br><span class="line">        <span class="comment"># 更新Q表格</span></span><br><span class="line">        self.Q[obs,action] += self.lr * (target_Q - predict_Q)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">save</span>(<span class="params">self</span>):</span><br><span class="line">        npy_file = <span class="string">&#x27;./q-table.npy&#x27;</span></span><br><span class="line">        np.save(npy_file, self.Q)</span><br><span class="line">        <span class="built_in">print</span>(npy_file + <span class="string">&#x27; saved.&#x27;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">load</span>(<span class="params">self, npy_file=<span class="string">&#x27;./q_table.npy&#x27;</span></span>):</span><br><span class="line">        self.Q = np.load(npy_file)</span><br><span class="line">        <span class="built_in">print</span>(npy_file + <span class="string">&#x27; loaded.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_episode</span>(<span class="params">env, agent, render=<span class="literal">False</span></span>):</span><br><span class="line">    total_steps = <span class="number">0</span> <span class="comment"># 记录当前episode走了多少step</span></span><br><span class="line">    total_reward = <span class="number">0</span> </span><br><span class="line">    obs = env.reset()</span><br><span class="line">    action = agent.sample(obs)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        next_obs, reward, done, _ = env.step(action)</span><br><span class="line">        next_action = agent.sample(next_obs)</span><br><span class="line">        agent.learn(obs, action, reward, next_obs, next_action, done)</span><br><span class="line">        action = next_action</span><br><span class="line">        obs = next_obs</span><br><span class="line">        total_reward += reward</span><br><span class="line">        total_steps += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> render:</span><br><span class="line">            env.render()</span><br><span class="line">            time.sleep(<span class="number">0.</span>)</span><br><span class="line">        <span class="keyword">if</span> done:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> total_reward, total_steps</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_episode</span>(<span class="params">env, agent</span>): </span><br><span class="line">    total_steps = <span class="number">0</span> <span class="comment"># 记录当前episode走了多少step</span></span><br><span class="line">    total_reward = <span class="number">0</span> </span><br><span class="line">    obs = env.reset()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        action = agent.predict(obs)</span><br><span class="line">        next_obs, reward, done, _ = env.step(action)</span><br><span class="line">        total_reward += reward</span><br><span class="line">        total_steps += <span class="number">1</span></span><br><span class="line">        obs = next_obs</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line">        env.render()</span><br><span class="line">        <span class="keyword">if</span> done:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> total_reward, total_steps</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    env = gym.make(<span class="string">&quot;CliffWalking-v0&quot;</span>)</span><br><span class="line">    agent = SarsaAgent(obs_n=env.observation_space.n, </span><br><span class="line">                       act_n=env.action_space.n,</span><br><span class="line">                       learning_rate=<span class="number">0.025</span>, gamma=<span class="number">0.9</span>, e_greed=<span class="number">0.1</span>)</span><br><span class="line">    <span class="keyword">for</span> episode <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">        total_reward, total_steps = run_episode(env, agent, <span class="literal">False</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Episode %s: total_steps = %s , total_reward = %.1f&#x27;</span> % (episode, total_steps, total_reward))</span><br><span class="line">    test_episode(env, agent)</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<h2 id="Q-Learning"><a href="#Q-Learning" class="headerlink" title="Q-Learning"></a>Q-Learning</h2><p>在Q-learning中，我们维护一张Q值表，表的维数为：状态数S * 动作数A，表中每个数代表在当前状态S下可以采用动作A可以获得的未来收益的折现和。我们不断的迭代我们的Q值表使其最终收敛，然后根据Q值表我们就可以在每个状态下选取一个最优策略。</p>
<p><img src="https://pic1.zhimg.com/v2-6fa4c30d7dfdf02a608c1758fc69edea_1440w.jpg" alt="img"></p>
<p>假设机器人必须越过迷宫并到达终点。有地雷，机器人一次只能移动一个地砖。如果机器人踏上矿井，机器人就死了。机器人必须在尽可能短的时间内到达终点。 得分/奖励系统如下：</p>
<ul>
<li>机器人在每一步都失去1点。这样做是为了使机器人采用<a href="https://zhida.zhihu.com/search?content_id=191787601&amp;content_type=Article&amp;match_order=1&amp;q=最短路径&amp;zhida_source=entity">最短路径</a>并尽可能快地到达目标。</li>
<li>如果机器人踩到地雷，则点损失为100并且游戏结束。</li>
<li>如果机器人获得动力⚡️，它会获得1点。</li>
<li>如果机器人达到最终目标，则机器人获得100分。 现在，显而易见的问题是：我们如何训练机器人以最短的路径到达最终目标而不踩矿井？</li>
</ul>
<h3 id="Q值表"><a href="#Q值表" class="headerlink" title="Q值表"></a><strong>Q值表</strong></h3><p>Q值表(Q-Table)是一个简单查找表的名称，我们计算每个状态的最大预期未来奖励。基本上，这张表将指导我们在每个状态采取最佳行动。</p>
<p><img src="https://pic3.zhimg.com/v2-0ae8f9bba40cb934c20978a5d6d95a68_1440w.jpg" alt="img"></p>
<h3 id="Q函数"><a href="#Q函数" class="headerlink" title="Q函数"></a><strong>Q函数</strong></h3><p>Q函数(Q-Function)即为上文提到的动作价值函数，他有两个输入：「状态」和「动作」。它将返回在该状态下执行该动作的未来奖励期望。</p>
<p><img src="https://pic3.zhimg.com/v2-45c7656e0245e84a0743cfa73ef17420_1440w.jpg" alt="img"></p>
<p>我们可以把Q函数视为一个在Q-Table上滚动的读取器，用于寻找与当前状态关联的行以及与动作关联的列。它会从相匹配的单元格中返回 Q 值。这就是未来奖励的期望。</p>
<p><img src="https://pic3.zhimg.com/v2-7b3c0c373dccad3cf3d5d4728b356c0c_1440w.jpg" alt="img"></p>
<p>在我们探索环境（environment）之前，<a href="https://zhida.zhihu.com/search?content_id=191787601&amp;content_type=Article&amp;match_order=1&amp;q=Q-table&amp;zhida_source=entity">Q-table</a> 会给出相同的任意的设定值（大多数情况下是 0）。随着对环境的持续探索，这个 Q-table 会通过迭代地使用 Bellman 方程（<a href="https://zhida.zhihu.com/search?content_id=191787601&amp;content_type=Article&amp;match_order=1&amp;q=动态规划方程&amp;zhida_source=entity">动态规划方程</a>）更新 Q(s，a) 来给出越来越好的近似。</p>
<h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a><strong>算法流程</strong></h3><p><img src="https://pic4.zhimg.com/v2-bc3517d0e73e145d525d9542e58b35e3_1440w.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/v2-6c9bc7197c4fe0c110ed3843c8a6fe4e_1440w.jpg" alt="img"></p>
<p><strong>第1步：初始化Q值表</strong> 我们将首先构建一个Q值表。有n列，其中n=操作数。有m行，其中m=状态数。我们将值初始化为0</p>
<p><img src="https://picx.zhimg.com/v2-89f932969cdbb19f8b105e430670b3bd_1440w.jpg" alt="img"></p>
<p><strong>步骤2和3：选择并执行操作</strong> 这些步骤的组合在不确定的时间内完成。这意味着此步骤一直运行，直到我们停止训练，或者训练循环停止。</p>
<p><img src="https://picx.zhimg.com/v2-80ca3bbb7471b464800df1bccfb0dff1_1440w.jpg" alt="img"></p>
<p>如果每个Q值都等于零，我们就需要权衡探索/利用（exploration/exploitation）的程度了，思路就是，在一开始，我们将使用 <a href="https://zhida.zhihu.com/search?content_id=191787601&amp;content_type=Article&amp;match_order=1&amp;q=epsilon&amp;zhida_source=entity">epsilon</a> 贪婪策略：</p>
<ul>
<li>我们指定一个探索速率「epsilon」，一开始将它设定为 1。这个就是我们将随机采用的步长。在一开始，这个速率应该处于最大值，因为我们不知道 Q-table 中任何的值。这意味着，我们需要通过随机选择动作进行大量的探索。</li>
<li>生成一个随机数。如果这个数大于 epsilon，那么我们将会进行「利用」（这意味着我们在每一步利用已经知道的信息选择动作）。否则，我们将继续进行探索。</li>
<li>在刚开始训练 Q 函数时，我们必须有一个大的 epsilon。随着智能体对估算出的 Q 值更有把握，我们将逐渐减小 epsilon。</li>
</ul>
<p><img src="https://pic3.zhimg.com/v2-d94d164f15947a25d50978c942940bf8_1440w.jpg" alt="img"></p>
<p><strong>步骤4和5：评估</strong> 现在我们采取了行动并观察了结果和奖励。我们需要更新功能Q（s，a）：</p>
<p><img src="https://pic1.zhimg.com/v2-62b52d433fc2079274e7affea881ae02_1440w.jpg" alt="img"></p>
<p>最后生成的Q表：</p>
<p><img src="https://pic2.zhimg.com/v2-66d5eccdf6520f8215c684b4016c09df_1440w.jpg" alt="img"></p>
<h3 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> gym</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QLearningAgent</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, obs_n, act_n, learning_rate=<span class="number">1e-2</span>, gamma=<span class="number">0.9</span>, e_greed=<span class="number">0.1</span></span>):</span><br><span class="line">        self.act_n = act_n  <span class="comment"># 动作维度，有几个动作可选</span></span><br><span class="line">        self.lr = learning_rate  <span class="comment"># 学习率</span></span><br><span class="line">        self.gamma = gamma  <span class="comment"># reward的衰减率</span></span><br><span class="line">        self.epsilon = e_greed  <span class="comment"># 按一定概率随机选动作</span></span><br><span class="line">        self.Q = np.zeros((obs_n, act_n))</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sample</span>(<span class="params">self, obs</span>):</span><br><span class="line">        <span class="keyword">if</span> np.random.uniform(<span class="number">0</span>, <span class="number">1</span>) &lt; (<span class="number">1.0</span> - self.epsilon):  <span class="comment"># 根据table的Q值选动作</span></span><br><span class="line">            action = self.predict(obs)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            action = np.random.choice(self.act_n)  <span class="comment"># 有一定概率随机探索选取一个动作</span></span><br><span class="line">        <span class="keyword">return</span> action</span><br><span class="line">    <span class="comment"># 根据输入观察值，预测输出的动作值</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">self, obs</span>):</span><br><span class="line">        Q_list = self.Q[obs, :]</span><br><span class="line">        maxQ = np.<span class="built_in">max</span>(Q_list)</span><br><span class="line">        action_list = np.where(Q_list == maxQ)[<span class="number">0</span>]  <span class="comment"># maxQ可能对应多个action</span></span><br><span class="line">        action = np.random.choice(action_list)</span><br><span class="line">        <span class="keyword">return</span> action</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">learn</span>(<span class="params">self, obs, action, reward, next_obs, done</span>): <span class="comment">#(S,A,R,S)</span></span><br><span class="line">        predict_Q = self.Q[obs, action]</span><br><span class="line">        <span class="keyword">if</span> done:</span><br><span class="line">            target_Q = reward</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            target_Q = reward + self.gamma * np.<span class="built_in">max</span>(self.Q[next_obs,:])</span><br><span class="line">        self.Q[obs, action] += self.lr * (target_Q - predict_Q)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">save</span>(<span class="params">self</span>):</span><br><span class="line">        npy_file = <span class="string">&#x27;./q-table.npy&#x27;</span></span><br><span class="line">        np.save(npy_file, self.Q)</span><br><span class="line">        <span class="built_in">print</span>(npy_file + <span class="string">&#x27; saved.&#x27;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">load</span>(<span class="params">self, npy_file=<span class="string">&#x27;./q_table.npy&#x27;</span></span>):</span><br><span class="line">        self.Q = np.load(npy_file)</span><br><span class="line">        <span class="built_in">print</span>(npy_file + <span class="string">&#x27; loaded.&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_episode</span>(<span class="params">env, agent, render=<span class="literal">False</span></span>):</span><br><span class="line">    <span class="comment"># 其实真正执行的策略和Sarsa是一样的，只不过学习的策略是保守的最优策略</span></span><br><span class="line">    total_steps = <span class="number">0</span></span><br><span class="line">    total_reward = <span class="number">0</span></span><br><span class="line">    obs = env.reset()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        action = agent.sample(obs)</span><br><span class="line">        next_obs, reward, done, _ = env.step(action)</span><br><span class="line">        agent.learn(obs, action, reward, next_obs, done)</span><br><span class="line">        obs = next_obs</span><br><span class="line"></span><br><span class="line">        total_reward += reward</span><br><span class="line">        total_steps += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> render:</span><br><span class="line">            env.render()</span><br><span class="line">        <span class="keyword">if</span> done:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> total_reward, total_steps</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_episode</span>(<span class="params">env, agent</span>):</span><br><span class="line">    total_reward = <span class="number">0</span></span><br><span class="line">    obs = env.reset()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        action = agent.predict(obs)  <span class="comment"># greedy</span></span><br><span class="line">        next_obs, reward, done, _ = env.step(action)</span><br><span class="line">        total_reward += reward</span><br><span class="line">        obs = next_obs</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line">        env.render()</span><br><span class="line">        <span class="keyword">if</span> done:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> total_reward</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    env = gym.make(<span class="string">&quot;CliffWalking-v0&quot;</span>)  <span class="comment"># 0 up, 1 right, 2 down, 3 left</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建一个agent实例，输入超参数</span></span><br><span class="line">    agent = QLearningAgent(</span><br><span class="line">        obs_n=env.observation_space.n,</span><br><span class="line">        act_n=env.action_space.n,</span><br><span class="line">        learning_rate=<span class="number">0.1</span>,</span><br><span class="line">        gamma=<span class="number">0.9</span>,</span><br><span class="line">        e_greed=<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 训练500个episode，打印每个episode的分数</span></span><br><span class="line">    <span class="keyword">for</span> episode <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">500</span>):</span><br><span class="line">        ep_reward, ep_steps = run_episode(env, agent, <span class="literal">False</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Episode %s: steps = %s , reward = %.1f&#x27;</span> % (episode, ep_steps, ep_reward))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 全部训练结束，查看算法效果</span></span><br><span class="line">    test_reward = test_episode(env, agent)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;test reward = %.1f&#x27;</span> % (test_reward))</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Deep-Q-Network"><a href="#Deep-Q-Network" class="headerlink" title="Deep Q Network"></a><strong>Deep Q Network</strong></h2><p>在普通的Q-learning中，当状态和动作空间是离散且维数不高时可使用<a href="https://zhida.zhihu.com/search?content_id=191787601&amp;content_type=Article&amp;match_order=3&amp;q=Q-Table&amp;zhida_source=entity">Q-Table</a>储存每个状态动作对的Q值，而当状态和动作空间是高维连续时，使用Q-Table不现实，我们无法构建可以存储超大<a href="https://zhida.zhihu.com/search?content_id=191787601&amp;content_type=Article&amp;match_order=1&amp;q=状态空间&amp;zhida_source=entity">状态空间</a>的Q_table。不过，在机器学习中， 有一种方法对这种事情很在行，那就是神经网络，可以将状态和动作当成神经网络的输入，然后经过神经网络分析后得到动作的 Q 值，这样就没必要在表格中记录 Q 值，而是直接使用神经网络预测Q值</p>
<p><img src="https://pica.zhimg.com/v2-cec53729a7c798c93012c478d8086596_1440w.jpg" alt="img"></p>
<h3 id="经验回放"><a href="#经验回放" class="headerlink" title="经验回放"></a><strong>经验回放</strong></h3><p>DQN利用Qlearning特点，目标策略与动作策略分离，学习时利用经验池储存的经验取batch更新Q。同时提高了样本的利用率，也打乱了样本状态相关性使其符合神经网络的使用特点。</p>
<h3 id="固定Q目标"><a href="#固定Q目标" class="headerlink" title="固定Q目标"></a><strong>固定Q目标</strong></h3><p>神经网络一般学习的是固定的目标，而Qlearning中Q同样为学习的变化量，变动太大不利于学习。所以DQN使Q在一段时间内保持不变，使神经网络更易于学习。</p>
<h3 id="算法流程-1"><a href="#算法流程-1" class="headerlink" title="算法流程"></a><strong>算法流程</strong></h3><p><img src="https://pica.zhimg.com/v2-1e4d1da2aaf789925227f21d4e6843a6_1440w.jpg" alt="img"></p>
<h3 id="主要问题"><a href="#主要问题" class="headerlink" title="主要问题"></a><strong>主要问题</strong></h3><ul>
<li>在估计值函数的时候一个任意小的变化可能导致对应动作被选择或者不被选择，这种不连续的变化是致使基于值函数的方法无法得到收敛保证的重要因素。</li>
<li>选择最大的Q值这样一个搜索过程在高纬度或者连续空间是非常困难的；</li>
<li>无法学习到<a href="https://zhida.zhihu.com/search?content_id=191787601&amp;content_type=Article&amp;match_order=1&amp;q=随机策略&amp;zhida_source=entity">随机策略</a>，有些情况下随机策略往往是最优策略。</li>
</ul>
<h3 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gym</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> Linear, Conv2d, ReLU</span><br><span class="line"><span class="keyword">import</span> PIL.Image <span class="keyword">as</span> Image</span><br><span class="line"></span><br><span class="line">device=torch.device(<span class="string">&quot;cuda:0&quot;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span><span class="string">&quot;cpu&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 经验池</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DQBReplayer</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, capacity</span>):</span><br><span class="line">        <span class="comment"># (S,A,R,S)</span></span><br><span class="line">        self.memory = pd.DataFrame(index=<span class="built_in">range</span>(capacity), columns=[<span class="string">&#x27;observation&#x27;</span>, <span class="string">&#x27;action&#x27;</span>, <span class="string">&#x27;reward&#x27;</span>, <span class="string">&#x27;next_observation&#x27;</span>, <span class="string">&#x27;done&#x27;</span>])</span><br><span class="line">        self.i = <span class="number">0</span></span><br><span class="line">        self.count = <span class="number">0</span></span><br><span class="line">        self.capacity = capacity</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">store</span>(<span class="params">self,*args</span>):</span><br><span class="line">        self.memory.loc[self.i] = args</span><br><span class="line">        self.i = (self.i + <span class="number">1</span>)%self.capacity</span><br><span class="line">        self.count = <span class="built_in">min</span>(self.count+<span class="number">1</span>, self.capacity)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sample</span>(<span class="params">self, size</span>):</span><br><span class="line">        indics = np.random.choice(self.count, size=size)</span><br><span class="line">        <span class="keyword">return</span> (np.stack(self.memory.loc[indics,field]) <span class="keyword">for</span> field <span class="keyword">in</span> self.memory.columns)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Q-Network</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DQN_net</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(DQN_net, self).__init__()</span><br><span class="line">        self.conv = nn.Sequential(</span><br><span class="line">            Conv2d(in_channels=<span class="number">4</span>, out_channels=<span class="number">32</span>, kernel_size=<span class="number">8</span>, stride=<span class="number">4</span>),</span><br><span class="line">            ReLU(),</span><br><span class="line">            Conv2d(in_channels=<span class="number">32</span>, out_channels=<span class="number">64</span>, kernel_size=<span class="number">4</span>, stride=<span class="number">2</span>),</span><br><span class="line">            ReLU(),</span><br><span class="line">            Conv2d(in_channels=<span class="number">64</span>, out_channels=<span class="number">64</span>, kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>),</span><br><span class="line">            ReLU()</span><br><span class="line">        )</span><br><span class="line">        self.classifier = nn.Sequential(</span><br><span class="line">            Linear(<span class="number">3136</span>, <span class="number">512</span>),</span><br><span class="line">            ReLU(),</span><br><span class="line">            Linear(<span class="number">512</span>, <span class="number">4</span>)</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = self.conv(x)</span><br><span class="line">        x = x.view(x.size(<span class="number">0</span>),-<span class="number">1</span>)</span><br><span class="line">        output = self.classifier(x)</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DQN</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, input_shape, env</span>):</span><br><span class="line">        <span class="built_in">super</span>(DQN, self).__init__()</span><br><span class="line">        self.replayer_start_size = <span class="number">100000</span></span><br><span class="line">        self.upon_times = <span class="number">20</span></span><br><span class="line">        self.replayer = DQBReplayer(capacity=self.replayer_start_size)</span><br><span class="line">        self.action_n = env.action_space.n</span><br><span class="line">        self.image_stack = input_shape[<span class="number">2</span>]</span><br><span class="line">        self.gamma = <span class="number">0.99</span></span><br><span class="line">        self.image_shape = (input_shape[<span class="number">0</span>], input_shape[<span class="number">1</span>])</span><br><span class="line">        self.e_net = DQN_net()</span><br><span class="line">        self.t_net = DQN_net()</span><br><span class="line"></span><br><span class="line">        self.learn_step = <span class="number">0</span></span><br><span class="line">        self.max_learn_step = <span class="number">650000</span></span><br><span class="line">        self.epsilon = <span class="number">1.</span></span><br><span class="line">        self.start_learn = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_next_state</span>(<span class="params">self,state=<span class="literal">None</span>,observation=<span class="literal">None</span></span>):</span><br><span class="line">        img=Image.fromarray(observation,<span class="string">&quot;RGB&quot;</span>)</span><br><span class="line">        img=img.resize(self.image_shape).convert(<span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">        img=np.asarray(img.getdata(),dtype=np.uint8,).reshape(img.size[<span class="number">1</span>],img.size[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> state <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            next_state = np.array([img,]*self.image_stack)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            next_state = np.append(state[<span class="number">1</span>:],[img,],axis=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> next_state</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decide</span>(<span class="params">self,state,step</span>):</span><br><span class="line">        <span class="keyword">if</span> self.start_learn == <span class="literal">False</span>: <span class="comment">#前50000步随机选择</span></span><br><span class="line">            action = np.random.randint(<span class="number">0</span>, <span class="number">4</span>)</span><br><span class="line">            <span class="keyword">return</span> action</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.epsilon -= <span class="number">0.0000053</span></span><br><span class="line">        <span class="keyword">if</span> step &lt; <span class="number">30</span>:</span><br><span class="line">            <span class="comment">#每局前三十步随机选择，中间30万，</span></span><br><span class="line">            <span class="comment">#以一定概率（1-epsilon）通过神经网络选择，</span></span><br><span class="line">            <span class="comment"># 最后30万次以0.99概率通过神经网络选择</span></span><br><span class="line">            action = np.random.randint(<span class="number">0</span>, <span class="number">4</span>)</span><br><span class="line">        <span class="keyword">elif</span> np.random.random() &lt; <span class="built_in">max</span>(self.epsilon, <span class="number">0.0005</span>):</span><br><span class="line">            action = np.random.randint(<span class="number">0</span>,<span class="number">4</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            state = state/<span class="number">128</span> - <span class="number">1</span></span><br><span class="line">            y = torch.Tensor(state).<span class="built_in">float</span>().unsqueeze(<span class="number">0</span>)</span><br><span class="line">            y = y.to(device)</span><br><span class="line">            x = self.e_net(y).detach()</span><br><span class="line">            <span class="keyword">if</span> self.learn_step%<span class="number">2000</span>==<span class="number">0</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;q value&#123;&#125;&quot;</span>.<span class="built_in">format</span>(x))</span><br><span class="line">            action = torch.argmax(x).data.item()</span><br><span class="line">        <span class="keyword">return</span> action</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    sum_reward = <span class="number">0</span></span><br><span class="line">    store_count = <span class="number">0</span></span><br><span class="line">    env = gym.make(<span class="string">&#x27;Breakout-v0&#x27;</span>)</span><br><span class="line">    net = DQN([<span class="number">84</span>,<span class="number">84</span>,<span class="number">4</span>], env).cuda()</span><br><span class="line">    </span><br><span class="line">    Load_Net = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> Load_Net==<span class="number">1</span>:</span><br><span class="line">        load_net_path = <span class="string">&#x27;./epsiode_2575_reward_10.0.pkl&#x27;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Load old net and the path is:&quot;</span>,load_net_path)</span><br><span class="line">        net.e_net = torch.load(load_net_path)</span><br><span class="line">        net.t_net = torch.load(load_net_path)</span><br><span class="line">    max_score = <span class="number">0</span></span><br><span class="line">    mse = nn.MSELoss()</span><br><span class="line">    mse = mse.cuda()</span><br><span class="line">    opt = torch.optim.RMSprop(net.e_net.parameters(), lr=<span class="number">0.0015</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20000</span>):</span><br><span class="line">        lives = <span class="number">5</span></span><br><span class="line">        obs = env.reset()</span><br><span class="line">        state = net.get_next_state(<span class="literal">None</span>,obs)</span><br><span class="line">        epoch_reward = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> i%<span class="number">100</span>==<span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;&#123;&#125; times_game&quot;</span>.<span class="built_in">format</span>(i),end=<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;epoch_reward:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(epoch_reward))</span><br><span class="line">        <span class="keyword">for</span> step <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">500000</span>):</span><br><span class="line">            action = net.decide(state,step=step)</span><br><span class="line">            obs, reward, done, _ = env.step(action)</span><br><span class="line">            next_state = net.get_next_state(state, obs) </span><br><span class="line">            epoch_reward += reward</span><br><span class="line">            net.replayer.store(state, action, reward, next_state, done)</span><br><span class="line">            net.learn_step += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> net.learn_step &gt;= net.replayer_start_size // <span class="number">2</span> <span class="keyword">and</span> net.learn_step % <span class="number">4</span> == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> net.start_learn == <span class="literal">False</span>:</span><br><span class="line">                    net.start_learn = <span class="literal">True</span></span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&#x27;Start Learn!&#x27;</span>)</span><br><span class="line">                sample_n = <span class="number">32</span></span><br><span class="line">                states, actions, rewards, next_states, dones = net.replayer.sample(sample_n)</span><br><span class="line">                states, next_states = states / <span class="number">128</span> -<span class="number">1</span>, next_states / <span class="number">128</span> -<span class="number">1</span></span><br><span class="line">                rewards = torch.Tensor(np.clip(rewards,-<span class="number">1</span>,<span class="number">1</span>)).unsqueeze(<span class="number">1</span>).cuda()</span><br><span class="line">                states, next_states = torch.Tensor(states).cuda(), torch.Tensor(next_states).cuda()</span><br><span class="line">                actions = torch.Tensor(actions).long().unsqueeze(<span class="number">1</span>).cuda()</span><br><span class="line">                dones = torch.Tensor(dones).unsqueeze(<span class="number">1</span>).cuda()</span><br><span class="line">                q = net.e_net(states).gather(<span class="number">1</span>, actions)</span><br><span class="line">                q_next = net.t_net(next_states).detach().<span class="built_in">max</span>(<span class="number">1</span>)[<span class="number">0</span>].reshape(sample_n, <span class="number">1</span>)</span><br><span class="line">                tq = rewards + net.gamma * (<span class="number">1</span>-done) * q_next</span><br><span class="line">                loss = mse(q, tq)</span><br><span class="line">                opt.zero_grad()</span><br><span class="line">                loss.backward()</span><br><span class="line">                opt.step()</span><br><span class="line">                <span class="keyword">if</span> net.learn_step % (net.upon_times * <span class="number">5</span>) == <span class="number">0</span>:</span><br><span class="line">                    net.t_net.load_state_dict(net.e_net.state_dict())</span><br><span class="line">                <span class="keyword">if</span> net.learn_step % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">                    loss_record = loss.item()</span><br><span class="line">                    a_r = torch.mean(rewards, <span class="number">0</span>).item()</span><br><span class="line">                </span><br><span class="line">            state = next_state</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> done:</span><br><span class="line">                save_net_path = <span class="string">&#x27;./&#x27;</span></span><br><span class="line">                sum_reward+=epoch_reward</span><br><span class="line">                <span class="keyword">if</span> epoch_reward &gt; max_score:</span><br><span class="line">                    name = <span class="string">&quot;epsiode_&quot;</span> + <span class="built_in">str</span>(net.learn_step) + <span class="string">&quot;_reward_&quot;</span> + <span class="built_in">str</span>(epoch_reward) + <span class="string">&quot;.pkl&quot;</span></span><br><span class="line">                    torch.save(net.e_net, save_net_path+name)</span><br><span class="line">                    max_score = epoch_reward</span><br><span class="line">                <span class="keyword">elif</span> i % <span class="number">1000</span> == <span class="number">0</span>:</span><br><span class="line">                    name =<span class="string">&quot;No.&quot;</span>+<span class="built_in">str</span>(i)+<span class="string">&quot;.pkl&quot;</span></span><br><span class="line">                    torch.save(net.e_net, save_net_path + name)</span><br><span class="line">                <span class="keyword">if</span> i%<span class="number">10</span>==<span class="number">0</span>:</span><br><span class="line">                    sum_reward=<span class="number">0</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">               </span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">PictureArray2Video</span>(<span class="params">pic_list, path=<span class="string">&#x27;./test.mp4&#x27;</span></span>):</span><br><span class="line">    h,w,_ = pic_list[<span class="number">0</span>].shape[<span class="number">0</span>], pic_list[<span class="number">0</span>].shape[<span class="number">1</span>], pic_list[<span class="number">0</span>].shape[<span class="number">2</span>]</span><br><span class="line">    <span class="built_in">print</span>(h,w)</span><br><span class="line">    writer = cv2.VideoWriter(path, cv2.VideoWriter_fourcc(<span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;v&#x27;</span>), <span class="number">10</span>, (w, h), <span class="literal">True</span>)</span><br><span class="line">    total_frame = <span class="built_in">len</span>(pic_list)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(total_frame):</span><br><span class="line">        writer.write(pic_list[i])</span><br><span class="line">    writer.release()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    pics = []</span><br><span class="line">    sum_reward = <span class="number">0</span></span><br><span class="line">    store_count = <span class="number">0</span></span><br><span class="line">    env = gym.make(<span class="string">&#x27;Breakout-v0&#x27;</span>)</span><br><span class="line">    net = DQN([<span class="number">84</span>,<span class="number">84</span>,<span class="number">4</span>], env).cuda()</span><br><span class="line">    </span><br><span class="line">    Load_Net = <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> Load_Net==<span class="number">1</span>:</span><br><span class="line">        load_net_path = <span class="string">&#x27;./epsiode_10219_reward_9.0.pkl&#x27;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Load old net and the path is:&quot;</span>,load_net_path)</span><br><span class="line">        net.e_net = torch.load(load_net_path)</span><br><span class="line">        net.t_net = torch.load(load_net_path)</span><br><span class="line">    max_score = <span class="number">0</span></span><br><span class="line">    mse = nn.MSELoss()</span><br><span class="line">    mse = mse.cuda()</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    obs = env.reset()</span><br><span class="line">    state = net.get_next_state(<span class="literal">None</span>,obs)</span><br><span class="line">    epoch_reward = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> step <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">500000</span>):</span><br><span class="line">        action = net.decide(state,step=step)</span><br><span class="line">        obs, reward, done, _ = env.step(action)</span><br><span class="line">        pic = env.render(mode=<span class="string">&#x27;rgb_array&#x27;</span>)</span><br><span class="line">        pic = cv2.cvtColor(pic,cv2.COLOR_BGR2RGB)</span><br><span class="line">        next_state = net.get_next_state(state, obs) </span><br><span class="line">        pics.append(pic)</span><br><span class="line">        <span class="keyword">if</span> done:</span><br><span class="line">            PictureArray2Video(pics)</span><br><span class="line">            <span class="keyword">break</span>   </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Policy-Gradient"><a href="#Policy-Gradient" class="headerlink" title="Policy Gradient"></a><strong>Policy Gradient</strong></h2><p>前面我们介绍的Q-Learning和DQN都是基于价值的强化学习算法，在给定一个状态下，计算采取每个动作的价值，我们选择有<a href="https://zhida.zhihu.com/search?content_id=191787601&amp;content_type=Article&amp;match_order=1&amp;q=最高Q值&amp;zhida_source=entity">最高Q值</a>（在所有状态下最大的期望奖励）的行动。如果我们省略中间的步骤，即直接根据当前的状态来选择动作，也就引出了强化学习中的另一种很重要的算法，即策略梯度(Policy Gradient， PG)</p>
<p>策略梯度不通过误差反向传播，它通过观测信息选出一个行为直接进行<a href="https://zhida.zhihu.com/search?content_id=191787601&amp;content_type=Article&amp;match_order=2&amp;q=反向传播&amp;zhida_source=entity">反向传播</a>，当然出人意料的是他并没有误差，而是利用reward奖励直接对选择行为的可能性进行增强和减弱，好的行为会被增加下一次被选中的概率，不好的行为会被减弱下次被选中的概率。</p>
<p>举例如下图所示：输入当前的状态，输出action的概率分布，选择概率最大的一个action作为要执行的操作。</p>
<p><img src="https://pica.zhimg.com/v2-1a8a4baf9752a489ced36a2d31e17d34_1440w.jpg" alt="img"></p>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a><strong>优缺点</strong></h3><p><strong>优点</strong></p>
<ul>
<li>连续的动作空间（或者高维空间）中更加高效；</li>
<li>可以实现随机化的策略；</li>
<li>某种情况下，价值函数可能比较难以计算，而策略函数较容易。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>通常收敛到<a href="https://zhida.zhihu.com/search?content_id=191787601&amp;content_type=Article&amp;match_order=1&amp;q=局部最优&amp;zhida_source=entity">局部最优</a>而非全局最优</li>
<li>评估一个策略通常低效（这个过程可能慢，但是具有更高的可变性，其中也会出现很多并不有效的尝试，而且<a href="https://zhida.zhihu.com/search?content_id=191787601&amp;content_type=Article&amp;match_order=1&amp;q=方差&amp;zhida_source=entity">方差</a>高）</li>
</ul>
<h3 id="REINFORCE"><a href="#REINFORCE" class="headerlink" title="REINFORCE"></a><strong>REINFORCE</strong></h3><p><a href="https://zhida.zhihu.com/search?content_id=191787601&amp;content_type=Article&amp;match_order=1&amp;q=蒙特卡罗策略梯度&amp;zhida_source=entity">蒙特卡罗策略梯度</a>reinforce算法是策略梯度最简单的也是最经典的一个算法。</p>
<p><img src="https://pica.zhimg.com/v2-1f3d4dcda65437b6014c6dc2666e8876_1440w.jpg" alt="img"></p>
<h3 id="算法流程-2"><a href="#算法流程-2" class="headerlink" title="算法流程"></a><strong>算法流程</strong></h3><p><img src="https://pic1.zhimg.com/v2-3a520192dd65ed89afc29322ef23a94a_1440w.jpg" alt="img"></p>
<p>首先我们需要一个 policy model 来输出动作概率，输出动作概率后，我们 sample() 函数去得到一个具体的动作，然后跟环境交互过后，我们可以得到一整个回合的数据。拿到回合数据之后，我再去执行一下 learn() 函数，在 learn() 函数里面，我就可以拿这些数据去构造<a href="https://zhida.zhihu.com/search?content_id=191787601&amp;content_type=Article&amp;match_order=1&amp;q=损失函数&amp;zhida_source=entity">损失函数</a>，扔给这个优化器去优化，去更新我的 policy model。</p>
<h3 id="示例代码-3"><a href="#示例代码-3" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> gym</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> Linear</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"><span class="keyword">from</span> torch.distributions <span class="keyword">import</span> Categorical</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">lr = <span class="number">0.002</span></span><br><span class="line">gamma = <span class="number">0.8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PGPolicy</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, input_size=<span class="number">4</span>, hidden_size=<span class="number">128</span>, output_size=<span class="number">2</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(PGPolicy, self).__init__()</span><br><span class="line">        self.fc1 = Linear(input_size, hidden_size)</span><br><span class="line">        self.fc2 = Linear(hidden_size, output_size)</span><br><span class="line">        self.dropout = nn.Dropout(p=<span class="number">0.6</span>)</span><br><span class="line">        </span><br><span class="line">        self.saved_log_probs = []<span class="comment"># 记录每一步的动作概率</span></span><br><span class="line">        self.rewards = []<span class="comment">#记录每一步的r</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = self.fc1(x)</span><br><span class="line">        x = self.dropout(x)</span><br><span class="line">        x = F.relu(x)</span><br><span class="line">        x = self.fc2(x)</span><br><span class="line">        out = F.softmax(x, dim=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">choose_action</span>(<span class="params">state, policy</span>):</span><br><span class="line">    state = torch.from_numpy(state).<span class="built_in">float</span>().unsqueeze(<span class="number">0</span>) <span class="comment"># 在索引0对应位置增加一个维度</span></span><br><span class="line">    probs = policy(state) </span><br><span class="line">    m = Categorical(probs) <span class="comment">#创建以参数probs为标准的类别分布,之后的m.sampe就会按此概率选择动作</span></span><br><span class="line">    action = m.sample()</span><br><span class="line">    policy.saved_log_probs.append(m.log_prob(action))</span><br><span class="line">    <span class="keyword">return</span> action.item()<span class="comment">#返回的就是int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">learn</span>(<span class="params">policy, optimizer</span>):</span><br><span class="line">    R = <span class="number">0</span></span><br><span class="line">    policy_loss = []</span><br><span class="line">    returns = []</span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> policy.rewards[::-<span class="number">1</span>]:</span><br><span class="line">        R = r + gamma*R</span><br><span class="line">        returns.insert(<span class="number">0</span>,R)<span class="comment">#从头部插入，即反着插入</span></span><br><span class="line">    returns = torch.tensor(returns)</span><br><span class="line">    <span class="comment"># 归一化（均值方差），eps是一个非常小的数，避免除数为0</span></span><br><span class="line">    eps = np.finfo(np.float64).eps.item()</span><br><span class="line">    returns = (returns - returns.mean()) / (returns.std() + eps)  </span><br><span class="line">    <span class="keyword">for</span> log_prob, R <span class="keyword">in</span> <span class="built_in">zip</span>(policy.saved_log_probs, returns):</span><br><span class="line">        policy_loss.append(-log_prob*R)</span><br><span class="line"></span><br><span class="line">    optimizer.zero_grad()</span><br><span class="line">    policy_loss = torch.cat(policy_loss).<span class="built_in">sum</span>()</span><br><span class="line">    policy_loss.backward()</span><br><span class="line">    optimizer.step()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">del</span> policy.rewards[:]  <span class="comment"># 清空数据</span></span><br><span class="line">    <span class="keyword">del</span> policy.saved_log_probs[:]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">episode_num</span>):</span><br><span class="line">    env = gym.make(<span class="string">&#x27;CartPole-v1&#x27;</span>)</span><br><span class="line">    env.seed(<span class="number">1</span>)</span><br><span class="line">    torch.manual_seed(<span class="number">1</span>)</span><br><span class="line">    policy = PGPolicy()</span><br><span class="line">    <span class="comment"># policy.load_state_dict(torch.load(&#x27;save_model.pt&#x27;))  # 模型导入</span></span><br><span class="line">    optimizer = optim.Adam(policy.parameters(), lr)</span><br><span class="line">    average_r = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, episode_num+<span class="number">1</span>): <span class="comment">#采这么多轨迹</span></span><br><span class="line">        obs = env.reset()</span><br><span class="line">        ep_r = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10000</span>):</span><br><span class="line">            action = choose_action(obs, policy)</span><br><span class="line">            obs, reward, done, _ = env.step(action)</span><br><span class="line">            policy.rewards.append(reward)</span><br><span class="line">            ep_r += reward</span><br><span class="line">            <span class="keyword">if</span> done:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        average_r = <span class="number">0.05</span> * ep_r + (<span class="number">1</span>-<span class="number">0.05</span>) * average_r</span><br><span class="line">        learn(policy, optimizer)</span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;Episode &#123;&#125;\tLast reward: &#123;:.2f&#125;\tAverage reward: &#123;:.2f&#125;&#x27;</span>.<span class="built_in">format</span>(i, ep_r, average_r))</span><br><span class="line"></span><br><span class="line">    torch.save(policy.state_dict(), <span class="string">&#x27;PGPolicy.pt&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    env = gym.make(<span class="string">&#x27;CartPole-v1&#x27;</span>)</span><br><span class="line">    env.seed(<span class="number">1</span>)</span><br><span class="line">    torch.manual_seed(<span class="number">1</span>)</span><br><span class="line">    policy = PGPolicy()</span><br><span class="line">    policy.load_state_dict(torch.load(<span class="string">&#x27;PGPolicy.pt&#x27;</span>))  <span class="comment"># 模型导入</span></span><br><span class="line">    average_r = <span class="number">0</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        obs = env.reset()</span><br><span class="line">        ep_r = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10000</span>):</span><br><span class="line">            action = choose_action(obs, policy)</span><br><span class="line">            obs, reward, done, _ = env.step(action)</span><br><span class="line">            policy.rewards.append(reward)</span><br><span class="line">            env.render()</span><br><span class="line">            time.sleep(<span class="number">0.1</span>)</span><br><span class="line">            ep_r += reward</span><br><span class="line">            <span class="keyword">if</span> done:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">train(<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#  test()</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Actor-Critic"><a href="#Actor-Critic" class="headerlink" title="Actor Critic"></a><strong>Actor Critic</strong></h2><p><a href="https://zhida.zhihu.com/search?content_id=191787601&amp;content_type=Article&amp;match_order=1&amp;q=演员-评论家算法&amp;zhida_source=entity">演员-评论家算法</a>(Actor-Critic)是基于策略(Policy Based)和基于价值(Value Based)相结合的方法</p>
<p><img src="https://picx.zhimg.com/v2-30c86bf5852c7278739988deb843fa2b_1440w.jpg" alt="img"></p>
<ul>
<li>演员(Actor)是指<a href="https://zhida.zhihu.com/search?content_id=191787601&amp;content_type=Article&amp;match_order=2&amp;q=策略函数&amp;zhida_source=entity">策略函数</a>πθ(a|s)，即学习一个策略来得到尽量高的回报。</li>
<li>评论家(Critic)是指值函数 Vπ(s)，对当前策略的值函数进行估计，即评估演员的好坏。</li>
<li>借助于价值函数，演员-评论家算法可以进行单步更新参数，不需要等到回合结束才进行更新。</li>
</ul>
<h3 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a><strong>网络结构</strong></h3><p>整体结构：</p>
<p><img src="https://pic2.zhimg.com/v2-6e27d52ea15a03b569ee21d504bf0cc1_1440w.jpg" alt="img"></p>
<p>Actor和Critic的网络结构：</p>
<p><img src="https://pic2.zhimg.com/v2-c3fef2d159d761a2a97c29c53acad071_1440w.jpg" alt="img"></p>
<h3 id="算法流程-3"><a href="#算法流程-3" class="headerlink" title="算法流程"></a><strong>算法流程</strong></h3><p><img src="https://pic1.zhimg.com/v2-33e2dbe0670759efcb823bf02dda8c06_1440w.jpg" alt="img"></p>
<h3 id="问题和改进"><a href="#问题和改进" class="headerlink" title="问题和改进"></a><strong>问题和改进</strong></h3><p>Actor Critic 取决于 Critic 的价值判断， 但是 Critic 难收敛， 再加上 Actor 的更新， 就更难收敛，为了解决该问题又提出了 A3C 算法和 DDPG 算法。</p>
<p><strong>改进算法1：A3C</strong> 异步的优势<a href="https://zhida.zhihu.com/search?content_id=191787601&amp;content_type=Article&amp;match_order=1&amp;q=行动者评论家算法&amp;zhida_source=entity">行动者评论家算法</a>（Asynchronous Advantage Actor-Critic，A3C），相比Actor-Critic，A3C的优化主要有3点，分别是异步训练框架，网络结构优化，Critic评估点的优化。其中异步训练框架是最大的优化。</p>
<p><img src="https://pica.zhimg.com/v2-56823ffd3980eb9a984676176b83384a_1440w.jpg" alt="img"></p>
<p><strong>改进算法2：DDPG</strong> 深度确定性策略梯度(Deep Deterministic Policy Gradient，DDPG)，从DDPG这个名字看，它是由D（Deep）+D（Deterministic ）+ PG(Policy Gradient)组成。</p>
<ul>
<li>Deep 是因为用了神经网络；</li>
<li>Deterministic 表示 DDPG 输出的是一个确定性的动作，可以用于连续动作的一个环境；</li>
<li>Policy Gradient 代表的是它用到的是<a href="https://zhida.zhihu.com/search?content_id=191787601&amp;content_type=Article&amp;match_order=1&amp;q=策略网络&amp;zhida_source=entity">策略网络</a>。REINFORCE 算法每隔一个 episode 就更新一次，但 DDPG 网络是每个 step 都会更新一次 policy 网络，也就是说它是一个单步更新的 policy 网络。</li>
</ul>
<p><img src="https://pic2.zhimg.com/v2-0bce8174e6dd2b4851ad4c90a86f9967_1440w.jpg" alt="img"></p>
<h3 id="示例代码-4"><a href="#示例代码-4" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> gym</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment">#####################  hyper parameters  ####################</span></span><br><span class="line">EPISODES = <span class="number">200</span></span><br><span class="line">EP_STEPS = <span class="number">200</span></span><br><span class="line">LR_ACTOR = <span class="number">0.001</span></span><br><span class="line">LR_CRITIC = <span class="number">0.002</span></span><br><span class="line">GAMMA = <span class="number">0.9</span></span><br><span class="line">TAU = <span class="number">0.01</span></span><br><span class="line">MEMORY_CAPACITY = <span class="number">10000</span></span><br><span class="line">BATCH_SIZE = <span class="number">32</span></span><br><span class="line">RENDER = <span class="literal">False</span></span><br><span class="line">ENV_NAME = <span class="string">&#x27;Pendulum-v1&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">########################## DDPG Framework ######################</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ActorNet</span>(nn.Module): <span class="comment"># define the network structure for actor and critic</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, s_dim, a_dim</span>):</span><br><span class="line">        <span class="built_in">super</span>(ActorNet, self).__init__()</span><br><span class="line">        self.fc1 = nn.Linear(s_dim, <span class="number">30</span>)</span><br><span class="line">        self.fc1.weight.data.normal_(<span class="number">0</span>, <span class="number">0.1</span>) <span class="comment"># initialization of FC1</span></span><br><span class="line">        self.out = nn.Linear(<span class="number">30</span>, a_dim)</span><br><span class="line">        self.out.weight.data.normal_(<span class="number">0</span>, <span class="number">0.1</span>) <span class="comment"># initilizaiton of OUT</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = self.fc1(x)</span><br><span class="line">        x = F.relu(x)</span><br><span class="line">        x = self.out(x)</span><br><span class="line">        x = torch.tanh(x)</span><br><span class="line">        actions = x * <span class="number">2</span> <span class="comment"># for the game &quot;Pendulum-v0&quot;, action range is [-2, 2]</span></span><br><span class="line">        <span class="keyword">return</span> actions</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CriticNet</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, s_dim, a_dim</span>):</span><br><span class="line">        <span class="built_in">super</span>(CriticNet, self).__init__()</span><br><span class="line">        self.fcs = nn.Linear(s_dim, <span class="number">30</span>)</span><br><span class="line">        self.fcs.weight.data.normal_(<span class="number">0</span>, <span class="number">0.1</span>)</span><br><span class="line">        self.fca = nn.Linear(a_dim, <span class="number">30</span>)</span><br><span class="line">        self.fca.weight.data.normal_(<span class="number">0</span>, <span class="number">0.1</span>)</span><br><span class="line">        self.out = nn.Linear(<span class="number">30</span>, <span class="number">1</span>)</span><br><span class="line">        self.out.weight.data.normal_(<span class="number">0</span>, <span class="number">0.1</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, s, a</span>):</span><br><span class="line">        x = self.fcs(s)</span><br><span class="line">        y = self.fca(a)</span><br><span class="line">        actions_value = self.out(F.relu(x+y))</span><br><span class="line">        <span class="keyword">return</span> actions_value</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DDPG</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, a_dim, s_dim, a_bound</span>):</span><br><span class="line">        self.a_dim, self.s_dim, self.a_bound = a_dim, s_dim, a_bound</span><br><span class="line">        self.memory = np.zeros((MEMORY_CAPACITY, s_dim * <span class="number">2</span> + a_dim + <span class="number">1</span>), dtype=np.float32)</span><br><span class="line">        self.pointer = <span class="number">0</span> <span class="comment"># serves as updating the memory data </span></span><br><span class="line">        <span class="comment"># Create the 4 network objects</span></span><br><span class="line">        self.actor_eval = ActorNet(s_dim, a_dim)</span><br><span class="line">        self.actor_target = ActorNet(s_dim, a_dim)</span><br><span class="line">        self.critic_eval = CriticNet(s_dim, a_dim)</span><br><span class="line">        self.critic_target = CriticNet(s_dim, a_dim)</span><br><span class="line">        <span class="comment"># create 2 optimizers for actor and critic</span></span><br><span class="line">        self.actor_optimizer = torch.optim.Adam(self.actor_eval.parameters(), lr=LR_ACTOR)</span><br><span class="line">        self.critic_optimizer = torch.optim.Adam(self.critic_eval.parameters(), lr=LR_CRITIC)</span><br><span class="line">        <span class="comment"># Define the loss function for critic network update</span></span><br><span class="line">        self.loss_func = nn.MSELoss()</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">store_transition</span>(<span class="params">self, s, a, r, s_</span>): <span class="comment"># how to store the episodic data to buffer</span></span><br><span class="line">        transition = np.hstack((s, a, [r], s_))</span><br><span class="line">        index = self.pointer % MEMORY_CAPACITY <span class="comment"># replace the old data with new data </span></span><br><span class="line">        self.memory[index, :] = transition</span><br><span class="line">        self.pointer += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">choose_action</span>(<span class="params">self, s</span>):</span><br><span class="line">        <span class="comment"># print(s)</span></span><br><span class="line">        s = torch.unsqueeze(torch.FloatTensor(s), <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> self.actor_eval(s)[<span class="number">0</span>].detach()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">learn</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># softly update the target networks</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> self.actor_target.state_dict().keys():</span><br><span class="line">            <span class="built_in">eval</span>(<span class="string">&#x27;self.actor_target.&#x27;</span> + x + <span class="string">&#x27;.data.mul_((1-TAU))&#x27;</span>)</span><br><span class="line">            <span class="built_in">eval</span>(<span class="string">&#x27;self.actor_target.&#x27;</span> + x + <span class="string">&#x27;.data.add_(TAU*self.actor_eval.&#x27;</span> + x + <span class="string">&#x27;.data)&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> self.critic_target.state_dict().keys():</span><br><span class="line">            <span class="built_in">eval</span>(<span class="string">&#x27;self.critic_target.&#x27;</span> + x + <span class="string">&#x27;.data.mul_((1-TAU))&#x27;</span>)</span><br><span class="line">            <span class="built_in">eval</span>(<span class="string">&#x27;self.critic_target.&#x27;</span> + x + <span class="string">&#x27;.data.add_(TAU*self.critic_eval.&#x27;</span> + x + <span class="string">&#x27;.data)&#x27;</span>)           </span><br><span class="line">        <span class="comment"># sample from buffer a mini-batch data</span></span><br><span class="line">        indices = np.random.choice(MEMORY_CAPACITY, size=BATCH_SIZE)</span><br><span class="line">        batch_trans = self.memory[indices, :]</span><br><span class="line">        <span class="comment"># extract data from mini-batch of transitions including s, a, r, s_</span></span><br><span class="line">        batch_s = torch.FloatTensor(batch_trans[:, :self.s_dim])</span><br><span class="line">        batch_a = torch.FloatTensor(batch_trans[:, self.s_dim:self.s_dim + self.a_dim])</span><br><span class="line">        batch_r = torch.FloatTensor(batch_trans[:, -self.s_dim - <span class="number">1</span>: -self.s_dim])</span><br><span class="line">        batch_s_ = torch.FloatTensor(batch_trans[:, -self.s_dim:])</span><br><span class="line">        <span class="comment"># make action and evaluate its action values</span></span><br><span class="line">        a = self.actor_eval(batch_s)</span><br><span class="line">        q = self.critic_eval(batch_s, a)</span><br><span class="line">        actor_loss = -torch.mean(q)</span><br><span class="line">        <span class="comment"># optimize the loss of actor network</span></span><br><span class="line">        self.actor_optimizer.zero_grad()</span><br><span class="line">        actor_loss.backward()</span><br><span class="line">        self.actor_optimizer.step()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># compute the target Q value using the information of next state</span></span><br><span class="line">        a_target = self.actor_target(batch_s_)</span><br><span class="line">        q_tmp = self.critic_target(batch_s_, a_target)</span><br><span class="line">        q_target = batch_r + GAMMA * q_tmp</span><br><span class="line">        <span class="comment"># compute the current q value and the loss</span></span><br><span class="line">        q_eval = self.critic_eval(batch_s, batch_a)</span><br><span class="line">        td_error = self.loss_func(q_target, q_eval)</span><br><span class="line">        <span class="comment"># optimize the loss of critic network</span></span><br><span class="line">        self.critic_optimizer.zero_grad()</span><br><span class="line">        td_error.backward()</span><br><span class="line">        self.critic_optimizer.step()</span><br><span class="line">        </span><br><span class="line"><span class="comment">############################### Training ######################################</span></span><br><span class="line"><span class="comment"># Define the env in gym</span></span><br><span class="line">env = gym.make(ENV_NAME)</span><br><span class="line">env = env.unwrapped</span><br><span class="line">env.seed(<span class="number">1</span>)</span><br><span class="line">s_dim = env.observation_space.shape[<span class="number">0</span>]</span><br><span class="line">a_dim = env.action_space.shape[<span class="number">0</span>]</span><br><span class="line">a_bound = env.action_space.high</span><br><span class="line">a_low_bound = env.action_space.low</span><br><span class="line"></span><br><span class="line">ddpg = DDPG(a_dim, s_dim, a_bound)</span><br><span class="line">var = <span class="number">3</span> <span class="comment"># the controller of exploration which will decay during training process</span></span><br><span class="line">t1 = time.time()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(EPISODES):</span><br><span class="line">    s = env.reset()</span><br><span class="line">    ep_r = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(EP_STEPS):</span><br><span class="line">        <span class="keyword">if</span> RENDER: env.render()</span><br><span class="line">        <span class="comment"># add explorative noise to action</span></span><br><span class="line">        a = ddpg.choose_action(s)</span><br><span class="line">        a = np.clip(np.random.normal(a, var), a_low_bound, a_bound)</span><br><span class="line">        s_, r, done, info, _ = env.step(a)</span><br><span class="line">        ddpg.store_transition(s, a, r / <span class="number">10</span>, s_) <span class="comment"># store the transition to memory</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> ddpg.pointer &gt; MEMORY_CAPACITY:</span><br><span class="line">            var *= <span class="number">0.9995</span> <span class="comment"># decay the exploration controller factor</span></span><br><span class="line">            ddpg.learn()</span><br><span class="line">            </span><br><span class="line">        s = s_</span><br><span class="line">        ep_r += r</span><br><span class="line">        <span class="keyword">if</span> j == EP_STEPS - <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Episode: &#x27;</span>, i, <span class="string">&#x27; Reward: %i&#x27;</span> % (ep_r), <span class="string">&#x27;Explore: %.2f&#x27;</span> % var)</span><br><span class="line">            <span class="keyword">if</span> ep_r &gt; -<span class="number">300</span> : RENDER = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Running time: &#x27;</span>, time.time() - t1)</span><br><span class="line">    </span><br><span class="line">       </span><br><span class="line">            </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    learn()    </span><br><span class="line">    env.close()</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1].<a href="https://zhuanlan.zhihu.com/p/466455380#:~:text=强化学习（Reinforcement learning，RL）讨论的问题是一个 智能体 (agent">强化学习入门：基本思想和经典算法 - 知乎</a> 怎么在一个复杂不确定的 环境 (environment) 里面去极大化它能获得的奖励。,动作 (action) 的 反应 (reward)， 来指导更好的动作，从而获得最大的 收益 (return)，这被称为在交互中学习，这样的学习方法就被称作强化学习。)</p>
<p>[2].<a href="https://blog.csdn.net/weixin_45696231/article/details/126723207">基础的强化学习(RL)算法及代码详细demo_强化学习代码-CSDN博客</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>强化学习</tag>
      </tags>
  </entry>
  <entry>
    <title>利用云服务器搭建 vpn</title>
    <url>/posts/e44c33b7.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>动态代理：灵活控制方法调用的艺术</title>
    <url>/posts/13138c9b.html</url>
    <content><![CDATA[<blockquote>
<p>介绍了动态代理的定义、优势、jvm动态代理实现方式、通过Consumer定制化前置和后置方法。</p>
</blockquote>
<hr>
<h2 id="一、动态代理的定义"><a href="#一、动态代理的定义" class="headerlink" title="一、动态代理的定义"></a>一、动态代理的定义</h2><p>动态代理（Dynamic Proxy）是 Java 提供的一种在<strong>运行时</strong>动态生成代理对象的机制，相较于静态代理为每个目标类都定义一个代理类，动态代理只需要一个实现InvocationHandler的类，通过Proxy.newProxyInstance方法即可自动创建各种目标类的代理类，其原理是反射，速度相较于CGLIB速度较慢。通过 <code>java.lang.reflect.Proxy</code> 类和 <code>InvocationHandler</code> 接口，我们可以实现对原始方法的<strong>拦截增强</strong>，常用于以下场景：</p>
<ul>
<li>日志记录</li>
<li>权限校验</li>
<li>事务管理</li>
<li>性能监控</li>
</ul>
<hr>
<h2 id="二、动态代理的三大优点"><a href="#二、动态代理的三大优点" class="headerlink" title="二、动态代理的三大优点"></a>二、动态代理的三大优点</h2><div class="table-container">
<table>
<thead>
<tr>
<th>优势</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>代码解耦</strong></td>
<td>将通用逻辑（如日志）与业务代码分离</td>
</tr>
<tr>
<td><strong>高复用性</strong></td>
<td>一个代理处理器可服务于多个接口</td>
</tr>
<tr>
<td><strong>运行时动态生成</strong></td>
<td>无需为每个类手动编写代理，由 JVM 动态创建代理类</td>
</tr>
</tbody>
</table>
</div>
<hr>
<h2 id="三、基础使用示例"><a href="#三、基础使用示例" class="headerlink" title="三、基础使用示例"></a>三、基础使用示例</h2><h3 id="3-1-定义接口与实现类"><a href="#3-1-定义接口与实现类" class="headerlink" title="3.1 定义接口与实现类"></a>3.1 定义接口与实现类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;添加用户: &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-通用代理实现"><a href="#3-2-通用代理实现" class="headerlink" title="3.2 通用代理实现"></a>3.2 通用代理实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BasicProxy</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BasicProxy</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;【前置通知】&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;【后置通知】&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">createProxy</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">            target.getClass().getClassLoader(),</span><br><span class="line">            target.getClass().getInterfaces(),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">BasicProxy</span>(target)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="四、使用-Consumer-实现灵活拦截"><a href="#四、使用-Consumer-实现灵活拦截" class="headerlink" title="四、使用 Consumer 实现灵活拦截"></a>四、使用 Consumer 实现灵活拦截</h2><h3 id="4-1-函数式接口-Consumer"><a href="#4-1-函数式接口-Consumer" class="headerlink" title="4.1 函数式接口 Consumer"></a>4.1 函数式接口 Consumer</h3><p><code>java.util.function.Consumer&lt;T&gt;</code> 是 Java 8 引入的函数式接口，其核心方法是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(T t)</span>;</span><br></pre></td></tr></table></figure>
<p>特点：</p>
<ul>
<li>接收参数不返回值</li>
<li>常用于实现回调逻辑</li>
</ul>
<h3 id="4-2-增强型代理实现"><a href="#4-2-增强型代理实现" class="headerlink" title="4.2 增强型代理实现"></a>4.2 增强型代理实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EnhancedProxy</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Consumer&lt;Method&gt; before;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Consumer&lt;Method&gt; after;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EnhancedProxy</span><span class="params">(Object target, </span></span><br><span class="line"><span class="params">                        Consumer&lt;Method&gt; before,</span></span><br><span class="line"><span class="params">                        Consumer&lt;Method&gt; after)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">        <span class="built_in">this</span>.before = before;</span><br><span class="line">        <span class="built_in">this</span>.after = after;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        before.accept(method); <span class="comment">// 执行前置逻辑</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        after.accept(method);  <span class="comment">// 执行后置逻辑</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="五、自定义前后置方法实战"><a href="#五、自定义前后置方法实战" class="headerlink" title="五、自定义前后置方法实战"></a>五、自定义前后置方法实战</h2><h3 id="5-1-为不同接口定制逻辑"><a href="#5-1-为不同接口定制逻辑" class="headerlink" title="5.1 为不同接口定制逻辑"></a>5.1 为不同接口定制逻辑</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用户服务代理</span></span><br><span class="line"><span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) Proxy.newProxyInstance(</span><br><span class="line">    UserServiceImpl.class.getClassLoader(),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;UserService.class&#125;,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">EnhancedProxy</span>(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>(),</span><br><span class="line">        method -&gt; System.out.println(<span class="string">&quot;&gt;&gt;&gt; 用户操作开始: &quot;</span> + method.getName()),</span><br><span class="line">        method -&gt; System.out.println(<span class="string">&quot;&lt;&lt;&lt; 用户操作结束: &quot;</span> + method.getName())</span><br><span class="line">    )</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 娱乐服务代理</span></span><br><span class="line"><span class="type">EntertainmentService</span> <span class="variable">es</span> <span class="operator">=</span> (EntertainmentService) Proxy.newProxyInstance(</span><br><span class="line">    MovieService.class.getClassLoader(),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;EntertainmentService.class&#125;,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">EnhancedProxy</span>(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MovieService</span>(),</span><br><span class="line">        method -&gt; System.out.println(<span class="string">&quot;★ 娱乐活动准备: &quot;</span> + method.getName()),</span><br><span class="line">        method -&gt; System.out.println(<span class="string">&quot;☆ 活动结束耗时统计...&quot;</span>)</span><br><span class="line">    )</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="5-2-执行效果"><a href="#5-2-执行效果" class="headerlink" title="5.2 执行效果"></a>5.2 执行效果</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; 用户操作开始: addUser</span></span><br><span class="line">添加用户: Alice</span><br><span class="line">&lt;&lt;&lt; 用户操作结束: addUser</span><br><span class="line"></span><br><span class="line">★ 娱乐活动准备: playMovie</span><br><span class="line">播放电影: 星际穿越</span><br><span class="line">☆ 活动结束耗时统计...</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="六、架构优化总结"><a href="#六、架构优化总结" class="headerlink" title="六、架构优化总结"></a>六、架构优化总结</h2><div class="table-container">
<table>
<thead>
<tr>
<th>方案</th>
<th>优点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>基础代理</td>
<td>实现简单，快速上手</td>
<td>所有方法需要相同增强逻辑</td>
</tr>
<tr>
<td>增强型代理</td>
<td>支持不同接口的差异化处理</td>
<td>需要灵活定制拦截逻辑的场景</td>
</tr>
</tbody>
</table>
</div>
<p><strong>最佳实践建议</strong>：</p>
<ol>
<li>使用 Lambda 表达式简化 <code>Consumer</code> 实现</li>
<li>通过工厂模式封装代理创建过程</li>
<li>结合注解实现更精细化的方法级控制</li>
</ol>
<h2 id="代码附录"><a href="#代码附录" class="headerlink" title="代码附录"></a>代码附录</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">(String username)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deleteUser</span><span class="params">(String username)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Adding user: &quot;</span> + username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteUser</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Deleting user: &quot;</span> + username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Girl</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">watchTV</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Daughter</span> <span class="keyword">implements</span> <span class="title class_">Girl</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">watchTV</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;watching TV&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ServiceProxy</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Consumer&lt;Method&gt; before;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Consumer&lt;Method&gt; after;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 支持自定义前置和后置逻辑的构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServiceProxy</span><span class="params">(Object target, Consumer&lt;Method&gt; before, Consumer&lt;Method&gt; after)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">        <span class="built_in">this</span>.before = before;</span><br><span class="line">        <span class="built_in">this</span>.after = after;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        before.accept(method);          <span class="comment">// 执行自定义前置逻辑</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        after.accept(method);           <span class="comment">// 执行自定义后置逻辑</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getProxyInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">                target.getClass().getClassLoader(),</span><br><span class="line">                target.getClass().getInterfaces(),</span><br><span class="line">                <span class="built_in">this</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">p1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// UserService 的代理逻辑</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">        <span class="type">ServiceProxy</span> <span class="variable">userProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServiceProxy</span>(</span><br><span class="line">                userService,</span><br><span class="line">                method -&gt; System.out.println(<span class="string">&quot;[用户服务] 准备执行: &quot;</span> + method.getName()),</span><br><span class="line">                method -&gt; System.out.println(<span class="string">&quot;[用户服务] 完成执行: &quot;</span> + method.getName())</span><br><span class="line">        );</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">proxyUserService</span> <span class="operator">=</span> (UserService) userProxy.getProxyInstance();</span><br><span class="line">        proxyUserService.addUser(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">        proxyUserService.deleteUser(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Girl 的代理逻辑</span></span><br><span class="line">        <span class="type">Daughter</span> <span class="variable">daughter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Daughter</span>();</span><br><span class="line">        <span class="type">ServiceProxy</span> <span class="variable">girlProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServiceProxy</span>(</span><br><span class="line">                daughter,</span><br><span class="line">                method -&gt; System.out.println(<span class="string">&quot;[女孩行为] 方法开始: &quot;</span> + method.getName()),</span><br><span class="line">                method -&gt; System.out.println(<span class="string">&quot;[女孩行为] 方法结束: &quot;</span> + method.getName())</span><br><span class="line">        );</span><br><span class="line">        <span class="type">Girl</span> <span class="variable">mother</span> <span class="operator">=</span> (Girl) girlProxy.getProxyInstance();</span><br><span class="line">        mother.watchTV();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>动态代理</tag>
      </tags>
  </entry>
  <entry>
    <title>半平面交</title>
    <url>/posts/d0f12e08.html</url>
    <content><![CDATA[<blockquote>
<p>半平面交用于求几个凸包围成的面积</p>
</blockquote>
<p>一条直线可以将平面分为两部分，我们取左半部分，右半部分舍弃，那么所有的直线围成的左半部分的面积的交集就是半平面交。</p>
<h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><p>首先把所有线首先按照角度从小到大排序，角度相同就按照线从左到右排序，排序后用一个双端队列来维护，每次新进来一条边，判断这条边是否在队列的队尾两条边的交点左边，如果是，就把队尾元素pop出去，如此往复，队头也是如此，所有边遍历完后还要用队头去维护队尾，用队尾去维护队头</p>
<h2 id="线点"><a href="#线点" class="headerlink" title="线点"></a>线点</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line">	<span class="type">double</span> x,y;</span><br><span class="line">&#125;pt[MAXN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">line</span>&#123;</span></span><br><span class="line">	point a,b;</span><br><span class="line">&#125;L[MAXN];</span><br></pre></td></tr></table></figure>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>思想很简单，但是实现很复杂，一点点错误满盘皆输，这8个函数非常有用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">point operator-(point a,point b)&#123;	<span class="comment">//重载运算符 </span></span><br><span class="line">	<span class="keyword">return</span> &#123;a.x-b.x,a.y-b.y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> <span class="title function_">cross</span><span class="params">(point a,point b)</span>&#123;		<span class="comment">//叉积 </span></span><br><span class="line">	<span class="keyword">return</span> a.x*b.y-a.y*b.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> <span class="title function_">area</span><span class="params">(point a,point b,point c)</span>&#123;	<span class="comment">//ab向量叉乘ac向量 </span></span><br><span class="line">	<span class="keyword">return</span> cross(b-a,c-a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> <span class="title function_">get_angle</span><span class="params">(line x)</span>&#123;	<span class="comment">//得到线的角度 </span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">atan2</span>(x.b.y-x.a.y,x.b.x-x.a.x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">cmp</span><span class="params">(line a,line b)</span>&#123;</span><br><span class="line">	<span class="type">double</span> ag1=get_angle(a),ag2=get_angle(b);	<span class="comment">//得到两条线的角度 </span></span><br><span class="line">	<span class="keyword">if</span>(ag1==ag2) <span class="keyword">return</span> (area(a.a,a.b,b.b)&lt;<span class="number">0</span>);	<span class="comment">//返回左边的，这是因为两条平行的直线左边的有用 </span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> ag1&lt;ag2;	<span class="comment">//角度小的在前 </span></span><br><span class="line">&#125;</span><br><span class="line">point <span class="title function_">get_J</span><span class="params">(point p,point u,point q,point v)</span>&#123;	<span class="comment">//得到交点 </span></span><br><span class="line">	point w=p-q;</span><br><span class="line">	<span class="type">double</span> t=cross(v,w)/cross(u,v);</span><br><span class="line">	<span class="keyword">return</span> &#123;p.x+u.x*t,p.y+u.y*t&#125;;</span><br><span class="line">&#125;</span><br><span class="line">point <span class="title function_">get_J</span><span class="params">(line a,line b)</span>&#123;		<span class="comment">//重载 </span></span><br><span class="line">	<span class="keyword">return</span> get_J(a.a,a.b-a.a,b.a,b.b-b.a); </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">onRight</span><span class="params">(line a,line b,line c)</span>&#123;		<span class="comment">//判断a是否在bc交点右面 </span></span><br><span class="line">	point x=get_J(b,c);</span><br><span class="line">	<span class="keyword">return</span> area(a.a,a.b,x)&lt;=<span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ACWING2803凸多边形"><a href="#ACWING2803凸多边形" class="headerlink" title="ACWING2803凸多边形"></a><a href="https://www.acwing.com/problem/content/2805/">ACWING2803凸多边形</a></h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SUP=<span class="number">0x800000</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-8</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line">	<span class="type">double</span> x,y;</span><br><span class="line">&#125;pt[MAXN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">line</span>&#123;</span></span><br><span class="line">	point a,b;</span><br><span class="line">&#125;L[MAXN];</span><br><span class="line"><span class="type">int</span> cnt,n,m;</span><br><span class="line"><span class="type">int</span> front,tail;</span><br><span class="line"><span class="type">int</span> dq[MAXN];</span><br><span class="line">point operator-(point a,point b)&#123;	<span class="comment">//重载运算符 </span></span><br><span class="line">	<span class="keyword">return</span> &#123;a.x-b.x,a.y-b.y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> <span class="title function_">cross</span><span class="params">(point a,point b)</span>&#123;		<span class="comment">//叉积 </span></span><br><span class="line">	<span class="keyword">return</span> a.x*b.y-a.y*b.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> <span class="title function_">area</span><span class="params">(point a,point b,point c)</span>&#123;	<span class="comment">//ab向量叉乘ac向量 </span></span><br><span class="line">	<span class="keyword">return</span> cross(b-a,c-a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> <span class="title function_">get_angle</span><span class="params">(line x)</span>&#123;	<span class="comment">//得到线的角度 </span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">atan2</span>(x.b.y-x.a.y,x.b.x-x.a.x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">cmp</span><span class="params">(line a,line b)</span>&#123;</span><br><span class="line">	<span class="type">double</span> ag1=get_angle(a),ag2=get_angle(b);	<span class="comment">//得到两条线的角度 </span></span><br><span class="line">	<span class="keyword">if</span>(ag1==ag2) <span class="keyword">return</span> (area(a.a,a.b,b.b)&lt;<span class="number">0</span>);	<span class="comment">//返回左边的，这是因为两条平行的直线左边的有用 </span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> ag1&lt;ag2;	<span class="comment">//角度小的在前 </span></span><br><span class="line">&#125;</span><br><span class="line">point <span class="title function_">get_J</span><span class="params">(point p,point u,point q,point v)</span>&#123;	<span class="comment">//得到交点 </span></span><br><span class="line">	point w=p-q;</span><br><span class="line">	<span class="type">double</span> t=cross(v,w)/cross(u,v);</span><br><span class="line">	<span class="keyword">return</span> &#123;p.x+u.x*t,p.y+u.y*t&#125;;</span><br><span class="line">&#125;</span><br><span class="line">point <span class="title function_">get_J</span><span class="params">(line a,line b)</span>&#123;		<span class="comment">//重载 </span></span><br><span class="line">	<span class="keyword">return</span> get_J(a.a,a.b-a.a,b.a,b.b-b.a); </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">onRight</span><span class="params">(line a,line b,line c)</span>&#123;		<span class="comment">//判断a是否在bc交点右面 </span></span><br><span class="line">	point x=get_J(b,c);</span><br><span class="line">	<span class="keyword">return</span> area(a.a,a.b,x)&lt;=<span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">half</span><span class="params">()</span>&#123;</span><br><span class="line">	sort(L+<span class="number">1</span>,L+<span class="number">1</span>+cnt,cmp);</span><br><span class="line">	front=<span class="number">1</span>;tail=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i&gt;=<span class="number">2</span> &amp;&amp; get_angle(L[i<span class="number">-1</span>])==get_angle(L[i])) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">while</span>(tail-front&gt;=<span class="number">1</span> &amp;&amp; onRight(L[i],L[dq[tail<span class="number">-1</span>]],L[dq[tail]])) tail--;</span><br><span class="line">		<span class="keyword">while</span>(tail-front&gt;=<span class="number">1</span> &amp;&amp; onRight(L[i],L[dq[front]],L[dq[front+<span class="number">1</span>]])) front++;</span><br><span class="line">		dq[++tail]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(tail-front&gt;=<span class="number">1</span> &amp;&amp; onRight(L[dq[front]],L[dq[tail<span class="number">-1</span>]],L[dq[tail]])) tail--;</span><br><span class="line">	<span class="keyword">while</span>(tail-front&gt;=<span class="number">1</span> &amp;&amp; onRight(L[dq[tail]],L[dq[front]],L[dq[front+<span class="number">1</span>]])) front++;</span><br><span class="line">	dq[++tail]=dq[front];</span><br><span class="line">	<span class="type">double</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> js=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=front;i&lt;tail;i++)&#123;</span><br><span class="line">		pt[++js]=get_J(L[dq[i]],L[dq[i+<span class="number">1</span>]]);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i+<span class="number">1</span>&lt;=js;i++)&#123;</span><br><span class="line">		ans+=area(pt[<span class="number">1</span>],pt[i],pt[i+<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;fixed&lt;&lt;setprecision(<span class="number">3</span>)&lt;&lt;ans/<span class="number">2</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;m;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;pt[j].x&gt;&gt;pt[j].y;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(j!=m) L[++cnt]=&#123;pt[j].x,pt[j].y,pt[j+<span class="number">1</span>].x,pt[j+<span class="number">1</span>].y&#125;;</span><br><span class="line">			<span class="keyword">else</span> L[++cnt]=&#123;pt[j].x,pt[j].y,pt[<span class="number">1</span>].x,pt[<span class="number">1</span>].y&#125;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	half();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title>可持久化01字典树</title>
    <url>/posts/462ec91a.html</url>
    <content><![CDATA[<h1 id="可持久化01字典树"><a href="#可持久化01字典树" class="headerlink" title="可持久化01字典树"></a>可持久化01字典树</h1><blockquote>
<p>作用：实现区间查询异或最大</p>
<p>时复：插入和查询都是O(logn)</p>
</blockquote>
<h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><p>先开一个内存池，动态开点，每次插入一个数都建一个根节点，从根节点拉出一条链，链上的节点一边连向上一个版本的节点，一边连向新插入的点，再开一个num数组表示每一个节点经过了几次，查询时当高版本的num值大于低版本的num值时表示在这个区间内有对应的值，走到最后直接返回即可</p>
<h2 id="P4735-最大异或和"><a href="#P4735-最大异或和" class="headerlink" title="P4735 最大异或和"></a><a href="https://www.luogu.com.cn/problem/P4735">P4735 最大异或和</a></h2><p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/20210511170238.png" alt="image-20210511170230311"></p>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定有初始值的n个数，m此操作，每次可以选择插入一个数或者查询一个区间内和给定的数异或最大是多少？</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/20200304122526467.png" alt="https://m-sea-blog.com/archives/1450/"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">600000</span>*<span class="number">40</span>;</span><br><span class="line"><span class="type">int</span> ch[MAXN][<span class="number">2</span>],rt[MAXN];</span><br><span class="line"><span class="type">int</span> val[MAXN],num[MAXN];</span><br><span class="line"><span class="type">int</span> tot,n,m,pre,tmp;</span><br><span class="line"><span class="type">int</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> last,<span class="type">int</span> x)</span>&#123;</span><br><span class="line">	<span class="type">int</span> root=++tot,u=root;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">31</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">		<span class="type">int</span> id=(x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">		ch[u][id]=++tot;</span><br><span class="line">		ch[u][!id]=ch[last][!id];</span><br><span class="line">		num[ch[u][id]]=num[ch[last][id]]+<span class="number">1</span>;</span><br><span class="line">		u=ch[u][id];</span><br><span class="line">		last=ch[last][id];</span><br><span class="line">	&#125;</span><br><span class="line">	val[u]=x;</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r) <span class="keyword">return</span> <span class="number">0</span>^x;  <span class="comment">// 特判当区间为空</span></span><br><span class="line">	<span class="type">int</span> ret=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">31</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">		<span class="type">int</span> id=(x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(num[ch[r][!id]]&gt;num[ch[l][!id]])&#123;</span><br><span class="line">			<span class="keyword">if</span>(!id==<span class="number">1</span>) ret+=(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">			l=ch[l][!id];</span><br><span class="line">			r=ch[r][!id];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(id==<span class="number">1</span>) ret+=(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">			l=ch[l][id];</span><br><span class="line">			r=ch[r][id];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret^x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;tmp;</span><br><span class="line">		pre^=tmp;  <span class="comment">//前缀异或</span></span><br><span class="line">		rt[i]=insert(rt[i<span class="number">-1</span>],pre);  <span class="comment">//插入</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="type">char</span> op;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;op;</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;tmp;</span><br><span class="line">			n++;</span><br><span class="line">			pre^=tmp;</span><br><span class="line">			rt[n]=insert(rt[n<span class="number">-1</span>],pre);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="type">int</span> l,r,x;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r&gt;&gt;x;</span><br><span class="line">			<span class="keyword">if</span>(l<span class="number">-1</span>==<span class="number">0</span>) <span class="built_in">cout</span>&lt;&lt;query(<span class="number">0</span>,rt[r<span class="number">-1</span>],pre^x)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;  <span class="comment">//注意这里如果l-1已经等于0了，则直接查询0到r-1范围即可</span></span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;query(rt[l<span class="number">-2</span>],rt[r<span class="number">-1</span>],pre^x)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5 1</span></span><br><span class="line"><span class="comment">2 6 4 3 6</span></span><br><span class="line"><span class="comment">Q 3 5 4 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>可持久化系列</tag>
      </tags>
  </entry>
  <entry>
    <title>可持久化并查集</title>
    <url>/posts/1011873c.html</url>
    <content><![CDATA[<h1 id="可持久并查集"><a href="#可持久并查集" class="headerlink" title="可持久并查集"></a>可持久并查集</h1><blockquote>
<p>前置知识：主席树、可持久化数组</p>
<p>作用：保存历史的集合版本，查询过去版本</p>
<p>空间复杂度&gt;=(klog(n)+2^log(n)^-1) [一般开40倍原空间]</p>
</blockquote>
<p><a href="https://www.cnblogs.com/peng-ym/p/9357220.html">详细讲解</a></p>
<h2 id="大致过程"><a href="#大致过程" class="headerlink" title="大致过程"></a>大致过程</h2><p>将fa数组和dep数组可持久化，fa数组就有了各个版本不同的值，如果开结构体的话只需要将fa定义成结构体类型，因为两个数组可持久化后下标是相同的，需要注意的是不能路径压缩，一定要按秩合并！</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://www.luogu.com.cn/problem/P3402">洛谷模板</a></p>
<p><img src="C:\Users\60116\AppData\Roaming\Typora\typora-user-images\image-20210426204636666.png" alt="image-20210426204636666" style="zoom:50%;" /></p>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定n个集合，每一个集合初始只有自己一个数，接下来m次操作，每次操作有三种选择，合并a和b，回到k版本，询问a和b是否属于一个集合</p>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>将fa数组和dep数组可持久化，需要注意的是一定不能路径压缩，因为每次要保存版本，只是拉出来一条链，压缩路径的话就会影响其他版本的fa数组值，例如现在高版本压缩了一次路径，低版本的fa数组值被改变了，之后查询低版本时就会出错！如果没有了路径压缩那么时间就会慢很多，所以一定要按秩合并来优化一下，为什么按秩合并会快一点呢？</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/20210426213038.png" alt="image-20210426213034161" style="zoom:50%;" /></p>
<p>看这个图，倘若询问2和4是否在一个集合，第一个畸形图就需要多往上走两步，而第二个图就可以省下些时间。</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#pragma G++ optimize(2)</span></span><br><span class="line"><span class="comment">//#pragma G++ optimize(3,&quot;Ofast&quot;,&quot;inline&quot;)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SUB=<span class="number">-0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-4</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> E=<span class="built_in">exp</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> ls,rs,val;</span><br><span class="line">&#125;fa[MAXN*<span class="number">40</span>];  </span><br><span class="line"><span class="type">int</span> dep[MAXN*<span class="number">40</span>],rt[MAXN*<span class="number">40</span>];</span><br><span class="line"><span class="type">int</span> n,m,op,a,b,tot,k;</span><br><span class="line"><span class="type">int</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span>&#123;  </span><br><span class="line">	<span class="type">int</span> root=++tot;</span><br><span class="line">	<span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">		fa[root].val=l;  <span class="comment">//初始fa数组值为本身</span></span><br><span class="line">		<span class="keyword">return</span> root;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	fa[root].ls=build(l,mid);</span><br><span class="line">	fa[root].rs=build(mid+<span class="number">1</span>,r);</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> nod,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span>&#123;  <span class="comment">//查询x在这个版本的fa数组下标</span></span><br><span class="line">	<span class="keyword">if</span>(l==r) <span class="keyword">return</span> nod;</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=mid) <span class="keyword">return</span> query(fa[nod].ls,l,mid,x);  <span class="comment">//在左子树上</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> query(fa[nod].rs,mid+<span class="number">1</span>,r,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> nod,<span class="type">int</span> x)</span>&#123;</span><br><span class="line">	<span class="type">int</span> now=query(nod,<span class="number">1</span>,n,x);  <span class="comment">//查询x点在这个版本中fa数组的下标</span></span><br><span class="line">	<span class="keyword">if</span>(fa[now].val==x) <span class="keyword">return</span> now;  <span class="comment">//如果x的父亲值就是x说明x就是祖先</span></span><br><span class="line">	<span class="keyword">return</span> find(nod,fa[now].val);  <span class="comment">//否则就继续找</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">remerge</span><span class="params">(<span class="type">int</span> pre,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">	<span class="type">int</span> root=++tot;</span><br><span class="line">	fa[root]=fa[pre];  <span class="comment">//合并时需要创建一个新版本</span></span><br><span class="line">	<span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">		fa[root].val=y;  <span class="comment">//更新这个位置的父亲值</span></span><br><span class="line">		<span class="keyword">return</span> root;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=mid) fa[root].ls=remerge(fa[pre].ls,l,mid,x,y);</span><br><span class="line">	<span class="keyword">else</span> fa[root].rs=remerge(fa[pre].rs,mid+<span class="number">1</span>,r,x,y);</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	rt[<span class="number">0</span>]=build(<span class="number">1</span>,n);  <span class="comment">//初始化fa数组</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;op;</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">			rt[i]=rt[i<span class="number">-1</span>];  <span class="comment">//一定不能少了这一句，之前我就是想着remerge里面已经创建当前版本了，所以这一句没必要，但是如果两个点已经在一个集合里了，下面的if就不会执行，当前版本就没有保存</span></span><br><span class="line">			<span class="type">int</span> x=find(rt[i],a),y=find(rt[i],b);  <span class="comment">//查询a和b在当前版本的祖先</span></span><br><span class="line">			<span class="keyword">if</span>(fa[x].val!=fa[y].val)&#123;  </span><br><span class="line">				<span class="keyword">if</span>(dep[x]&gt;dep[y]) swap(x,y);  <span class="comment">//按秩合并</span></span><br><span class="line">				rt[i]=remerge(rt[i<span class="number">-1</span>],<span class="number">1</span>,n,fa[x].val,fa[y].val);  <span class="comment">//保存版本</span></span><br><span class="line">				<span class="keyword">if</span>(dep[x]==dep[y]) dep[y]++;  <span class="comment">//如果两个集合高度相同的话，合并后父集合高度要加一</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>)&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;k;</span><br><span class="line">			rt[i]=rt[k];  <span class="comment">//回到k版本</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">3</span>)&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">			rt[i]=rt[i<span class="number">-1</span>];  <span class="comment">//新建版本</span></span><br><span class="line">			<span class="type">int</span> fx=find(rt[i],a),fy=find(rt[i],b);  <span class="comment">//查询</span></span><br><span class="line">			<span class="keyword">if</span>(fx==fy) <span class="built_in">cout</span>&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>可持续化并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>可持久化数组</title>
    <url>/posts/9bca2feb.html</url>
    <content><![CDATA[<h1 id="可持久化数组-可持久化线段树"><a href="#可持久化数组-可持久化线段树" class="headerlink" title="可持久化数组(可持久化线段树)"></a>可持久化数组(可持久化线段树)</h1><blockquote>
<p>前置知识：主席树</p>
<p>作用：记录下历史版本，可以进入历史版本进行修改或者查询</p>
</blockquote>
<h2 id="洛谷P3919"><a href="#洛谷P3919" class="headerlink" title="洛谷P3919"></a>洛谷P3919</h2><p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/20210508213141.png" alt="image-20210425201653739" style="zoom:50%;" /></p>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定初始版本数组的n个数，之后m次操作，可以查询或者单点修改，每次查询或者修改都会产生一个新版本，查询产生一摸一样的版本，修改会产生一个只有一个位置不同的版本，版本数连续递增，输出每次查询某一个版本的某一个位置的数是几？</p>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>原本想用vector开n个表示数组的每一个位置的不同版本，想的是每次只把一个数塞进要修改的ve里，不过这样会有问题。正解是可持续化数组，本质上就是一个保存历史版本的线段树，利用主席树的思想单点修改时只拉出来一条链保存修改过的信息。</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#pragma G++ optimize(2)</span></span><br><span class="line"><span class="comment">//#pragma G++ optimize(3,&quot;Ofast&quot;,&quot;inline&quot;)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SUB=<span class="number">-0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-4</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> E=<span class="built_in">exp</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> ls,rs,val;</span><br><span class="line">&#125;hjt[MAXN*<span class="number">32</span>];</span><br><span class="line"><span class="type">int</span> arr[MAXN],rt[MAXN];</span><br><span class="line"><span class="type">int</span> n,m,tot,cnt;</span><br><span class="line"><span class="type">int</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span>&#123;  <span class="comment">//首先建一个初始的树</span></span><br><span class="line">	<span class="type">int</span> root=++tot;  <span class="comment">//分配空间</span></span><br><span class="line">	<span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">		hjt[root].val=arr[l];  <span class="comment">//到叶子节点就保存值</span></span><br><span class="line">		<span class="keyword">return</span> root;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	hjt[root].ls=build(l,mid);  <span class="comment">//建造左子树</span></span><br><span class="line">	hjt[root].rs=build(mid+<span class="number">1</span>,r);  <span class="comment">//建造右子树</span></span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> pre,<span class="type">int</span> pos,<span class="type">int</span> val,<span class="type">int</span> l,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">	<span class="type">int</span> root=++tot;</span><br><span class="line">	hjt[root]=hjt[pre];</span><br><span class="line">	<span class="keyword">if</span>(l==r)&#123;  <span class="comment">//单点修改</span></span><br><span class="line">		hjt[root].val=val;</span><br><span class="line">		<span class="keyword">return</span> root;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(pos&lt;=mid) hjt[root].ls=insert(hjt[pre].ls,pos,val,l,mid);</span><br><span class="line">	<span class="keyword">else</span> hjt[root].rs=insert(hjt[pre].rs,pos,val,mid+<span class="number">1</span>,r);</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> pos)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r) <span class="keyword">return</span> hjt[x].val;</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(pos&lt;=mid) <span class="keyword">return</span> query(l,mid,hjt[x].ls,pos);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> query(mid+<span class="number">1</span>,r,hjt[x].rs,pos);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;arr[i];</span><br><span class="line">	rt[cnt]=build(<span class="number">1</span>,n);</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="type">int</span> k,op,pos,val;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;k&gt;&gt;op;</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;pos&gt;&gt;val;</span><br><span class="line">			rt[++cnt]=insert(rt[k],pos,val,<span class="number">1</span>,n);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;pos;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;query(<span class="number">1</span>,n,rt[k],pos)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">			rt[++cnt]=rt[k];  <span class="comment">//直接复制过来之前的版本</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>可持久化数组</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集求联通块</title>
    <url>/posts/823c4696.html</url>
    <content><![CDATA[<h2 id="P1197-JSOI2008-星球大战"><a href="#P1197-JSOI2008-星球大战" class="headerlink" title="P1197 [JSOI2008]星球大战"></a>P1197 [JSOI2008]星球大战</h2><p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/20210226153916.png" alt="image-20210226153906812" style="zoom:67%;" /></p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>n个星球，m条边，k此摧毁，每次都会摧毁一个星球，摧毁一次求一次联通块，没摧毁时也要输出一次</p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>求联通块有两种方法</p>
<ol>
<li>利用dfs或者bfs从每一个点出发，把能到达的点都标记，每一个点都走一次，时间复杂度为O(n)，</li>
<li>使用并查集，单独n个点联通块就是n个，当两个点连接起来并且这两个点分别属于两个不同的联通块时，把他们合并成一个集合，联通块数量-1，时间复杂度差不多等于边的数量，&gt;O(m)</li>
</ol>
<p>如果只是求一次联通块的数量显然第一种方法更优，但是这道题每少一个点就要求一次联通块，如果用第一种方法时复O(kn)，这道题会超时，这时如果用并查集正着来做，时复O(mk)，也会超时，但是换一种思路，这道题要摧毁星球，我们倒着来，修建星球，每修建一个求一次联通块，而这时并查集时复就是常数级别O(max(m,k))，每修建一个多了一个点，联通块+1，看看和这个点相连的点是否属于一个集合，属于就-1，一个pair存点，再用链式前向星存一下图</p>
<h2 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SUB=<span class="number">-0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> eps=<span class="number">1e-4</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> to,next;</span><br><span class="line">&#125;e[MAXN];</span><br><span class="line"><span class="type">int</span> fa[MAXN],ans[MAXN],head[MAXN],dead[MAXN];</span><br><span class="line"><span class="type">bool</span> vis[MAXN];</span><br><span class="line"><span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; b[MAXN];</span><br><span class="line"><span class="type">int</span> tot,n,m,k;</span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span>&#123;</span><br><span class="line">	e[tot]=&#123;v,head[u]&#125;;</span><br><span class="line">	head[u]=tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==fa[x]) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">return</span> fa[x]=find(fa[x]);</span><br><span class="line">&#125; </span><br><span class="line"><span class="type">void</span> <span class="title function_">remerge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">	<span class="type">int</span> fx=find(x),fy=find(y);</span><br><span class="line">	<span class="keyword">if</span>(fx!=fy) fa[fx]=fy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++) fa[i]=i;</span><br><span class="line">	<span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span> head);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="type">int</span> u,v;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">		b[i]=&#123;u,v&#125;;</span><br><span class="line">		add(u,v);</span><br><span class="line">		add(v,u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;dead[i];</span><br><span class="line">		vis[dead[i]]=<span class="number">1</span>;  <span class="comment">//标记这个点被摧毁了</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> num=n-k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="comment">//如果条边连接的两个点都没有被摧毁且两者不在同一个集合</span></span><br><span class="line">		<span class="keyword">if</span>(!vis[b[i].first] &amp;&amp; !vis[b[i].second] &amp;&amp; find(b[i].first)!=find(b[i].second))&#123;</span><br><span class="line">			remerge(b[i].first,b[i].second);</span><br><span class="line">			num--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//此时就是所有星球被摧毁的联通块</span></span><br><span class="line">	ans[<span class="number">0</span>]=num;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=k;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">		num++; <span class="comment">//加一个点联通块+1</span></span><br><span class="line">		vis[dead[i]]=<span class="number">0</span>;  <span class="comment">//清除这个点的标记</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=head[dead[i]];~j;j=e[j].next)&#123;  <span class="comment">//遍历这个点相连的点</span></span><br><span class="line">			<span class="type">int</span> v=e[j].to;</span><br><span class="line">			<span class="keyword">if</span>(!vis[v] &amp;&amp; find(v)!=find(dead[i]))&#123;  <span class="comment">//相连点存活且不在一个集合联通块-1</span></span><br><span class="line">				num--;</span><br><span class="line">				remerge(v,dead[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		ans[k-i+<span class="number">1</span>]=num;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//倒着输出</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=k;i&gt;=<span class="number">0</span>;i--) <span class="built_in">cout</span>&lt;&lt;ans[i]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用dfs求：</p>
<p>20分，其中一个地方爆栈了，可以换成bfs来求</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">400010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SUB=<span class="number">-0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> eps=<span class="number">1e-4</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> to,next;</span><br><span class="line">&#125;e[<span class="number">200010</span>];</span><br><span class="line"><span class="type">int</span> n,m,tot,k,x,y,js;</span><br><span class="line"><span class="type">int</span> head[MAXN];</span><br><span class="line"><span class="type">bool</span> vis[MAXN],used[MAXN],book[MAXN];</span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span>&#123;</span><br><span class="line">	e[tot]=&#123;v,head[u]&#125;;</span><br><span class="line">	head[u]=tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">	vis[x]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[x];~i;i=e[i].next)&#123;</span><br><span class="line">		<span class="type">int</span> v=e[i].to;</span><br><span class="line">		<span class="keyword">if</span>(vis[v] || used[v]) <span class="keyword">continue</span>;</span><br><span class="line">		dfs(v);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span> head);</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">		add(x,y);</span><br><span class="line">		add(y,x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(vis[i] || used[i]) <span class="keyword">continue</span>;</span><br><span class="line">		js++;</span><br><span class="line">		dfs(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;js&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">while</span>(k--)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">		js=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">		used[x]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(vis[i] || used[i]) <span class="keyword">continue</span>;</span><br><span class="line">			js++;</span><br><span class="line">			dfs(i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;js&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>并查集求联通块</tag>
      </tags>
  </entry>
  <entry>
    <title>字典树</title>
    <url>/posts/eea60a6a.html</url>
    <content><![CDATA[<h1 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h1><blockquote>
<p>作用：快速实现查询某一个字符串是否出现过，类似字符串哈希</p>
<p>时复：O(L) [L:要查询的字符串长度]</p>
<p>空间复杂度：正比于需要插入的字符串总量，比普通数组存储要省空间</p>
</blockquote>
<h2 id="大致过程"><a href="#大致过程" class="headerlink" title="大致过程"></a>大致过程</h2><p>每一个节点代表一个字符，根节点为0，从根节点到叶子节点是一个完整的字符串，实际上就是一个前缀树，两个相同前缀的字符串在字典树上就有一个相同的前缀路径，给每一个节点编一个号，从1开始，用一个二维数组，第一维表示编号，第二维表示字符下标(s[i]-‘a’)，来表示这个编号的节点下有没有这个字符，这样一来省去了相同前缀的空间，而且查询可以每次以O(1)时间查询当前编号下是否有查询字符，需要查询L次，所以是O(L)</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><a href="https://www.luogu.com.cn/problem/P2580">洛谷模板P2580</a></p>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定n个字符串，m次询问，每次询问一个给定字符串是否出现过？</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>两种做法：</p>
<ol>
<li>map</li>
<li>trie字典树</li>
</ol>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#pragma G++ optimize(2)</span></span><br><span class="line"><span class="comment">//#pragma G++ optimize(3,&quot;Ofast&quot;,&quot;inline&quot;)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SUB=<span class="number">-0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-4</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> E=<span class="built_in">exp</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">int</span> nex[MAXN][<span class="number">27</span>];</span><br><span class="line"><span class="type">bool</span> exist[MAXN];</span><br><span class="line"><span class="type">int</span> tot;</span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(<span class="built_in">string</span> s)</span>&#123;</span><br><span class="line">	<span class="type">int</span> len=s.size(),p=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">		<span class="type">int</span> c=s[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">		<span class="keyword">if</span>(!nex[p][c]) nex[p][c]=++tot;</span><br><span class="line">		p=nex[p][c];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="built_in">string</span> s)</span>&#123;</span><br><span class="line">	<span class="type">int</span> len=s.size(),p=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">		<span class="type">int</span> c=s[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">		<span class="keyword">if</span>(!nex[p][c]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		p=nex[p][c];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!exist[p])&#123;</span><br><span class="line">		exist[p]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="type">int</span> n,m;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="built_in">string</span> now;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;now;</span><br><span class="line">		insert(now);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;m;</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="built_in">string</span> now;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;now;</span><br><span class="line">		<span class="type">int</span> k=find(now);</span><br><span class="line">		<span class="keyword">if</span>(k==<span class="number">0</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;WRONG\n&quot;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(k==<span class="number">1</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;OK\n&quot;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;REPEAT\n&quot;</span>; </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字典树</tag>
      </tags>
  </entry>
  <entry>
    <title>回归问题</title>
    <url>/posts/edb5b5ea.html</url>
    <content><![CDATA[<blockquote>
<p>线性回归就是多项式回归的一种特殊情况，在线性回归中只存在一次项，所以只能拟合直线，而多项式回归则存在高次项，可以拟合曲线。本文代码都是基于多项式回归的，所以w是一个向量，并且没有考虑多元函数的情况，只存在x和y两个变量</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>机器学习中的线性回归是一种简单但强大的技术，其作用包括但不限于以下几个方面：</p>
<ol>
<li><strong>预测：</strong> 最常见的用途是用来预测目标变量的数值。通过学习输入特征和目标变量之间的线性关系，线性回归模型可以用来预测未知数据点的目标变量值。例如，根据房屋的面积、卧室数量等特征，预测房屋的售价。</li>
<li><strong>关联分析：</strong> 可以用线性回归来分析输入特征与目标变量之间的关联程度。通过观察特征与目标变量之间的线性关系，可以识别出哪些特征对目标变量有显著影响，进而深入了解数据之间的关系。</li>
<li><strong>异常检测：</strong> 通过观察模型的预测残差（实际值与预测值之间的差异），可以识别出可能是异常的数据点。这些异常点可能是数据采集或处理过程中的错误，或者是真实世界中的特殊情况，值得进一步调查。</li>
<li><strong>特征工程：</strong> 线性回归可以用来评估特征的重要性和影响程度。基于模型的系数（权重），可以识别出哪些特征对目标变量的影响最大，从而指导特征选择和特征工程的过程。</li>
<li><strong>解释性：</strong> 线性回归模型具有很强的解释性，模型的系数可以直观地解释特征对目标变量的影响程度。这使得线性回归在决策支持系统和业务解释性要求较高的场景中非常有用。</li>
</ol>
<p>总的来说，线性回归在机器学习中扮演着重要的角色，是许多其他复杂模型的基础。它提供了一种简单而有效的方法来建模和预测数据，同时具有很强的解释性，使得其在实际应用中得到了广泛的应用。</p>
<h1 id="成本函数"><a href="#成本函数" class="headerlink" title="成本函数"></a>成本函数</h1><p>成本函数在回归问题中的作用是衡量模型预测值与真实值之间的差异，或者说衡量模型的预测误差。它是优化算法的核心，用于指导模型参数的更新，使得模型能够更好地拟合训练数据并得到更准确的预测结果。</p>
<p>具体来说，成本函数在回归问题中的作用包括以下几个方面：</p>
<ol>
<li><p><strong>评估模型性能：</strong> 成本函数提供了一个度量模型预测性能的指标。通过计算成本函数的值，可以了解模型对训练数据的拟合程度，以及模型的预测误差大小。成本函数的值越小，表示模型的预测结果与真实值越接近，模型性能越好。</p>
</li>
<li><p><strong>优化模型参数：</strong> 成本函数是优化算法的目标函数，优化算法的目标是最小化成本函数的值。通过最小化成本函数，可以找到使模型预测误差最小化的参数值，从而得到更准确的模型。常见的优化算法包括梯度下降、随机梯度下降等，它们通过计算成本函数的梯度来指导参数的更新。</p>
</li>
<li><p><strong>调整模型复杂度：</strong> 成本函数可以帮助调整模型的复杂度，以避免过拟合或欠拟合的问题。通过引入正则化项或调整模型的超参数，可以改变成本函数的形式，从而影响模型的学习过程和预测性能。</p>
</li>
</ol>
<p>在回归问题中，常用的成本函数包括均方误差（Mean Squared Error，MSE）、均方根误差（Root Mean Squared Error，RMSE）、平均绝对误差（Mean Absolute Error，MAE）等。这些成本函数可以根据具体的问题和需求进行选择，用于评估模型的性能并指导模型的优化。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">compute_cost</span>(<span class="params">x, y, w, b</span>):</span><br><span class="line">    m = x.shape[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    cost_sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        f_wb = <span class="built_in">sum</span>(w * x[i]) + b</span><br><span class="line">        cost = (f_wb - y[i]) ** <span class="number">2</span></span><br><span class="line">        cost_sum = cost_sum + cost</span><br><span class="line">    total_cost = (<span class="number">1</span> / (<span class="number">2</span> * m)) * cost_sum</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> total_cost</span><br></pre></td></tr></table></figure>
<h1 id="计算梯度"><a href="#计算梯度" class="headerlink" title="计算梯度"></a>计算梯度</h1><p><img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/image-20240202133656183.png" alt="image-20240202133656183"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">compute_gradient</span>(<span class="params">x, y, w, b</span>):</span><br><span class="line">    m = x.shape[<span class="number">0</span>]</span><br><span class="line">    dj_dw = <span class="number">0</span></span><br><span class="line">    dj_db = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        f_wb = <span class="built_in">sum</span>(w * x[i]) + b</span><br><span class="line">        dj_dw_i = (f_wb - y[i]) * x[i]</span><br><span class="line">        dj_db_i = f_wb - y[i]</span><br><span class="line">        dj_db += dj_db_i</span><br><span class="line">        dj_dw += dj_dw_i</span><br><span class="line">    dj_dw = dj_dw / m</span><br><span class="line">    dj_db = dj_db / m</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dj_dw, dj_db</span><br></pre></td></tr></table></figure>
<h1 id="标准化和归一化"><a href="#标准化和归一化" class="headerlink" title="标准化和归一化"></a>标准化和归一化</h1><p>标准化（Normalization）和归一化（Standardization）是数据预处理中常用的两种技术，它们的作用不同，适用于不同的情况：</p>
<ol>
<li><p><strong>标准化（Standardization）：</strong></p>
<ul>
<li><strong>作用：</strong> 标准化的主要作用是使数据的分布符合标准正态分布（均值为0，标准差为1）。通过减去特征的均值，然后除以特征的标准差，可以将数据的均值调整为0，标准差调整为1。</li>
<li><strong>优点：</strong> 标准化不会改变数据的原始分布形状，适用于大部分机器学习算法，特别是那些对数据分布敏感的算法，如支持向量机（SVM）和k近邻（KNN）等。</li>
<li><strong>适用情况：</strong> 当特征的数值范围差异较大，或者特征的分布不符合标准正态分布时，可以考虑使用标准化。</li>
</ul>
</li>
<li><p><strong>归一化（Normalization）：</strong></p>
<ul>
<li><strong>作用：</strong> 归一化的主要作用是将特征缩放到一个指定的范围内，通常是[0, 1]或[-1, 1]。通过对每个特征的数值进行线性变换，使其落在指定的范围内。</li>
<li><strong>优点：</strong> 归一化可以消除特征之间的量纲差异，使得不同特征具有相同的重要性。它也有助于加速模型的收敛速度，并提高模型的性能。</li>
<li><strong>适用情况：</strong> 当特征的数值范围差异较大，或者特征的数值范围不重要，但需要保证特征具有相同的重要性时，可以考虑使用归一化。</li>
</ul>
</li>
</ol>
<p>总的来说，标准化和归一化是常用的数据预处理技术，可以帮助提高模型的性能和稳定性。选择使用哪种技术取决于数据的特点和机器学习算法的需求，需要根据具体情况进行选择。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">zscore_normalize_features</span>(<span class="params">X</span>):</span><br><span class="line">    mu = np.mean(X, axis=<span class="number">0</span>)  <span class="comment"># mu will have shape (n,)</span></span><br><span class="line">    sigma = np.std(X, axis=<span class="number">0</span>)  <span class="comment"># sigma will have shape (n,)</span></span><br><span class="line">    X_norm = (X - mu) / sigma</span><br><span class="line">    <span class="keyword">return</span> X_norm</span><br></pre></td></tr></table></figure>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">zscore_normalize_features</span>(<span class="params">X</span>):</span><br><span class="line">    mu = np.mean(X, axis=<span class="number">0</span>)  <span class="comment"># 平均值</span></span><br><span class="line">    sigma = np.std(X, axis=<span class="number">0</span>)  <span class="comment"># 标准差</span></span><br><span class="line">    X_norm = (X - mu) / sigma</span><br><span class="line">    <span class="keyword">return</span> X_norm</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compute_cost</span>(<span class="params">x, y, w, b</span>):</span><br><span class="line">    m = x.shape[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    cost_sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        f_wb = <span class="built_in">sum</span>(w * x[i]) + b</span><br><span class="line">        cost = (f_wb - y[i]) ** <span class="number">2</span></span><br><span class="line">        cost_sum = cost_sum + cost</span><br><span class="line">    total_cost = (<span class="number">1</span> / (<span class="number">2</span> * m)) * cost_sum</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> total_cost</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compute_gradient</span>(<span class="params">x, y, w, b</span>):</span><br><span class="line">    m = x.shape[<span class="number">0</span>] <span class="comment"># x 是二维向量，一维表示数量，二维表示特征数量（高次项数量）</span></span><br><span class="line">    dj_dw = <span class="number">0</span></span><br><span class="line">    dj_db = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        f_wb = <span class="built_in">sum</span>(w * x[i]) + b</span><br><span class="line">        dj_dw_i = (f_wb - y[i]) * x[i]</span><br><span class="line">        dj_db_i = f_wb - y[i]</span><br><span class="line">        dj_db += dj_db_i</span><br><span class="line">        dj_dw += dj_dw_i</span><br><span class="line">    dj_dw = dj_dw / m</span><br><span class="line">    dj_db = dj_db / m</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dj_dw, dj_db</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gradient_descent</span>(<span class="params">X, y, num_iters, alpha</span>):</span><br><span class="line">    J_history = []	<span class="comment"># 调试，打印每次的成本</span></span><br><span class="line">    w = np.zeros(X.shape[<span class="number">1</span>]) <span class="comment"># 随便初始化 w 和 b</span></span><br><span class="line">    b = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_iters):</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Calculate the gradient and update the parameters</span></span><br><span class="line">        dj_dw, dj_db = compute_gradient(X, y, w, b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Update Parameters using w, b, alpha and gradient</span></span><br><span class="line">        w = w - alpha * dj_dw  <span class="comment">##更新 w 和 b</span></span><br><span class="line">        b = b - alpha * dj_db  </span><br><span class="line"></span><br><span class="line">        <span class="comment"># Save cost J at each iteration</span></span><br><span class="line">        J_history.append(compute_cost(X, y, w, b))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Print cost every at intervals 10 times or as many iterations if &lt; 10</span></span><br><span class="line">        <span class="keyword">if</span> i % math.ceil(num_iters / <span class="number">10</span>) == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Iteration <span class="subst">&#123;i: 4d&#125;</span>: Cost <span class="subst">&#123;J_history[-<span class="number">1</span>]:<span class="number">8.10</span>f&#125;</span>   &quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> w, b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x = np.arange(<span class="number">0</span>,<span class="number">20</span>,<span class="number">1</span>)</span><br><span class="line">y = np.sin(x/<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多项式高次项，自己根据情况指定</span></span><br><span class="line">X = np.c_[x, x**<span class="number">2</span>, x**<span class="number">3</span>,x**<span class="number">4</span>, x**<span class="number">5</span>, x**<span class="number">6</span>, x**<span class="number">7</span>, x**<span class="number">8</span>, x**<span class="number">9</span>, x**<span class="number">10</span>, x**<span class="number">11</span>, x**<span class="number">12</span>, x**<span class="number">13</span>]</span><br><span class="line">X = zscore_normalize_features(X) <span class="comment"># 标准化</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model_w, model_b = gradient_descent(X, y, <span class="number">1000000</span>, <span class="number">1e-1</span>)</span><br><span class="line"></span><br><span class="line">plt.scatter(x, y, marker=<span class="string">&#x27;x&#x27;</span>, c=<span class="string">&#x27;r&#x27;</span>, label=<span class="string">&quot;Actual Value&quot;</span>)</span><br><span class="line">plt.title(<span class="string">&quot;Normalized x x**2, x**3 feature&quot;</span>)</span><br><span class="line">plt.plot(x, X@model_w + model_b, label=<span class="string">&quot;Predicted Value&quot;</span>) <span class="comment"># x @ model_w 就是矩阵乘法</span></span><br><span class="line">plt.xlabel(<span class="string">&quot;x&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;y&quot;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<h1 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h1><p><img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/image-20240202134136841.png" alt="image-20240202134136841"></p>
<h1 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h1><p><a href="https://blog.csdn.net/qq_40582172/article/details/111527286">文章链接</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>线性回归</tag>
      </tags>
  </entry>
  <entry>
    <title>小Q与异或</title>
    <url>/posts/53b46afd.html</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="C:\Users\60116\AppData\Roaming\Typora\typora-user-images\image-20210427204752367.png" alt="image-20210427204752367" style="zoom:67%;" /></p>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>让你构造一个序列，满足m个位置的前缀异或等于m个值</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>先把p位置的值定成x，把每一个定好的位置标记一下，从前往后跑，没有标记过的点就给他定一个比1e9要大的数，之所以要比1e9要大，是因为要保证定好的位置和它的前一个位置异或不为0，而定好的位置的值x&lt;=1e9，输出时，就输出每一个数和前一个数的异或结果</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n , m;</span><br><span class="line"><span class="type">int</span> ned[<span class="number">1200000</span>] , is[<span class="number">1200000</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">work</span> <span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> i , p , x , pre;</span><br><span class="line">	<span class="built_in">scanf</span> ( <span class="string">&quot;%d%d&quot;</span> , &amp;n , &amp;m );</span><br><span class="line">	<span class="keyword">for</span> ( i = <span class="number">1</span> ; i &lt;= m ; i++ ) &#123;</span><br><span class="line">		<span class="built_in">scanf</span> ( <span class="string">&quot;%d%d&quot;</span> , &amp;p , &amp;x );</span><br><span class="line">		<span class="keyword">if</span> ( is[p] &amp;&amp; ned[p] != x ) &#123;</span><br><span class="line">			<span class="built_in">printf</span> ( <span class="string">&quot;-1\n&quot;</span> );</span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">		ned[p] = x;</span><br><span class="line">		is[p] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> ( i = <span class="number">1</span> ; i &lt;= n ; i++ ) &#123;</span><br><span class="line">		<span class="keyword">if</span> ( is[i] == <span class="number">0</span> ) &#123;</span><br><span class="line">			ned[i] = <span class="number">1000000000</span> + i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> ( ned[i] == ned[i<span class="number">-1</span>] ) &#123;</span><br><span class="line">			<span class="built_in">printf</span> ( <span class="string">&quot;-1\n&quot;</span> );</span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> ( i = <span class="number">1</span> ; i &lt;= n ; i++ ) &#123;</span><br><span class="line">		<span class="built_in">printf</span> ( <span class="string">&quot;%d%c&quot;</span> , ned[i<span class="number">-1</span>] ^ ned[i] , i==n?<span class="string">&#x27;\n&#x27;</span>:<span class="string">&#x27; &#x27;</span> );</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span> &#123;</span><br><span class="line">	work ();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>异或题</tag>
      </tags>
  </entry>
  <entry>
    <title>数位DP</title>
    <url>/posts/a3781d1f.html</url>
    <content><![CDATA[<blockquote>
<p>数位DP</p>
<p>解决的是求一段区间中满足一定条件的数的数量，形式固定</p>
</blockquote>
<h2 id="数位DP模板"><a href="#数位DP模板" class="headerlink" title="数位DP模板"></a>数位DP模板</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num[<span class="number">100</span>],dp[<span class="number">100</span>][...];</span><br><span class="line"><span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> ...,<span class="type">bool</span> limit)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(pos==<span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">	<span class="keyword">if</span>(!limit &amp;&amp; dp[pos][...]!=<span class="number">-1</span>) <span class="keyword">return</span> dp[pos][...];</span><br><span class="line">	<span class="type">int</span> up=limit?num[pos]:<span class="number">9</span>;</span><br><span class="line">	<span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=up; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(...) sum+=dfs(pos<span class="number">-1</span>,...,limit &amp;&amp; (i==up));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!limit) dp[pos][...]=sum;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ps 如果有前导0就可以加一个 lead,一开始传1，然后后面就传lead&amp;&amp;(i==0)就可以了</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">work</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">	<span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(x) &#123;</span><br><span class="line">		num[++len]=x%<span class="number">10</span>;</span><br><span class="line">		x=x/<span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dfs(len,...,<span class="number">1</span>); <span class="comment">//第一位直接上限位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以一道例题讲解算法</p>
<h2 id="不要62"><a href="#不要62" class="headerlink" title="不要62"></a><a href="https://acm.hdu.edu.cn/showproblem.php?pid=2089">不要62</a></h2><p>求[L,R]内所有没出现4、62的数字数量，比如662、458这些都不满足条件。</p>
<p>首先转化为算1~R满足条件数字的问题，然后用fun(R)-fun(L-1)就是答案，数位DP就是对数位进行记忆化搜索，保存可以利用的信息，从而进行剪枝优化时间。核心在于dp[][]数组去保存信息，第一维表示当前的位数，第二维表示前一位的状态，记录的是这一维没有限制时符合条件的数量，也就是当前这一位是0~9时的数量，因为这个状态重复的最多且计算量大</p>
<p>这就是这道题目的代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当前的数位，前一位是否为6，前一位是否有限制</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> pos,<span class="type">bool</span> state,<span class="type">bool</span> limit)</span>&#123;</span><br><span class="line">    <span class="comment">//到最后一位返回1，表示有一个数满足要求</span></span><br><span class="line">	<span class="keyword">if</span>(pos==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//前一位没有限制表示当前可以取得数字是0~9，看一下是否可以记忆化剪枝</span></span><br><span class="line">    <span class="comment">//注意这里dp为0也可以返回，因为dp记录的是这种状态的答案数量，可能为0</span></span><br><span class="line">	<span class="keyword">if</span>(!limit &amp;&amp; dp[pos][state]!=<span class="number">-1</span>) <span class="keyword">return</span> dp[pos][state];</span><br><span class="line">    <span class="comment">//当前最高计算到多少位</span></span><br><span class="line">	<span class="type">int</span> up=limit?num[pos]:<span class="number">9</span>;</span><br><span class="line">    <span class="comment">//计算这个状态的答案sum</span></span><br><span class="line">	<span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=up;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(state &amp;&amp; i==<span class="number">2</span>) <span class="keyword">continue</span>;	<span class="comment">//62跳过</span></span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">4</span>) <span class="keyword">continue</span>;	<span class="comment">//4跳过</span></span><br><span class="line">		sum+=dfs(pos<span class="number">-1</span>,i==<span class="number">6</span>,limit&amp;&amp;num[pos]==i); <span class="comment">//深搜累加答案</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!limit) dp[pos][state]=sum; <span class="comment">//保存状态</span></span><br><span class="line">	<span class="keyword">return</span> sum;	<span class="comment">//记得返回答案</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">work</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">	cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(x)&#123;</span><br><span class="line">		num[++cnt]=x%<span class="number">10</span>;	<span class="comment">//保存数位</span></span><br><span class="line">		x/=<span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dfs(cnt,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Round-Numbers"><a href="#Round-Numbers" class="headerlink" title="Round Numbers"></a><a href="http://poj.org/problem?id=3252">Round Numbers</a></h2><p>统计区间中二进制0的个数不小于1的个数的所有数字。</p>
<p>这里比不要62多了一个参数，表示是否有前导零。</p>
<p>写法1：</p>
<p>三维dp，第三维表示总位数，这个地方我刚开始写错了，没考虑到这个，只记录了0的数量，其实1的数量也要考虑进去，否则1个0，1个1和1个0，2个1就会被记录成一个状态，导致答案错误，这里我这么写主要为了使用ksm剪枝，更快求出答案。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> js,<span class="type">bool</span> limit,<span class="type">bool</span> lead)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(pos==<span class="number">0</span>) <span class="keyword">return</span> js&gt;=(res-js);</span><br><span class="line">	<span class="keyword">if</span>(!limit &amp;&amp; !lead &amp;&amp; js&gt;=(res-js)) dp[pos][js][res]=ksm(<span class="number">2</span>,pos);</span><br><span class="line">	<span class="keyword">if</span>(!limit &amp;&amp; !lead &amp;&amp; dp[pos][js][res]!=<span class="number">-1</span>) <span class="keyword">return</span> dp[pos][js][res];</span><br><span class="line">	<span class="type">int</span> up=limit?num[pos]:<span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=up;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">0</span> &amp;&amp; lead)&#123;</span><br><span class="line">			res--;</span><br><span class="line">			sum+=dfs(pos<span class="number">-1</span>,js,limit&amp;&amp;num[pos]==i,<span class="number">1</span>);</span><br><span class="line">			res++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> sum+=dfs(pos<span class="number">-1</span>,i==<span class="number">0</span>?js+<span class="number">1</span>:js,limit&amp;&amp;num[pos]==i,<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!limit &amp;&amp; !lead) dp[pos][js][res]=sum;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">work</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">	cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(x)&#123;</span><br><span class="line">		num[++cnt]=x%<span class="number">2</span>;</span><br><span class="line">		x/=<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	res=cnt;</span><br><span class="line">	<span class="keyword">return</span> dfs(cnt,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写法2：</p>
<p>当前位是0就加，是1就减，直接包含了所有状态，省空间且写法简单，需要学习，初始值为32因为不能减到负数，因为还要作为数组下标存储状态</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> js,<span class="type">bool</span> limit,<span class="type">bool</span> lead)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(pos==<span class="number">0</span>) <span class="keyword">return</span> js&gt;=<span class="number">32</span>;</span><br><span class="line">	<span class="keyword">if</span>(!limit &amp;&amp; !lead &amp;&amp; dp[pos][js]!=<span class="number">-1</span>) <span class="keyword">return</span> dp[pos][js];</span><br><span class="line">	<span class="type">int</span> up=limit?num[pos]:<span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=up;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">0</span> &amp;&amp; lead) sum+=dfs(pos<span class="number">-1</span>,js,limit&amp;&amp;num[pos]==i,<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">else</span> sum+=dfs(pos<span class="number">-1</span>,i==<span class="number">0</span>?js+<span class="number">1</span>:js<span class="number">-1</span>,limit&amp;&amp;num[pos]==i,<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!limit &amp;&amp; !lead) dp[pos][js]=sum;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">work</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">	cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(x)&#123;</span><br><span class="line">		num[++cnt]=x%<span class="number">2</span>;</span><br><span class="line">		x/=<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	res=cnt;</span><br><span class="line">	<span class="keyword">return</span> dfs(cnt,<span class="number">32</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数位DP</tag>
      </tags>
  </entry>
  <entry>
    <title>数学期望</title>
    <url>/posts/b9d78651.html</url>
    <content><![CDATA[<blockquote>
<p>期望: 结果乘以结果出现的概率</p>
<p>$E(X+Y)=E(X)+E(Y)$</p>
<p>$E(XY)=E(X)E(Y)——(X和Y相互独立)$</p>
</blockquote>
<h2 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>投硬币，连续出现K次正面的投掷次数期望值。</p>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>假设已经连续抛出$n-1$次正面，需要$T<em>{n−1}$次。想得到$n$次正面，则再进行一次投掷$Tn=T</em>{n−1}+1+?$</p>
<p>若硬币为正面则游戏结束，还需要抛0次$Tn=T_{n−1}+1+0.5∗0+?$）</p>
<p>如果硬币为反面，则游戏重来，还需要投掷$0.5∗Tn$次，递推公式如下所示：</p>
<p>$Tn=T_{n−1}+1+0.5∗0+0.5∗Tn$</p>
<p>求出通项公式:</p>
<p>$Tn=2^{n+1}+2$</p>
<h2 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h2><p><a href="https://ac.nowcoder.com/acm/problem/25193">题目链接</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/image-20211119093700596.png" alt="image-20211119093700596"></p>
<p>设dp[i]表示i个座位最后坐满人的情况，那么对于n个座位而言，第一个人上车就有n个选择，坐在第一个位置，剩下的就是dp[n-2]，坐在第二个位置，剩下的就是$dp[0]+dp[n-3]$，坐在第三个位置，剩下的就是$dp[1]+dp[n-4]$，以此类推…</p>
<p>求个和，就是$2*sum[n-2]$，sum[n-2]表示前n-2项的前缀和(dp[0]=0)</p>
<p>还要把第一个人加上，因为有n个选择，所以加n，每一个选择有$1/n$的概率，所以最后除以n</p>
<p>$dp[i]=(i+2*cnt)/n$</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1000002</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1000000007</span>;</span><br><span class="line">ll dp[N];</span><br><span class="line">ll <span class="title function_">ksm</span><span class="params">(ll a,ll b)</span>&#123;</span><br><span class="line">	ll res=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(b)&#123;</span><br><span class="line">		<span class="keyword">if</span>(b&amp;<span class="number">1</span>) res=res*a%mod;</span><br><span class="line">		a=a*a%mod;</span><br><span class="line">		b&gt;&gt;=<span class="number">1</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">ll <span class="title function_">inv</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ksm(x,mod<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	dp[<span class="number">1</span>]=<span class="number">1</span>; dp[<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">	ll cnt=<span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		dp[i]=(<span class="number">2</span>*cnt%mod+i)*inv(i)%mod;</span><br><span class="line">		cnt=(cnt+dp[i<span class="number">-1</span>])%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;dp[n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="问题三"><a href="#问题三" class="headerlink" title="问题三"></a>问题三</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>三个骰子，给出每个骰子的面数，求随机摇出的三个数字和出现次数最多的是什么？如果有多个和出现次数一样，输出最小的。</p>
<h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><p><a href="https://p31prshut.blog.luogu.org/ti-xie-p2911-usaco08oct-niu-gu-tou-bovine-bones">大犇题解</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> a[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>;i++) <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">	sort(a+<span class="number">1</span>,a+<span class="number">1</span>+<span class="number">3</span>);</span><br><span class="line">	<span class="keyword">if</span>(a[<span class="number">2</span>]&lt;=(a[<span class="number">3</span>]-a[<span class="number">1</span>]+<span class="number">1</span>)) <span class="built_in">cout</span>&lt;&lt;<span class="number">1</span>+a[<span class="number">1</span>]+a[<span class="number">2</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="number">1</span>+a[<span class="number">3</span>]+(a[<span class="number">2</span>]-(a[<span class="number">3</span>]-a[<span class="number">1</span>]+<span class="number">1</span>))/<span class="number">2</span>+<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>期望</tag>
      </tags>
  </entry>
  <entry>
    <title>整数分块</title>
    <url>/posts/f7996318.html</url>
    <content><![CDATA[<blockquote>
<p>整数分块可以以log(n)的时间复杂度内求出${\sum_{i=1}^n\lfloor n/i \rfloor}$</p>
</blockquote>
<h2 id="小G的约数"><a href="#小G的约数" class="headerlink" title="小G的约数"></a>小G的约数</h2><p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/20210227160808.png" alt="image-20210227160754599" style="zoom:67%;" /></p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>单纯求F(n)O(n)求出，现在求$\sum<em>{i=1}^nF_i$，可以换种思路，从个体对整体的贡献下手，对于每一个约数求有这个约数的所有数数量，显然是n/i个，然后乘上i，那么问题就转化为了${\sum</em>{i=1}^n\lfloor n/i \rfloor*i}$，很明显的整数分块模板，什么是整数分块，考虑n=10的时候n/i的表</p>
<p>i:   1  2 3 4 5 6 7 8 9 10</p>
<p>n/i: 10 5 3 2 2 1 1 1 1 1</p>
<p>发现数字呈从大到小块状分布，只要知道了一个块的左端和右端就能直接算出这个块的n/i的和，这里有一个结论：$N/i==N/i’时，i’的最大值：N/(N/i)$,i’也就是右端点，因此可以枚举每一段区间，n/i的所有数字中不同数字的数量不会超过2*sqrt(n)个，因此时复就是sqrt(n)</p>
<h2 id="整数分块函数"><a href="#整数分块函数" class="headerlink" title="整数分块函数"></a>整数分块函数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ll <span class="title function_">get</span><span class="params">(ll x)</span>&#123;</span><br><span class="line">	ll ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=x;i++)&#123;</span><br><span class="line">        ll r=x/(x/i);</span><br><span class="line">        ret+=x/i*(r-i+<span class="number">1</span>);</span><br><span class="line">	    i=r;  <span class="comment">//把指针移到右端点的下一个位置，这里移到右端点是因为i++</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ACCODE"><a href="#ACCODE" class="headerlink" title="ACCODE"></a>ACCODE</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SUB=<span class="number">-0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> eps=<span class="number">1e-4</span>;</span><br><span class="line">ll <span class="title function_">get</span><span class="params">(ll x)</span>&#123;</span><br><span class="line">	ll ret=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=x;i++)&#123;</span><br><span class="line">		ll r=x/(x/i);</span><br><span class="line">		ret+=(r-i+<span class="number">1</span>)*(x/i)*(i+r)/<span class="number">2</span>;  <span class="comment">//这里要乘以等差数组前缀和</span></span><br><span class="line">		i=r;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	ios;</span><br><span class="line">	ll n;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;get(get(n))&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>整数分块</tag>
      </tags>
  </entry>
  <entry>
    <title>扩展KMP</title>
    <url>/posts/82a15c1d.html</url>
    <content><![CDATA[<h1 id="扩展KMP"><a href="#扩展KMP" class="headerlink" title="扩展KMP"></a>扩展KMP</h1><blockquote>
<p>解决的问题： 求解母串以i位置开始的后缀子串与模式串的最大公共前缀</p>
<p>时复： O(母串长度+模式串长度)</p>
</blockquote>
<p>引入两个概念，extend[]数组表示以母串i位置开始的后缀子串与模式串的最大公共前缀，next[]数组表示模式串以i位置开始的后缀子串与模式串的最大公共前缀，一个是模式串与母串，一个是模式串与模式串</p>
<p>与KMP类似，都采用了利用之前已经得到的信息来优化当前的时间</p>
<h2 id="大致过程"><a href="#大致过程" class="headerlink" title="大致过程"></a>大致过程</h2><p>记一个po表示起始位置，求解extend数组需要先求出next数组，而求解next数组的过程和求extend过程一致，只不过是把模式串当作母串</p>
<p><img src="https://img-blog.csdn.net/2018052216265837?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMTYwNjA1/font/5a6L5L2T" alt="img"></p>
<p>(1) 第一步，我们先对原串S1和模式串S2进行逐一匹配，直到发生不配对的情况。我们可以看到，S1[0]=S2[0],S1[1]=S2[1],S1[2]=S2[2],S1[3] ≠S2[3],此时匹配失败，第一步结束，我们得到S1[0,2]=S2[0,2],即extend[0]=3;</p>
<p>(2) Extend[0]的计算如第一步所示，那么extend[1]的计算是否也要从原串S1的1位置，模式串的0位置开始进行逐一匹配呢？扩展KMP优化的便是这个过程。从extend[0]=3的结果中，我们可以知道，S1[0,2]=S2[0,2],那么S1[1.2]=S2[1,2]。因为next[1]=4,所以S2[1,4]=S2[0,3],即S2[1,2]=S[0,1],可以得出S1[1,2]=S2[1,2]=S2[0,1],然后我们继续匹配，S1[3] ≠S2[3],匹配失败，extend[1]=2;</p>
<p>(3) 因为extend[1]=2,则S1[1,2]=S2[0,1],所以S1[2,2]=S2[0,0],因为next[0]=5,所以S1[0,5]=S2[0,5],所以S2[0,0]=S2[0,0],又回到S1[2,2]=S2[0,0],继续匹配下一位，因为S1[3] ≠S2[1],所以下一位匹配失败，extend[2]=1;</p>
<p>(4) 到计算原串S1的3号位置（在之前的步骤中能匹配到的最远的位置+1,即发生匹配失败的位置），这种情况下，我们会回到步骤（1）的方式，从原串S1的3号位置开始和模式串的0号位置开始，进行逐一匹配，直到匹配失败，此时的extend[]值即为它的匹配长度。因为S1[3] ≠S2[0],匹配失败，匹配长度为0，即extend[3]=0;</p>
<p>(5) 计算S1的4号位置extend[]。由于原串S1的4号位置也是未匹配过的，我们也是回到步骤（1）的方式，从原串S1的4号位置开始和模式串S2的0号位置开始进行逐一匹配，可以看到，S1[4]=S2[0],S1[5]=S2[1],S1[6]=S2[2],S1[7]=S2[3],S1[8]=S2[4],S1[9] ≠S2[5],此时原串S1的9号位置发生匹配失败，最多能匹配到原串S1的8号位置，即S1[4,8]=S2[0,4],匹配长度为5，即extend[4]=5;</p>
<p>(6) 计算S1的5号位置extend[].由于原串S1的5号位置是匹配过的（在步骤（5）中匹配了），我们从extend[4]=5得出，S1[4,8]=S2[0,4],即S1[5,8]=S2[1,4],和步骤（2）的计算方式类似，我们从next[1]=4可知，S2[0,3]=S2[1,4],即S1[5,8]=S2[0,3],然后我们继续匹配原串S1的9号位置和S2的4号位置，S1[9]=S2[4],继续匹配，S1[10]=S2[5],此时原串S1的所有字符皆匹配完毕，皆大欢喜，则S1[5,10]=S2[0,5],extend[5]=6;</p>
<p>(7) 从原串S1的6号位置到10号位置的extend[]的计算，与原串S1的1号位置到3号位置的计算基本相同。S1[6,10]=S2[1,5],因为next[1]=4，所以S2[1,4]=S[0,3],所以S1[6,9]=S2[0,3],此时不在需要判断匹配下一位的字符了，直接extend[6]=4;(具体原因在后面的分析总结中有说明)</p>
<p>(8) S1[7,10]=S2[2,5],因为next[3]=2,所以S2[3,4]=S2[0,1],所以S1[8,9]=S2[0,1],匹配长度为2，即extend[7]=3;</p>
<p>(9) S1[8,10]=S2[3,5],因为next[3]=2,所以S2[3,4]=S2[0,1],所以S1[8,9]=S2[0,1],匹配长度为2，即extend[8]=2;</p>
<p>(10) S1[9,10]=S2[4,5],因为next[4]=1,所以S2[4,5]=S2[0,0],所以S1[9,9]=S2[0,0],匹配长度为1，即extend[9]=1;</p>
<p>(11) S1[10,10]=S2[5,5],因为next[5]=0,所以匹配长度为0，即extend[10]=0;</p>
<p>至此，所有的匹配已经结束，相信，如果你仔细的看了上述的例子，已经对扩展KMP有了一定的了解了，它的计算过程中，主要是步骤一和步骤二的计算过程。下面我们对这两个过程归纳一下：</p>
<p><img src="https://img-blog.csdn.net/20180522162729858?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMTYwNjA1/font/5a6L5L2T" alt="img"></p>
<p>我们可以得出，len=next[k+1-Po],S2[0,len-1]=S2[k+1-Po,k+Po+len],所以S1[k+1,k+len]=S2[k+1-Po,k+Po+len]=S2[0,len-1],即extend[k+1]=len;</p>
<p>那么会不会出现S1[k+len+1]=S2[len]的情况呢？答案是否定的</p>
<p>假如S1[k+len+1]=S2[len],则S1[k+1,k+len+1]=S2[0,len]</p>
<p>因为k+len&lt;P,所以k+len+1&lt;=P</p>
<p>所以S1[k+1,k+len+1]=S2[k+1-Po,k+Po+len+1]=S2[0,len]</p>
<p>此时，next[k+1-Po]=len+1与原假设不符合，所以此时S1[k+len+1]≠S2[len],不需要再次判断。</p>
<p>（2）当（k+1）+len-1=k+len&gt;=P时，即以下情况：</p>
<p><img src="https://img-blog.csdn.net/20180522162806418?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMTYwNjA1" alt="img"></p>
<p>我们可以看出，由S1[Po,P]=S2[0,P-Po]可得出S1[k+1,P]=S2[k+1-Po,P-po]，len=next[k+1-Po],所以S2[0,len-1]=S2[k+1-Po,k+len+Po]</p>
<p>所以S1[k+1,p]=S2[0,P-k-1]</p>
<p>由于大于P的位置我们还未进行匹配，所以从原串S1的P+1位置开始和模式串的P-k位置开始进行逐一匹配，直到匹配失败，并更新相应的Po位置和最远匹配位置P,此时extend[k+1]=P-k+后来逐一匹配的匹配长度。</p>
<p>其实，next[]数组的计算过程与extend[]的计算过程基本一致，可以看成是原串S2和模式串S2的扩展KMP进行计算，每次计算extend[k+1]时，next[i](0&lt;=i&lt;=k)已经算出来了，算出extend[k+1]的时候，意味着next[k+1]=extend[k+1]也计算出来了。</p>
<p>时间复杂度分析</p>
<p>通过上面的算法可知，我们原串S1的每一个字符串只会进行一次匹配，extend[k+1]的计算可以通过之前extend<a href="0&lt;=i&lt;=k">i\</a>的值得出，由于需要用相同的方法对模式串S2进行一次预处理，所以扩展KMP的时间复杂度为O(l1+l2),其中，l1为原串S1的长度，l2为模式串S2的长度。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">getnext</span><span class="params">(<span class="built_in">string</span> T)</span>&#123;</span><br><span class="line">	<span class="type">int</span> len=T.size();</span><br><span class="line">	nex[<span class="number">0</span>]=len;</span><br><span class="line">	<span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(p+<span class="number">1</span>&lt;len &amp;&amp; T[p]==T[p+<span class="number">1</span>]) p++;  <span class="comment">//这里注意把边界写在前面</span></span><br><span class="line">	nex[<span class="number">1</span>]=p;</span><br><span class="line">	<span class="type">int</span> po=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;len;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i+nex[i-po]&lt;po+nex[po]) nex[i]=nex[i-po];  <span class="comment">//第一种情况，直接得到答案</span></span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="type">int</span> j=po+nex[po]-i;  </span><br><span class="line">			<span class="keyword">if</span>(j&lt;<span class="number">0</span>) j=<span class="number">0</span>;  <span class="comment">//超出已匹配的字符串长度，需要重新匹配</span></span><br><span class="line">			<span class="keyword">while</span>(i+j&lt;len &amp;&amp; T[i+j]==T[j]) j++;</span><br><span class="line">			nex[i]=j;</span><br><span class="line">			po=i;  <span class="comment">//长度超出，更新起始位置</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">extmp</span><span class="params">(<span class="built_in">string</span> S,<span class="built_in">string</span> T)</span>&#123;</span><br><span class="line">	<span class="type">int</span> len1=S.size(), len2=T.size();</span><br><span class="line">	getnext(T);</span><br><span class="line">	<span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(p&lt;len1 &amp;&amp; p&lt;len2 &amp;&amp; S[p]==T[p]) p++;  <span class="comment">//边界写到前面</span></span><br><span class="line">	ext[<span class="number">0</span>]=p;</span><br><span class="line">	<span class="type">int</span> po=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len1;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i+nex[i-po]&lt;po+ext[po]) ext[i]=nex[i-po];</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="type">int</span> j=po+ext[po]-i;</span><br><span class="line">			<span class="keyword">if</span>(j&lt;<span class="number">0</span>) j=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span>(i+j&lt;len1 &amp;&amp; j&lt;len2 &amp;&amp; T[j]==S[i+j]) j++;</span><br><span class="line">			ext[i]=j;</span><br><span class="line">			po=i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="武辰延的字符串"><a href="#武辰延的字符串" class="headerlink" title="武辰延的字符串"></a>武辰延的字符串</h2><p><a href="https://ac.nowcoder.com/acm/contest/9984/B">题目</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/20210407203054.png" alt="image-20210407203042725" style="zoom:50%;" /></p>
<p>可以用扩展KMP来做，将s2当作母串，对于s1和s1的公共前缀子串，每一个位置的extend值累加起来就是答案</p>
<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">string</span> S,T;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ext[<span class="number">110000</span>],nex[<span class="number">110000</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">getnext</span><span class="params">(<span class="built_in">string</span> T)</span>&#123;</span><br><span class="line">	<span class="type">int</span> len=T.size();</span><br><span class="line">	nex[<span class="number">0</span>]=len;</span><br><span class="line">	<span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(p+<span class="number">1</span>&lt;len &amp;&amp; T[p]==T[p+<span class="number">1</span>]) p++;</span><br><span class="line">	nex[<span class="number">1</span>]=p;</span><br><span class="line">	<span class="type">int</span> po=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;len;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i+nex[i-po]&lt;po+nex[po]) nex[i]=nex[i-po];</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="type">int</span> j=po+nex[po]-i;</span><br><span class="line">			<span class="keyword">if</span>(j&lt;<span class="number">0</span>) j=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span>(i+j&lt;len &amp;&amp; T[i+j]==T[j]) j++;</span><br><span class="line">			nex[i]=j;</span><br><span class="line">			po=i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">extmp</span><span class="params">(<span class="built_in">string</span> S,<span class="built_in">string</span> T)</span>&#123;</span><br><span class="line">	<span class="type">int</span> len1=S.size(), len2=T.size();</span><br><span class="line">	getnext(T);</span><br><span class="line">	<span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(p&lt;len1 &amp;&amp; p&lt;len2 &amp;&amp; S[p]==T[p]) p++;</span><br><span class="line">	ext[<span class="number">0</span>]=p;</span><br><span class="line">	<span class="type">int</span> po=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len1;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i+nex[i-po]&lt;po+ext[po]) ext[i]=nex[i-po];</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="type">int</span> j=po+ext[po]-i;</span><br><span class="line">			<span class="keyword">if</span>(j&lt;<span class="number">0</span>) j=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span>(i+j&lt;len1 &amp;&amp; j&lt;len2 &amp;&amp; T[j]==S[i+j]) j++;</span><br><span class="line">			ext[i]=j;</span><br><span class="line">			po=i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;T&gt;&gt;S;</span><br><span class="line">	extmp(S,T);</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> len1=T.size(),len2=S.size(),ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len1;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i&gt;=len2) <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span>(T[i]!=S[i]) <span class="keyword">break</span>;</span><br><span class="line">		ans+=ext[i+<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>最大回文子串</title>
    <url>/posts/8eeb6466.html</url>
    <content><![CDATA[<h1 id="马拉车算法-Manacher"><a href="#马拉车算法-Manacher" class="headerlink" title="马拉车算法(Manacher)"></a>马拉车算法(Manacher)</h1><p>:::success</p>
<p>解决的问题：</p>
<p>以O(n)时间求出一个字符串的最长回文子串长度</p>
<p>:::</p>
<h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><p>如果求最大回文子串，暴力做法是从一个点开始，每次向左和右同时延伸一个单位，比较是否相同，但是这种方式比较难受的是如果字符串长度是偶数，那么可能对称中心不在字符上，而在两个字符之间，如果还想使用上面的方法就必须让指针在字符之间停留一下，所以考虑在每一个字符之间以及开头结尾（开头结尾添加是要让添加字符后的答案和未添加时的答案有一个对应关系）都添加相同的未出现的字符，这里用”#”表示，这样一来aba就变成了#a#b#a#，这样一来无论原串的长度为奇或偶转化后的字符串长度永远是奇数(2*l+1)，这时会发现添加后的字符串找出来的最长回文子串长度永远等于原串的最长回文子串长度+1（无论原串长度为奇数或偶数），所以对改变后的字符串求解的答案-1就是答案。</p>
<p>引入Len数组表示一个字符向左或向右可延伸的最长回文长度，比如aba，那么Len[1]=2（ab）</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/20210409161413.png" alt="image-20210409161400175" style="zoom:50%;" /></p>
<p>当求Len[i]时Len[i_mirror]是已知的，又因为黑色区域都是回文的，所以Len[i]=min(Len[i_mirror],mx-i)，之所以要和mx-i取一个较小的是因为可能左边的Len比较大，而对于当前位置的i+Len[i]超过了mx就会造成答案错误，因为mx右面的都还没有匹配过</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> <span class="title function_">process</span><span class="params">(<span class="built_in">string</span> s)</span>&#123;</span><br><span class="line">	<span class="type">int</span> len=s.size();</span><br><span class="line">	<span class="built_in">string</span> ret;</span><br><span class="line">	ret+=<span class="string">&quot;^&quot;</span>;  <span class="comment">//开头加上当前字符中没有的字符，而且开头的字符不能和结尾的字符相同，这是因为不能增加可匹配的回文长度（会改变答案） </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">		ret+=<span class="string">&quot;#&quot;</span>;</span><br><span class="line">		ret+=s[i];</span><br><span class="line">	&#125;</span><br><span class="line">	ret+=<span class="string">&quot;#$&quot;</span>;  <span class="comment">//结尾加上和开头不一样的字符 </span></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">manacher</span><span class="params">(<span class="built_in">string</span> s)</span>&#123;</span><br><span class="line">	s=process(s);  <span class="comment">//加上特殊字符，使得字符数量变成奇数 </span></span><br><span class="line">	<span class="type">int</span> c=<span class="number">0</span>,mx=<span class="number">0</span>,len=s.size(),sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i&lt;mx) Len[i]=min(mx-i,Len[<span class="number">2</span>*c-i]);  <span class="comment">//2*c-i就是关于c的对称点 ，之所以取min是因为可能左边的Leni比较大，</span></span><br><span class="line">											  <span class="comment">//这个点如果向右延伸这么长就超出mx了，而mx右面的位置都是没有匹配的，不确定是否可以组成回文 </span></span><br><span class="line">		<span class="keyword">else</span> Len[i]=<span class="number">1</span>;  <span class="comment">//如果当前位置已经超出最大的匹配范围了，就设置为1（当前字符就算一个回文） </span></span><br><span class="line">		<span class="keyword">while</span>(s[i+Len[i]]==s[i-Len[i]]) Len[i]++;  <span class="comment">//从当前点进行暴力匹配查看当前点可以延伸的最大长度 </span></span><br><span class="line">		<span class="keyword">if</span>(i+Len[i]&gt;mx)&#123;  <span class="comment">//如果超出了最大可延伸长度则更新 </span></span><br><span class="line">			c=i;  <span class="comment">//更新对称中心 </span></span><br><span class="line">			mx=i+Len[i];  <span class="comment">//更新最大延伸长度 </span></span><br><span class="line">			sum=max(sum,Len[i]);  <span class="comment">//更新答案 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum<span class="number">-1</span>;  <span class="comment">//答案要减1，无论奇偶转换后的字符串求得的最大回文长度都是答案减1，可以手推一下，很简单的 </span></span><br><span class="line">	<span class="comment">//aba (#a#b#a#)</span></span><br><span class="line">	<span class="comment">//abba (#a#b#b#a#)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="延伸求最大回文子串长什么样"><a href="#延伸求最大回文子串长什么样" class="headerlink" title="延伸求最大回文子串长什么样"></a>延伸求最大回文子串长什么样</h2><p>既然有了最大回文子串的长度，也可以计算出匹配到最大长度时的对称中心下标，那么只要找到原串和处理过的字符串的下标对应关系就可以求出max回文子串长啥样了，经过模拟发现j=2(i+1)(j:处理过的下标)，i-Len[i]+2是匹配到的最长回文子串的开头字符的下标，所以可以求得最大回文子串</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改此处即可</span></span><br><span class="line"><span class="keyword">if</span>(Len[i]&gt;sum)&#123;</span><br><span class="line">    sum=Len[i];</span><br><span class="line">    st=(i-Len[i]+<span class="number">2</span>)/<span class="number">2</span><span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> bk.substr(st,sum<span class="number">-1</span>);  <span class="comment">//答案要减1，无论奇偶转换后的字符串求得的最大回文长度都是答案减1，可以手推一下，很简单的 </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Manacher</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/posts/0.html</url>
    <content><![CDATA[<h1 id="树链剖分"><a href="#树链剖分" class="headerlink" title="树链剖分"></a>树链剖分</h1><blockquote>
<p>求解问题：在树上进行区间修改区间查询问题，求lca问题，维护路径信息</p>
<p>主要思想：将树上的点分割成一条一条的链，每一条链的第一个点是链头(父亲)，利用dfs序按照链优先的思想加上序号，这样每一条链上面的序号都是连续的，就把树上的点映射到了一条数轴上</p>
<p>时复：找到父亲，重子节点，子树大小（dfs1）O(N)，进行一次dfs序(dfs2 O(N))，每一条路径都能被分割成最多log2n条链，因此链头数量不超过log2n，每次求lca时复logn</p>
</blockquote>
<h2 id="重链剖分"><a href="#重链剖分" class="headerlink" title="重链剖分"></a>重链剖分</h2><blockquote>
<p>dfn数组: 每一个点映射到链上的标号</p>
<p>rnk数组: 每一个标号对应点的编号 (rnk[dfn[x]]=x)</p>
<p>dep数组: 每一个节点的深度</p>
<p>fa数组: 节点父亲</p>
<p>siz数组: 子树大小</p>
<p>son数组: 重孩子</p>
<p>top数组: 节点在链上链头的编号</p>
<p>以上7个数组是树链剖分的几个必要数组，根据题目不同会使用上面的某几个数组</p>
</blockquote>
<p>定义：</p>
<ol>
<li>重子节点是子树节点最多的那棵树的根节点，如果有多个随意取出一个即可</li>
<li>剩下的非重子节点的点都是轻子节点</li>
<li>从当前节点到重子节点的边是重边</li>
<li>从当前节点到轻子节点的边是轻边</li>
<li>若干条首尾相连的重边称为重链，所有落单的点也当作重链</li>
</ol>
<p><img src="https://oi-wiki.org/graph/images/hld.png" alt="HLD" style="zoom:50%;" /></p>
<p>利用以上定义可以将一棵树分成若干条链，这些链上的dfs序号是连续的</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">dfs1</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">	siz[x]=<span class="number">1</span>;  <span class="comment">//当前子树大小为1</span></span><br><span class="line">    son[x]=<span class="number">-1</span>;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];~i;i=e[i].next)&#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(v==fa[x]) <span class="keyword">continue</span>;</span><br><span class="line">        fa[v]=x;  <span class="comment">//深搜之前一定要更新父亲</span></span><br><span class="line">        dep[v]=dep[x]+<span class="number">1</span>;  <span class="comment">//往下深搜之前一定要先把深度给更新了</span></span><br><span class="line">        dfs1(v);</span><br><span class="line">        siz[x]=siz[v]+<span class="number">1</span>;  <span class="comment">//深搜过后才能更新子树大小</span></span><br><span class="line">        <span class="keyword">if</span>(son[x]==<span class="number">-1</span> || siz[son[x]]&lt;siz[v]) son[x]=v;  <span class="comment">//找到重子节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> t)</span>&#123;</span><br><span class="line">	top[x]=t;  <span class="comment">//这条链的链头</span></span><br><span class="line">    cnt++;  <span class="comment">//dfs序加一</span></span><br><span class="line">    dfn[x]=cnt;  <span class="comment">//给节点标上dfs序</span></span><br><span class="line">    rnk[cnt]=x;  <span class="comment">//返回dfs序对应的节点</span></span><br><span class="line">    <span class="keyword">if</span>(son[x]==<span class="number">-1</span>) <span class="keyword">return</span> ;</span><br><span class="line">    dfs2(son[x],t);  <span class="comment">//优先遍历重子节点，到重子节点的边都是重链，所以链头不变</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];~i;i=e[i].next)&#123;</span><br><span class="line">		<span class="type">int</span> v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(v==fa[x] || v==son[x]) <span class="keyword">continue</span>;</span><br><span class="line">        dfs2(v,v);  <span class="comment">//到轻子节点，链头要变化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="树上单点修改区间查询"><a href="#树上单点修改区间查询" class="headerlink" title="树上单点修改区间查询"></a>树上单点修改区间查询</h2><p>求两个点的区间值时，在找lca的过程中保存信息，最后输出答案即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#pragma G++ optimize(2)</span></span><br><span class="line"><span class="comment">//#pragma G++ optimize(3,&quot;Ofast&quot;,&quot;inline&quot;)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SUB=<span class="number">-0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-4</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> E=<span class="built_in">exp</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> to,next;</span><br><span class="line">&#125;e[MAXN];</span><br><span class="line"><span class="type">int</span> head[MAXN],w[MAXN];</span><br><span class="line"><span class="type">int</span> tot;</span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span>&#123;</span><br><span class="line">	e[tot]=&#123;v,head[u]&#125;;</span><br><span class="line">	head[u]=tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,a,b,q;</span><br><span class="line"><span class="type">int</span> dfn[MAXN],siz[MAXN],dep[MAXN],fa[MAXN];</span><br><span class="line"><span class="type">int</span> son[MAXN],top[MAXN],rnk[MAXN];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> las)</span>&#123; <span class="comment">//求出dep、son、siz、fa</span></span><br><span class="line">	son[x]=<span class="number">-1</span>;</span><br><span class="line">	siz[x]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[x];~i;i=e[i].next)&#123;</span><br><span class="line">		<span class="type">int</span> v=e[i].to;</span><br><span class="line">		<span class="keyword">if</span>(v==las) <span class="keyword">continue</span>;</span><br><span class="line">		fa[v]=x;</span><br><span class="line">		dep[v]=dep[x]+<span class="number">1</span>;</span><br><span class="line">		dfs(v,x);</span><br><span class="line">		siz[x]+=siz[v];</span><br><span class="line">		<span class="keyword">if</span>(son[x]==<span class="number">-1</span> || siz[v]&gt;siz[son[x]]) son[x]=v;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> t)</span>&#123; <span class="comment">//求出dfn、rnk、top</span></span><br><span class="line">	++cnt;</span><br><span class="line">	dfn[x]=cnt;</span><br><span class="line">	rnk[cnt]=x;</span><br><span class="line">	top[x]=t;</span><br><span class="line">	<span class="keyword">if</span>(son[x]!=<span class="number">-1</span>) dfs2(son[x],t);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[x];~i;i=e[i].next)&#123;</span><br><span class="line">		<span class="type">int</span> v=e[i].to;</span><br><span class="line">		<span class="keyword">if</span>(v==fa[x] || v==son[x]) <span class="keyword">continue</span>;</span><br><span class="line">		dfs2(v,v);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lson (u&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rson (u&lt;&lt;1|1)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> l,r,mx,sum;</span><br><span class="line">&#125;tr[MAXN&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">pushup</span><span class="params">(<span class="type">int</span> u)</span>&#123;</span><br><span class="line">	tr[u].mx=max(tr[lson].mx,tr[rson].mx);</span><br><span class="line">	tr[u].sum=tr[lson].sum+tr[rson].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">		tr[u]=&#123;l,r,w[rnk[l]],w[rnk[l]]&#125;;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	tr[u]=&#123;l,r&#125;;</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	build(lson,l,mid);</span><br><span class="line">	build(rson,mid+<span class="number">1</span>,r);</span><br><span class="line">	pushup(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pos,<span class="type">int</span> val)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(tr[u].l==tr[u].r)&#123;</span><br><span class="line">		tr[u].mx=val;</span><br><span class="line">		tr[u].sum=val;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid=tr[u].l+tr[u].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(pos&lt;=mid) update(lson,pos,val);</span><br><span class="line">	<span class="keyword">else</span> update(rson,pos,val);</span><br><span class="line">	pushup(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">qmax</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> ql,<span class="type">int</span> qr)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(tr[u].l&gt;=ql &amp;&amp; tr[u].r&lt;=qr) <span class="keyword">return</span> tr[u].mx;</span><br><span class="line">	<span class="type">int</span> ret=-INF;</span><br><span class="line">	<span class="type">int</span> mid=tr[u].l+tr[u].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(ql&lt;=mid) ret=max(ret,qmax(lson,ql,qr));</span><br><span class="line">	<span class="keyword">if</span>(mid+<span class="number">1</span>&lt;=qr) ret=max(ret,qmax(rson,ql,qr));</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">query_mx</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">	<span class="type">int</span> l=x,r=y;</span><br><span class="line">	<span class="type">int</span> ret=-INF;</span><br><span class="line">	<span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">		<span class="keyword">if</span>(dep[top[x]]&gt;dep[top[y]])&#123;</span><br><span class="line">			ret=max(ret,qmax(<span class="number">1</span>,dfn[top[x]],dfn[x]));</span><br><span class="line">			x=fa[top[x]];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			ret=max(ret,qmax(<span class="number">1</span>,dfn[top[y]],dfn[y]));</span><br><span class="line">			y=fa[top[y]];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(dfn[x]&gt;dfn[y]) ret=max(ret,qmax(<span class="number">1</span>,dfn[y],dfn[x]));</span><br><span class="line">	<span class="keyword">else</span> ret=max(ret,qmax(<span class="number">1</span>,dfn[x],dfn[y]));</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">qsum</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> ql,<span class="type">int</span> qr)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(tr[u].l&gt;=ql &amp;&amp; tr[u].r&lt;=qr) <span class="keyword">return</span> tr[u].sum;</span><br><span class="line">	<span class="type">int</span> ret=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> mid=tr[u].l+tr[u].r&gt;&gt;<span class="number">1</span>; </span><br><span class="line">	<span class="keyword">if</span>(ql&lt;=mid) ret+=qsum(lson,ql,qr);</span><br><span class="line">	<span class="keyword">if</span>(qr&gt;=mid+<span class="number">1</span>) ret+=qsum(rson,ql,qr);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">query_sum</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">	<span class="type">int</span> ret=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">		<span class="keyword">if</span>(dep[top[x]]&gt;dep[top[y]])&#123;</span><br><span class="line">			ret+=qsum(<span class="number">1</span>,dfn[top[x]],dfn[x]);</span><br><span class="line">			x=fa[top[x]];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			ret+=qsum(<span class="number">1</span>,dfn[top[y]],dfn[y]);</span><br><span class="line">			y=fa[top[y]];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(dfn[x]&gt;dfn[y]) ret+=qsum(<span class="number">1</span>,dfn[y],dfn[x]);</span><br><span class="line">	<span class="keyword">else</span> ret+=qsum(<span class="number">1</span>,dfn[x],dfn[y]);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="comment">// debug;</span></span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span> head);</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">		add(a,b);</span><br><span class="line">		add(b,a);</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">	dfs2(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;w[i];</span><br><span class="line">	build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">	<span class="comment">// cout&lt;&lt;tr[1].mx&lt;&lt;endl;</span></span><br><span class="line">	<span class="comment">// cout&lt;&lt;qmax(1,1,4)&lt;&lt;endl;</span></span><br><span class="line">	<span class="comment">// for(int i=1;i&lt;=n;i++) cout&lt;&lt;dfn[i]&lt;&lt;&quot; &quot;;</span></span><br><span class="line">	<span class="comment">// cout&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line">	<span class="comment">// for(int i=1;i&lt;=n;i++) cout&lt;&lt;son[i]&lt;&lt;&quot; &quot;;</span></span><br><span class="line">	<span class="comment">// cout&lt;&lt;endl;</span></span><br><span class="line">	<span class="comment">// for(int i=1;i&lt;=n;i++) cout&lt;&lt;dep[i]&lt;&lt;&quot; &quot;;</span></span><br><span class="line">	<span class="comment">// cout&lt;&lt;endl;</span></span><br><span class="line">	<span class="comment">// for(int i=1;i&lt;=n;i++) cout&lt;&lt;rnk[i]&lt;&lt;&quot; &quot;;</span></span><br><span class="line">	<span class="comment">// cout&lt;&lt;endl;</span></span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;q;</span><br><span class="line">	<span class="keyword">while</span>(q--)&#123;</span><br><span class="line">		<span class="built_in">string</span> s;</span><br><span class="line">		<span class="type">int</span> u,v;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;s&gt;&gt;u&gt;&gt;v;</span><br><span class="line">		<span class="keyword">if</span>(s==<span class="string">&quot;CHANGE&quot;</span>) update(<span class="number">1</span>,dfn[u],v);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(s==<span class="string">&quot;QMAX&quot;</span>) <span class="built_in">cout</span>&lt;&lt;query_mx(<span class="number">1</span>,u,v)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;query_sum(<span class="number">1</span>,u,v)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="comment">// if(u==3 &amp;&amp; v==6) cout&lt;&lt;qmax(1,3,4)&lt;&lt;&quot;ss&quot;&lt;&lt;endl;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title>爬取唯美图片</title>
    <url>/posts/add36e4f.html</url>
    <content><![CDATA[<blockquote>
<p>通过Beautiful定位标签，获取图片链接，仅限于图片直接内嵌于网页源代码中，有的网站图片链接藏在js文件，无法爬取</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#爬取umei.cc中的图片</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">domain = <span class="string">&quot;https://umei.cc/katongdongman/dongmantupian/&quot;</span> <span class="comment">#网站地址</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.45 Safari/537.36&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">res = requests.get(domain, headers=headers)</span><br><span class="line">res.encoding = <span class="string">&#x27;utf-8&#x27;</span>  <span class="comment">#防止中文乱码</span></span><br><span class="line">content = res.text  <span class="comment">#获取源代码</span></span><br><span class="line"></span><br><span class="line">mainPage = BeautifulSoup(content, <span class="string">&quot;html.parser&quot;</span>)    <span class="comment">#创建Beautiful对象，说明其使用的语言</span></span><br><span class="line">img_list = mainPage.find(<span class="string">&quot;div&quot;</span>, class_=<span class="string">&quot;TypeList&quot;</span>).find_all(<span class="string">&quot;img&quot;</span>)  <span class="comment">#找到class=&quot;TypeList&quot;的div标签包裹的所有img标签</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> img <span class="keyword">in</span> img_list:    <span class="comment">#遍历这些img标签</span></span><br><span class="line">    img_scr = img.get(<span class="string">&quot;src&quot;</span>)    <span class="comment">#获取其中的src属性值</span></span><br><span class="line">    <span class="comment"># print(img_name)</span></span><br><span class="line">    imgName = <span class="string">&quot;img/&#123;&#125;&quot;</span>.<span class="built_in">format</span>(img_scr.split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">1</span>])   <span class="comment">#获取图片名称</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(imgName, mode=<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:  <span class="comment">#打开文件</span></span><br><span class="line">        f.write(requests.get(img_scr).content)  <span class="comment">#写入二进制码</span></span><br><span class="line">    f.close()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;over&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;all over!&quot;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P1069-细胞分裂</title>
    <url>/posts/4ac79732.html</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1069">题目链接</a></p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/20210225153205.png" alt="image-20210225153142932" style="zoom:67%;" /></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>有n种不同数量的细胞，每一个细胞每一秒都会分裂出一个新的，现在要把某一种细胞平均分到m1^m2^个容器里面，问选一种细胞，使得等待的时间最短，如果无法均分到容器中，就输出-1</p>
<h2 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h2><p>要均分就表示Si^t^%m1^m2^==0求t的最小值，看一下数据范围发现m1比较小，而Si很大，分别对Si和m1分解质因子，只要m1中的每一个质因子Si中都有，那么Si就可以通过分裂均分到m1^m2^中，因此不需要把Si的所有质因子都找到，只需要找到小于等于m1的所有质因子即可，因此时间复杂度就是n*3e3就是3e7，对于m1和Si共有的质因子需要满足pi*t&gt;=pm1*m2，要让满足条件的t最小就是取所有共有质因子的最大比值，然后所有比值中取最小</p>
<h2 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SUB=<span class="number">-0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> eps=<span class="number">1e-4</span>;</span><br><span class="line"><span class="type">int</span> tail,pr[MAXN/<span class="number">10</span>];</span><br><span class="line"><span class="type">bool</span> np[MAXN];</span><br><span class="line"><span class="type">void</span> <span class="title function_">ol</span><span class="params">()</span>&#123;</span><br><span class="line">	np[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">1000000</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!np[i]) pr[++tail]=i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=tail &amp;&amp; pr[j]&lt;=<span class="number">1000000</span>/i;j++)&#123;</span><br><span class="line">			np[i*pr[j]]=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(i%pr[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span> n,m1,m2;</span><br><span class="line"><span class="type">int</span> S[MAXN],z1[MAXN],z2[MAXN];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	ios;</span><br><span class="line">	ol();</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m1&gt;&gt;m2;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;S[i];</span><br><span class="line">	<span class="keyword">if</span>(m1==<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tail &amp;&amp; pr[i]&lt;=m1/pr[i];i++)&#123;</span><br><span class="line">		<span class="keyword">while</span>(m1%pr[i]==<span class="number">0</span>)&#123;</span><br><span class="line">			z1[pr[i]]+=m2;</span><br><span class="line">			m1/=pr[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(m1&gt;<span class="number">1</span>) z1[m1]+=m2;</span><br><span class="line">	<span class="type">int</span> ans=INF;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(z2,<span class="number">0</span>,<span class="keyword">sizeof</span> z2);</span><br><span class="line">		<span class="type">int</span> bk=S[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=tail &amp;&amp; pr[j]&lt;=S[i]/pr[j];j++)&#123;</span><br><span class="line">			<span class="keyword">while</span>(S[i]%pr[j]==<span class="number">0</span>)&#123;</span><br><span class="line">				z2[pr[j]]++;</span><br><span class="line">				S[i]/=pr[j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(S[i]&gt;<span class="number">1</span> &amp;&amp; S[i]&lt;=<span class="number">30000</span>) z2[S[i]]++;</span><br><span class="line">		<span class="type">int</span> flag=<span class="number">0</span>,mx=<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=tail;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(z1[pr[j]] &amp;&amp; !z2[pr[j]])&#123;</span><br><span class="line">				flag=<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(z1[pr[j]] &amp;&amp; z2[pr[j]]) mx=max(mx,(z1[pr[j]]<span class="number">-1</span>)/z2[pr[j]]+<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!flag) ans=min(ans,mx);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(ans!=INF) <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>质因子分解</tag>
      </tags>
  </entry>
  <entry>
    <title>爬取豆瓣Top250电影信息</title>
    <url>/posts/e15caf4c.html</url>
    <content><![CDATA[<blockquote>
<p>使用了request、re(正则)、csv模块</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#爬取豆瓣Top250的电影名称，评分，导演与演员</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;https://movie.douban.com/top250&quot;</span> <span class="comment">#豆瓣链接</span></span><br><span class="line">headers = &#123;     <span class="comment"># headers，伪装浏览器访问</span></span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>:<span class="string">&quot;: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.45 Safari/537.36&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">obj = re.<span class="built_in">compile</span>(<span class="string">r&#x27;&lt;li&gt;.*?&lt;span class=&quot;title&quot;&gt;(?P&lt;name&gt;.*?)&lt;/span&gt;.*?&#x27;</span>  <span class="comment"># 正则预编译查找模式</span></span><br><span class="line">                 <span class="string">r&#x27;&lt;p class=&quot;&quot;&gt;(?P&lt;actors&gt;.*?)&lt;/p&gt;.*?&#x27;</span></span><br><span class="line">                 <span class="string">r&#x27;&lt;span class=&quot;rating_num&quot; property=&quot;v:average&quot;&gt;(?P&lt;score&gt;.*?)&lt;/span&gt;.*?&#x27;</span>, re.S)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;peaTop250.csv&quot;</span>, mode=<span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:    <span class="comment"># 以utf-8编码打开csv文件</span></span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>(num&lt;<span class="number">250</span>):     <span class="comment"># 爬取每一个页面的信息</span></span><br><span class="line">        URL = url + <span class="string">&quot;?start=&#123;&#125;&amp;filter=&quot;</span>.<span class="built_in">format</span>(num)     <span class="comment">#更改页面地址</span></span><br><span class="line">        <span class="built_in">print</span>(URL)</span><br><span class="line">        content = requests.get(url=URL, headers=headers).text   <span class="comment">#得到页面源代码</span></span><br><span class="line">        res = obj.finditer(content)     <span class="comment">#按照预编译好的规则查找响应的值，并储存到一个迭代器中，存储类型为字典</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> res:</span><br><span class="line">            f.write(<span class="string">&quot;作者:&quot;</span> + i.group(<span class="string">&quot;name&quot;</span>) + <span class="string">&quot;\n&quot;</span>) <span class="comment">#写到csv中</span></span><br><span class="line">            f.write(i.group(<span class="string">&quot;actors&quot;</span>).replace(<span class="string">&quot; &quot;</span>,<span class="string">&#x27;&#x27;</span>).replace(<span class="string">&#x27;\n&#x27;</span>,<span class="string">&#x27;&#x27;</span>).replace(<span class="string">&quot;&amp;nbsp&quot;</span>,<span class="string">&#x27; &#x27;</span>) + <span class="string">&quot;\n&quot;</span>) <span class="comment">#把字符串中的空格回车消除和&amp;nbsp转化为空格</span></span><br><span class="line">            f.write(<span class="string">&quot;评分:&quot;</span> + i.group(<span class="string">&quot;score&quot;</span>) + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        num+=<span class="number">25</span></span><br><span class="line"></span><br><span class="line">f.close()   <span class="comment">#关闭文件</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;over&quot;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客小白月赛29</title>
    <url>/posts/f1b375ae.html</url>
    <content><![CDATA[<h2 id="B-二进制"><a href="#B-二进制" class="headerlink" title="B 二进制"></a>B 二进制</h2><p>题目链接: <a href="https://ac.nowcoder.com/acm/contest/8564/B">https://ac.nowcoder.com/acm/contest/8564/B</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/20210221185349.png" alt="image-20210221185340310" style="zoom: 50%;" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/20210221185433.png" alt="image-20210221185431834" style="zoom:50%;" /></p>
<p>单纯与或者单纯或单纯异或都支持交换律，但是他们放在一起就不支持交换律了，比如1先和0与再和1或结果是1，但是1先和1或再和0与结果就不一样，可以设两个数，一个所有位都是0，一个所有位都是1，把这两个分别进行上述操作，最后得出来的结果按位对比，如果0变成了1且1变成了0则这个位肯定是异或1，如果0变成0且1变成0则这一位是与0，如果0变成1且1变成1这一位肯定是或1，按照这个规律可以求出这个数，任何一个数与1或0异或0都不变，所以可以设置三个数，一个全设为1，另外两个全设为0，当这个位是与0时，就用全为1的变量减去(1&lt;&lt;i)这一位上的数，另外两个同理</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SUB=<span class="number">-0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> eps=<span class="number">1e-4</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a=<span class="number">0</span>,b=(<span class="number">1</span>&lt;&lt;<span class="number">20</span>)<span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="type">int</span> op,v;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;op&gt;&gt;v;</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">			a&amp;=v;</span><br><span class="line">			b&amp;=v;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>)&#123;</span><br><span class="line">			a|=v;</span><br><span class="line">			b|=v;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			a^=v;</span><br><span class="line">			b^=v;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> yu=(<span class="number">1</span>&lt;&lt;<span class="number">20</span>)<span class="number">-1</span>,huo=<span class="number">0</span>,yihuo=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>( (a&gt;&gt;i)&amp;<span class="number">1</span> )&#123;</span><br><span class="line">			<span class="keyword">if</span>((b&gt;&gt;i)&amp;<span class="number">1</span>) huo+=(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">			<span class="keyword">else</span> yihuo+=(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(!((b&gt;&gt;i)&amp;<span class="number">1</span>)) yu-=(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="number">3</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;yu&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="number">2</span>&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;huo&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="number">3</span>&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;yihuo&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>题目</tag>
      </tags>
  </entry>
  <entry>
    <title>种类并查集</title>
    <url>/posts/7bf7b6ec.html</url>
    <content><![CDATA[<p>种类并查集可以解决多种关系的问题，比如两个人不是朋友的关系，其思想是多开几倍的空间，假如有n种关系，就开n倍的空间，然后用+n来表示两个不同集合的关系</p>
<h2 id="食物链P2024"><a href="#食物链P2024" class="headerlink" title="食物链P2024"></a>食物链P2024</h2><p>链接：<a href="https://www.luogu.com.cn/problem/P2024">https://www.luogu.com.cn/problem/P2024</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/20210225222508212.png" alt="20210225222508212"></p>
<p>开3倍空间维护3个集合，分别表示A、B、C，例如1和2是朋友，那就把3个集合中的1和2合并，1吃2，就把A集合中1和B集合中的2合并，B集合中的1和C集合的2合并，C集合的1和A集合的2合并，再来一个2吃3，这样一来C中的3和A中的1也在一个集合里了，维护了C吃A的关系，也就是如果Ai和Bj的祖先相同就表示Ai吃Bj，另外两个同理</p>
<h2 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">20010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SUB=<span class="number">-0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> eps=<span class="number">1e-4</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> u,v,w;</span><br><span class="line">&#125;arr[MAXN];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> fa[MAXN*<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==fa[x]) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> fa[x]=find(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">remerge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">	<span class="type">int</span> fx=find(x),fy=find(y);</span><br><span class="line">	<span class="keyword">if</span>(fx!=fy) fa[fx]=fy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">cmp</span><span class="params">(node a,node b)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.w&gt;b.w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">cin</span>&gt;&gt;arr[i].u&gt;&gt;arr[i].v&gt;&gt;arr[i].w;</span><br><span class="line">	sort(arr+<span class="number">1</span>,arr+<span class="number">1</span>+m,cmp);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++) fa[i]=i;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="type">int</span> x=arr[i].u,y=arr[i].v;</span><br><span class="line">		<span class="keyword">if</span>(find(x)==find(y) || find(x+n)==find(y+n))&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;arr[i].w&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		remerge(x+n,y);</span><br><span class="line">        remerge(x,y+n);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>种类并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>类的加载</title>
    <url>/posts/807bd2a4.html</url>
    <content><![CDATA[<h1 id="Class文件结构"><a href="#Class文件结构" class="headerlink" title="Class文件结构"></a>Class文件结构</h1><ol>
<li>魔数(Magic Number)</li>
<li>Class 文件版本号</li>
<li>常量池(Constant Pool)</li>
<li>访问标志(Access Flags)</li>
<li>当前类(This Class)、父类(…</li>
<li>字段表集合(Fields)</li>
<li>方法表集合(Methods)</li>
<li>属性表集合(Attributes</li>
</ol>
<h1 id="OOP-KLASS"><a href="#OOP-KLASS" class="headerlink" title="OOP-KLASS"></a>OOP-KLASS</h1><p>HotSpot采用Oop-Klass模型来表示Java对象。其中Klass对应着Java对象的类型，就是方法区存储的元数据结构体，用C语言的结构体表示，如类的继承关系、方法表、字段表、常量池等。而Oop则对应着Java对象的实例（Instance）。</p>
<p>Oop是一个继承体系，其中<code>oop</code>是体系中的最高父类。这里的<strong>Oop</strong>并非是Object-oriented programming，而是<strong>Ordinary object pointer</strong>（普通对象指针），是HotSpot用来表示Java对象的实例信息的一个体系。其中<code>oop</code>是Oop体系中的最高父类，整个继承体系如下所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/v2-200ae7e6a744adae705bb7b01977211b_1440w.jpg" alt="OOP继承体系"></p>
<p><code>oop</code>的子类有两个，分别是<code>instanceOop</code>和<code>arrayOop</code>。前者表示Java中普通的对象，后者则表示数组对象。<code>arrayOop</code>也有两个子类，<code>objArrayOop</code>表示普通对象类型的数组，而<code>typeArrayOopDesc</code>则表示基础类型的数组。如下图所示，<code>oop</code>的存储结构主要由对象头和对象体组成。</p>
<p>Oop的存储结构可以分成对象头和对象体，对象头主要由两部分组成，一部分是 <strong>Mark Word</strong>，另一部分包括 <strong>Klass 指针</strong>，还可能包含<strong>数组长度（针对数组对象）</strong>。 Mark Word 用于存储对象的一些运行时数据，如哈希码、分代年龄、锁状态等信息，对象体存储的是具体的成员属性。值得注意的是，<strong>如果成员属性属于普通对象类型，则<code>oop</code>只存储它的地址</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/v2-81b315e29d4bf91f127fe2881e1c3d79_1440w.jpg" alt="成员属性属于对象类型"></p>
<p>代码中通过对象实例调用方法，JVM如何找到这个方法的定义然后执行呢？通过下图即可知道答案，通过栈帧的局部变量表中存储的对象引用，从堆中找到相应的Java对象实例，对象头中维护了指向Klass结构的指针，指向方法区该类型的InstanceKlass，其中包含了该类的定义，就是Class文件中的定义加载到JVM后的结构表示，其中还维护了一个指向Class对象的指针，Class对象存储在堆中，除了类的定义信息，还添加了例如<code>getName</code>、<code>getSimpleName</code>、<code>getModifiers</code>等方法，方便对类的操作。<strong>注意：下图只是示意图，描述并不完整。</strong></p>
<p> <img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/image-20250227110657806.png" alt="OOP-KLASS"></p>
<h1 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h1><p>类从被加载到虚拟机内存中开始到卸载出内存为止，它的整个生命周期可以简单概括为 7 个阶段：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）。其中，验证、准备和解析这三个阶段可以统称为连接（Linking）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/lifecycle-of-a-class.png" alt="一个类的完整生命周期"></p>
<h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>类加载过程的第一步，主要完成下面 3 件事情：</p>
<ol>
<li>通过全类名获取定义此类的二进制字节流。</li>
<li>将字节流所代表的静态存储结构转换为<strong>方法区</strong>的运行时数据结构<code>InstanceKlass</code>。</li>
<li>在<strong>内存中</strong>生成一个代表该类的 <code>Class</code> 对象，作为方法区这些数据的访问入口。</li>
<li></li>
</ol>
<p>加载这一步主要是通过我们后面要讲到的 <strong>类加载器</strong> 完成的。类加载器有很多种，当我们想要加载一个类的时候，具体是哪个类加载器加载由 <strong>双亲委派模型</strong> 决定（不过，我们也能打破由双亲委派模型）。</p>
<p>每个 Java 类都有一个引用指向加载它的 <code>ClassLoader</code>。不过，数组类不是通过 <code>ClassLoader</code> 创建的，而是 JVM 在需要的时候自动创建的，数组类通过<code>getClassLoader()</code>方法获取 <code>ClassLoader</code> 的时候和该数组的元素类型的 <code>ClassLoader</code> 是一致的。</p>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p><strong>验证是连接阶段的第一步，这一阶段的目的是确保 Class 文件的字节流中包含的信息符合《Java 虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。</strong></p>
<p>验证阶段也不是必须要执行的阶段。如果程序运行的全部代码(包括自己编写的、第三方包中的、从外部加载的、动态生成的等所有代码)都已经被反复使用和验证过，在生产环境的实施阶段就可以考虑使用 <code>-Xverify:none</code> 参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。但是需要注意的是 <code>-Xverify:none</code> 和 <code>-noverify</code> 在 JDK 13 中被标记为 deprecated ，在未来版本的 JDK 中可能会被移除。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/class-loading-process-verification.png" alt="验证阶段示意图"></p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p><strong>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段</strong>。</p>
<p>这时候进行内存分配的仅包括类变量（ Class Variables ，即静态变量，被 <code>static</code> 关键字修饰的变量，只与类相关，因此被称为类变量），而不包括实例变量。实例变量会在对象实例化时随着对象一块分配在 Java 堆中。</p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p><strong>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</strong> 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符 7 类符号引用进行。</p>
<p>.符号引用(SymbolicReferences):符号引用以一组符号来描述所引用的目标，符号可以是任何只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引形式的字面量，用的目标并不一定是已经加载到虚拟机内存当中的内容。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在《Java虚拟机规范》的Class文件格式中。<br>·直接引用(DirectReferences):直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在。</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p><strong>初始化阶段是执行初始化方法 <code>&lt;clinit&gt; ()</code>方法的过程，是类加载的最后一步，这一步 JVM 才开始真正执行类中定义的 Java 程序代码(字节码)。</strong></p>
<blockquote>
<p> 说明：<code>&lt;clinit&gt; ()</code>方法是编译之后自动生成的。</p>
</blockquote>
<p>对于初始化阶段，虚拟机严格规范了有且只有 6 种情况下，必须对类进行初始化(只有主动去使用类才会初始化类)：</p>
<ol>
<li>当遇到 <code>new</code>、 <code>getstatic</code>、<code>putstatic</code> 或 <code>invokestatic</code> 这 4 条字节码指令时，比如 <code>new</code> 一个类，读取一个静态字段(未被 final 修饰)、或调用一个类的静态方法时。 <ul>
<li>当 jvm 执行 <code>new</code> 指令时会初始化类。即当程序创建一个类的实例对象。</li>
<li>当 jvm 执行 <code>getstatic</code> 指令时会初始化类。即程序访问类的静态变量(不是静态常量，常量会被加载到运行时常量池)。</li>
<li>当 jvm 执行 <code>putstatic</code> 指令时会初始化类。即程序给类的静态变量赋值。</li>
<li>当 jvm 执行 <code>invokestatic</code> 指令时会初始化类。即程序调用类的静态方法。</li>
</ul>
</li>
<li>使用 <code>java.lang.reflect</code> 包的方法对类进行反射调用时如 <code>Class.forName(&quot;...&quot;)</code>, <code>newInstance()</code> 等等。如果类没初始化，需要触发其初始化。</li>
<li>初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。</li>
<li>当虚拟机启动时，用户需要定义一个要执行的主类 (包含 <code>main</code> 方法的那个类)，虚拟机会先初始化这个类。</li>
<li><code>MethodHandle</code> 和 <code>VarHandle</code> 可以看作是轻量级的反射调用机制，而要想使用这 2 个调用，<br> 就必须先使用 <code>findStaticVarHandle</code> 来初始化要调用的类。</li>
<li><strong>「补充，来自<a href="https://github.com/Snailclimb/JavaGuide/issues/745">issue745</a>」</strong> 当一个接口中定义了 JDK8 新加入的默认方法（被 default 关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</li>
</ol>
<h2 id="类卸载"><a href="#类卸载" class="headerlink" title="类卸载"></a>类卸载</h2><blockquote>
<p>卸载这部分内容来自 <a href="https://github.com/Snailclimb/JavaGuide/issues/662">issue#662</a>由 <strong><a href="https://github.com/guang19">guang19</a></strong> 补充完善。</p>
</blockquote>
<p><strong>卸载类即该类的 Class 对象被 GC。</strong></p>
<p>卸载类需要满足 3 个要求:</p>
<ol>
<li>该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象。</li>
<li>该类没有在其他任何地方被引用</li>
<li>该类的类加载器的实例已被 GC</li>
</ol>
<p>所以，在 JVM 生命周期内，由 jvm 自带的类加载器加载的类是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。</p>
<p>只要想通一点就好了，JDK 自带的 <code>BootstrapClassLoader</code>, <code>ExtClassLoader</code>, <code>AppClassLoader</code> 负责加载 JDK 提供的类，所以它们(类加载器的实例)肯定不会被回收。而我们自定义的类加载器的实例是可以被回收的，所以使用我们自定义加载器加载的类是可以被卸载掉的。</p>
<h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><h2 id="重复加载问题"><a href="#重复加载问题" class="headerlink" title="重复加载问题"></a>重复加载问题</h2><p>假设有两个自定义类加载器 <code>ClassLoaderA</code> 和 <code>ClassLoaderB</code>，它们都可以独立加载类。现在有一个类 <code>MyClass</code>，<code>ClassLoaderA</code> 和 <code>ClassLoaderB</code> 都收到了加载 <code>MyClass</code> 的请求。由于没有双亲委派模型，它们不会将加载请求委派给父类加载器，而是各自去加载 <code>MyClass</code>，这样 <code>MyClass</code> 就会被重复加载。</p>
<h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>JVM 中内置了三个重要的 <code>ClassLoader</code>：</p>
<ol>
<li><strong><code>BootstrapClassLoader</code>(启动类加载器)</strong>：最顶层的加载类，由 C++实现，通常表示为 null，并且没有父级，主要用来加载 JDK 内部的核心类库（ <code>%JAVA_HOME%/lib</code>目录下的 <code>rt.jar</code>、<code>resources.jar</code>、<code>charsets.jar</code>等 jar 包和类）以及被 <code>-Xbootclasspath</code>参数指定的路径下的所有类。</li>
<li><strong><code>ExtensionClassLoader</code>(扩展类加载器)</strong>：主要负责加载 <code>%JRE_HOME%/lib/ext</code> 目录下的 jar 包和类以及被 <code>java.ext.dirs</code> 系统变量所指定的路径下的所有类。</li>
<li><strong><code>AppClassLoader</code>(应用程序类加载器)</strong>：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/img/class-loader-parents-delegation-model.png" alt="类加载器层次关系图"></p>
<p>Java 类加载器采用双亲委派模型，当一个类加载器收到类加载请求时，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都会传送到最顶层的启动类加载器。只有当父类加载器反馈自己无法完成该加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。</p>
<p>在这个过程中，类加载器会维护一个已加载类的列表，这个列表通常使用类的全限定名（包含包名的类名，如 <code>java.lang.String</code>）作为键来存储已经加载的类的信息。当收到一个类加载请求时，类加载器会首先检查这个列表，看请求加载的类的全限定名是否已经存在于列表中。</p>
<h2 id="打破双亲委派模型的办法"><a href="#打破双亲委派模型的办法" class="headerlink" title="打破双亲委派模型的办法"></a>打破双亲委派模型的办法</h2><p>自定义加载器的话，需要继承 <code>ClassLoader</code> 。如果我们不想打破双亲委派模型，就重写 <code>ClassLoader</code> 类中的 <code>findClass()</code> 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。但是，如果想打破双亲委派模型则需要重写 <code>loadClass()</code> 方法。</p>
<p>为什么是重写 <code>loadClass()</code> 方法打破双亲委派模型呢？双亲委派模型的执行流程已经解释了：</p>
<p>类加载器在进行类加载的时候，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成（调用父加载器 <code>loadClass()</code>方法来加载类）。</p>
<p>重写 <code>loadClass()</code>方法之后，我们就可以改变传统双亲委派模型的执行流程。例如，子类加载器可以在委派给父类加载器之前，先自己尝试加载这个类，或者在父类加载器返回之后，再尝试从其他地方加载这个类。具体的规则由我们自己实现，根据项目需求定制化。</p>
]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>类的加载过程</tag>
      </tags>
  </entry>
  <entry>
    <title>秋招-操作系统篇</title>
    <url>/posts/63753db4.html</url>
    <content><![CDATA[<h1 id="Unix"><a href="#Unix" class="headerlink" title="Unix"></a>Unix</h1><h2 id="什么叫一切皆文件"><a href="#什么叫一切皆文件" class="headerlink" title="什么叫一切皆文件"></a>什么叫一切皆文件</h2><p>这个是 Unix 的一个核心哲学，我给你拆开讲：</p>
<ol>
<li>“一切皆文件”是什么意思</li>
</ol>
<p>在 Unix 系统里，<strong>几乎所有东西都用“文件”这种统一接口来访问</strong>：</p>
<ul>
<li>普通文件：磁盘上的文本、二进制文件</li>
<li>目录：其实是存储文件名到 inode 的映射表</li>
<li>设备：键盘、显示器、硬盘、网卡都被抽象成“特殊文件”，放在 <code>/dev</code> 下</li>
<li>管道、FIFO、Socket：进程间通信对象，也以文件描述符的方式访问</li>
<li>甚至内核接口：比如 <code>/proc</code>、<code>/sys</code> 里的伪文件，用来读取系统信息</li>
</ul>
<p>所以用户态只需要 <code>open() / read() / write() / close()</code> 这一套 API，就能操作各种资源，而不用关心底层差异。</p>
<ol>
<li>为什么要这样设计</li>
</ol>
<p><strong>核心是抽象统一性</strong>：</p>
<ol>
<li><strong>简化接口</strong>：程序员不需要学习 N 套 API，读写磁盘和读写串口本质上没区别。</li>
<li><strong>提高可移植性</strong>：应用只依赖标准文件 API，不管硬件怎么变，内核保证兼容。</li>
<li><strong>增强组合性</strong>：因为统一成“文件”，就能用管道把命令组合起来（<code>ls | grep txt | wc -l</code>），这就是 Unix 强大的“工具拼装哲学”。</li>
<li>一个例子 🌰</li>
</ol>
<ul>
<li>打开一个磁盘文件：<code>fd = open(&quot;data.txt&quot;, O_RDONLY);</code></li>
<li>打开一个终端设备：<code>fd = open(&quot;/dev/tty&quot;, O_RDONLY);</code></li>
<li>打开一个 TCP 连接（本质也是 socket 文件描述符）：<code>fd = socket(...);</code></li>
</ul>
<p>对进程来说，拿到的都是 <code>fd</code>（文件描述符），之后都用 <code>read(fd, buf, size)</code>，完全不用关心底层是磁盘、键盘还是网卡。</p>
<p>✅ 所以，“一切皆文件”不是说硬件真的变成了文件，而是 <strong>内核把所有资源抽象成统一的文件接口，让用户进程通过相同的方式访问</strong>。</p>
<h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><ul>
<li><strong>文件描述符就是一个非负整数</strong>，是进程访问文件对象的“索引”。</li>
<li>每个进程都有一个 <strong>文件描述符表</strong>（在 PCB 中），里面存放着“文件描述符 → 内核文件对象”的映射关系。</li>
</ul>
<p>它相当于 <strong>进程与内核中文件对象之间的“句柄”</strong>，主要作用有：</p>
<ul>
<li><strong>标识已打开的文件</strong><br>当进程 <code>open()</code> 一个文件时，内核会创建一个 <code>file</code> 结构体表示这个文件对象，并返回一个文件描述符（整数）。<br>之后进程只要传递这个整数，就能继续读写该文件。</li>
<li><strong>屏蔽底层差异</strong><br>无论是磁盘文件、Socket、管道还是设备，用户态程序都只需要用 FD 操作，不必关心底层细节。</li>
<li><strong>资源管理</strong><br>内核通过 FD 表跟踪哪些文件被打开，何时关闭，避免资源泄露。</li>
</ul>
<p>当进程 <code>open(&quot;a.txt&quot;)</code> 时，内核会在内存中创建一个 <strong>文件对象（struct file）</strong>。</p>
<p>这个对象包含：</p>
<ul>
<li>文件的偏移量（读写指针）</li>
<li>访问模式（读/写/追加）</li>
<li>对应的 inode 指针（记录文件在磁盘上的元数据：权限、大小、数据块位置）</li>
</ul>
<h2 id="Linux-和-Unix"><a href="#Linux-和-Unix" class="headerlink" title="Linux 和 Unix"></a>Linux 和 Unix</h2><p><strong>Unix</strong> 最早是 1969 年 AT&amp;T 贝尔实验室研发的操作系统，它有几个特点：</p>
<ul>
<li>多用户、多任务</li>
<li>使用 C 语言实现（可移植性强）</li>
<li>“一切皆文件”的设计哲学</li>
</ul>
<p><strong>Linux</strong> 出现于 1991 年，Linus Torvalds 编写的内核，它是 <strong>类 Unix (Unix-like)</strong> 系统：</p>
<ul>
<li>借鉴了 Unix 的设计思想和接口（比如 POSIX API）</li>
<li>但代码完全重写，<strong>不是 Unix 的直接分支</strong></li>
</ul>
<p>所以，Linux 不是严格意义的 Unix，而是“模仿 Unix 的自由实现”。</p>
<h2 id="内核空间"><a href="#内核空间" class="headerlink" title="内核空间"></a>内核空间</h2><h3 id="祛魅"><a href="#祛魅" class="headerlink" title="祛魅"></a>祛魅</h3><p>所谓内核本质上就是<strong>权限更高的 C 语言程序</strong>，替代我们去负责底层的功能，<strong>系统调用就是 C 语言暴露出来的一个函数而已</strong>，所以不要把内核想的很抽象。进程之间通信的信号量不过是 C 语言的一个 int 变量，管道只不过是 C 语言的一个对象（环形缓冲区），消息队列不过是一个链表。这些听起来很高级的词汇底层不过还是我们学过的哪些数据结构实现的。</p>
<h3 id="操作系统和内核区别"><a href="#操作系统和内核区别" class="headerlink" title="操作系统和内核区别"></a>操作系统和内核区别</h3><p>首先明确一个概念：操作系统 ≠ 内核</p>
<ul>
<li><p><strong>内核 (Kernel)</strong></p>
</li>
<li><p>操作系统的核心部分</p>
</li>
<li>负责最底层的功能：进程调度、内存管理、文件系统、设备驱动、中断处理、系统调用接口</li>
<li><p>可以理解为“硬件和软件之间的桥梁”</p>
</li>
<li><p><strong>操作系统 (Operating System, OS)</strong></p>
</li>
<li><p>不仅包含内核，还包括：</p>
</li>
<li><p><strong>用户态的系统工具</strong>（shell、命令行、系统服务）</p>
</li>
<li><strong>系统库</strong>（glibc、Win32 API）</li>
<li><p><strong>配置文件、守护进程</strong>等</p>
</li>
<li><p>内核是 OS 的核心，但不是全部</p>
</li>
</ul>
<p><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/1741254082862-0f6bf403-c2fb-4905-b67d-c36e48da4946.png" alt="img"></p>
<p>其中的非直接缓冲区（JVM）就是在用户空间中，内核缓冲区（OS）就是在内核空间上。</p>
<p>内核空间是操作系统内核的专用内存区域，用于<strong>存储内核代码、数据结构和运行内核级别的系统调用</strong>。内核空间具有较高的权限级别，能够直接访问硬件资源和底层系统服务。一般来说，内核空间是受到严格保护的，用户级别的程序不能直接访问内核空间，以确保操作系统的稳定性和安全性。</p>
<p><strong>用户空间是为用户级别的应用程序和服务分配的内存区域</strong>。它包含了应用程序的代码、数据和运行时堆栈。用户空间与内核空间相对隔离，具有较低的权限级别，不能直接访问内核空间或硬件资源。应用程序需要通过系统调用与内核空间进行交互，请求操作系统提供的服务。</p>
<p>内核空间和用户空间的划分有助于操作系统实现内存保护和权限控制，确保系统运行的稳定性和安全性。当用户程序需要访问系统资源或执行特权操作时，它需要<strong>通过系统调用切换到内核空间</strong>，由内核代理执行相应的操作。这种设计可以防止恶意或错误的用户程序直接访问内核空间，从而破坏系统的稳定性和安全性。同时，这种划分也提高了操作系统的可扩展性，因为内核空间和用户空间可以独立地进行扩展和优化。</p>
<h1 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h1><p>为了避免由于中断处理程序执行时间过长，而影响正常进程的调度，Linux 将中断处理程序分为上半部和下半部：</p>
<ul>
<li>上半部，对应<strong>硬中断</strong>，由硬件触发中断，用来快速处理中断；</li>
<li>下半部，对应<strong>软中断</strong>，由内核触发中断，在内核线程执行，用来异步处理上半部未完成的工作；</li>
</ul>
<p>Linux 中的软中断包括网络收发、定时、调度、RCU 锁等各种类型，可以通过查看 /proc/softirqs 来观察软中断的累计中断次数情况，如果要实时查看中断次数的变化率，可以使用 watch -d cat /proc/softirqs 命令。</p>
<p>每一个 CPU 都有各自的软中断内核线程，我们还可以用 ps 命令来查看内核线程，一般名字在中括号里面到，都认为是内核线程。</p>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><h3 id="虚拟内存的作用"><a href="#虚拟内存的作用" class="headerlink" title="虚拟内存的作用"></a>虚拟内存的作用</h3><p>如果没有虚拟内存，所有应用程序都需要直接和物理内存打交道，但计算机会同时运行多个应用程序，每个应用程序不知道其他应用程序使用的内存地址，这就导致如果两个程序使用了同一个内存地址，就会造成写覆盖的问题，这也是为什么单片机只能运行一个程序的原因。</p>
<p>操作系统引入虚拟内存以后，应用程序就不需要知道其他程序使用什么内存，只管好自己就行了，虚拟地址到物理地址的转换完全交给操作系统来完成。进程持有的虚拟地址会通过 CPU 芯片中的内存管理单元（MMU）的映射关系，来转换变成物理地址，然后再通过物理地址访问内存。</p>
<p><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/1756886868111-091b7171-e759-41ce-be85-b06a532bd7ac.png" alt="img"></p>
<p><strong>虚拟内存的作用：</strong></p>
<ul>
<li>第一，虚拟内存可以使得进程对运行内存超过物理内存大小，因为程序运行符合局部性原理，CPU 访问内存会有很明显的重复访问的倾向性，对于那些没有被经常使用到的内存，我们可以把它换出到物理内存之外，比如硬盘上的 swap 区域。</li>
<li>第二，由于每个进程都有自己的页表，所以每个进程的虚拟内存空间就是相互独立的。进程也没有办法访问其他进程的页表，所以这些页表是私有的，这就解决了多进程之间地址冲突的问题。</li>
<li>第三，页表里的页表项中除了物理地址之外，还有一些标记属性的比特，比如控制一个页的读写权限，标记该页是否存在等。在内存访问方面，操作系统提供了更好的安全性。</li>
</ul>
<p><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/1756891828861-a7b151a5-141e-44e6-ad34-c18b6ccdc7b3.png" alt="img"></p>
<h3 id="操作系统分配内存的过程"><a href="#操作系统分配内存的过程" class="headerlink" title="操作系统分配内存的过程"></a>操作系统分配内存的过程</h3><p><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/1756890221472-0ef9d755-b62a-4710-adc2-b692cb16c619.png" alt="img"></p>
<p>OOM Killer 机制会根据算法选择一个占用物理内存较高的进程，然后将其杀死，以便释放内存资源，如果物理内存依然不足，OOM Killer 会继续杀死占用物理内存较高的进程，直到释放足够的内存位置。</p>
<h3 id="哪些内存可以被回收？"><a href="#哪些内存可以被回收？" class="headerlink" title="哪些内存可以被回收？"></a>哪些内存可以被回收？</h3><p>主要有两类内存可以被回收，而且它们的回收方式也不同。</p>
<ul>
<li><strong>文件页</strong>（File-backed Page）：内核缓存的磁盘数据（Buffer）和内核缓存的文件数据（Cache）都叫作文件页。大部分文件页，都可以直接释放内存，以后有需要时，再从磁盘重新读取就可以了。而那些被应用程序修改过，并且暂时还没写入磁盘的数据（也就是脏页），就得先写入磁盘，然后才能进行内存释放。所以，<strong>回收干净页的方式是直接释放内存，回收脏页的方式是先写回磁盘后再释放内存</strong>。</li>
<li><strong>匿名页</strong>（Anonymous Page）：这部分内存没有实际载体，不像文件缓存有硬盘文件这样一个载体，比如堆、栈数据等。这部分内存很可能还要再次被访问，所以不能直接释放内存，它们<strong>回收的方式是通过 Linux 的 Swap 机制</strong>，Swap 会把不常访问的内存先写到磁盘中，然后释放这些内存，给其他更需要的进程使用。再次访问这些内存时，重新从磁盘读入内存就可以了。</li>
</ul>
<p>文件页和匿名页的回收都是基于 LRU 算法，也就是优先回收不常访问的内存。LRU 回收算法，实际上维护着 active 和 inactive 两个双向链表，其中：</p>
<ul>
<li><strong>active_list</strong> 活跃内存页链表，这里存放的是最近被访问过（活跃）的内存页；</li>
<li><strong>inactive_list</strong> 不活跃内存页链表，这里存放的是很少被访问（非活跃）的内存页；</li>
</ul>
<h2 id="内存分段"><a href="#内存分段" class="headerlink" title="内存分段"></a>内存分段</h2><p>程序是由若干个逻辑分段组成的，如可由<strong>代码分段、数据分段、栈段、堆段</strong>组成。不同的段是有不同的属性的，所以就用分段（<em>Segmentation</em>）的形式把这些段分离出来。</p>
<p>通过下面两张图可以清晰了解段式内存管理方案。</p>
<p><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/1756886921246-bb989ff8-3527-405d-bc4e-ac0627860122.png" alt="img"></p>
<p><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/1756887091345-60f64cd8-7c25-4f2b-baae-e0fe73a1021f.png" alt="img"></p>
<p>分段的办法很好，解决了程序本身不需要关心具体的物理内存地址的问题，但它也有一些不足之处：</p>
<ul>
<li>第一个就是<strong>内存碎片</strong>的问题。</li>
<li>第二个就是<strong>内存交换的效率低</strong>的问题。</li>
</ul>
<p>下面这张图说明了段式内存管理如何导致外部碎片。</p>
<p><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/1756887219155-f687ca97-2a83-4fa1-8abb-90befe1146cc.png" alt="img"></p>
<p>解决「外部内存碎片」的问题就是<strong>内存交换</strong>。</p>
<p>可以把音乐程序占用的那 256MB 内存写到硬盘上，然后再从硬盘上读回来到内存里。不过再读回的时候，我们不能装载回原来的位置，而是紧紧跟着那已经被占用了的 512MB 内存后面。这样就能空缺出连续的 256MB 空间，于是新的 200MB 程序就可以装载进来。</p>
<p>这个内存交换空间，在 Linux 系统里，也就是我们常看到的 Swap 空间，这块空间是从硬盘划分出来的，用于内存与硬盘的空间交换。</p>
<p>但因为硬盘的访问速度要比内存慢太多了，每一次内存交换，我们都需要把一大段连续的内存数据写到硬盘上。</p>
<h2 id="内存分页"><a href="#内存分页" class="headerlink" title="内存分页"></a>内存分页</h2><h3 id="简单分页"><a href="#简单分页" class="headerlink" title="简单分页"></a>简单分页</h3><p>分段的好处就是能产生连续的内存空间，但是会出现「外部内存碎片和内存交换的空间太大」的问题。</p>
<p>分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小。这样一个连续并且尺寸固定的内存空间，我们叫<strong>页</strong>（<em>Page</em>）。在 Linux 下，每一页的大小为 <code>4KB</code>。虚拟地址与物理地址之间通过<strong>页表</strong>来映射，如下图：</p>
<p><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/1756887374868-a0913532-6710-49fa-86c8-cc1f72610e8f.png" alt="img"></p>
<p>页表是存储在内存里的，<strong>内存管理单元</strong> （<em>MMU</em>）就做将虚拟内存地址转换成物理地址的工作。</p>
<p>而当进程访问的虚拟地址在页表中查不到时，系统会产生一个<strong>缺页异常</strong>，进入系统内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。</p>
<p>分页是怎么解决分段的「外部内存碎片和内存交换效率低」的问题？</p>
<p>每个段在物理内存中是连续存放的，这也是造成外部碎片的原因，页式管理把内存空间分割成固定大小的页，页与页之间在物理内存中不要求连续，可以分散到任意空闲页框中，所以才提升了内存利用率。</p>
<p>如果内存空间不够，操作系统会把其他正在运行的进程中的「最近没被使用」的内存页面给释放掉，也就是暂时写在硬盘上，称为<strong>换出</strong>（<em>Swap Out</em>）。一旦需要的时候，再加载进来，称为<strong>换入</strong>（<em>Swap In</em>）。所以，一次性写入磁盘的也只有少数的一个页或者几个页，不会花太多时间，<strong>内存交换的效率就相对比较高。</strong></p>
<p><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/1756887672015-9cff89a1-a849-4c7f-a23a-27a289f424ec.png" alt="img"></p>
<p>更进一步地，分页的方式使得我们在加载程序的时候，不再需要一次性都把程序加载到物理内存中。我们完全可以在进行虚拟内存和物理内存的页之间的映射之后，并不真的把页加载到物理内存里，而是<strong>只有在程序运行中，需要用到对应虚拟内存页里面的指令和数据时，再加载到物理内存里面去。</strong></p>
<p><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/1756887704605-b682b8de-f679-4ce1-9994-074d8680578b.png" alt="img"></p>
<p>简单的分页有什么缺陷吗？</p>
<p>页表占用的空间很大。</p>
<p>在 32 位的环境下，虚拟地址空间共有 4GB，假设一个页的大小是 4KB（2^12），那么就需要大约 100 万 （2^20） 个页，每个「页表项」需要 4 个字节大小来存储，那么整个 4GB 空间的映射就需要有 <code>4MB</code> 的内存来存储页表。那么，<code>100</code> 个进程的话，就需要 <code>400MB</code> 的内存来存储页表，这是非常大的内存了，更别说 64 位的环境了。</p>
<h3 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h3><p>套娃， 再加一层页表来映射二级页表，这样就不需要一次性把二级页表全部加载进来，只需要加载一级页表即可，使用到哪个二级页表再延迟加载。</p>
<p>对于 64 位的系统，通常是四级目录，分别是：</p>
<ul>
<li><p>全局页目录项 PGD（<em>Page Global Directory</em>）；</p>
</li>
<li><p>上层页目录项 PUD（<em>Page Upper Directory</em>）；</p>
</li>
<li><p>中间页目录项 PMD（<em>Page Middle Directory</em>）；</p>
</li>
<li><p>页表项 PTE（<em>Page Table Entry</em>）；</p>
</li>
</ul>
<p><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/1756887786556-202dee52-8be8-4fd3-81ba-d146427c1854.png" alt="img"></p>
<h3 id="TLB"><a href="#TLB" class="headerlink" title="TLB"></a>TLB</h3><p>通常称为页表缓存、转址旁路缓存、快表等。把最常访问的几个页表项存储到访问速度更快的硬件，记录虚拟地址与物理地址的映射关系，加快转换</p>
<h2 id="段页式管理"><a href="#段页式管理" class="headerlink" title="段页式管理"></a>段页式管理</h2><p>内存分段和内存分页并不是对立的，它们是可以组合起来在同一个系统中使用的，那么组合起来后，通常称为<strong>段页式内存管理</strong>。</p>
<p><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/1756888104671-ba1f3bd2-b5fb-4939-8a24-976b7e2173cb.png" alt="img"></p>
<h2 id="Linux-内存布局"><a href="#Linux-内存布局" class="headerlink" title="Linux 内存布局"></a>Linux 内存布局</h2><p>从硬件上讲，x86 是段页式管理，但 Linux 为了简化管理，把所有段都设置成整个地址空间，所以实际上是用的纯页式管理。</p>
<p>在 Linux 操作系统中，虚拟地址空间的内部又被分为<strong>内核空间和用户空间</strong>两部分，不同位数的系统，地址空间的范围也不同。比如最常见的 32 位和 64 位系统，如下所示：</p>
<p><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/1756888297638-d994de27-cedf-4a6c-b2e0-e7fee630b8e8.png" alt="img"></p>
<p>虽然每个进程都各自有独立的虚拟内存，但是<strong>每个虚拟内存中的内核地址，其实关联的都是相同的物理内存</strong>。这样，进程切换到内核态后，就可以很方便地访问内核空间内存。</p>
<p><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/1756888305966-40d1b16d-1ac9-4c4e-834a-78a061385c21.png" alt="img"></p>
<p>用户空间分布的情况，以 32 位系统为例，我画了一张图来表示它们的关系：</p>
<p><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/1756888333682-0d8f6a11-840d-41a5-b9f7-e04f80d0ea20.png" alt="img"></p>
<ul>
<li>代码段，包括二进制可执行代码；</li>
<li>数据段，包括已初始化的静态常量和全局变量；</li>
<li>BSS 段，包括未初始化的静态变量和全局变量；</li>
<li>堆段，包括动态分配的内存，从低地址开始向上增长；</li>
<li>文件映射段，包括动态库、共享内存等，从低地址开始向上增长（<a href="http://lishiwen4.github.io/linux/linux-process-memory-location">跟硬件和内核版本有关(opens new window)</a>）；</li>
<li>栈段，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是 <code>8 MB</code>。当然系统也提供了参数，以便我们自定义大小；</li>
</ul>
<p>上图中的内存布局可以看到，代码段下面还有一段内存空间的（灰色部分），这一块区域是「保留区」，之所以要有保留区这是因为在大多数的系统里，我们认为比较小数值的地址不是一个合法地址，例如，我们通常在 C 的代码里会将无效的指针赋值为 NULL。因此，这里会出现一段不可访问的内存保留区，防止程序因为出现 bug，导致读或写了一些小内存地址的数据，而使得程序跑飞。</p>
<p>在这 7 个内存段中，堆和文件映射段的内存是动态分配的。比如说，使用 C 标准库的 <code>malloc()</code> 或者 <code>mmap()</code> ，就可以分别在堆和文件映射段动态分配内存。</p>
<p><strong>这里的段是逻辑上的段，物理上依旧是页式内存管理。</strong></p>
<h2 id="预读机制"><a href="#预读机制" class="headerlink" title="预读机制"></a>预读机制</h2><h3 id="什么是预读机制？"><a href="#什么是预读机制？" class="headerlink" title="什么是预读机制？"></a>什么是预读机制？</h3><p>Linux 操作系统为基于 Page Cache 的读缓存机制提供<strong>预读机制</strong>，一个例子是：</p>
<ul>
<li>应用程序只想读取磁盘上文件 A 的 offset 为 0-3KB 范围内的数据，由于磁盘的基本读写单位为 block（4KB），于是操作系统至少会读 0-4KB 的内容，这恰好可以在一个 page 中装下。</li>
<li>但是操作系统出于空间局部性原理（靠近当前被访问数据的数据，在未来很大概率会被访问到），会选择将磁盘块 offset [4KB,8KB)、[8KB,12KB) 以及 [12KB,16KB) 都加载到内存，于是额外在内存中申请了 3 个 page；</li>
</ul>
<h3 id="预读失效会带来什么问题？"><a href="#预读失效会带来什么问题？" class="headerlink" title="预读失效会带来什么问题？"></a>预读失效会带来什么问题？</h3><p>如果<strong>这些被提前加载进来的页，并没有被访问</strong>，相当于这个预读工作是白做了，这个就是<strong>预读失效</strong>。</p>
<p>如果使用传统的 LRU 算法，就会把「预读页」放到 LRU 链表头部，而当内存空间不够的时候，还需要把末尾的页淘汰掉。</p>
<p>如果这些「预读页」如果一直不会被访问到，就会出现一个很奇怪的问题，<strong>不会被访问的预读页却占用了 LRU 链表前排的位置，而末尾淘汰的页，可能是热点数据，这样就大大降低了缓存命中率</strong> 。</p>
<h3 id="如何避免预读失效造成的影响？"><a href="#如何避免预读失效造成的影响？" class="headerlink" title="如何避免预读失效造成的影响？"></a>如何避免预读失效造成的影响？</h3><p>我们不能因为害怕预读失效，而将预读机制去掉，大部分情况下，空间局部性原理还是成立的。</p>
<p>要避免预读失效带来影响，最好就是<strong>让预读页停留在内存里的时间要尽可能的短，让真正被访问的页才移动到 LRU 链表的头部，从而保证真正被读取的热数据留在内存里的时间尽可能长</strong>。</p>
<p>Linux 操作系统和 MySQL Innodb 通过改进传统 LRU 链表来避免预读失效带来的影响，具体的改进分别如下：</p>
<ul>
<li>Linux 操作系统实现两个了 LRU 链表：<strong>活跃 LRU 链表（active_list）和非活跃 LRU 链表（inactive_list）</strong>；</li>
<li>MySQL 的 Innodb 存储引擎是在一个 LRU 链表上划分来 2 个区域：<strong>young 区域 和 old 区域</strong>。</li>
</ul>
<p>这两个改进方式，设计思想都是类似的，<strong>都是将数据分为了冷数据和热数据，然后分别进行 LRU 算法</strong>。不再像传统的 LRU 算法那样，所有数据都只用一个 LRU 算法管理。</p>
<p>接下来，具体聊聊 Linux 和 MySQL 是如何避免预读失效带来的影响？</p>
<p>Linux 是如何避免预读失效带来的影响？</p>
<p>Linux 操作系统实现两个了 LRU 链表：<strong>活跃 LRU 链表（active_list）和非活跃 LRU 链表（inactive_list）</strong>。</p>
<ul>
<li><strong>active list</strong> 活跃内存页链表，这里存放的是最近被访问过（活跃）的内存页；</li>
<li><strong>inactive list</strong> 不活跃内存页链表，这里存放的是很少被访问（非活跃）的内存页；</li>
</ul>
<p>有了这两个 LRU 链表后，<strong>预读页就只需要加入到 inactive list 区域的头部，当页被真正访问的时候，才将页插入 active list 的头部</strong>。如果预读的页一直没有被访问，就会从 inactive list 移除，这样就不会影响 active list 中的热点数据。</p>
<p>MySQL 是如何避免预读失效带来的影响？</p>
<p>young 区域在 LRU 链表的前半部分，old 区域则是在后半部分，这两个区域都有各自的头和尾节点，如下图：</p>
<p><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/1756892254693-a3cefa17-92c8-4030-9e9f-fecef53a5ec0.png" alt="img"></p>
<p>young 区域与 old 区域在 LRU 链表中的占比关系并不是一比一的关系，而是 63:37（默认比例）的关系。</p>
<p><strong>划分这两个区域后，预读的页就只需要加入到 old 区域的头部，当页被真正访问的时候，才将页插入 young 区域的头部</strong>。如果预读的页一直没有被访问，就会从 old 区域移除，这样就不会影响 young 区域中的热点数据。</p>
<h2 id="缓存污染"><a href="#缓存污染" class="headerlink" title="缓存污染"></a>缓存污染</h2><h3 id="什么是缓存污染？"><a href="#什么是缓存污染？" class="headerlink" title="什么是缓存污染？"></a>什么是缓存污染？</h3><p>虽然 Linux （实现两个 LRU 链表）和 MySQL （划分两个区域）通过改进传统的 LRU 数据结构，避免了预读失效带来的影响。</p>
<p>但是如果还是使用「只要数据被访问一次，就将数据加入到活跃 LRU 链表头部（或者 young 区域）」这种方式的话，那么<strong>还存在缓存污染的问题</strong>。</p>
<p>我以 MySQL 举例子，Linux 发生缓存污染的现象也是类似。</p>
<p>当某一个 SQL 语句<strong>扫描了大量的数据</strong>时，在 Buffer Pool 空间比较有限的情况下，可能会将 <strong>Buffer Pool 里的所有页都替换出去，导致大量热数据被淘汰了</strong>，等这些热数据又被再次访问的时候，由于缓存未命中，就会产生大量的磁盘 I/O，MySQL 性能就会急剧下降。</p>
<h3 id="怎么避免缓存污染造成的影响？"><a href="#怎么避免缓存污染造成的影响？" class="headerlink" title="怎么避免缓存污染造成的影响？"></a>怎么避免缓存污染造成的影响？</h3><p><strong>只要我们提高进入到活跃 LRU 链表（或者 young 区域）的门槛，就能有效地保证活跃 LRU 链表（或者 young 区域）里的热点数据不会被轻易替换掉</strong>。</p>
<p>Linux 操作系统和 MySQL Innodb 存储引擎分别是这样提高门槛的：</p>
<ul>
<li><strong>Linux 操作系统</strong>：在内存页被访问<strong>第二次</strong>的时候，才将页从 inactive list 升级到 active list 里。</li>
<li><p><strong>MySQL Innodb</strong>：在内存页被访问<strong>第二次</strong>的时候，并不会马上将该页从 old 区域升级到 young 区域，因为还要进行<strong>停留在 old 区域的时间判断</strong>：</p>
</li>
<li><p>如果第二次的访问时间与第一次访问的时间<strong>在 1 秒内</strong>（默认值），那么该页就<strong>不会</strong>被从 old 区域升级到 young 区域；</p>
</li>
<li>如果第二次的访问时间与第一次访问的时间<strong>超过 1 秒</strong>，那么该页就<strong>会</strong>从 old 区域升级到 young 区域；</li>
</ul>
<h2 id="malloc-是如何分配内存的？"><a href="#malloc-是如何分配内存的？" class="headerlink" title="malloc 是如何分配内存的？"></a>malloc 是如何分配内存的？</h2><p>malloc() 源码里默认定义了一个阈值：</p>
<ul>
<li>方式一：如果用户分配的内存小于 128 KB，则通过 brk() 系统调用从堆分配内存；</li>
<li>方式二：如果用户分配的内存大于 128 KB，则通过 mmap() 系统调用在文件映射区域分配内存；</li>
</ul>
<p><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/1756888984393-c1d7d0cf-c94f-482a-a6d4-d45a5569b830.png" alt="img"></p>
<p><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/1756889038319-993d4c40-c860-49e8-a8ed-d97a43a81900.png" alt="img"></p>
<h3 id="malloc-1-会分配多大的虚拟内存？"><a href="#malloc-1-会分配多大的虚拟内存？" class="headerlink" title="malloc(1) 会分配多大的虚拟内存？"></a>malloc(1) 会分配多大的虚拟内存？</h3><p>malloc() 在分配内存的时候，并不是老老实实按用户预期申请的字节数来分配内存空间大小，而是<strong>会预分配更大的空间作为内存池</strong>。</p>
<p><a href="https://xiaolincoding.com/os/3_memory/malloc.html#malloc-1-会分配多大的虚拟内存">4.2 malloc 是如何分配内存的？</a></p>
<h3 id="free-释放内存，会归还给操作系统吗？"><a href="#free-释放内存，会归还给操作系统吗？" class="headerlink" title="free 释放内存，会归还给操作系统吗？"></a>free 释放内存，会归还给操作系统吗？</h3><ul>
<li>如果 malloc 通过 brk() 方式申请的内存的情况：通过 free 释放内存后，堆内存还是存在的，并没有归还给操作系统。这是因为与其把这 1 字节释放给操作系统，不如先缓存着放进 malloc 的内存池里，当进程再次申请 1 字节的内存时就可以直接复用，这样速度快了很多。</li>
<li>如果 malloc 通过 mmap 方式申请的内存：free 释放内存后就会归归还给操作系统。</li>
</ul>
<h3 id="为什么不全部使用-mmap-来分配内存？"><a href="#为什么不全部使用-mmap-来分配内存？" class="headerlink" title="为什么不全部使用 mmap 来分配内存？"></a>为什么不全部使用 mmap 来分配内存？</h3><p><code>mmap</code> 灵活干净但开销大，<code>brk</code> 管理堆速度快但对大块和碎片敏感。<code>malloc</code> 混着用，让小内存分配享受 <code>brk</code> 的速度红利，让大内存分配享受 <code>mmap</code> 的独立与干净，各取所长，才能在各种内存分配需求下都交出比较均衡、高效的答卷。</p>
<p>要是全用 <code>mmap</code>，小内存分配的频繁开销会让程序慢得怀疑人生；要是全用 <code>brk</code>，遇上大内存或者长期运行产生大量碎片，程序可能就“卡死”在明明有内存却分配不出来的尴尬境地。所以，这个组合拳，打得有理！</p>
<details class="lake-collapse"><summary id="ucd6e7802"><span class="ne-text" style="font-size: 16px">更详细的解释</span></summary><p id="u68b9b74c" class="ne-p" style="margin: 0; padding: 0; min-height: 24px"><span class="ne-text" style="color: rgb(44, 62, 80); font-size: 16px">咱们来聊聊</span><span class="ne-text" style="color: rgb(44, 62, 80); font-size: 16px"> </span><code class="ne-code" style="font-family: SFMono-Regular, Consolas, Liberation Mono, Menlo, Courier, monospace; background-color: rgba(0, 0, 0, 0.06); border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; padding: 0px 2px"><span class="ne-text" style="color: rgb(71, 101, 130); background-color: rgba(27, 31, 35, 0.05); font-size: 16px">malloc</span></code><span class="ne-text" style="color: rgb(44, 62, 80); font-size: 16px"> </span><span class="ne-text" style="color: rgb(44, 62, 80); font-size: 16px">为啥不一股脑儿全用</span><span class="ne-text" style="color: rgb(44, 62, 80); font-size: 16px"> </span><code class="ne-code" style="font-family: SFMono-Regular, Consolas, Liberation Mono, Menlo, Courier, monospace; background-color: rgba(0, 0, 0, 0.06); border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; padding: 0px 2px"><span class="ne-text" style="color: rgb(71, 101, 130); background-color: rgba(27, 31, 35, 0.05); font-size: 16px">mmap</span></code><span class="ne-text" style="color: rgb(44, 62, 80); font-size: 16px"> </span><span class="ne-text" style="color: rgb(44, 62, 80); font-size: 16px">来分内存，非得搞个</span><span class="ne-text" style="color: rgb(44, 62, 80); font-size: 16px"> </span><code class="ne-code" style="font-family: SFMono-Regular, Consolas, Liberation Mono, Menlo, Courier, monospace; background-color: rgba(0, 0, 0, 0.06); border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; padding: 0px 2px"><span class="ne-text" style="color: rgb(71, 101, 130); background-color: rgba(27, 31, 35, 0.05); font-size: 16px">brk</span></code><span class="ne-text" style="color: rgb(44, 62, 80); font-size: 16px"> </span><span class="ne-text" style="color: rgb(44, 62, 80); font-size: 16px">+</span><span class="ne-text" style="color: rgb(44, 62, 80); font-size: 16px"> </span><code class="ne-code" style="font-family: SFMono-Regular, Consolas, Liberation Mono, Menlo, Courier, monospace; background-color: rgba(0, 0, 0, 0.06); border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; padding: 0px 2px"><span class="ne-text" style="color: rgb(71, 101, 130); background-color: rgba(27, 31, 35, 0.05); font-size: 16px">mmap</span></code><span class="ne-text" style="color: rgb(44, 62, 80); font-size: 16px"> </span><span class="ne-text" style="color: rgb(44, 62, 80); font-size: 16px">的组合拳。这事儿吧，说白了就是性能和资源管理上的一种权衡，没有一招鲜吃遍天的好事儿。</span></p><p id="uedfe022b" class="ne-p" style="margin: 0; padding: 0; min-height: 24px"><span class="ne-text" style="color: rgb(44, 62, 80); font-size: 16px">你想啊，</span><code class="ne-code" style="font-family: SFMono-Regular, Consolas, Liberation Mono, Menlo, Courier, monospace; background-color: rgba(0, 0, 0, 0.06); border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; padding: 0px 2px"><span class="ne-text" style="color: rgb(71, 101, 130); background-color: rgba(27, 31, 35, 0.05); font-size: 16px">mmap</span></code><span class="ne-text" style="color: rgb(44, 62, 80); font-size: 16px"> </span><span class="ne-text" style="color: rgb(44, 62, 80); font-size: 16px">确实挺酷的，每次都能从操作系统那儿划拉一块全新的、独立的虚拟内存区域给你，用完了直接</span><span class="ne-text" style="color: rgb(44, 62, 80); font-size: 16px"> </span><code class="ne-code" style="font-family: SFMono-Regular, Consolas, Liberation Mono, Menlo, Courier, monospace; background-color: rgba(0, 0, 0, 0.06); border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; padding: 0px 2px"><span class="ne-text" style="color: rgb(71, 101, 130); background-color: rgba(27, 31, 35, 0.05); font-size: 16px">munmap</span></code><span class="ne-text" style="color: rgb(44, 62, 80); font-size: 16px"> </span><span class="ne-text" style="color: rgb(44, 62, 80); font-size: 16px">还回去，干干净净，碎片问题也少。但问题就在于，这“酷”是有代价的！每次调用</span><span class="ne-text" style="color: rgb(44, 62, 80); font-size: 16px"> </span><code class="ne-code" style="font-family: SFMono-Regular, Consolas, Liberation Mono, Menlo, Courier, monospace; background-color: rgba(0, 0, 0, 0.06); border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; padding: 0px 2px"><span class="ne-text" style="color: rgb(71, 101, 130); background-color: rgba(27, 31, 35, 0.05); font-size: 16px">mmap</span></code><span class="ne-text" style="color: rgb(44, 62, 80); font-size: 16px">，都得劳烦操作系统内核跑一趟，做一大堆事情：找个没人用的地址空间、设置好页表项、可能还要清空内存页（确保安全）、更新内核数据结构…… 这一套流程下来，开销可比在用户态捣鼓点指针大多了。要是你程序里动不动就分配释放一堆小块儿内存（比如链表节点、小对象啥的），每次都来这么一趟</span><span class="ne-text" style="color: rgb(44, 62, 80); font-size: 16px"> </span><code class="ne-code" style="font-family: SFMono-Regular, Consolas, Liberation Mono, Menlo, Courier, monospace; background-color: rgba(0, 0, 0, 0.06); border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; padding: 0px 2px"><span class="ne-text" style="color: rgb(71, 101, 130); background-color: rgba(27, 31, 35, 0.05); font-size: 16px">mmap/munmap</span></code><span class="ne-text" style="color: rgb(44, 62, 80); font-size: 16px">，那性能可就真得慢得掉渣了，系统调用本身、TLB（快表）刷新的开销都能把你拖垮。</span></p><p id="u57a3d795" class="ne-p" style="margin: 0; padding: 0; min-height: 24px"><span class="ne-text" style="color: rgb(44, 62, 80); font-size: 16px">这时候</span><span class="ne-text" style="color: rgb(44, 62, 80); font-size: 16px"> </span><code class="ne-code" style="font-family: SFMono-Regular, Consolas, Liberation Mono, Menlo, Courier, monospace; background-color: rgba(0, 0, 0, 0.06); border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; padding: 0px 2px"><span class="ne-text" style="color: rgb(71, 101, 130); background-color: rgba(27, 31, 35, 0.05); font-size: 16px">brk</span></code><span class="ne-text" style="color: rgb(44, 62, 80); font-size: 16px"> </span><span class="ne-text" style="color: rgb(44, 62, 80); font-size: 16px">的价值就体现出来了。它本质上是挪动一个叫“program break”的指针，把进程堆区的尾巴伸长或者缩短。分配小块内存时，</span><code class="ne-code" style="font-family: SFMono-Regular, Consolas, Liberation Mono, Menlo, Courier, monospace; background-color: rgba(0, 0, 0, 0.06); border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; padding: 0px 2px"><span class="ne-text" style="color: rgb(71, 101, 130); background-color: rgba(27, 31, 35, 0.05); font-size: 16px">malloc</span></code><span class="ne-text" style="color: rgb(44, 62, 80); font-size: 16px"> </span><span class="ne-text" style="color: rgb(44, 62, 80); font-size: 16px">在用户空间自己管理堆区这块地盘就行了。它预先通过</span><span class="ne-text" style="color: rgb(44, 62, 80); font-size: 16px"> </span><code class="ne-code" style="font-family: SFMono-Regular, Consolas, Liberation Mono, Menlo, Courier, monospace; background-color: rgba(0, 0, 0, 0.06); border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; padding: 0px 2px"><span class="ne-text" style="color: rgb(71, 101, 130); background-color: rgba(27, 31, 35, 0.05); font-size: 16px">brk</span></code><span class="ne-text" style="color: rgb(44, 62, 80); font-size: 16px"> </span><span class="ne-text" style="color: rgb(44, 62, 80); font-size: 16px">扩大堆区（比如一次申请一大块），然后在这块连续的内存里，像切豆腐一样，根据你的请求切出合适的小块给你。释放的时候呢，也不是立刻还给操作系统，而是记录起来（放进空闲链表之类的结构），等下次有人再要小块内存时直接复用。只有当堆顶一大块连续内存都空闲了，</span><code class="ne-code" style="font-family: SFMono-Regular, Consolas, Liberation Mono, Menlo, Courier, monospace; background-color: rgba(0, 0, 0, 0.06); border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; padding: 0px 2px"><span class="ne-text" style="color: rgb(71, 101, 130); background-color: rgba(27, 31, 35, 0.05); font-size: 16px">malloc</span></code><span class="ne-text" style="color: rgb(44, 62, 80); font-size: 16px"> </span><span class="ne-text" style="color: rgb(44, 62, 80); font-size: 16px">才可能用</span><span class="ne-text" style="color: rgb(44, 62, 80); font-size: 16px"> </span><code class="ne-code" style="font-family: SFMono-Regular, Consolas, Liberation Mono, Menlo, Courier, monospace; background-color: rgba(0, 0, 0, 0.06); border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; padding: 0px 2px"><span class="ne-text" style="color: rgb(71, 101, 130); background-color: rgba(27, 31, 35, 0.05); font-size: 16px">brk</span></code><span class="ne-text" style="color: rgb(44, 62, 80); font-size: 16px"> </span><span class="ne-text" style="color: rgb(44, 62, 80); font-size: 16px">把尾巴缩回去，把内存真正还给系统。这么搞，好处太明显了：对于大量、频繁的小内存申请释放，绝大部分操作都在用户态搞定，速度快得飞起，系统调用的开销被摊得非常薄。碎片问题虽然存在，但</span><span class="ne-text" style="color: rgb(44, 62, 80); font-size: 16px"> </span><code class="ne-code" style="font-family: SFMono-Regular, Consolas, Liberation Mono, Menlo, Courier, monospace; background-color: rgba(0, 0, 0, 0.06); border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; padding: 0px 2px"><span class="ne-text" style="color: rgb(71, 101, 130); background-color: rgba(27, 31, 35, 0.05); font-size: 16px">malloc</span></code><span class="ne-text" style="color: rgb(44, 62, 80); font-size: 16px"> </span><span class="ne-text" style="color: rgb(44, 62, 80); font-size: 16px">自己会努力合并相邻的空闲块来缓解。</span></p><p id="u87021a15" class="ne-p" style="margin: 0; padding: 0; min-height: 24px"><span class="ne-text" style="color: rgb(44, 62, 80); font-size: 16px">当然，</span><code class="ne-code" style="font-family: SFMono-Regular, Consolas, Liberation Mono, Menlo, Courier, monospace; background-color: rgba(0, 0, 0, 0.06); border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; padding: 0px 2px"><span class="ne-text" style="color: rgb(71, 101, 130); background-color: rgba(27, 31, 35, 0.05); font-size: 16px">brk</span></code><span class="ne-text" style="color: rgb(44, 62, 80); font-size: 16px"> </span><span class="ne-text" style="color: rgb(44, 62, 80); font-size: 16px">也不是万金油。堆区是连续的，要是中间被零零碎碎的小块占着，即使总空闲空间够，也可能找不到一块连续的大空间来满足大内存申请（这就是内部碎片）。而且，堆区理论上只能向一个方向长（通常向上），管理起来没那么灵活。</span></p><p id="u1687e1f0" class="ne-p" style="margin: 0; padding: 0; min-height: 24px"><span class="ne-text" style="color: rgb(44, 62, 80); font-size: 16px">所以，</span><code class="ne-code" style="font-family: SFMono-Regular, Consolas, Liberation Mono, Menlo, Courier, monospace; background-color: rgba(0, 0, 0, 0.06); border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; padding: 0px 2px"><span class="ne-text" style="color: rgb(71, 101, 130); background-color: rgba(27, 31, 35, 0.05); font-size: 16px">malloc</span></code><span class="ne-text" style="color: rgb(44, 62, 80); font-size: 16px"> </span><span class="ne-text" style="color: rgb(44, 62, 80); font-size: 16px">的智慧就在于“看人下菜碟”：</span></p><ol class="ne-ol" style="margin: 0; padding-left: 23px"><li id="u977375a6" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(48, 79, 254); font-size: 16px">小内存、频繁请求</span></strong><span class="ne-text" style="color: rgb(44, 62, 80); font-size: 16px">：主要靠</span><span class="ne-text" style="color: rgb(44, 62, 80); font-size: 16px"> </span><code class="ne-code" style="font-family: SFMono-Regular, Consolas, Liberation Mono, Menlo, Courier, monospace; background-color: rgba(0, 0, 0, 0.06); border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; padding: 0px 2px"><span class="ne-text" style="color: rgb(71, 101, 130); background-color: rgba(27, 31, 35, 0.05); font-size: 16px">brk</span></code><span class="ne-text" style="color: rgb(44, 62, 80); font-size: 16px"> </span><span class="ne-text" style="color: rgb(44, 62, 80); font-size: 16px">管理的堆区。用户态搞定，速度快如闪电。</span></li><li id="u13aa67d8" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(48, 79, 254); font-size: 16px">大内存（通常超过一个阈值，比如几百KB）</span></strong><span class="ne-text" style="color: rgb(44, 62, 80); font-size: 16px">：直接用 </span><code class="ne-code" style="font-family: SFMono-Regular, Consolas, Liberation Mono, Menlo, Courier, monospace; background-color: rgba(0, 0, 0, 0.06); border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; padding: 0px 2px"><span class="ne-text" style="color: rgb(71, 101, 130); background-color: rgba(27, 31, 35, 0.05); font-size: 16px">mmap</span></code><span class="ne-text" style="color: rgb(44, 62, 80); font-size: 16px"> 单独映射一块。这样避免了在堆区造成难以忍受的大洞（外部碎片），释放时也能干净利落地立刻归还给系统，不拖累堆区。</span></li></ol></details>

<h3 id="怎么处理堆空间连续增长产生的内存碎片？"><a href="#怎么处理堆空间连续增长产生的内存碎片？" class="headerlink" title="怎么处理堆空间连续增长产生的内存碎片？"></a>怎么处理堆空间连续增长产生的内存碎片？</h3><p>这就是 JVM GC 干的工作了，常见的方案有：紧凑/压缩堆、空闲链表管理、分代/区域分配等。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>brk（堆）</strong></th>
<th><strong>mmap</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>内存连续性</strong></td>
<td>必须连续</td>
<td>虚拟地址可分散，物理页不要求连续</td>
</tr>
<tr>
<td><strong>小块分配</strong></td>
<td>高效，但容易产生堆碎片</td>
<td>不适合小块频繁分配，开销大</td>
</tr>
<tr>
<td><strong>大块分配</strong></td>
<td>堆碎片可能导致失败</td>
<td>独立映射，释放干净，不影响堆</td>
</tr>
</tbody>
</table>
</div>
<h3 id="free-函数只传入一个内存地址，为什么能知道要释放多大的内存？"><a href="#free-函数只传入一个内存地址，为什么能知道要释放多大的内存？" class="headerlink" title="free() 函数只传入一个内存地址，为什么能知道要释放多大的内存？"></a>free() 函数只传入一个内存地址，为什么能知道要释放多大的内存？</h3><p>malloc 返回给用户态的内存起始地址比进程的堆空间起始地址多了 16 字节，这个多出来的 16 字节就是保存了该内存块的描述信息，比如有该内存块的大小。</p>
<p><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/1756889962832-cf1336ed-f948-4226-85c7-71476b8a1091.png" alt="img"></p>
<p>这样当执行 free() 函数时，free 会对传入进来的内存地址向左偏移 16 字节，然后从这个 16 字节的分析出当前的内存块的大小，自然就知道要释放多大的内存了。</p>
<h1 id="进程、线程、协程"><a href="#进程、线程、协程" class="headerlink" title="进程、线程、协程"></a>进程、线程、协程</h1><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/1742175190519-5b74a634-93d3-4cd2-b6f4-e00ad84b088e.webp" alt="图有错误：线程私有的只有寄存器和栈，没有堆"></p>
<ul>
<li>首先，我们来谈谈<strong>进程</strong>。进程是操作系统中进行资源分配和调度的基本单位，它拥有自己的<strong>独立内存空间和系统资源</strong>。每个进程都有<strong>独立的堆和栈</strong>，不与其他进程共享。进程间通信需要通过特定的机制，如<strong>管道、消息队列、信号量</strong>等。由于进程拥有独立的内存空间，因此其稳定性和安全性相对较高，但同时上下文切换的开销也较大，因为需要保存和恢复整个进程的状态。</li>
<li>接下来是<strong>线程</strong>。线程是进程内的一个执行单元，也是CPU调度和分派的基本单位。与进程不同，线程<strong>共享进程的内存空间</strong>，包括<strong>堆和全局变量</strong>。线程之间通信更加高效，因为它们可以直接读写共享内存。线程的上下文切换开销较小，因为只需要保存和恢复线程的上下文，而不是整个进程的状态。然而，由于多个线程共享内存空间，因此存在数据竞争和线程安全的问题，需要通过<strong>同步和互斥</strong>机制来解决。</li>
<li>最后是<strong>协程</strong>。协程是一种<strong>用户态的轻量级线程</strong>，其调度完全由用户程序控制，而不需要内核的参与。协程拥有自己的<strong>寄存器上下文和栈</strong>，但与其他协程共享堆内存。协程的切换开销非常小，因为只需要保存和恢复协程的上下文，而无需进行内核级的上下文切换。这使得协程在处理大量并发任务时具有非常高的效率。然而，协程需要程序员显式地进行调度和管理，相对于线程和进程来说，其编程模型更为复杂。内核根本不知道有协程存在，所以 <strong>什么时候挂起、什么时候恢复，全靠程序员写代码来标记</strong>。</li>
</ul>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><p><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/1756898230042-b19d4376-dfeb-4d7d-a58c-051492ce8190.png" alt="img"></p>
<p><strong>挂起状态：进程没有占用实际的物理内存空间的情况**</strong>，**挂起状态可以分为两种：</p>
<ul>
<li>阻塞挂起状态：进程在外存（硬盘）并等待某个事件的出现；</li>
<li>就绪挂起状态：进程在外存（硬盘），但只要进入内存，即刻立刻运行；</li>
</ul>
<h3 id="PCB"><a href="#PCB" class="headerlink" title="PCB"></a>PCB</h3><p><strong>进程描述信息：</strong></p>
<ul>
<li>进程标识符：标识各个进程，每个进程都有一个并且唯一的标识符；</li>
<li>用户标识符：进程归属的用户，用户标识符主要为共享和保护服务；</li>
</ul>
<p><strong>进程控制和管理信息：</strong></p>
<ul>
<li>进程当前状态，如 new、ready、running、waiting 或 blocked 等；</li>
<li>进程优先级：进程抢占 CPU 时的优先级；</li>
</ul>
<p><strong>资源分配清单：</strong></p>
<ul>
<li>有关内存地址空间或虚拟地址空间的信息，所打开文件的列表和所使用的 I/O 设备信息。</li>
</ul>
<p><strong>CPU 相关信息：</strong></p>
<ul>
<li>CPU 中各个寄存器的值，当进程被切换时，CPU 的状态信息都会被保存在相应的 PCB 中，以便进程重新执行时，能从断点处继续执行。</li>
</ul>
<p>每个 PCB 是如何组织的呢？</p>
<p>通常是通过<strong>链表</strong>的方式进行组织，把具有<strong>相同状态的进程链在一起，组成各种队列</strong>。比如：</p>
<ul>
<li>将所有处于就绪状态的进程链在一起，称为<strong>就绪队列</strong>；</li>
<li>把所有因等待某事件而处于等待状态的进程链在一起就组成各种<strong>阻塞队列</strong>；</li>
<li>另外，对于运行队列在单核 CPU 系统中则只有一个运行指针了，因为单核 CPU 在某个时间，只能运行一个程序。</li>
</ul>
<p>那么，就绪队列和阻塞队列链表的组织形式如下图：</p>
<p><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/1756898528005-b608d726-bddd-43a9-8132-e2646160ff70.png" alt="img"></p>
<h3 id="进程的控制"><a href="#进程的控制" class="headerlink" title="进程的控制"></a>进程的控制</h3><p><strong>01 创建进程</strong></p>
<p>操作系统允许一个进程创建另一个进程，而且允许子进程继承父进程所拥有的资源。</p>
<p>创建进程的过程如下：</p>
<ul>
<li>申请一个空白的 PCB，并向 PCB 中填写一些控制和管理进程的信息，比如进程的唯一标识等；</li>
<li>为该进程分配运行时所必需的资源，比如内存资源；</li>
<li>将 PCB 插入到就绪队列，等待被调度运行；</li>
</ul>
<p><strong>02 终止进程</strong></p>
<p>进程可以有 3 种终止方式：正常结束、异常结束以及外界干预（信号 <code>kill</code> 掉）。</p>
<p>当子进程被终止时，其在父进程处继承的资源应当还给父进程。而当父进程被终止时，该父进程的子进程就变为孤儿进程，会被 1 号进程收养，并由 1 号进程对它们完成状态收集工作。</p>
<p>终止进程的过程如下：</p>
<ul>
<li>查找需要终止的进程的 PCB；</li>
<li>如果处于执行状态，则立即终止该进程的执行，然后将 CPU 资源分配给其他进程；</li>
<li>如果其还有子进程，则应将该进程的子进程交给 1 号进程接管；</li>
<li>将该进程所拥有的全部资源都归还给操作系统；</li>
<li>将其从 PCB 所在队列中删除；</li>
</ul>
<p><strong>03 阻塞进程</strong></p>
<p>当进程需要等待某一事件完成时，它可以调用阻塞语句把自己阻塞等待。而一旦被阻塞等待，它只能由另一个进程唤醒。</p>
<p>阻塞进程的过程如下：</p>
<ul>
<li>找到将要被阻塞进程标识号对应的 PCB；</li>
<li>如果该进程为运行状态，则保护其现场，将其状态转为阻塞状态，停止运行；</li>
<li>将该 PCB 插入到阻塞队列中去；</li>
</ul>
<p><strong>04 唤醒进程</strong></p>
<p>进程由「运行」转变为「阻塞」状态是由于进程必须等待某一事件的完成，所以处于阻塞状态的进程是绝对不可能叫醒自己的。</p>
<p>如果某进程正在等待 I/O 事件，需由别的进程发消息给它，则只有当该进程所期待的事件出现时，才由发现者进程用唤醒语句叫醒它。</p>
<p>唤醒进程的过程如下：</p>
<ul>
<li>在该事件的阻塞队列中找到相应进程的 PCB；</li>
<li>将其从阻塞队列中移出，并置其状态为就绪状态；</li>
<li>把该 PCB 插入到就绪队列中，等待调度程序调度；</li>
</ul>
<p>进程的阻塞和唤醒是一对功能相反的语句，如果某个进程调用了阻塞语句，则必有一个与之对应的唤醒语句。</p>
<h3 id="进程的上下文切换"><a href="#进程的上下文切换" class="headerlink" title="进程的上下文切换"></a>进程的上下文切换</h3><p>进程是由内核管理和调度的，所以进程的切换只能发生在内核态。</p>
<p>所以，<strong>进程的上下文切换不仅包含了**</strong>虚拟内存、栈、全局变量<strong><strong>等用户空间的资源，还包括了</strong></strong>内核堆栈、寄存器等<strong>**内核空间的资源。</strong></p>
<p>通常，会把交换的信息保存在进程的 PCB，当要运行另外一个进程的时候，我们需要从这个进程的 PCB 取出上下文，然后恢复到 CPU 中，这使得这个进程可以继续执行，如下图所示：</p>
<p><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/1756899023597-4221dbd5-fd80-41df-b9fa-567c8ffafb4e.png" alt="img"></p>
<p><strong>进程切换时数据都保存在哪里？</strong></p>
<ol>
<li><strong>PCB 中保存的信息</strong></li>
</ol>
<p>PCB（Process Control Block）主要保存 进程的核心元数据和必要的上下文，包括：</p>
<ul>
<li>CPU 状态：寄存器值（通用寄存器、程序计数器、栈指针、标志寄存器等）</li>
<li>进程标识信息：PID、父进程 PID、用户/组 ID</li>
<li>调度信息：进程状态（就绪、运行、阻塞）、优先级、时间片</li>
<li>内存管理信息：页表基址、段表信息、堆/栈边界</li>
<li>信号和 I/O 状态信息：挂起信号、等待队列、打开的文件描述符等</li>
</ul>
<p>PCB 中保存的是 操作系统切换进程必须的信息，足够恢复进程继续执行。</p>
<ol>
<li><strong>不直接保存到 PCB 的内容</strong></li>
</ol>
<p>大块内存数据：堆和栈内容本身通常仍在内存中，不会拷贝到 PCB，只保存栈指针和边界信息</p>
<ul>
<li>缓存、TLB 条目等硬件状态：在上下文切换时可能被刷新，不存 PCB</li>
<li>磁盘 I/O 缓冲：挂起的 I/O 数据通常在内核缓冲区，不存 PCB</li>
<li>PCB 更像是 索引和元信息，实际数据仍保留在内存或硬件资源中。</li>
</ul>
<h3 id="进程切换的开销"><a href="#进程切换的开销" class="headerlink" title="进程切换的开销"></a>进程切换的开销</h3><p>进程切换是指操作系统将 CPU 从一个进程切换到另一个进程运行，以实现多任务处理。这个过程会带来以下几方面的开销：</p>
<p><strong>保存和恢复现场信息</strong></p>
<ul>
<li>进程在运行过程中，CPU 的寄存器中会存储当前进程的各种信息，如程序计数器、通用寄存器的值等。当进行进程切换时，需要将这些寄存器中的值保存到进程的控制块（PCB）中，以便在该进程下次被调度运行时能够恢复到原来的状态。保存和恢复这些现场信息需要执行一系列的指令，这会消耗一定的 CPU 时间。</li>
</ul>
<p><strong>内存管理相关开销</strong></p>
<ul>
<li><strong>页表切换</strong>：每个进程都有自己独立的地址空间，通过页表来实现虚拟地址到物理地址的映射。当进程切换时，需要切换页表，使 CPU 能够正确地访问新进程的内存空间。页表的切换需要更新 CPU 中的页表寄存器，这会导致内存访问的局部性原理被破坏，使得后续的内存访问可能需要更多的时间来查找页表，增加了内存访问的延迟。</li>
<li><strong>TLB 刷新</strong>：转换后备缓冲器（TLB）是 CPU 中用于加速虚拟地址到物理地址转换的缓存。当进程切换时，由于页表发生了变化，TLB 中的内容可能不再有效，需要进行刷新。TLB 刷新会导致后续的地址转换无法直接从 TLB 中获取结果，而需要再次访问页表，增加了地址转换的时间。</li>
</ul>
<p><strong>进程调度开销</strong></p>
<ul>
<li>操作系统需要执行进程调度算法，从就绪队列中选择一个合适的进程来运行。这个过程需要对各个进程的状态、优先级等信息进行检查和比较，以确定下一个应该运行的进程。调度算法的执行需要消耗一定的 CPU 时间，尤其是在系统中进程数量较多时，调度的开销会更加明显。</li>
</ul>
<p><strong>缓存失效</strong></p>
<ul>
<li>当进程切换时，原来进程使用的 CPU 缓存（如指令缓存、数据缓存等）中的内容可能对于新进程不再有效，因为不同进程的代码和数据通常是不同的。新进程开始运行后，可能需要重新从内存中加载指令和数据到缓存中，这会导致缓存未命中的情况增加，从而增加了内存访问的时间，降低了 CPU 的执行效率。</li>
</ul>
<p><strong>上下文切换的硬件开销</strong></p>
<ul>
<li>在一些硬件架构中，进程切换可能会触发一些硬件相关的操作，如更新处理器的状态寄存器、清除流水线等。这些硬件操作也会消耗一定的时间和能量，增加了进程切换的总体开销。</li>
</ul>
<h3 id="进程的通讯方式"><a href="#进程的通讯方式" class="headerlink" title="进程的通讯方式"></a>进程的通讯方式</h3><p><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/1756903620740-9f920960-ac86-4edc-887b-adc2bfcfeb7c.png" alt="img"></p>
<p><a href="https://xiaolincoding.com/os/4_process/process_commu.html#管道">5.2 进程间有哪些通信方式？</a>讲的更详细。</p>
<ol>
<li><strong>管道：</strong></li>
</ol>
<ul>
<li>所谓的管道，就是内核里面的一个<strong>环形缓存区</strong>。</li>
<li>管道传输数据是<strong>单向的</strong>。</li>
<li>管道这种通信方式<strong>效率低</strong>，不适合进程间频繁地交换数据。</li>
</ul>
<p><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/1756904280445-b042859b-6c35-4906-96de-3423613d651a.png" alt="img"></p>
<ol>
<li><strong>消息队列：</strong></li>
</ol>
<ul>
<li>消息队列是保存在内核中的<strong>消息链表</strong>。在发送数据时，会分成一个一个独立的数据单元，也就是消息体（数据块），消息体是用户自定义的数据类型，消息的发送方和接收方要约定好消息体的数据类型，所以每个消息体都是固定大小的存储块，不像管道是无格式的字节流数据。如果进程从消息队列中读取了消息体，内核就会把这个消息体删除。</li>
<li>消息队列通信过程中，存在<strong>用户态与内核态之间的数据拷贝开销</strong>，因为进程写入数据到内核中的消息队列时，会发生从用户态拷贝数据到内核态的过程，同理另一进程读取内核中的消息数据时，会发生从内核态拷贝数据到用户态的过程。</li>
</ul>
<ol>
<li><strong>共享内存：</strong></li>
</ol>
<p><strong>共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中。</strong>这样这个进程写入的东西，另外一个进程马上就能看到了，都不需要拷贝来拷贝去，传来传去，大大提高了进程间通信的速度。</p>
<p>共享内存<strong>解决了**</strong>效率低<strong><strong>和</strong></strong>用户态与内核态数据拷贝**的问题，但是存在数据覆写的风险，信号量就是为了解决这个问题。</p>
<p><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/1742176270826-751f4587-a0e1-4d2b-8831-e05d5d2649d8.png" alt="img"></p>
<ol>
<li><strong>信号量：</strong></li>
</ol>
<p>信号量其实是<strong>一个整型的**</strong>计数器<strong>，主要用于实现进程间的</strong>互斥与同步**，而不是用于缓存进程间通信的数据。</p>
<p>信号量表示资源的数量，控制信号量的方式有两种原子操作：</p>
<ul>
<li>一个是 <strong>P 操作</strong>，这个操作会把信号量减去 1，相减后如果信号量 &lt; 0，则表明资源已被占用，进程需阻塞等待；相减后如果信号量 &gt;= 0，则表明还有资源可使用，进程可正常继续执行。</li>
<li>另一个是 <strong>V 操作</strong>，这个操作会把信号量加上 1，相加后如果信号量 &lt;= 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量 &gt; 0，则表明当前没有阻塞中的进程；</li>
</ul>
<p>P 操作是用在进入共享资源之前，V 操作是用在离开共享资源之后，这两个操作是必须成对出现的。</p>
<p>信号初始化为 <code>1</code>，就代表着是<strong>互斥信号量</strong>，它可以保证共享内存在任何时刻只有一个进程在访问，这就很好的保护了共享内存。</p>
<ol>
<li><strong>信号</strong></li>
</ol>
<p>在 Linux 操作系统中， 为了响应各种各样的事件，提供了几十种信号，分别代表不同的意义。我们可以通过 <code>kill -l</code> 命令，查看所有的信号：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">kill</span> -l</span></span><br><span class="line"> 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP</span><br><span class="line"> 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1</span><br><span class="line">11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM</span><br><span class="line">16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP</span><br><span class="line">21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR</span><br><span class="line">31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-1  64) SIGRTMAX</span><br></pre></td></tr></table></figure>
<p>运行在 shell 终端的进程，我们可以通过键盘输入某些组合键的时候，给进程发送信号。例如</p>
<ul>
<li>Ctrl+C 产生 <code>SIGINT</code> 信号，表示终止该进程；</li>
<li>Ctrl+Z 产生 <code>SIGTSTP</code> 信号，表示停止该进程，但还未结束；</li>
</ul>
<p>如果进程在后台运行，可以通过 <code>kill</code> 命令的方式给进程发送信号，但前提需要知道运行中的进程 PID 号，例如：</p>
<ul>
<li>kill -9 1050 ，表示给 PID 为 1050 的进程发送 <code>SIGKILL</code> 信号，用来立即结束该进程；</li>
</ul>
<p>所以，信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令）。</p>
<p>信号是<strong>异步通信机制</strong>，因为可以在任何时候发送信号给某一进程，一旦有信号产生，我们就有下面这几种，用户进程对信号的处理方式。</p>
<p><strong>1.执行默认操作</strong>。Linux 对每种信号都规定了默认操作，例如，上面列表中的 SIGTERM 信号，就是终止进程的意思。</p>
<p><strong>2.捕捉信号</strong>。我们可以为信号定义一个信号处理函数。当信号发生时，我们就执行相应的信号处理函数。</p>
<p><strong>3.忽略信号</strong>。当我们不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。有两个信号是应用进程无法捕捉和忽略的，即 <code>SIGKILL</code> 和 <code>SEGSTOP</code>，它们用于在任何时候中断或结束某一进程。</p>
<ol>
<li><strong>Socket</strong></li>
</ol>
<p>可以实现跨主机或者本地进程之间的通信，本地字节流 socket 和 本地数据报 socket 在 bind 的时候，不像 TCP 和 UDP 要绑定 IP 地址和端口，而是<strong>绑定一个本地文件</strong>，这也就是它们之间的最大区别。</p>
<h3 id="fork创建子进程时，子进程会复用父进程的资源吗"><a href="#fork创建子进程时，子进程会复用父进程的资源吗" class="headerlink" title="fork创建子进程时，子进程会复用父进程的资源吗"></a>fork创建子进程时，子进程会复用父进程的资源吗</h3><p>在使用<code>fork</code>创建子进程时，子进程会在一定程度上复用父进程的资源，但也有一些资源是独立分配和管理的。以下是具体说明：</p>
<p><strong>内存资源</strong></p>
<ul>
<li>一般情况下，子进程会<strong>复制父进程的地址空间</strong>，包括代码段、数据段、堆和栈等。这意味着子进程拥有一份与父进程<strong>相同的内存内容的拷贝，但它们在物理上是独立的，各自有自己的地址空间</strong>。</li>
<li>不过，现代操作系统通常采用写时复制（Copy - On - Write，COW）技术来优化内存使用。在子进程创建后的一段时间内，如果父进程和子进程都没有对共享的内存区域进行写操作，那么它们实际上共享相同的物理内存页面。<strong>只有当其中一个进程试图修改某个页面时，操作系统才会为修改的进程创建一个新的物理页面来存储修改后的数据，以确保两个进程的内存空间相互独立。</strong></li>
</ul>
<p><strong>文件资源</strong></p>
<ul>
<li>子进程会继承父进程打开的文件描述符。这意味着父进程中已经打开的文件，在子进程中仍然是打开的，并且文件指针的位置也与父进程相同。</li>
<li>例如，如果父进程打开了一个文件用于读取，在<code>fork</code>之后，子进程也可以从该文件的当前位置继续读取数据（管道的原理）。不过，对文件描述符的操作，如关闭文件描述符，在父进程和子进程中是相互独立的，一个进程关闭文件描述符不会影响另一个进程对该文件的访问，除非两个进程都关闭了对应的文件描述符，否则文件不会真正被关闭。</li>
</ul>
<p><strong>其他资源</strong></p>
<ul>
<li>子进程会继承父进程的一些其他属性，如进程的当前工作目录、用户ID、组ID等。</li>
<li>但子进程有自己独立的进程ID，并且与父进程在进程调度、信号处理等方面是相互独立的。信号的处理在父进程和子进程中是独立设置的，一个进程接收到信号后执行的操作不会影响另一个进程。</li>
</ul>
<p><code>fork</code>创建的子进程会复用父进程的部分资源，这使得子进程在创建后能够快速地开始执行，同时又保证了子进程与父进程在一定程度上的独立性，以便各自进行独立的操作和资源管理。</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>主要有三种线程的实现方式：</p>
<ul>
<li><p><strong>用户线程（<em>*</em></strong>User Thread<strong>*</strong>）**：在用户空间实现的线程，不是由内核管理的线程，是由用户态的线程库来完成线程的管理；</p>
</li>
<li><p><strong>内核线程（<em>*</em></strong>Kernel Thread<strong>*</strong>）**：在内核中实现的线程，是由内核管理的线程；</p>
</li>
<li><p><strong>轻量级进程（<em>*</em></strong>LightWeight Process<strong>*</strong>）**：在内核中来支持用户线程；</p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>多对一</strong></th>
<th><strong>一对一</strong></th>
<th><strong>多对多</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/1756902195254-bb9c0f37-27f8-49fa-8e99-96df6f98a575.png" alt="img"></td>
<td><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/1756902201500-dbfcb914-dc88-4f27-8578-97b48b384f7c.png" alt="img"></td>
<td><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/1756902205746-6266d67b-3998-4471-ac74-7957f0d9dc92.png" alt="img"></td>
</tr>
</tbody>
</table>
</div>
<h3 id="用户态线程"><a href="#用户态线程" class="headerlink" title="用户态线程"></a>用户态线程</h3><p>用户级线程的模型，也就类似前面提到的<strong>多对一</strong>的关系，即多个用户线程对应同一个内核线程，如下图所示：</p>
<p><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/1756902510942-29f91aff-b1f6-4870-a05e-42eb5e20994c.png" alt="img"></p>
<p>总结：速度快，风险高。</p>
<p>用户线程的<strong>优点</strong>：</p>
<ul>
<li>每个进程都需要有它私有的线程控制块（TCB）列表，用来跟踪记录它各个线程状态信息（PC、栈指针、寄存器），TCB 由用户级线程库函数来维护，可用于不支持线程技术的操作系统；</li>
<li>用户线程的切换也是由线程库函数来完成的，无需用户态与内核态的切换，所以速度特别快；</li>
</ul>
<p>用户线程的<strong>缺点</strong>：</p>
<ul>
<li>由于操作系统不参与线程的调度，如果一个线程发起了系统调用而阻塞，那进程所包含的用户线程都不能执行了。</li>
<li>当一个线程开始运行后，除非它主动地交出 CPU 的使用权，否则它所在的进程当中的其他线程无法运行，因为用户态的线程没法打断当前运行中的线程，它没有这个特权，只有操作系统才有，但是用户线程不是由操作系统管理的。</li>
<li>由于时间片分配给进程，故与其他进程比，在多线程执行时，每个线程得到的时间片较少，执行会比较慢；</li>
</ul>
<h3 id="内核线程"><a href="#内核线程" class="headerlink" title="内核线程"></a>内核线程</h3><p>内核线程的模型，也就类似前面提到的<strong>一对一</strong>的关系，即一个用户线程对应一个内核线程，如下图所示：</p>
<p><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/1756902510942-29f91aff-b1f6-4870-a05e-42eb5e20994c.png" alt="img"></p>
<p>和用户级线程刚好反过来，速度慢，风险低。</p>
<p>内核线程的<strong>优点</strong>：</p>
<ul>
<li>在一个进程当中，如果某个内核线程发起系统调用而被阻塞，并不会影响其他内核线程的运行；</li>
<li>分配给线程，多线程的进程获得更多的 CPU 运行时间；</li>
</ul>
<p>内核线程的<strong>缺点</strong>：</p>
<ul>
<li>在支持内核线程的操作系统中，由内核来维护进程和线程的上下文信息，如 PCB 和 TCB；</li>
<li>线程的创建、终止和切换都是通过系统调用的方式来进行，因此对于系统来说，系统开销比较大；</li>
</ul>
<h3 id="轻量级进程"><a href="#轻量级进程" class="headerlink" title="轻量级进程"></a>轻量级进程</h3><p><strong>轻量级进程（<em>*</em></strong>Light-weight process，LWP<strong>*</strong>）是内核支持的用户线程，一个进程可有一个或多个 LWP，每个 LWP 是跟内核线程一对一映射的，也就是 LWP 都是由一个内核线程支持，而且 LWP 是由内核管理并像普通进程一样被调度**。</p>
<p><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/1756902990444-05def627-4703-4be2-8a7a-a1e4c1648716.png" alt="img"></p>
<p><strong>1 : 1 模式</strong></p>
<p>一个线程对应到一个 LWP 再对应到一个内核线程，如上图的进程 4，属于此模型。</p>
<ul>
<li>优点：实现并行，当一个 LWP 阻塞，不会影响其他 LWP；</li>
<li>缺点：每一个用户线程，就产生一个内核线程，创建线程的开销较大。</li>
</ul>
<p><strong>N : 1 模式</strong></p>
<p>多个用户线程对应一个 LWP 再对应一个内核线程，如上图的进程 2，线程管理是在用户空间完成的，此模式中用户的线程对操作系统不可见。</p>
<ul>
<li>优点：用户线程要开几个都没问题，且上下文切换发生用户空间，切换的效率较高；</li>
<li>缺点：一个用户线程如果阻塞了，则整个进程都将会阻塞，另外在多核 CPU 中，是没办法充分利用 CPU 的。</li>
</ul>
<p><strong>M : N 模式</strong></p>
<p>根据前面的两个模型混搭一起，就形成 <code>M:N</code> 模型，该模型提供了两级控制，首先多个用户线程对应到多个 LWP，LWP 再一一对应到内核线程，如上图的进程 3。</p>
<ul>
<li>优点：综合了前两种优点，大部分的线程上下文发生在用户空间，且多个线程又可以充分利用多核 CPU 的资源。</li>
</ul>
<p><strong>组合模式</strong></p>
<p>如上图的进程 5，此进程结合 <code>1:1</code> 模型和 <code>M:N</code> 模型。开发人员可以针对不同的应用特点调节内核线程的数目来达到物理并行性和逻辑并行性的最佳方案。</p>
<h3 id="线程崩溃了进程也会崩溃吗？"><a href="#线程崩溃了进程也会崩溃吗？" class="headerlink" title="线程崩溃了进程也会崩溃吗？"></a>线程崩溃了进程也会崩溃吗？</h3><p>答案：是的，线程共享资源，为了避免影响其他线程，干脆直接停掉，但也存在特殊情况，如果进程自定义了信号处理函数且信号并不是 kill -9 这种强制命令，那么可能忽略停止操作。</p>
<p>通过信号的方式停止进程，其背后的机制如下：</p>
<ol>
<li>CPU 执行正常的进程指令。</li>
<li>调用 kill 系统调用向进程发送信号（假设为 11，即 SIGSEGV，一般非法访问内存报的都是这个错误）。</li>
<li>进程收到操作系统发的信号，CPU 暂停当前程序运行，并将控制权转交给操作系统。</li>
<li><strong>操作系统根据情况执行相应的信号处理程序（函数），一般执行完信号处理程序逻辑后会让进程退出。</strong></li>
</ol>
<p>注意上面的第五步，如果进程没有注册自己的信号处理函数，那么操作系统会执行默认的信号处理程序（一般最后会让进程退出），但如果注册了，则会执行自己的信号处理函数，这样的话就给了进程一个垂死挣扎的机会，它收到 kill 信号后，可以调用 exit() 来退出，<strong>但也可以使用 sigsetjmp，siglongjmp 这两个函数来恢复进程的执行。</strong></p>
<p>为什么线程崩溃不会导致 JVM 进程崩溃？</p>
<p>这个问题也有答案了，JVM 自定义了信号处理函数。</p>
<h3 id="线程栈空间溢出怎么办？"><a href="#线程栈空间溢出怎么办？" class="headerlink" title="线程栈空间溢出怎么办？"></a>线程栈空间溢出怎么办？</h3><p>每个操作系统创建线程时会为它分配栈空间，有一个默认大小，Linux 是 8MB，每个线程的栈空间大小是可以通过代码调整的，溢出会触发<strong>段错误</strong>。</p>
<h3 id="线程上下文的切换的详细过程？"><a href="#线程上下文的切换的详细过程？" class="headerlink" title="线程上下文的切换的详细过程？"></a>线程上下文的切换的详细过程？</h3><p><strong>详细过程：</strong></p>
<p>线程切换的详细过程可以分为以下几个步骤：</p>
<ul>
<li><strong>上下文保存</strong>：当操作系统决定切换到另一个线程时，它首先会保存当前线程的上下文信息。上下文信息包括<strong>一些 CPU 信息（寄存器状态（程序计数器、通用寄存器等）） 、栈指针、**</strong>栈中的数据**等，用于保存线程的执行状态。</li>
<li><strong>切换到调度器</strong>：操作系统将执行权切换到调度器（Scheduler）。调度器负责选择下一个要执行的线、程，并根据调度算法做出决策。</li>
<li><strong>上下文恢复</strong>：调度器选择了下一个要执行的线程后，它会从该线程保存的上下文信息中恢复线程的执行状态。</li>
<li><strong>切换到新线程</strong>：调度器将执行权切换到新线程，使其开始执行。</li>
</ul>
<p>上下文信息的保存通常由操作系统负责管理，具体保存在哪里取决于操作系统的实现方式。一般情况下，上下文信息会保存在<strong>线程的控制块</strong>（Thread Control Block，TCB）中。</p>
<p><strong>TCB</strong>是操作系统用于管理线程的数据结构，包含了线程的状态、寄存器的值、堆栈信息等。当发生线程切换时，操作系统会通过切换TCB来保存和恢复线程的上下文信息</p>
<h3 id="线程相比进程能减少开销体现在哪里？"><a href="#线程相比进程能减少开销体现在哪里？" class="headerlink" title="线程相比进程能减少开销体现在哪里？"></a>线程相比进程能减少开销体现在哪里？</h3><ul>
<li><strong>内存管理共享</strong>：线程共享进程的虚拟地址空间、堆、全局变量等，因此切换线程时无需保存或切换页表、段表等虚拟地址映射信息。</li>
<li><strong>文件与I/O共享</strong>：线程共享进程的文件描述符表和其他内核资源，无需切换文件句柄或打开文件状态。</li>
<li><strong>上下文切换粒度小</strong>：线程切换只需保存和恢复 CPU 寄存器、栈指针和少量线程局部状态，而不涉及完整 PCB 信息。</li>
</ul>
<p><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/28a3cc75ad448c561a2f4edb600de5f5.svg" alt="img"></p>
<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>多线程编程是比较困难的，因为调度程序任何时候都能中断线程， 必须保留锁，去保护程序中重要部分，防止多线程在执行的过程中断。</p>
<p>而协程默认会做好全方位保护， 以防止中断。我们必须显示产出才能让程序的余下部分运行。对协程来说， 无需保留锁， 而在多个线程之间同步操作， 协程自身就会同步， 因为在任意时刻， 只有一个协程运行。总结下大概下面几点：</p>
<ul>
<li>无需系统内核的上下文切换，减小开销；</li>
<li>无需原子操作锁定及同步的开销，不用担心资源共享的问题；</li>
<li>单线程即可实现高并发，单核 CPU 即便支持上万的协程都不是问题，所以很适合用于高并发处理，尤其是在应用在网络爬虫中。</li>
</ul>
<p>同时也存在一些缺点：</p>
<ul>
<li>无法使用 CPU 的多核</li>
</ul>
<p>协程的本质是个单线程，它不能同时用 CPU 的多个核，协程需要和进程配合才能运行在多CPU上。当然我们日常所编写的绝大部分应用都没有这个必要，就比如网络爬虫来说，限制爬虫的速度还有其他的因素，比如网站并发量、网速等问题都会是爬虫速度限制的因素。除非做一些密集型应用，这个时候才可能会用到多进程和协程。</p>
<ul>
<li>处处都要使用非阻塞代码</li>
</ul>
<p>写协程就意味着你要一值写一些非阻塞的代码，使用各种异步版本的库，比如后面的异步爬虫教程中用的aiohttp就是一个异步版本的request库等。 不过这些缺点并不能影响到使用协程的优势。</p>
<h2 id="进程可以创建多少个线程？"><a href="#进程可以创建多少个线程？" class="headerlink" title="进程可以创建多少个线程？"></a>进程可以创建多少个线程？</h2><p>创建一个线程，分配的资源只有栈空间，程序计数器是存储在 CPU 寄存器硬件资源里的，而每个操作系统分配的栈空间是有默认大小的，所以理论上根据操作系统位数（32bit 或者 64bit）就可以得到虚拟内存大小，根据虚拟内存大小和为线程分配栈空间大小就可以计算出最多可以分配多少个线程，这个值在 64bit 系统内是几千万。</p>
<p>但实际上线程最大数量<strong>还受系统参数的影响</strong>。</p>
<ul>
<li><strong><em>/proc/sys/kernel/threads-max\</em></strong>，表示系统支持的最大线程数，默认值是 <code>14553</code>；</li>
<li><strong><em>/proc/sys/kernel/pid_max\</em></strong>，表示系统全局的 PID 号数值的限制，每一个进程或线程都有 ID，ID 的值超过这个数，进程或线程就会创建失败，默认值是 <code>32768</code>；</li>
<li><strong><em>/proc/sys/vm/max_map_count\</em></strong>，表示限制一个进程可以拥有的VMA(虚拟内存区域)的数量，具体什么意思我也没搞清楚，反正如果它的值很小，也会导致创建线程失败，默认值是 <code>65530</code>。</li>
</ul>
<h2 id="线程间通讯有什么方式？"><a href="#线程间通讯有什么方式？" class="headerlink" title="线程间通讯有什么方式？"></a>线程间通讯有什么方式？</h2><p><a href="https://xiaolincoding.com/interview/os.html#线程间通讯有什么方式">https://xiaolincoding.com/interview/os.html#%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E8%AE%AF%E6%9C%89%E4%BB%80%E4%B9%88%E6%96%B9%E5%BC%8F</a></p>
<h2 id="浏览器为什么使用多进程而不是多线程？"><a href="#浏览器为什么使用多进程而不是多线程？" class="headerlink" title="浏览器为什么使用多进程而不是多线程？"></a>浏览器为什么使用多进程而不是多线程？</h2><p>虽然多线程在某些场景下性能表现出色，但很多程序（如浏览器）依旧选择多进程模型，主要是基于稳定性、安全性、资源管理和兼容性等多方面的综合考量，以下为你详细分析：</p>
<p><strong>稳定性（主要）</strong></p>
<ul>
<li><strong>进程隔离优势</strong>：进程间拥有独立的内存空间和系统资源，一个进程崩溃时，不会对其他进程造成影响。以浏览器为例，各个标签页通常运行在独立的进程中，如果某个标签页因恶意脚本或代码错误崩溃，不会导致整个浏览器或其他标签页关闭，用户可以继续使用其他功能。</li>
<li><strong>线程崩溃影响</strong>：多线程程序中，所有线程共享同一进程的内存空间，若一个线程出现错误（如访问非法内存），可能会导致整个进程崩溃，影响程序的正常运行。</li>
</ul>
<p><strong>资源管理（方便）</strong></p>
<ul>
<li><strong>独立资源分配</strong>：每个进程可以独立分配和管理资源，如CPU、内存等。浏览器可以根据不同标签页的需求，灵活分配资源，避免某个标签页占用过多资源而影响其他标签页的性能。</li>
<li><strong>线程资源竞争</strong>：多线程程序中，线程之间会竞争共享资源，需要使用同步机制（如锁）来保证数据的一致性，但这可能会导致性能下降，甚至出现死锁等问题。</li>
</ul>
<p><strong>安全性</strong></p>
<ul>
<li><strong>进程沙箱机制</strong>：多进程模型便于实现更严格的安全策略，例如为不同进程设置沙箱。浏览器可以将渲染进程放在沙箱中运行，限制其对系统资源的访问权限，防止恶意网页利用漏洞攻击系统。</li>
<li><strong>线程安全隐患</strong>：多线程环境下，由于线程共享内存，数据竞争和同步问题较为复杂，容易出现安全漏洞。攻击者可能利用这些漏洞进行数据篡改或执行恶意代码。</li>
</ul>
<p><strong>兼容性（给不同编程语言和技术实现的插件提供不同的环境）</strong></p>
<ul>
<li><strong>支持不同类型插件</strong>：一些程序（如浏览器）需要支持各种类型的插件，这些插件可能使用不同的编程语言和技术实现。多进程模型可以为每个插件提供独立的运行环境，避免插件之间的兼容性问题。</li>
<li><strong>线程兼容性挑战</strong>：多线程环境下，不同插件的代码可能会相互影响，导致兼容性问题，增加开发和维护的难度。</li>
</ul>
<p><strong>多核利用</strong></p>
<ul>
<li><strong>充分利用多核CPU</strong>：多进程模型可以更好地利用多核CPU的并行计算能力，每个进程可以在不同的CPU核心上独立运行，提高程序的整体性能。</li>
<li><strong>线程并行限制</strong>：虽然多线程也能利用多核CPU，但由于线程之间的同步和竞争问题，可能无法充分发挥多核CPU的优势。</li>
</ul>
<h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><p>Linux 文件系统会为每个文件分配两个数据结构：<strong>索引节点（<em>*</em></strong>index node<strong>*</strong>）和目录项（<strong>*</strong>directory entry<strong>*</strong>）**，它们主要用来记录文件的元信息和目录层次结构。</p>
<ul>
<li>索引节点，也就是 <em>inode</em>，用来记录文件的元信息，比如 inode 编号、文件大小、访问权限、创建时间、修改时间、<strong>数据在磁盘的位置</strong>等等。索引节点是文件的<strong>唯一</strong>标识，它们之间一一对应，也同样都会被存储在硬盘中，所以<strong>索引节点同样占用磁盘空间</strong>。</li>
<li>目录项，也就是 <em>dentry</em>，用来记录文件的名字、<strong>索引节点指针</strong>以及与其他目录项的层级关联关系。多个目录项关联起来，就会形成目录结构，但它与索引节点不同的是，<strong>目录项是由内核维护的一个数据结构，不存放于磁盘，而是缓存在内存</strong>。</li>
</ul>
<p>由于索引节点唯一标识一个文件，而目录项记录着文件的名字，所以目录项和索引节点的关系是多对一，也就是说，一个文件可以有多个别名。比如，<strong>硬链接</strong>的实现就是多个目录项中的索引节点指向同一个文件。</p>
<p><strong>注意：</strong>目录也是文件，也是用索引节点唯一标识，与目录项是一对多的关系，目录项是内存的数据结构，缓存在内存。目录是磁盘上的文件，和普通文件不同的是，普通文件在磁盘里面保存的是文件数据，而目录文件在磁盘里面保存子目录或文件。</p>
<p><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/1756954525938-2fe29342-5392-4b74-bf26-fafe7ad58698.png" alt="img"></p>
<p>索引节点是存储在硬盘上的数据，那么为了加速文件的访问，通常会把索引节点加载到内存中。</p>
<p>另外，磁盘进行格式化的时候，会被分成三个存储区域，分别是超级块、索引节点区和数据块区。</p>
<ul>
<li><em>超级块</em>，用来存储文件系统的详细信息，比如块个数、块大小、空闲块等等。</li>
<li><em>索引节点区</em>，用来存储索引节点；</li>
<li><em>数据块区</em>，用来存储文件或目录数据；</li>
</ul>
<p>我们不可能把超级块和索引节点区全部加载到内存，这样内存肯定撑不住，所以只有当需要使用的时候，才将其加载进内存，它们加载进内存的时机是不同的：</p>
<ul>
<li>超级块：当文件系统挂载时进入内存；</li>
<li>索引节点区：当文件被访问时进入内存；</li>
</ul>
<h2 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h2><p>文件系统的种类众多，而操作系统希望<strong>对用户提供一个统一的接口</strong>，于是在用户层与文件系统层引入了中间层，这个中间层就称为<strong>虚拟文件系统（<em>*</em></strong>Virtual File System，VFS<strong>*</strong>）。**</p>
<p><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/1756954525938-2fe29342-5392-4b74-bf26-fafe7ad58698.png" alt="img"></p>
<p>Linux 支持的文件系统也不少，根据存储位置的不同，可以把文件系统分为三类：</p>
<ul>
<li><em>磁盘的文件系统</em>，它是直接把数据存储在磁盘中，比如 Ext 2/3/4、XFS 等都是这类文件系统。</li>
<li><em>内存的文件系统</em>，这类文件系统的数据不是存储在硬盘的，而是占用内存空间，我们经常用到的 <code>/proc</code> 和 <code>/sys</code> 文件系统都属于这一类，读写这类文件，实际上是读写内核中相关的数据。</li>
<li><em>网络的文件系统</em>，用来访问其他计算机主机数据的文件系统，比如 NFS、SMB 等等。</li>
</ul>
<p>文件系统首先要先挂载到某个目录才可以正常使用，比如 Linux 系统在启动时，会把文件系统挂载到根目录。</p>
<h2 id="虚拟内存和文件系统的关系"><a href="#虚拟内存和文件系统的关系" class="headerlink" title="虚拟内存和文件系统的关系"></a>虚拟内存和文件系统的关系</h2><p>磁盘的数据不都是以文件的形式组织的，磁盘划分了一块 swap 区域专门给虚拟内存换入换出使用，既进程堆里面对象、栈的数据、BSS 段数据都是直接存储在磁盘中的，它们可以称为匿名页，如果要进入内存只能通过两种方式：swap 分区、swap 文件：</p>
<p><strong>Swap 分区（Swap Partition）</strong></p>
<ul>
<li>专门划出的磁盘区域，只用于虚拟内存换出。</li>
<li>系统知道每个页在 swap 分区的偏移位置。</li>
</ul>
<p><strong>Swap 文件（Swap File）</strong></p>
<ul>
<li>普通文件，但内核直接操作它的页块，绕过普通文件访问接口。</li>
<li>文件系统本身不知道这些页存放在 swap 文件里对应的哪块，内核维护映射表（页 → swap offset）。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>页类型</strong></th>
<th><strong>磁盘位置</strong></th>
<th><strong>谁管理</strong></th>
<th><strong>文件系统知道吗？</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>文件映射页</strong></td>
<td>文件系统中的文件块</td>
<td>VFS + VM</td>
<td>是</td>
</tr>
<tr>
<td><strong>匿名页</strong></td>
<td>Swap 分区 / Swap 文件</td>
<td>VM 内核管理</td>
<td>否（文件系统不知道具体位置）</td>
</tr>
</tbody>
</table>
</div>
<p>它们都是使用<strong>块设备驱动（Block Device Driver）</strong> 操作磁盘。</p>
<p>块设备驱动负责与磁盘硬件交互，包括：</p>
<ul>
<li>读/写扇区</li>
<li>DMA 传输</li>
<li>调度 I/O 请求</li>
</ul>
<p>不同的上层模块（VFS、VM）只是组织和调度 I/O 的方式不同，但<strong>物理磁盘访问都是通过同一套驱动</strong>。</p>
<h2 id="文件描述符表、打开文件表"><a href="#文件描述符表、打开文件表" class="headerlink" title="文件描述符表、打开文件表"></a>文件描述符表、打开文件表</h2><p>在类 Unix 系统里，和文件相关的有三类重要的数据结构：</p>
<ol>
<li><strong>进程级：文件描述符表（per-process file descriptor table）</strong></li>
</ol>
<ul>
<li>每个进程独有。</li>
<li>存放「文件描述符 → 打开文件表项的指针」。</li>
</ul>
<ol>
<li><strong>系统级：打开文件表（system-wide open file table）</strong></li>
</ol>
<ul>
<li>操作系统内核维护，所有进程共享。</li>
<li><p>每个表项包含：</p>
</li>
<li><p>文件读/写偏移量（file offset）</p>
</li>
<li>文件状态标志（读/写/追加等）</li>
<li>指向 vnode/inode 的指针</li>
</ul>
<ol>
<li><strong>文件系统级：inode 表（vnode/inode table）</strong></li>
</ol>
<ul>
<li>记录文件的元数据（权限、大小、数据块地址等）。</li>
</ul>
<p>操作系统在打开文件表中维护着打开文件的状态和信息：</p>
<ul>
<li>文件指针：系统跟踪上次读写位置作为当前文件位置指针，这种指针对打开文件的某个进程来说是唯一的；</li>
<li>文件打开计数器：文件关闭时，操作系统必须重用其打开文件表条目，否则表内空间不够用。因为多个进程可能打开同一个文件，所以系统在删除打开文件条目之前，必须等待最后一个进程关闭文件，该计数器跟踪打开和关闭的数量，当该计数为 0 时，系统关闭文件，删除该条目；</li>
<li>文件磁盘位置：绝大多数文件操作都要求系统修改文件数据，该信息保存在内存中，以免每个操作都从磁盘中读取；</li>
<li>访问权限：每个进程打开文件都需要有一个访问模式（创建、只读、读写、添加等），该信息保存在进程的打开文件表中，以便操作系统能允许或拒绝之后的 I/O 请求；</li>
</ul>
<p>用户和操作系统对文件的读写操作是有差异的，<strong>用户习惯以字节的方式读写文件，而操作系统则是以数据块来读写文件</strong>，那屏蔽掉这种差异的工作就是文件系统了。</p>
<h2 id="磁盘文件组织方式"><a href="#磁盘文件组织方式" class="headerlink" title="磁盘文件组织方式"></a>磁盘文件组织方式</h2><h3 id="1-连续分配（Contiguous-Allocation）"><a href="#1-连续分配（Contiguous-Allocation）" class="headerlink" title="1. 连续分配（Contiguous Allocation）"></a>1. 连续分配（Contiguous Allocation）</h3><p><strong>定义：</strong></p>
<ul>
<li>为文件分配一组连续的磁盘块（物理地址连续）。</li>
<li>文件的目录项只需记录：起始块号 + 长度。</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>顺序访问性能最佳（磁盘只需一次定位）。</li>
<li>随机访问性能也很好（起始块号+偏移即可）。</li>
<li>实现简单。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>文件在创建时必须知道最大长度，不利于动态增长。</li>
<li>会产生<strong>外部碎片</strong>，空闲块可能被切割零散。</li>
<li>文件扩展时可能需要搬迁整个文件，代价大。</li>
</ul>
<h3 id="2-隐式链表分配（Linked-Allocation-隐式链表）"><a href="#2-隐式链表分配（Linked-Allocation-隐式链表）" class="headerlink" title="2. 隐式链表分配（Linked Allocation, 隐式链表）"></a>2. 隐式链表分配（Linked Allocation, 隐式链表）</h3><p><strong>定义：</strong></p>
<ul>
<li>每个文件由一条链表连接的磁盘块组成。</li>
<li>每个磁盘块里存放下一个磁盘块的地址（类似链表“next”指针）。</li>
<li>目录项只需记录：起始块号。</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>文件可动态增长（只需在末尾追加新块）。</li>
<li>不会产生外部碎片（只要有空闲块就能用）。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>随机访问性能差</strong>，要从头顺着链表走。</li>
<li>每个块要存指针，浪费存储空间。</li>
<li>指针丢失或损坏，整个链表可能断裂（文件损坏）。</li>
</ul>
<h3 id="3-显式链表分配（File-Allocation-Table-FAT-方式）"><a href="#3-显式链表分配（File-Allocation-Table-FAT-方式）" class="headerlink" title="3. 显式链表分配（File Allocation Table, FAT 方式）"></a>3. 显式链表分配（File Allocation Table, FAT 方式）</h3><p><strong>定义：</strong></p>
<ul>
<li>不把“下一个块的地址”存在数据块中，而是存在一张<strong>文件分配表（FAT）</strong>里。</li>
<li>FAT 表在内存中缓存，目录项只需记录：起始块号。</li>
<li>FAT[块号] = 下一块的地址。</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>随机访问比隐式链表快，可以在内存中快速查找 FAT。</li>
<li>仍然支持文件动态增长。</li>
<li>数据块里不再存指针，空间利用率更高。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>FAT 表本身可能很大（磁盘块数目多时）。</li>
<li>FAT 表损坏会导致文件丢失。</li>
<li>文件仍然不支持真正的直接随机定位（要查表走链）。</li>
</ul>
<h3 id="4-索引分配（Indexed-Allocation）"><a href="#4-索引分配（Indexed-Allocation）" class="headerlink" title="4. 索引分配（Indexed Allocation）"></a>4. 索引分配（Indexed Allocation）</h3><p><strong>定义：</strong></p>
<ul>
<li>给每个文件分配一个<strong>索引块</strong>，里面保存该文件所有数据块的地址。</li>
<li>目录项只需记录：索引块号。</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>随机访问性能好（可直接通过索引定位）。</li>
<li>支持文件动态增长（只需增加索引项）。</li>
<li>没有外部碎片问题。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>索引块本身要占用额外存储空间。</li>
<li>对于大文件，单个索引块可能不够，需要多级索引（比如 Unix inode 的直接/间接/多级索引）。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><div class="table-container">
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>顺序访问</strong></th>
<th><strong>随机访问</strong></th>
<th><strong>空间利用率</strong></th>
<th><strong>动态增长</strong></th>
<th><strong>碎片问题</strong></th>
<th><strong>实现复杂度</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>连续分配</strong></td>
<td>很好</td>
<td>很好</td>
<td>有外部碎片</td>
<td>不好</td>
<td>外部碎片</td>
<td>简单</td>
</tr>
<tr>
<td><strong>隐式链表分配</strong></td>
<td>一般</td>
<td>很差</td>
<td>有指针开销</td>
<td>好</td>
<td>无</td>
<td>简单</td>
</tr>
<tr>
<td><strong>显式链表分配</strong></td>
<td>一般</td>
<td>一般</td>
<td>较好</td>
<td>好</td>
<td>无</td>
<td>中等</td>
</tr>
<tr>
<td><strong>索引分配</strong></td>
<td>好</td>
<td>好</td>
<td>索引开销</td>
<td>好</td>
<td>无</td>
<td>较复杂</td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/1756956619991-fc419cc1-fe8d-4e64-b95c-25d6e70727c6.png" alt="img"></p>
<h3 id="linux-选择的方式"><a href="#linux-选择的方式" class="headerlink" title="linux 选择的方式"></a>linux 选择的方式</h3><p><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/1756956645361-05f31a5b-fbbd-4418-9014-1e43bfa695da.png" alt="img"></p>
<p>它是根据文件的大小，存放的方式会有所变化：</p>
<ul>
<li>如果存放文件所需的数据块小于 10 块，则采用直接查找的方式；</li>
<li>如果存放文件所需的数据块超过 10 块，则采用一级间接索引方式；</li>
<li>如果前面两种方式都不够存放大文件，则采用二级间接索引方式；</li>
<li>如果二级间接索引也不够存放大文件，这采用三级间接索引方式；</li>
</ul>
<p>那么，文件头（<em>Inode</em>）就需要包含 13 个指针：</p>
<ul>
<li>10 个指向数据块的指针；</li>
<li>第 11 个指向索引块的指针；</li>
<li>第 12 个指向二级索引块的指针；</li>
<li>第 13 个指向三级索引块的指针；</li>
</ul>
<p>所以，这种方式能很灵活地支持小文件和大文件的存放：</p>
<ul>
<li>对于小文件使用直接查找的方式可减少索引数据块的开销；</li>
<li>对于大文件则以多级索引的方式来支持，所以大文件在访问数据块时需要大量查询；</li>
</ul>
<p>这个方案就用在了 Linux Ext 2/3 文件系统里，虽然解决大文件的存储，但是对于大文件的访问，需要大量的查询，效率比较低。</p>
<h2 id="空闲空间管理"><a href="#空闲空间管理" class="headerlink" title="空闲空间管理"></a>空闲空间管理</h2><h3 id="空闲表法"><a href="#空闲表法" class="headerlink" title="空闲表法"></a>空闲表法</h3><p>空闲表法就是为所有空闲空间建立一张表，表内容包括空闲区的第一个块号和该空闲区的块个数，注意，这个方式是连续分配的。如下图：</p>
<p><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/1756956645361-05f31a5b-fbbd-4418-9014-1e43bfa695da.png" alt="img"></p>
<p>这种方法仅当有少量的空闲区时才有较好的效果。因为，如果存储空间中有着大量的小的空闲区，则空闲表变得很大，这样查询效率会很低。另外，这种分配技术适用于建立连续文件。</p>
<h3 id="空闲链表法"><a href="#空闲链表法" class="headerlink" title="空闲链表法"></a>空闲链表法</h3><p>我们也可以使用「链表」的方式来管理空闲空间，每一个空闲块里有一个指针指向下一个空闲块，这样也能很方便的找到空闲块并管理起来。如下图：<br><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/1756956940405-0bf86939-7385-4b25-b5a7-cf99f7037bdb.png" alt="img"></p>
<p>空闲表法和空闲链表法都不适合用于大型文件系统，因为这会使空闲表或空闲链表太大。</p>
<h3 id="位图法"><a href="#位图法" class="headerlink" title="位图法"></a>位图法</h3><p>位图是利用二进制的一位来表示磁盘中一个盘块的使用情况，磁盘上所有的盘块都有一个二进制位与之对应。</p>
<p>当值为 0 时，表示对应的盘块空闲，值为 1 时，表示对应的盘块已分配。它形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1111110011111110001110110111111100111 ...</span><br></pre></td></tr></table></figure>
<p>在 Linux 文件系统就采用了位图的方式来管理空闲空间，不仅用于数据空闲块的管理，还用于 inode 空闲块的管理，因为 inode 也是存储在磁盘的，自然也要有对其管理。</p>
<h3 id="Linux-选择方式"><a href="#Linux-选择方式" class="headerlink" title="Linux 选择方式"></a>Linux 选择方式</h3><p>下图给出了 Linux Ext2 整个文件系统的结构和块组的内容，文件系统都由大量块组组成，在硬盘上相继排布：</p>
<p><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/1756957020317-6d048760-3335-4214-8c13-46465ba976a1.png" alt="img"></p>
<p>最前面的第一个块是引导块，在系统启动时用于启用引导，接着后面就是一个一个连续的块组了，块组的内容如下：</p>
<ul>
<li><em>超级块</em>，包含的是文件系统的重要信息，比如 inode 总个数、块总个数、每个块组的 inode 个数、每个块组的块个数等等。</li>
<li><em>块组描述符</em>，包含文件系统中各个块组的状态，比如块组中空闲块和 inode 的数目等，每个块组都包含了文件系统中「所有块组的组描述符信息」。</li>
<li><em>数据位图和 inode 位图</em>， 用于表示对应的数据块或 inode 是空闲的，还是被使用中。</li>
<li><em>inode 列表</em>，包含了块组中所有的 inode，inode 用于保存文件系统中与各个文件和目录相关的所有元数据。</li>
<li><em>数据块</em>，包含文件的有用数据。</li>
</ul>
<p>你可以会发现每个块组里有很多重复的信息，比如<strong>超级块和块组描述符表，这两个都是全局信息，而且非常的重要</strong>，这么做是有两个原因：</p>
<ul>
<li>如果系统崩溃破坏了超级块或块组描述符，有关文件系统结构和内容的所有信息都会丢失。如果有冗余的副本，该信息是可能恢复的。</li>
<li>通过使文件和管理数据尽可能接近，减少了磁头寻道和旋转，这可以提高文件系统的性能。</li>
</ul>
<p>不过，Ext2 的后续版本采用了稀疏技术。该做法是，超级块和块组描述符表不再存储到文件系统的每个块组中，而是只写入到块组 0、块组 1 和其他 ID 可以表示为 3、 5、7 的幂的块组中。</p>
<h2 id="目录的存储"><a href="#目录的存储" class="headerlink" title="目录的存储"></a>目录的存储</h2><p><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/1756957107404-9c7375c3-c6f8-4437-a38c-38d5990b850a.png" alt="img"></p>
<p>如果一个目录有超级多的文件，我们要想在这个目录下找文件，按照列表一项一项的找，效率就不高了。</p>
<p>于是，保存目录的格式改成<strong>哈希表</strong>，对文件名进行哈希计算，把哈希值保存起来，如果我们要查找一个目录下面的文件名，可以通过名称取哈希。如果哈希能够匹配上，就说明这个文件的信息在相应的块里面。</p>
<p>Linux 系统的 ext 文件系统就是采用了哈希表，来保存目录的内容，这种方法的优点是查找非常迅速，插入和删除也较简单，不过需要一些预备措施来避免哈希冲突。</p>
<p>目录查询是通过在磁盘上反复搜索完成，需要不断地进行 I/O 操作，开销较大。所以，为了减少 I/O 操作，<strong>把当前使用的文件目录缓存在内存</strong>，以后要使用该文件时只要在内存中操作，从而降低了磁盘操作次数，提高了文件系统的访问速度。</p>
<h2 id="软链接和硬链接"><a href="#软链接和硬链接" class="headerlink" title="软链接和硬链接"></a>软链接和硬链接</h2><p><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/1756957107404-9c7375c3-c6f8-4437-a38c-38d5990b850a.png" alt="img"></p>
<p>硬链接是<strong>多个目录项中的「索引节点」指向一个文件</strong>，也就是指向同一个 inode，但是 inode 是不可能跨越文件系统的，每个文件系统都有各自的 inode 数据结构和列表，所以<strong>硬链接是不可用于跨文件系统的</strong>。由于多个目录项都是指向一个 inode，那么<strong>只有删除文件的所有硬链接以及源文件时，系统才会彻底删除该文件。</strong></p>
<p><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/1756957231659-94f42935-a22d-42e1-9869-9f1d180f5fbd.png" alt="img"></p>
<p>软链接相当于重新创建一个文件，这个文件有<strong>独立的 inode</strong>，但是这个<strong>文件的内容是另外一个文件的路径</strong>，所以访问软链接的时候，实际上相当于访问到了另外一个文件，所以<strong>软链接是可以跨文件系统的</strong>，甚至<strong>目标文件被删除了，链接文件还是在的，只不过指向的文件找不到了而已。</strong></p>
<h2 id="文件-I-O"><a href="#文件-I-O" class="headerlink" title="文件 I/O"></a>文件 I/O</h2><p>文件的读写方式各有千秋，对于文件的 I/O 分类也非常多，常见的有</p>
<ul>
<li>缓冲与非缓冲 I/O</li>
<li>直接与非直接 I/O</li>
<li>阻塞与非阻塞 I/O VS 同步与异步 I/O</li>
</ul>
<p>接下来，分别对这些分类讨论讨论。</p>
<h3 id="缓冲与非缓冲-I-O（用户态标准库层面）"><a href="#缓冲与非缓冲-I-O（用户态标准库层面）" class="headerlink" title="缓冲与非缓冲 I/O（用户态标准库层面）"></a>缓冲与非缓冲 I/O（用户态标准库层面）</h3><ul>
<li><strong>层次</strong>：用户态（标准 C 库，如 <code>stdio.h</code> 的 <code>fread</code>/<code>fwrite</code>）</li>
<li><strong>定义</strong>：是否利用 <strong>标准库内部缓冲区（用户态缓冲区）</strong>。</li>
</ul>
<p>文件操作的标准库是可以实现数据的缓存，那么<strong>根据「是否利用标准库缓冲」，可以把文件 I/O 分为缓冲 I/O 和非缓冲 I/O</strong>：</p>
<ul>
<li>缓冲 I/O，利用的是标准库的缓存实现文件的加速访问，而标准库再通过系统调用访问文件。</li>
<li>非缓冲 I/O，直接通过系统调用访问文件，不经过标准库缓存。</li>
</ul>
<p>这里所说的「缓冲」特指标准库内部实现的缓冲。</p>
<p>比方说，很多程序遇到换行时才真正输出，而换行前的内容，其实就是被标准库暂时缓存了起来，这样做的目的是，减少系统调用的次数，毕竟系统调用是有 CPU 上下文切换的开销的。</p>
<h3 id="直接与非直接-I-O（内核-磁盘访问层面）"><a href="#直接与非直接-I-O（内核-磁盘访问层面）" class="headerlink" title="直接与非直接 I/O（内核/磁盘访问层面）"></a>直接与非直接 I/O（内核/磁盘访问层面）</h3><p><strong>根据是「否利用操作系统的缓存PageCache」，可以把文件 I/O 分为直接 I/O 与非直接 I/O</strong>：</p>
<ul>
<li>直接 I/O，不会发生内核缓存和用户程序之间数据复制，而是直接经过文件系统访问磁盘。</li>
<li>非直接 I/O，读操作时，数据从内核缓存中拷贝给用户程序，写操作时，数据从用户程序拷贝给内核缓存，再由内核决定什么时候写入数据到磁盘。</li>
</ul>
<p>如果你在使用文件操作类的系统调用函数时，指定了 <code>O_DIRECT</code> 标志，则表示使用直接 I/O。如果没有设置过，默认使用的是非直接 I/O。</p>
<p><strong>PageCache 的作用</strong>：PageCache 是一个内核缓冲区，进程从磁盘读的内容都先经过这里，然后再走向用户缓冲区，目的是起到缓存复用的作用，可能两个进程访问同一个数据，只要一个进程访问缓存以后，第二个进程就不需要再读磁盘了。同理进程向磁盘写数据也会经过这个缓冲区。</p>
<p>还有一点，读取磁盘数据的时候，需要找到数据所在的位置，但是对于机械磁盘来说，就是通过磁头旋转到数据所在的扇区，再开始「顺序」读取数据，但是旋转磁头这个物理动作是非常耗时的，为了降低它的影响，<strong>PageCache 使用了「预读功能」</strong>。</p>
<p>所以，PageCache 的优点主要是两个：</p>
<ul>
<li><strong>缓存最近被访问的数据；</strong></li>
<li><p><strong>预读功能；</strong></p>
<p>Page Cache 由多个 page 构成。page 在操作系统中通常为 4KB 大小（32bits/64bits），而 Page Cache 的大小则为 4KB 的整数倍。</p>
</li>
</ul>
<p>但<strong>针对大文件的读取</strong>，不应该使用 PageCache，因为大文件会把整个 PageCache 占满，而且大文件使用 read 调用程序会等待磁盘数据准备完成，导致阻塞很久，所以针对大文件的读写，应该采用<strong>异步 IO+直接 IO 的方式。</strong></p>
<p><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/1756973618870-502cc27d-69d5-4aaf-ae7a-20924bd37515.png" alt="img"></p>
<p>如果用了非直接 I/O 进行写数据操作，内核什么情况下才会把缓存数据写入到磁盘？</p>
<p>以下几种场景会触发内核缓存的数据写入磁盘：</p>
<ul>
<li>在调用 <code>write</code> 的最后，当发现内核缓存的数据太多的时候，内核会把数据写到磁盘上；</li>
<li>用户主动调用 <code>sync</code>，内核缓存会刷到磁盘上；</li>
<li>当内存十分紧张，无法再分配页面时，也会把内核缓存的数据刷到磁盘上；</li>
<li>内核缓存的数据的缓存时间超过某个时间时，也会把数据刷到磁盘上；</li>
</ul>
<p>进程写文件（使用缓冲 IO）过程中，写一半的时候，进程发生了崩溃，已写入的数据会丢失吗？</p>
<p>答案，是不会的。</p>
<p>因为进程在执行 write （使用缓冲 IO）系统调用的时候，实际上是将文件数据写到了内核的 page cache，它是文件系统中用于缓存文件数据的缓冲，所以即使进程崩溃了，文件数据还是保留在内核的 page cache，我们读数据的时候，也是从内核的 page cache 读取，因此还是依然读的进程崩溃前写入的数据。</p>
<p>内核会找个合适的时机，将 page cache 中的数据持久化到磁盘。但是如果 page cache 里的文件数据，在持久化到磁盘化到磁盘之前，系统发生了崩溃，那这部分数据就会丢失了。</p>
<p>当然， 我们也可以在程序里调用 fsync 函数，在写文文件的时候，立刻将文件数据持久化到磁盘，这样就可以解决系统崩溃导致的文件数据丢失的问题。</p>
<h3 id="阻塞与非阻塞-I-O-VS-同步与异步-I-O"><a href="#阻塞与非阻塞-I-O-VS-同步与异步-I-O" class="headerlink" title="阻塞与非阻塞 I/O VS 同步与异步 I/O"></a>阻塞与非阻塞 I/O VS 同步与异步 I/O</h3><p>实际上，无论是阻塞 I/O、非阻塞 I/O，还是基于非阻塞 I/O 的多路复用<strong>都是同步调用。因为它们在 read 调用时，内核将数据从内核空间拷贝到应用程序空间，过程都是需要等待的，也就是说这个过程是同步的，如果内核实现的拷贝效率不高，read 调用就会在这个同步过程中等待比较长的时间。</strong></p>
<p>而真正的<strong>异步 I/O</strong> 是「内核数据准备好」和「数据从内核态拷贝到用户态」这两个过程都不用等待。</p>
<p><a href="https://xiaolincoding.com/os/6_file_system/file_system.html#阻塞与非阻塞-i-o-vs-同步与异步-i-o">https://xiaolincoding.com/os/6_file_system/file_system.html#%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E-i-o-vs-%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5-i-o</a></p>
<h3 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h3><p>在没有 DMA 技术前，I/O 的过程是这样的：</p>
<p><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/1756972608620-34e2e6f5-a0ac-4dab-87e6-caf64e0be268.png" alt="img"></p>
<p>整个数据的传输过程，都要需要 CPU 亲自参与搬运数据的过程，而且这个过程，CPU 是不能做其他事情的。</p>
<p>什么是 DMA 技术？简单理解就是，<strong>在进行 I/O 设备和内存的数据传输的时候，数据搬运的工作全部交给 DMA 控制器，而 CPU 不再参与任何与数据搬运相关的事情，这样 CPU 就可以去处理别的事务</strong>。</p>
<p><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/1756972944128-96bfd8d9-6432-49ff-83d6-b3d0e7683c0f.png" alt="img"></p>
<p>可以看到， <strong>CPU 不再参与「将数据从磁盘控制器缓冲区搬运到内核空间」的工作，这部分工作全程由 DMA 完成</strong>。但是 CPU 在这个过程中也是必不可少的，因为传输什么数据，从哪里传输到哪里，都需要 CPU 来告诉 DMA 控制器。</p>
<p>早期 DMA 只存在在主板上，如今由于 I/O 设备越来越多，数据传输的需求也不尽相同，所以每个 I/O 设备里面都有自己的 DMA 控制器。</p>
<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="互斥锁和自旋锁"><a href="#互斥锁和自旋锁" class="headerlink" title="互斥锁和自旋锁"></a>互斥锁和自旋锁</h2><p>这两种锁是最基础的锁，其他的锁都是基于这两种基础的锁实现的。</p>
<ul>
<li><strong>互斥锁</strong>加锁失败后，线程会<strong>释放 CPU</strong> ，给其他线程；</li>
<li><strong>自旋锁</strong>加锁失败后，线程会<strong>忙等待</strong>，直到它拿到锁；</li>
</ul>
<p><strong>对于互斥锁加锁失败而阻塞的现象，是由操作系统内核实现的</strong>。当加锁失败时，内核会将线程置为「睡眠」状态，等到锁被释放后，内核会在合适的时机唤醒线程，当这个线程成功获取到锁后，于是就可以继续执行。如下图：</p>
<p><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/1756907566582-317b4c5e-52ab-4478-b484-e7bf41efc453.png" alt="img"></p>
<p>自旋锁是通过 CPU 提供的 <code>CAS</code> 函数（<em>Compare And Swap</em>），在<strong>「用户态」</strong>完成加锁和解锁操作，不会主动产生线程上下文切换，所以相比互斥锁来说，会快一些，开销也小一些。</p>
<p>一般加锁的过程，包含两个步骤：</p>
<ul>
<li>第一步，查看锁的状态，如果锁是空闲的，则执行第二步；</li>
<li>第二步，将锁设置为当前线程持有；</li>
</ul>
<p>CAS 函数就把这两个步骤合并成一条硬件级指令，形成<strong>原子指令</strong>，这样就保证了这两个步骤是不可分割的，要么一次性执行完两个步骤，要么两个步骤都不执行。</p>
<p>使用自旋锁的时候，当发生多线程竞争锁的情况，加锁失败的线程会「忙等待」，直到它拿到锁。这里的「忙等待」可以用 <code>while</code> 循环等待实现，不过最好是使用 CPU 提供的 <code>PAUSE</code> 指令来实现「忙等待」，因为可以减少循环等待时的耗电量。</p>
<h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><details class="lake-collapse"><summary id="ucc4aa0fb"><span class="ne-text" style="font-size: 16px">读写锁的实现原理</span></summary><p id="ue548fe34" class="ne-p" style="margin: 0; padding: 0; min-height: 24px"><span class="ne-text" style="font-size: 16px">读写锁本身是高级锁，它可以</span><strong><span class="ne-text" style="font-size: 16px">基于更低级的独占锁实现</span></strong><span class="ne-text" style="font-size: 16px">：</span></p><ol class="ne-ol" style="margin: 0; padding-left: 23px"><li id="u4f15cf30" data-lake-index-type="0"><strong><span class="ne-text" style="font-size: 16px">互斥锁 + 计数器</span></strong></li></ol><ul class="ne-list-wrap" style="margin: 0; padding-left: 23px; list-style: none"><ul ne-level="1" class="ne-ul" style="margin: 0; padding-left: 23px; list-style: circle"><li id="u728cf38d" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">一个互斥锁保护计数器和状态</span></li><li id="uc3a3d2fe" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">计数器记录当前读者数量</span></li><li id="u9e0e2fcc" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">写者必须等到计数器为 0 才能获得锁</span></li><li id="ua8b47b60" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">读者在获取锁时增加计数器，释放时减少</span></li></ul></ul><ol start="2" class="ne-ol" style="margin: 0; padding-left: 23px"><li id="u703e1c5d" data-lake-index-type="0"><strong><span class="ne-text" style="font-size: 16px">自旋锁 + 计数器</span></strong></li></ol><ul class="ne-list-wrap" style="margin: 0; padding-left: 23px; list-style: none"><ul ne-level="1" class="ne-ul" style="margin: 0; padding-left: 23px; list-style: circle"><li id="u4819e4b1" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">类似逻辑，但等待者自旋，而不是睡眠</span></li></ul></ul></details>

<p>写锁是「独占锁」，因为任何时刻只能有一个线程持有写锁，类似互斥锁和自旋锁，而读锁是「共享锁」，因为读锁可以被多个线程同时持有。</p>
<p>读写锁可以分为「读优先锁」、「写优先锁」、「公平读写锁」。</p>
<ul>
<li><strong>读优先锁：</strong>读优先锁期望的是，读锁能被更多的线程持有，以便提高读线程的并发性，它的工作方式是：当读线程 A 先持有了读锁，写线程 B 在获取写锁的时候，会被阻塞，并且在阻塞过程中，后续来的读线程 C 仍然可以成功获取读锁，最后直到读线程 A 和 C 释放读锁后，写线程 B 才可以成功获取写锁。如下图：</li>
</ul>
<p><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/1756908133359-cb81b4e2-e985-4b38-854f-85b2b9bc5a8c.png" alt="img"></p>
<ul>
<li><strong>写优先锁：</strong>而「写优先锁」是优先服务写线程，其工作方式是：当读线程 A 先持有了读锁，写线程 B 在获取写锁的时候，会被阻塞，并且在阻塞过程中，后续来的读线程 C 获取读锁时会失败，于是读线程 C 将被阻塞在获取读锁的操作，这样只要读线程 A 释放读锁后，写线程 B 就可以成功获取写锁。如下图：</li>
</ul>
<p><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/1756908148223-25847f8b-6dd0-4858-ae94-b5d2197b7f0a.png" alt="img"></p>
<ul>
<li><strong>公平读写锁：</strong>比较简单的一种方式是：用队列把获取锁的线程排队，不管是写线程还是读线程都按照先进先出的原则加锁即可，这样读线程仍然可以并发，也不会出现「饥饿」的现象。</li>
</ul>
<p>互斥锁和自旋锁都是最基本的锁，读写锁可以根据场景来选择这两种锁其中的一个进行实现。</p>
<h2 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a>乐观锁与悲观锁</h2><p>前面提到的互斥锁、自旋锁、读写锁，都是属于悲观锁。</p>
<p>悲观锁做事比较悲观，它认为<strong>多线程同时修改共享资源的概率比较高，于是很容易出现冲突，所以访问共享资源前，先要上锁</strong>。</p>
<p>那相反的，如果多线程同时修改共享资源的概率比较低，就可以采用乐观锁。</p>
<p>乐观锁做事比较乐观，它假定冲突的概率很低，它的工作方式是：<strong>先修改完共享资源，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作</strong>。</p>
<p>放弃后如何重试，这跟业务场景息息相关，虽然重试的成本很高，但是冲突的概率足够低的话，还是可以接受的。</p>
<p>可见，乐观锁的心态是，不管三七二十一，先改了资源再说。另外，你会发现<strong>乐观锁全程并没有加锁，所以它也叫无锁编程</strong>。</p>
<p>这里举一个场景例子：在线文档。</p>
<p>我们都知道在线文档可以同时多人编辑的，如果使用了悲观锁，那么只要有一个用户正在编辑文档，此时其他用户就无法打开相同的文档了，这用户体验当然不好了。</p>
<p>那实现多人同时编辑，实际上是用了乐观锁，它允许多个用户打开同一个文档进行编辑，编辑完提交之后才验证修改的内容是否有冲突。</p>
<p>怎么样才算发生冲突？这里举个例子，比如用户 A 先在浏览器编辑文档，之后用户 B 在浏览器也打开了相同的文档进行编辑，但是用户 B 比用户 A 提交早，这一过程用户 A 是不知道的，当 A 提交修改完的内容时，那么 A 和 B 之间并行修改的地方就会发生冲突。</p>
<p>服务端要怎么验证是否冲突了呢？通常方案如下：</p>
<ul>
<li>由于发生冲突的概率比较低，所以先让用户编辑文档，但是浏览器在下载文档时会记录下服务端返回的文档版本号；</li>
<li>当用户提交修改时，发给服务端的请求会带上原始文档版本号，服务器收到后将它与当前版本号进行比较，如果版本号不一致则提交失败，如果版本号一致则修改成功，然后服务端版本号更新到最新的版本号。</li>
</ul>
<p>实际上，我们常见的 SVN 和 Git 也是用了乐观锁的思想，先让用户编辑代码，然后提交的时候，通过版本号来判断是否产生了冲突，发生了冲突的地方，需要我们自己修改后，再重新提交。</p>
<p>乐观锁虽然去除了加锁解锁的操作，但是一旦发生冲突，重试的成本非常高，所以<strong>只有在冲突概率非常低，且加锁成本非常高的场景时，才考虑使用乐观锁。</strong></p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>死锁只有<strong>同时满足</strong>以下四个条件才会发生：</p>
<ul>
<li>互斥条件；</li>
<li>持有并等待条件；</li>
<li>不可剥夺条件；</li>
<li>环路等待条件；</li>
</ul>
<h3 id="如何避免死锁"><a href="#如何避免死锁" class="headerlink" title="如何避免死锁"></a>如何避免死锁</h3><p>前面我们提到，产生死锁的四个必要条件是：<strong>互斥条件、持有并等待条件、不可剥夺条件、环路等待条件</strong>。</p>
<p>那么避免死锁问题就只需要破环其中一个条件就可以，最常见的并且可行的就是<strong>使用资源有序分配法，来破环环路等待条件</strong>。（或者银行家算法）</p>
<p>线程 A 和 线程 B 获取资源的顺序要一样，当线程 A 是先尝试获取资源 A，然后尝试获取资源 B 的时候，线程 B 同样也是先尝试获取资源 A，然后尝试获取资源 B。也就是说，线程 A 和 线程 B 总是以相同的顺序申请自己想要的资源。</p>
<h1 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h1><h2 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h2><p>先来先服务调度算法</p>
<p>最短作业优先调度算法</p>
<p>高响应比优先调度算法</p>
<p>时间片轮转调度算法</p>
<p>最高优先级调度算法</p>
<p>多级反馈队列调度算法</p>
<h2 id="内存页面置换算法"><a href="#内存页面置换算法" class="headerlink" title="内存页面置换算法"></a>内存页面置换算法</h2><p>最佳页面置换算法</p>
<p>先进先出置换算法</p>
<p>最近最久未使用的置换算法</p>
<p>时钟页面置换算法</p>
<p>最不常用算法</p>
<h2 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h2><p>先来先服务</p>
<p>最短寻道时间优先</p>
<p>扫描算法</p>
<p>循环扫描算法</p>
<p>LOOK 与 C-LOOK算法</p>
<h1 id="网络系统"><a href="#网络系统" class="headerlink" title="网络系统"></a>网络系统</h1><h2 id="零拷贝技术"><a href="#零拷贝技术" class="headerlink" title="零拷贝技术"></a>零拷贝技术</h2><p>讲零拷贝之前，先看一下传统的文件传输方法：</p>
<p>传统 I/O 的工作方式是，数据读取和写入是从用户空间到内核空间来回复制，而内核空间的数据是通过操作系统层面的 I/O 接口从磁盘读取或写入。</p>
<p>代码通常如下，一般会需要两个系统调用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">read(file, tmp_buf, len);</span><br><span class="line">write(socket, tmp_buf, len);</span><br></pre></td></tr></table></figure>
<p><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/1756973050450-2e223542-394a-4460-bca5-db88b8c1b3c5.png" alt="img"></p>
<p>期间共<strong>发生了 4 次用户态与内核态的上下文切换</strong>，因为发生了两次系统调用，一次是 <code>read()</code> ，一次是 <code>write()</code>，每次系统调用都得先从用户态切换到内核态，等内核完成任务后，再从内核态切换回用户态。上下文切换到成本并不小，一次切换需要耗时几十纳秒到几微秒，虽然时间看上去很短，但是在高并发的场景下，这类时间容易被累积和放大，从而影响系统的性能。</p>
<p>其次，还<strong>发生了 4 次数据拷贝</strong>，其中两次是 DMA 的拷贝，另外两次则是通过 CPU 拷贝的。</p>
<p><strong>要想提高文件传输的性能，就需要减少「用户态与内核态的上下文切换」和「内存拷贝」的次数</strong>。</p>
<p><strong>零拷贝技术实现的方式通常有 2 种：</strong></p>
<ul>
<li><strong>mmap + write</strong></li>
<li><strong>sendfile</strong></li>
</ul>
<p><strong>mmap + write</strong></p>
<p>在前面我们知道，<code>read()</code> 系统调用的过程中会把内核缓冲区的数据拷贝到用户的缓冲区里，于是为了减少这一步开销，我们可以用 <code>mmap()</code> 替换 <code>read()</code> 系统调用函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">buf = mmap(file, len);</span><br><span class="line">write(sockfd, buf, len);</span><br></pre></td></tr></table></figure>
<p><code>mmap()</code> 系统调用函数会直接把内核缓冲区里的数据「<strong>映射</strong>」到用户空间，这样，操作系统内核与用户空间就不需要再进行任何的数据拷贝操作。</p>
<p><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/1756973165969-1dc98f96-c41c-486b-aca1-b5d8ce4b73e6.png" alt="img"></p>
<p>使用 <code>mmap()</code> 来代替 <code>read()</code>， 可以减少一次数据拷贝的过程。</p>
<p>但这还不是最理想的零拷贝，因为仍然需要通过 CPU 把内核缓冲区的数据拷贝到 socket 缓冲区里，而且仍然需要 4 次上下文切换，因为系统调用还是 2 次。</p>
<p><strong>sendfile</strong></p>
<p>在 Linux 内核版本 2.1 中，提供了一个专门发送文件的系统调用函数 <code>sendfile()</code>，函数形式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendfile</span><span class="params">(<span class="type">int</span> out_fd, <span class="type">int</span> in_fd, <span class="type">off_t</span> *offset, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure>
<p>它的前两个参数分别是目的端和源端的文件描述符，后面两个参数是源端的偏移量和复制数据的长度，返回值是实际复制数据的长度。</p>
<p>首先，它可以替代前面的 <code>read()</code> 和 <code>write()</code> 这两个系统调用，这样就可以减少一次系统调用，也就减少了 2 次上下文切换的开销。</p>
<p>其次，该系统调用，可以直接把内核缓冲区里的数据拷贝到 socket 缓冲区里，不再拷贝到用户态，这样就只有 2 次上下文切换，和 3 次数据拷贝。如下图：</p>
<p><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/1756973240008-28f0f642-eb6f-408c-9d8a-f36fbad0edbb.png" alt="img"></p>
<p>但是这还不是真正的零拷贝技术，如果网卡支持 SG-DMA（<em>The Scatter-Gather Direct Memory Access</em>）技术（和普通的 DMA 有所不同），我们可以进一步减少通过 CPU 把内核缓冲区里的数据拷贝到 socket 缓冲区的过程。</p>
<p>于是，从 Linux 内核 <code>2.4</code> 版本开始起，对于支持网卡支持 SG-DMA 技术的情况下， <code>sendfile()</code> 系统调用的过程发生了点变化，具体过程如下：</p>
<ul>
<li>第一步，通过 DMA 将磁盘上的数据拷贝到内核缓冲区里；</li>
<li>第二步，缓冲区描述符和数据长度传到 socket 缓冲区，这样网卡的 SG-DMA 控制器就可以直接将内核缓存中的数据拷贝到网卡的缓冲区里，此过程不需要将数据从操作系统内核缓冲区拷贝到 socket 缓冲区中，这样就减少了一次数据拷贝；</li>
</ul>
<p>所以，这个过程之中，只进行了 2 次数据拷贝，如下图：</p>
<p><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/1756973365107-68a93f50-e508-412e-99a1-22564b18b719-20250918152957375.png" alt="img"></p>
<p>这就是所谓的<strong>零拷贝（<em>*</em></strong>Zero-copy<strong>*</strong>）技术，因为我们没有在内存层面去拷贝数据，也就是说全程没有通过 CPU 来搬运数据，所有的数据都是通过 DMA 来进行传输的。**。</p>
<p>零拷贝技术的文件传输方式相比传统文件传输的方式，减少了 2 次上下文切换和数据拷贝次数，<strong>只需要 2 次上下文切换和数据拷贝次数，就可以完成文件的传输，而且 2 次的数据拷贝过程，都不需要通过 CPU，2 次都是由 DMA 来搬运。</strong></p>
<p><strong>需要注意的是，零拷贝技术是不允许进程对文件内容作进一步的加工的，比如压缩数据再发送。</strong></p>
<p><strong>另外，当传输大文件时，不能使用零拷贝，因为可能由于 PageCache 被大文件占据，而导致「热点」小文件无法利用到 PageCache，并且大文件的缓存命中率不高，这时就需要使用「异步 IO + 直接 IO 」的方式。</strong></p>
<h2 id="零拷贝与Direct-I-O-的区别"><a href="#零拷贝与Direct-I-O-的区别" class="headerlink" title="零拷贝与Direct I/O 的区别"></a>零拷贝与Direct I/O 的区别</h2><p>两者的应用场景不一样。一个是用户直接写磁盘，一个是发送网络请求。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/1758077613445-78bab3f8-2f58-44b8-8213-6d6e0c16c282.png" alt="img"></th>
<th><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/1756973365107-68a93f50-e508-412e-99a1-22564b18b719.png" alt="img"></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<h2 id="IO-多路复用"><a href="#IO-多路复用" class="headerlink" title="IO 多路复用"></a>IO 多路复用</h2><p>多路复用是操作系统内部实现的，暴露了一些 API，mysql、redis、消息队列等中间件底层实现会调用这些 API 来实现多路复用。</p>
<p><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/1756978469791-73f3d15b-7afb-493f-b9c4-0e73941bc586.png" alt="img"></p>
<p>优化的地方 1：</p>
<p>select 和 poll 维护了一个<strong>文件描述符集合</strong>，拷贝时间复杂度 O(n)。</p>
<p>epoll 在内核里使用<strong>红黑树**</strong>来跟踪进程所有待检测的文件描述字**，把需要监控的 socket 通过 <code>epoll_ctl()</code> 函数加入内核中的红黑树里，红黑树是个高效的数据结构，增删改一般时间复杂度是 <code>O(logn)</code>。而 select/poll 内核里没有类似 epoll 红黑树这种保存所有待检测的 socket 的数据结构，所以 select/poll 每次操作时都传入整个 socket 集合给内核，而 epoll 因为在内核维护了红黑树，可以保存所有待检测的 socket ，所以只需要传入一个待检测的 socket，减少了内核和用户空间大量的数据拷贝和内存分配。</p>
<p>优化的地方 2：</p>
<p>select 和 poll 逐个检查文件是否准备就绪，select 通过 bitsmap 标记准备就绪的 Socket，然后把 bitsmap 和文件描述符集合都 拷贝到进程缓冲区，进程遍历 bitsmap 来调用 read 接口读取准备好的数据。select 使用<strong>固定长度</strong>的 BitsMap，表示文件描述符集合，而且所支持的<strong>文件描述符的个数是有限制的</strong>，在 Linux 系统中，由内核中的 FD_SETSIZE 限制， 默认最大值为 <code>1024</code>，只能监听 0~1023 的文件描述符。poll 不再用BitsMap 来存储所关注的文件描述符，取而代之用动态数组，以链表形式来组织，突破了 select 的文件描述符个数限制。</p>
<p>epoll 使用<strong>事件驱动</strong>的机制，内核里<strong>维护了一个链表来记录就绪事件</strong>，当某个 socket 有事件发生时，通过<strong>回调函数</strong>内核会将其加入到这个就绪事件列表中，当用户调用 <code>epoll_wait()</code> 函数时，只会返回有事件发生的文件描述符的个数，不需要像 select/poll 那样轮询扫描整个 socket 集合，大大提高了检测的效率。</p>
<p><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/1756978212042-59fd74cb-cf26-4532-aa4b-4cab479fb6a9.png" alt="img"></p>
<p>epoll 的方式即使监听的 Socket 数量越多的时候，效率不会大幅度降低，能够同时监听的 Socket 的数目也非常的多了，上限就为系统定义的进程打开的最大文件描述符个数。因而，<strong>epoll 被称为解决 C10K 问题的利器</strong>。</p>
<h3 id="阻塞-IO-与非阻塞-IO"><a href="#阻塞-IO-与非阻塞-IO" class="headerlink" title="阻塞 IO 与非阻塞 IO"></a>阻塞 IO 与非阻塞 IO</h3><ol>
<li>阻塞 I/O</li>
</ol>
<ul>
<li>最简单的方式：直接 <code>recv()</code>，如果没有数据，线程就卡住。</li>
<li>缺点：效率低，一直阻塞。</li>
<li><p>非阻塞 + 轮询</p>
</li>
<li><p>把 socket 设置成非阻塞：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fcntl(fd, F_SETFL, O_NONBLOCK);</span><br></pre></td></tr></table></figure>
<ul>
<li>然后不停地 <code>recv()</code> 或 <code>send()</code>，发现返回 <code>EAGAIN</code> 就说明暂时没数据。</li>
<li>缺点：CPU 空转，占用资源大。</li>
</ul>
<h3 id="select、poll、epoll-图示"><a href="#select、poll、epoll-图示" class="headerlink" title="select、poll、epoll 图示"></a>select、poll、epoll 图示</h3><p><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/1741268381784-e7bec94c-164b-49af-a8cf-17b7c2966606.png" alt="img"></p>
<p><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/1741268359095-134869f0-9940-46c7-aeed-7980321054a6.png" alt="img"></p>
<p><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/1741269881912-ce4c1bf1-ad45-470d-9413-1c667fd83a48.png" alt="img"></p>
<p><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/1741269484629-0901ef0a-c026-47d5-a9ca-f68293454637.png" alt="img"></p>
<h3 id="epoll-的工作模式"><a href="#epoll-的工作模式" class="headerlink" title="epoll 的工作模式"></a>epoll 的工作模式</h3><ul>
<li><strong>水平触发</strong>：当文件描述符关联的内核缓冲区非空，或者有数据可以读取时，系统会一直发出可读信号进行通知。类似地，当写缓冲区不满，有空间可以写入时，系统会一直发出可写信号。这种模式支持阻塞和非阻塞两种方式，是许多 IO 多路复用机制（如 epoll）的默认模式。</li>
<li><strong>边缘触发</strong>：当文件描述符关联的读内核缓冲区由空转化为非空的时候，系统会发出可读信号进行通知。当写缓冲区由满转化为不满的时候，系统会发出可写信号。边缘触发仅在状态发生变化时通知一次，不会持续通知。</li>
</ul>
<h2 id="什么是一致性哈希"><a href="#什么是一致性哈希" class="headerlink" title="什么是一致性哈希"></a>什么是一致性哈希</h2><p>一致性哈希是为了解决负载均衡哈希算法无法应对扩容和缩容的问题。</p>
<p><code>hash(key) % 3</code> 公式对数据进行了映射。但是有一个很致命的问题，<strong>如果节点数量发生了变化，也就是在对系统做扩容或者缩容时，必须迁移改变了映射关系的数据</strong>，否则会出现查询不到数据的问题。</p>
<p>要解决这个问题的办法，就需要我们进行<strong>迁移数据</strong>，比如节点的数量从 3 变化为 4 时，要基于新的计算公式 hash(key) % 4 ，重新对数据和节点做映射。</p>
<p>假设总数据条数为 M，哈希算法在面对节点数量变化时，<strong>最坏情况下所有数据都需要迁移，所以它的数据迁移规模是 O(M)</strong>，这样数据的迁移成本太高了。</p>
<p>一致性哈希算法就很好地解决了分布式系统在扩容或者缩容时，发生过多的数据迁移的问题。</p>
<p>一致哈希算法也用了取模运算，但与哈希算法不同的是，哈希算法是对节点的数量进行取模运算，而<strong>一致哈希算法是对 2^32 进行取模运算，是一个固定的值</strong>。</p>
<p>我们可以把一致哈希算法是对 2^32 进行取模运算的结果值组织成一个圆环，就像钟表一样，钟表的圆可以理解成由 60 个点组成的圆，而此处我们把这个圆想象成由 2^32 个点组成的圆，这个圆环被称为<strong>哈希环</strong>。</p>
<p>一致性哈希要进行两步哈希：</p>
<ul>
<li>第一步：对存储节点进行哈希计算，也就是对存储节点做哈希映射，比如根据节点的 IP 地址进行哈希；</li>
<li>第二步：当对数据进行存储或访问时，对数据进行哈希映射；</li>
</ul>
<p>所以，<strong>一致性哈希是指将「存储节点」和「数据」都映射到一个首尾相连的哈希环上</strong>。</p>
<p>问题来了，对「数据」进行哈希映射得到一个结果要怎么找到存储该数据的节点呢？</p>
<p>答案是，映射的结果值往<strong>顺时针的方向的找到第一个节点</strong>，就是存储该数据的节点。</p>
<p>举个例子，有 3 个节点经过哈希计算，映射到了如下图的位置：</p>
<p><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/1756980251232-53605833-8cc6-4360-8e2c-6e90527eb572.png" alt="img"></p>
<p>假设节点数量从 3 增加到了 4，新的节点 D 经过哈希计算后映射到了下图中的位置：</p>
<p><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/1756980271301-ca90ec35-7409-4896-9904-fcb518158f8f.png" alt="img"></p>
<p>你可以看到，key-01、key-03 都不受影响，只有 key-02 需要被迁移节点 D。</p>
<p>假设节点数量从 3 减少到了 2，比如将节点 A 移除：</p>
<p><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/1756980280269-c334742c-4e6d-4a12-9fd7-a9ba76efd2ed.png" alt="img"></p>
<p>你可以看到，key-02 和 key-03 不会受到影响，只有 key-01 需要被迁移节点 B。</p>
<p>因此，<strong>在一致哈希算法中，如果增加或者移除一个节点，仅影响该节点在哈希环上顺时针相邻的后继节点，其它数据也不会受到影响</strong>。</p>
<p>上面这些图中 3 个节点映射在哈希环还是比较分散的，所以看起来请求都会「均衡」到每个节点。</p>
<p>但是<strong>一致性哈希算法并不保证节点能够在哈希环上分布均匀</strong>，这样就会带来一个问题，会有大量的请求集中在一个节点上。</p>
<p>比如，下图中 3 个节点的映射位置都在哈希环的右半边：</p>
<p><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/1756980289091-47958cac-8b9a-44d5-b675-5e406c3b211b.png" alt="img"></p>
<p>所以，<strong>一致性哈希算法虽然减少了数据迁移量，但是存在节点分布不均匀的问题</strong>。</p>
<p>解决做法是，<strong>不再将真实节点映射到哈希环上，而是将虚拟节点映射到哈希环上，并将虚拟节点映射到实际节点，所以这里有「两层」映射关系。</strong></p>
<p>比如对每个节点分别设置 3 个虚拟节点：</p>
<ul>
<li>对节点 A 加上编号来作为虚拟节点：A-01、A-02、A-03</li>
<li>对节点 B 加上编号来作为虚拟节点：B-01、B-02、B-03</li>
<li>对节点 C 加上编号来作为虚拟节点：C-01、C-02、C-03</li>
</ul>
<p>引入虚拟节点后，原本哈希环上只有 3 个节点的情况，就会变成有 9 个虚拟节点映射到哈希环上，哈希环上的节点数量多了 3 倍。</p>
<p><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/1756980289091-47958cac-8b9a-44d5-b675-5e406c3b211b.png" alt="img"></p>
<p><strong>节点数量多了后，节点在哈希环上的分布就相对均匀了</strong></p>
<h1 id="BIO-和-NIO"><a href="#BIO-和-NIO" class="headerlink" title="BIO 和 NIO"></a>BIO 和 NIO</h1><p><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/1751809065379-2405d058-a5fb-43a5-b38d-fb00bf1460ab.webp" alt="img"></p>
<p><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/1751809070352-2ad71b54-396a-4e52-8e0f-528180ff48b7.webp" alt="img"></p>
<p>从这两图可以看出，NIO的单线程能处理连接的数量比BIO要高出很多，而为什么单线程能处理更多的连接呢？原因就是图二中出现的<code>Selector</code>。<br>当一个连接建立之后，他有两个步骤要做，第一步是接收完客户端发过来的全部数据，第二步是服务端处理完请求业务之后返回response给客户端。NIO和BIO的区别主要是在第一步。<br>在BIO中，等待客户端发数据这个过程是阻塞的，这样就造成了一个线程只能处理一个请求的情况，而机器能支持的最大线程数是有限的，这就是为什么BIO不能支持高并发的原因。<br>而NIO中，当一个Socket建立好之后，Thread并不会阻塞去接受这个Socket，而是将这个请求交给Selector，Selector会不断的去遍历所有的Socket，一旦有一个Socket建立完成，他会通知Thread，然后Thread处理完数据再返回给客户端——<strong>这个过程是不阻塞的</strong>，这样就能让一个Thread处理更多的请求了。<br>下面两张图是基于BIO的处理流程和netty的处理流程，辅助你理解两种方式的差别：</p>
<p><img src="https://dora-blog.oss-cn-beijing.aliyuncs.com/1751809149749-14675ed5-fefc-43c0-be31-2e47aef1adb2.webp" alt="img"></p>
<h1 id="常见系统调用"><a href="#常见系统调用" class="headerlink" title="常见系统调用"></a>常见系统调用</h1><h2 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h2><p><code>mmap</code> 的全称是 <strong>memory map</strong>，意思就是<strong>把文件或设备的内容映射到进程的虚拟内存地址空间</strong>。</p>
<p>底层机制：</p>
<ol>
<li>进程调用 <code>mmap()</code> → 内核会在进程的 <strong>虚拟地址空间</strong> 中找到一块空闲区域（VMA，虚拟内存区域）。</li>
<li>这块区域不会立刻分配物理内存，而是建立虚拟地址和目标文件页（<strong>或者匿名页</strong>）的<strong>映射关系</strong>。</li>
<li>当进程第一次访问这段内存时，会触发 <strong>缺页中断</strong>（page fault），内核这时才把对应的文件内容读到 <strong>PageCache</strong>，并建立物理页和虚拟页的映射。</li>
<li>进程读写这段内存，就相当于直接在操作系统的 PageCache 上操作，而不是通过 <code>read()</code>/<code>write()</code> 系统调用。</li>
</ol>
<p>换句话说，<code>mmap</code> 的原理就是：<strong>用户空间地址直接映射到内核的 PageCache 或匿名页，通过缺页中断来延迟分配物理内存。</strong></p>
<p><strong>映射到 PageCache 或匿名页有什么区别？malloc 使用的是哪种方式？</strong></p>
<ol>
<li><strong>文件映射 mmap</strong></li>
</ol>
<ul>
<li><strong>内存页映射到文件对应的</strong> <strong>PageCache**</strong>。**</li>
<li><strong>PageCache 是全局的，多个进程 mmap 同一个文件时，确实会共享同一份物理页。</strong></li>
<li><strong>所以这类 mmap 的内容不是进程“独有”的。</strong></li>
</ul>
<ol>
<li><strong>匿名 mmap (MAP_ANONYMOUS)</strong></li>
</ol>
<ul>
<li><strong>内存页没有对应文件，只是内核分配的物理页，专属于调用进程。</strong></li>
<li><strong>这类 mmap 就是“用户私有内存”，和 malloc 出来的效果一样。</strong></li>
<li><strong>除非进程特意用</strong> <code>**fork()**</code> <strong>或者</strong> <code>**MAP_SHARED**</code><strong>，否则不会被其他进程看到或修改。</strong></li>
</ul>
<p>👉 <strong>malloc 分配大对象时用的就是 匿名 mmap，不是文件 mmap，所以它得到的是 用户独有的私有空间，不会被其他进程覆盖。</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><code>**read()/write()**</code></th>
<th><code>**mmap**</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>数据拷贝</strong></td>
<td><strong>用户缓冲区 ←→ 内核缓冲区</strong></td>
<td><strong>直接访问 PageCache，省一次拷贝</strong></td>
</tr>
<tr>
<td><strong>接口</strong></td>
<td><strong>系统调用</strong></td>
<td><strong>像访问数组一样</strong></td>
</tr>
<tr>
<td><strong>使用场景</strong></td>
<td><strong>适合小文件读写，简单可靠</strong></td>
<td><strong>大文件访问、随机读写、共享内存、设备映射</strong></td>
</tr>
<tr>
<td><strong>内存利用</strong></td>
<td><strong>多一份用户缓冲区</strong></td>
<td><strong>直接用 PageCache，更节省内存</strong></td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>内核</tag>
        <tag>进程与线程</tag>
      </tags>
  </entry>
  <entry>
    <title>纪念我逝去的ACM</title>
    <url>/posts/c4e80fbc.html</url>
    <content><![CDATA[<blockquote>
<p>2021.12.04下午4点，第46届ACM/ICPC南京站圆满结束，同时这也寓意着我的ACM生涯到此也正式画上了句号。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/image-20220102200127985.png" alt="image-20220102200127985"></p>
<h2 id="生涯战绩"><a href="#生涯战绩" class="headerlink" title="生涯战绩"></a>生涯战绩</h2><ul>
<li>2020-河南省CCPC-银牌</li>
<li>2020-天梯赛-国三</li>
<li>2021-蓝桥杯-国二</li>
<li>2021-河南省ICPC-银牌</li>
<li>2021-天梯赛-国二</li>
<li>2021-河南省CCPC-银牌</li>
<li>2021-ICPC南京站-铜牌</li>
</ul>
<h2 id="相遇"><a href="#相遇" class="headerlink" title="相遇"></a>相遇</h2><p>&emsp;&emsp;我与ACM的接触纯属偶然，甚至对于计算机专业的选择我也并不自信，19年高考失利，伴随着不再复读的决心进入了我的分数可以达到的最好专业，刚入学时，因为对新事物的好奇，我奔走于各个社团之间，希望能丰富自己的大学生活。十月份学校举行百团大战活动，我在许多社团都填了报名表，但不幸的是，没有一个社团愿意收我<del>咱也不知道他们收人的标准是什么咱也不敢问</del>，当时我一直在参与微控科创协会的C语言培训，一周大概有3次，每次2个小时左右，当时我真的是一个纯小白，但经过了一段时间的C语言学习，我慢慢地爱上了这门语言，还记得当时在控制台打印出杨辉三角时，我内心不可言喻的欣喜。</p>
<p>&emsp;&emsp;某天晚上，班群里发来了算法协会的一个招新公告，我当时对于这个协会是一点概念都没有的，只是听说它是一个编程型的协会，而且使用C语言，反正我也没有协会可去就报了名，周六是招新日子，记得是上午10点在机房招新，当天早晨7点我还去参加了学校的乒乓球协会选拔赛\笑哭，由于有一定的C语言基础，对于学长们的提问，我也一一回答了上来，最后我还记得学长们问我的最后一个问题是“如果将来你组队，你给自己起的队名是什么？”现在想想，可能学长只是单纯不知道起啥队名，想从我这提取点灵感吧，hhh。</p>
<p>&emsp;&emsp;之后我也顺利成章地进入了协会，进入协会后我发现，这个协会的学长们个个都是大佬，一些在我看来非常困难的问题在他们眼里好像就是计算1+1等于几，不过虽然他们很强，但不得不吐槽的是，讲课讲地确实不咋滴，记得当时我连cin都还不会用的时候，就已经开始讲STL了…每次去机房敲代码都好像看天书，不过也正是因为有了这样“薄弱”的基础，为我后来“毫不费力”地进入协会埋下伏笔。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/1641130309864.jpg" alt="机房敲代码" style="zoom:25%;" /></p>
<h2 id="招新"><a href="#招新" class="headerlink" title="招新"></a>招新</h2><p>&emsp;&emsp;具体校赛日期我记不得了，甚至校赛和招新赛的先后顺序我也忘了，印象中应该是校赛在前，当时是17届学长们出题组织的比赛，早上9点到下午2点，当时看到这个比赛时间都晕了，这是什么牛马时间？<del>后来的我：才5个小时怎么够用呢？这个BUG再给我几分钟我就调出来了</del>，当时的题目还是半英半中，我直接看的头晕，还好签到是中文，我也只写了两道签到，然后就溜了，没错跑去吃饭了，后来看了榜单，好家伙，焦作一中榜一，当时的我都震惊了，被屠榜了！现在看来，太正常不过了，和这么多OI爷同台竞技，能把第二保住学长们就已经很厉害了orz，最后排到60多名开外的我还混了个三等奖\手动狗头。</p>
<p>&emsp;&emsp;招新赛其实是我真正意义上的第一场比赛，因为这场比赛才符合我当时的水平，当时大概有几十号人参加，蒟蒻的我还是用C语言去写的题目，甚至连一些缩进都没调，现在的我再去看当时提交的代码，真不敢相信世界上真的有写出这样代码的人，不过比较幸运的是，最后我还取得了第三名的好成绩，虽然排在我后面的那些人到后面都超过了我\卑微，比较遗憾的是，后来我才知道当时季军是有奖品的，一个耳机，而由于我的提前离场，奖品只好颁发给下一名了<img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/017AE03F.gif" alt="img" style="zoom:25%;" />，也是在这一场我第一次见到了乔佬的威力，也认识了老牛。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/1641130327003.jpg" alt="训练赛第一次AK" style="zoom:25%;" /></p>
<h2 id="寒假-疫情"><a href="#寒假-疫情" class="headerlink" title="寒假+疫情"></a>寒假+疫情</h2><p>&emsp;&emsp;之后进入协会后我们就被放养了，之后再训练就是在寒假时了，但是由于网络的不便，并没有什么强制手段，所以大部分人也都在摸鱼，including me，当时只有一周一次的训练赛，还记得当时是下午2点半开始，每次都搞得我紧张兮兮，当然监管手段不严，当时很多人都直接从网上搜到题解，改一下就直接交了。</p>
<p>&emsp;&emsp;2020的寒假我收获最大的并不是算法知识，而是剪辑。</p>
<p>&emsp;&emsp;当时的我刷到学校抖音上自制的一个爱情公寓片头，完完全全吸引到我了，当时的我也对新事物充满了好奇，便开始搜索各种剪辑教程，每天从早到晚都在琢磨怎么做出这样的特效，功夫不负有心人，我也确实最后做出来了，虽然是个低配版的，后来因为恢复系统，没有备份也丢失了，现在那些剪辑技巧我也全忘光了。</p>
<p>&emsp;&emsp;之后因为疫情，一整个学期我都在家里度过，天天盼望开学，到最后还是寒假暑假连着放，不过因为在家，我也有了更多属于自己的时间，这段时间里我接触到了贯穿我整个ACM生涯乃至未来职业生涯的Hexo博客。</p>
<p>&emsp;&emsp;因为记录算法的需要，我需要一个可以记录知识的博客，当时我还在用CSDN，但无奈颜控的我实在接受不了它的丑陋，把目光盯向了Hexo博客，剪辑的技巧我忘光了，但是Hexo博客却从始至终都在陪伴着我，第一次接触Hexo博客是打开龙佬的Sakura，当时就觉得这个网页好漂亮，好想拥有，后来才知道原来龙佬讲过一次课，就是关于怎么去搭建一个自己的Hexo博客，而我竟然没有看到这个消息！苦逼的我只能自己搜索各种教程，但当时的我实在是太小白了，当时的我还在使用360，可想而知，当时我的技术知识有多么薄弱，配置一个ssh秘钥死活弄不好，最后还是在闲鱼上下单了，30rmb，离谱的是，接单的那个人竟然也没给我弄好…他没有把仓库名后缀改成.github.io，导致页面死活访问不了，就这个小错误他鼓弄了一下午加一个晚上，后来实在弄不好，就不了了之了，不过他人确实挺好最后还说不收钱，不过我还是给他打了钱，这个问题最后还是请教龙佬才解决的，还记得当时搭建成功后那高兴劲啊，当时就发了一条说说。</p>
<p>&emsp;&emsp;后来就入了Hexo的坑，之后的整整一个月都在学习怎么美化博客，尝试了各种各样的主题，因为Sakura主题需要cdn，当时我不会，死活配置不好，就转向Matery，用了这个主题一段时间后还是喜欢Sakura，又开始推翻重来，就这样摸着石头慢慢过了河，还真配置好了，弄好以后就开始各种花里胡哨的美化，加一个板娘啊，加一个点击特效啊等等，后来全被我删了，美化的尽头就是默认，这句话真的深有体会，前前后后折腾了一个多月，期末考试就到了，之后就忙着复习，值得一提的是当时的我不知道慕课脚本，竟然还在手算高数题\大哭。</p>
<h2 id="第一次暑期集训"><a href="#第一次暑期集训" class="headerlink" title="第一次暑期集训"></a>第一次暑期集训</h2><p>&emsp;&emsp;之后就迎来了我ACM生涯中最重要的一段时期，2020暑期培训，从这个培训开始我才是真正意义上地开启了ACM生涯，还记得当时强哥说的一句话，“如果说暑期培训之前你们是一点一点提升的话，那么暑期培训就是一段一段提升的”，这句话现在的我深有体会，当时每天上午9点学长们准时开始讲课，讲完课后给我拉题让我们去做，每天都是10道左右，就是这样每天不间断地训练写题，我的编程能力和算法知识提升速度飞快，也是在这样的环境下，我认识了潘姥爷，还记得和潘姥爷讨论的第一题是一道CF的题目，每组样例时限1s，潘姥爷看成了这道题时限1s，时复感人。</p>
<p>&emsp;&emsp;当时每周六都会有一次积分赛，积分赛的平台是龙佬搭建的Domjudge，我是一个测试恐惧者，每次考试前我总会睡不着觉，紧张兮兮，积分赛也不例外，不过幸运的是，第一次积分赛题目比较友好，而我呢也比较幸运，竟然成为了第一个AK的人<del>虽然算上罚时我就掉到第3了</del>，当时吃的那顿午饭贼香。后面的积分赛难度就慢慢上去了，而且还邀请了河工业的人一起来打，我们也次次被屠榜，到后面已经被打麻了，不过最后我还是以总集训第二名的成绩留在了协会并且抱上了潘姥爷这个大腿。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/image-20220102215847102.png" alt="积分赛榜单" style="zoom: 50%;" /></p>
<h2 id="三只菜鸟齐力下厨"><a href="#三只菜鸟齐力下厨" class="headerlink" title="三只菜鸟齐力下厨"></a>三只菜鸟齐力下厨</h2><p>&emsp;&emsp;开学后的生活开始单调起来，没有课的时候就到机房训练，当时已经开始组队赛，我也是见识到了潘姥爷的厉害，当时的我也算比较强，可能也是和潘姥爷实力最接近的时候了吧。之后就是各种训练赛，各种自闭时刻…</p>
<p>&emsp;&emsp;10月份，我们正式组了队，同时也迎来了新成员，老牛，我更加自闭，这货思维这么敏捷吗？后面的训练赛我只管躺平，他俩去C就行了。</p>
<p>&emsp;&emsp;因为比赛需要队名，我们没有什么好的灵感，于是就让潘姥爷决定了，于是“三只菜鸟齐力下厨”便诞生了。</p>
<p>&emsp;&emsp;之后就是两场真正意义上的正式赛。</p>
<p>&emsp;&emsp;10月中旬，河南省CCPC省赛，银牌。（差几发罚时就金牌的我们无比自信，没想到出道即巅峰）</p>
<p>&emsp;&emsp;10月末，CCPC秦皇岛站，打铁。</p>
<p>&emsp;&emsp;11月，天梯赛，国三。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/1641130450908.jpg" alt="秦皇岛打铁" style="zoom: 20%;" /></p>
<h2 id="寒假"><a href="#寒假" class="headerlink" title="寒假"></a>寒假</h2><p>&emsp;&emsp;之后就迎来了大二寒假，经过了几个月的磨合，我们仨已经正式踏入了ACM的大门，并把ICPC区域赛的牌子定为我们的目标，我们在校外租了房子，打算训练一个寒假，而这个寒假也成为了我大学生涯里意义非凡的一页。</p>
<p>&emsp;&emsp;放假后并没有回家，<del>学校当然不允许，所以我们是黑户</del>，我们自己买了锅碗瓢盆，每天去菜市场买菜自己做饭吃，当时的环境不能说差，只能说将就着死不掉，一天我们受邀去了学长们租的房子，就好像是穷人家的孩子进了王思聪的大门一样，装修豪华，有暖气，有冰箱，有天然气，有几个大床，天呐，他们是来训练的吗？他们真的不是来享福的吗？我们酸了。环境是差了点，但确实不影响我们训练，有暖气就够了，我们仨每天就挤在一个房间里整天对着各种变态题目掉头发，那个时候是我CF上分最快的时候，毕竟三个臭皮匠顶个诸葛亮。寒假末期，我们的心逐渐野了，开始下馆子，晚上也会开黑到深夜，想一想，那个时候的生活确实够惬意的。</p>
<p>&emsp;&emsp;然而我们却不知道，痛苦的时光正逐渐逼近。因为疫情延期开学，同学们都在庆祝，而我们就悲催了，我们的房子到期了，我们无家可归了，幸运的是学校部分学生已经返校，寝室已经可以住人了，不幸的是我们没有返校证明，不能进入宿舍，无奈，我们只能睡在机房，几个椅子拼在一起，几件衣服往上一铺，就是一张床，然而那一晚我永远不会忘记，一夜我醒了6次，早上起来浑身酸痛。</p>
<p>&emsp;&emsp;这样下去不是办法，还是要想办法混进宿舍，经过观察，阿姨晚上11点后一般就回屋休息了，我们就趁宿舍阿姨晚上不在的时候偷偷溜进去，我们甚至不敢开灯，害怕被抓，早上天微亮就要起床，因为这个时候阿姨不在，也是因为这，我吃到了学校“新鲜出炉”的饭菜。</p>
<p>&emsp;&emsp;白天就在机房训练，晚上就偷鸡摸狗，这样的生活持续了2个多星期终于开学了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/1641130541089.jpg" alt="寒假租的房子" style="zoom: 10%;" /></p>
<h2 id="焦煤生产-打铁-大队"><a href="#焦煤生产-打铁-大队" class="headerlink" title="焦煤生产(打铁)大队"></a>焦煤生产(打铁)大队</h2><p>&emsp;&emsp;开学后不就我们就迎来了第一场ICPC区域赛，昆明站，赛前觉得我们的队名不吉利（上次省赛差点拿金），于是决定更换队名，想了想，要能体现地方特色，高端上档次，要不就叫“焦煤生产大队”吧，老牛说，我们点头，于是焦煤打铁大队横空出世。</p>
<p>&emsp;&emsp;周日，赛前我们热血沸腾，赛中我们备受打击，赛后我们直接抑郁，1个小时半才签了到（第一题不算），然后就没有了然后，我写的那道计算几何最后也没做出来，赛后我浑浑噩噩地回到宿舍，盯着我写的代码，突然发现起点可能在右边，改了一下，A了，我直接自闭，第一场ICPC区域赛就这样草草收场。</p>
<p>&emsp;&emsp;经过了一个月的训练，我们迎来了第二场区域赛银川站，这时我们信心满满，我们模拟了前几年的各种赛站，基本上都是可以拿到铜牌，这一站我们无比自信，而且异常兴奋，因为这是我们第一次公费旅游，出去参加ICPC区域赛，银川，大西北，因为郑州到银川的车票没有了，我们选择了从太原倒车，太原风景针不戳，那一下午是我公费旅游最开心的一下午，凌晨我们坐上了去往银川的火车，十个小时的卧铺是真的难受，下车后，我就见到了传说中的西北风光，着实壮丽，西北的空气都要清新许多，但西北也着实荒凉，路边全都是荒地，坐在车上向外望，还能看到山顶的白雪，景色着实优美。</p>
<p>&emsp;&emsp;到旅馆收拾好行李，我们便去品尝了银川特色羊肉泡馍，确实美味，简单睡了一觉后，我们便乘车去往ICPC现场，宁夏理工学院，四面环河，着实牛皮，这确实不用担心学生们溜出去了，进入现场，场面确实够壮观的，各种学校的牌子摆的是整整齐齐，一眼望去，全是名校，几百个队伍挤在这么一个体育场里，声音嘈杂，我们也是格外兴奋，我们的旁边是一支清华队伍，压力陡增。</p>
<p>&emsp;&emsp;第二天现场赛，我们踌躇满志，准备大展宏图，拿到题后，开始翻译，emm？这是这个意思吗？我作为队伍翻译官直接懵逼，这句话啥意思啊？再读一遍，草，这么简单，秒了，OK，下一题，嗯？这又是啥意思，再读一遍，草，傻逼题，秒了，下一题，靠！这又是啥意思啊！再读一遍，哦，原来是这个意思，傻逼题，WA了，嗯？怎么会，再读一遍，靠，傻逼吧，什么鬼题目啊，A了，然后，然后就没有然后了，死活读不懂第四题，我们两个小时A了3道题，排名170+，最后结束，我们207，发205块牌子，靠！最后才知道第四题也是一道傻逼题，就是一个字典树的小应用，就这样，我们在火车里抑郁了十几个小时，比赛前一天灵笼特别篇正好上映，我都忍住没有去看，最后竟然是这样的结局，不过白老板确实帅！</p>
<p>&emsp;&emsp;不过银川一行也不是没有收获，毕竟是亲眼见证了ACM/ICPC名场面。</p>
<p>&emsp;&emsp;之后就是蓝桥杯和河南省ICPC省赛了，哪一个比赛我们都没有顺过，蓝桥国二，省赛银牌，总是遇到各种问题。</p>
<p>&emsp;&emsp;但值得一提的是省赛又一次公费旅游，挺爽的，农大真真真TM漂亮！</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/73820b9e01f1453cba0dcd81c7874deb.jpg" alt="" title="农大校门"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/0ec1800dcc764628b3f4165a0d82d645.jpg" alt="" title="打卡网红餐厅"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/3fd614f61f0a406fb241657ce00f6e5d.jpg" alt="" title="打卡太原"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/7bdbd85a276a457b8baa6eb536ff0008.jpg" alt="" title="银川现场赛"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/8fcc0b7dc089403ea89fbedfd1a01d1a.jpg" alt="" title="比赛当前头上的云"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/0a95736f2eca4a1eb91bbdf68993713d.jpg" alt="夜晚的郑州" title="夜晚的郑州"></p>
<h2 id="第二次暑期集训"><a href="#第二次暑期集训" class="headerlink" title="第二次暑期集训"></a>第二次暑期集训</h2><p>&emsp;&emsp;之后就放假了，于是我又迎来了2021年的暑期培训，七月初我们放假，在家待了将近两个星期，便又回到了学校机房。</p>
<p>&emsp;&emsp;这次集训与上次集训的最大不同就在于，我们从被组织者变成了组织者，因为ACM的知识我们已经基本覆盖完全，所以这个假期我们没有再去学习新算法，每天就是不停地打比赛，打比赛，记得当时一周有不下4次的比赛，有时甚至能达到每日一场，但高频率的比赛必定会伴随着补题不充分的问题，所以后来我们渐渐地也放掉了一些比赛。</p>
<p>&emsp;&emsp;值得一提的是，集训末期，我还自己摸索着搭建出了Domjudge博客，给学弟们出了最后一场集训赛。</p>
<p>&emsp;&emsp;集训里我见证了被淹没的理工大。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/0e9692d54db948a2b8571d62076d445f.jpg" alt="" title="等待CF开始"></p>
<h2 id="比赛末期"><a href="#比赛末期" class="headerlink" title="比赛末期"></a>比赛末期</h2><p>&emsp;&emsp;2021年的ICPC日程公布了，令我们感到十分抓狂的是，CCPC和ICPC完全重合，而且没有一场线下赛，得知这个消息，我们的大脑嗡嗡的，要知道，<code>线上铜牌，线下银牌啊</code>，没办法，只能接受现实，经过缜密思考，我们决定，参加济南站、南京站以及威海站。</p>
<p>&emsp;&emsp;济南赛前，我们摩拳擦掌，准备大展拳脚，看到题后，疯狂思考，于是1个小时过去了，我们样例还没推出来，心态裂开，最后还是潘姥爷猜了个结论，我们俩去验证，发现是对的，于是写了一个超级简单的dfs，就过了…后来去开高斯消元，因为没有做过这种取模题目，完全没有往这方面去想，一直在想怎么去防止丢精度以及爆ll，到最后也没有调出来。</p>
<p>&emsp;&emsp;打完以后，我们心态崩盘，看着这个一题手快有牌的场子，我们心里不知道骂了出题人多少遍。</p>
<p>&emsp;&emsp;威海，大佬云集，不说了，4题手慢无牌。</p>
<p>&emsp;&emsp;威海比赛过后，听说学弟沈阳拿牌了，心里咯噔一下，那种说不出的难受，训练了这么长时间，到最后竟然是输在了选赛站上，沈阳伤我两次（2020沈阳也比较简单）</p>
<p>&emsp;&emsp;南京之前，我们已经抱着无牌退役的心情去了，心想反正最后一场了，放手一搏吧。</p>
<p>&emsp;&emsp;感谢南京出题组，原来还有良心出题组会去照顾弱校，对比之前济南的数论场，银川的翻译场，南京的题目质量和比赛体验直接拉满，最后拿下106（真就差一名），遗憾铜首（退役了也不忘让我再遗憾一次）。</p>
<h2 id="最后的晚餐"><a href="#最后的晚餐" class="headerlink" title="最后的晚餐"></a>最后的晚餐</h2><p>&emsp;&emsp;2021.12.04晚，算协余孽共聚一桌，享用了退役前最后的晚餐，这次酒席，我一杯酒也没挡。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/5d5dd9eaf9da41ddb6b69fe3eedb41fd.jpg" alt="" title="最后的晚餐"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;回过头来看看我的ACM生涯，可谓曲曲折折，遗憾满满，省赛没有拿过金牌，区域赛只出去过一次，只拿到了一个铜牌，还是铜首，蓝桥也没有拿到国一，银川也只差3名，好像每次比赛总会出现一些问题，总是差一点点。但是既然已经结束了，回忆总是美好的，从2019年11月接触ACM，到2021年12月退役，整整两年，虽然期间经常摸鱼，但这两年我收获颇丰，第一次参加竞赛，第一次接触白酒，第一次喝吐，第一次合租房子，第一次没有自己的假期，第一次熬夜CF，第一次深夜KTV，第一次翻墙回学校，第一次结交如此多的能人异士，可以说，圆满了。</p>
<p>&emsp;&emsp;祝愿潘姥爷能早日找到自己的初恋，老牛能顺利通过大厂面试获得心仪offer，也祝愿我们都能拥有美好的人生。</p>
<p>&emsp;&emsp;最后感谢王老师，给了我们进入ACM大门的机会并且给我们提供了601这样一方净土。</p>
<p>&emsp;&emsp;感谢所有助攻人员，respect。</p>
<p>​    </p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>纪念我的ACM史</tag>
      </tags>
  </entry>
  <entry>
    <title>线段树区间修改</title>
    <url>/posts/54d18d14.html</url>
    <content><![CDATA[<p>朴素版的线段树只能实现单点修改区间查询，修改和查询的时间复杂度都是O(logn)</p>
<h2 id="懒标记问题"><a href="#懒标记问题" class="headerlink" title="懒标记问题"></a>懒标记问题</h2><p>加上懒标记后的线段树就可以实现区间修改了，比如我要把[a,b]的值加上k，肯定不会傻到n次单点修改，是个人都会想到假如递归到一个包含在[a,b]的区间时就不用继续往下递归了，直接告诉这个区间的管理员，把这个区间的和直接给修改了，但是假如你上面第一次增加时增加区间为[c,d]，并且区间[c,d]是包含在[a,b]中间的，现在又要在[e,d]增加k，e&gt;c的，这个时候你就会发现[e,d]这个区间增加了两次，因为第一次增加时你根本没有递归到[e,d]，而是递归到这个区间的上一层就直接返回了，现在你再在[e,d]区间增加值就会出错，因为少加了第一次的增值，所以应该找一个东西记录下来第一次增值，并且把他带到下面去，这时懒标记就出来了，新开一个数组lazy[i]，表示编号为i的区间的累计增值，那么第一次修改[c,d]时，lazy<a href="u表示区间[c,d]的编号">u\</a>就会记录下来增值，lazy[u]+=c，第二次修改经过这个已经修改过的区间时，就要顺带着把这个区间的修改值一起带过去，正所谓父亲欠下的债儿子去偿还，当修改[e,d]时，经过[c,d]区间时，就会把lazy值给带到下面的儿子区间里面</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pushdown</span><span class="params">(u)</span>&#123;</span><br><span class="line">	tr[u&lt;&lt;<span class="number">1</span>].val+=lazy[u];  <span class="comment">//儿子区间加上父亲区间的增值</span></span><br><span class="line">	tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].val+=lazy[u];</span><br><span class="line">	lazy[u&lt;&lt;<span class="number">1</span>]=lazy[u];  <span class="comment">//儿子区间也要加上标记，当以后再经过儿子区间时也要顺带增值去修改</span></span><br><span class="line">	lazy[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].val+=lazy[u];</span><br><span class="line">    lazy[u]=<span class="number">0</span>;  <span class="comment">//既然父亲的债给儿子了，父亲也就没有债了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是区间查询的灵魂了，朴素版和plus只差了几行代码而已，首先修改时判断区间条件变了，只要当前区间处于修改区间内就可以直接修改，修改时把区间值增加区间长度*增值，并把加法标记lazy累加即可</p>
<h2 id="线段树1"><a href="#线段树1" class="headerlink" title="线段树1"></a>线段树1</h2><p>一道模板题<a href="https://www.luogu.com.cn/problem/P3372">线段树1</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll SUP=<span class="number">0x800000</span>;</span><br><span class="line"><span class="type">const</span> ll MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-4</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	ll l,r,val;</span><br><span class="line">&#125;tr[MAXN&lt;&lt;<span class="number">2</span>];</span><br><span class="line">ll lazy[MAXN&lt;&lt;<span class="number">2</span>],arr[MAXN];</span><br><span class="line"><span class="type">void</span> <span class="title function_">pushup</span><span class="params">(ll u)</span>&#123;</span><br><span class="line">	tr[u].val=tr[u&lt;&lt;<span class="number">1</span>].val+tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">pushdown</span><span class="params">(ll u)</span>&#123;  <span class="comment">//区间修改灵魂代码</span></span><br><span class="line">	<span class="keyword">if</span>(lazy[u])&#123;</span><br><span class="line">		tr[u&lt;&lt;<span class="number">1</span>].val+=(tr[u&lt;&lt;<span class="number">1</span>].r-tr[u&lt;&lt;<span class="number">1</span>].l+<span class="number">1</span>)*lazy[u];</span><br><span class="line">		lazy[u&lt;&lt;<span class="number">1</span>]+=lazy[u];</span><br><span class="line">		tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].val+=(tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].r-tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].l+<span class="number">1</span>)*lazy[u];</span><br><span class="line">		lazy[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+=lazy[u];</span><br><span class="line">		lazy[u]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">build</span><span class="params">(ll u,ll l,ll r)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r) tr[u]=&#123;l,r,arr[l]&#125;;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		tr[u]=&#123;l,r&#125;;</span><br><span class="line">		ll mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		build(u&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">		build(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">		pushup(u); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(ll u,ll l,ll r,ll c)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(tr[u].l&gt;=l &amp;&amp; tr[u].r&lt;=r)&#123;</span><br><span class="line">		tr[u].val+=(tr[u].r-tr[u].l+<span class="number">1</span>)*c;  <span class="comment">//值加上区间长度*增值</span></span><br><span class="line">		lazy[u]+=c; <span class="comment">//标记累加</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		pushdown(u);  <span class="comment">//往下传时要顺带着把增值带过去</span></span><br><span class="line">		ll mid=(tr[u].l+tr[u].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(r&lt;=mid) add(u&lt;&lt;<span class="number">1</span>,l,r,c);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(l&gt;mid) add(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,c);</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			add(u&lt;&lt;<span class="number">1</span>,l,r,c);</span><br><span class="line">			add(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,c);</span><br><span class="line">		&#125;</span><br><span class="line">		pushup(u);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">ll <span class="title function_">query</span><span class="params">(ll u,ll l,ll r)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(tr[u].l&gt;=l &amp;&amp; tr[u].r&lt;=r) <span class="keyword">return</span> tr[u].val;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		pushdown(u);  <span class="comment">//记得查询函数也要往下传，只要往区间下面递归的都要pushdown!</span></span><br><span class="line">		ll mid=(tr[u].r+tr[u].l)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(r&lt;=mid) <span class="keyword">return</span> query(u&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(l&gt;mid) <span class="keyword">return</span> query(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			ll ret1=query(u&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">			ll ret2=query(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">			<span class="keyword">return</span> ret1+ret2;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	ll n,m;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;arr[i];</span><br><span class="line">	build(<span class="number">1</span>,<span class="number">1</span>,n); </span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		ll op;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;op;</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">			ll x,y,k;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;k;</span><br><span class="line">			add(<span class="number">1</span>,x,y,k);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			ll x,y;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;query(<span class="number">1</span>,x,y)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="线段树2"><a href="#线段树2" class="headerlink" title="线段树2"></a>线段树2</h2><p>接下来看一道比较难的升级版本<a href="https://www.luogu.com.cn/problem/P3373">线段树2</a></p>
<p><strong><img src="https://cdn.jsdelivr.net/gh/uncleacc/Sucai/20210119174515.png" alt="image-20210119174455193" style="zoom:50%;" /></strong></p>
<p>这道题只是增加了一个操作，不只可以给一段区间增加值，也可以乘上一个值，假如两种运算分开考的话那么这道题就是一道模板题，但难就难在他一起考了，你一定会想到这就会涉及到优先级问题，因为假如给一段区间增加了一个值，又给这段区间乘上一个值，之后递归时经过这个区间时，你就弄不清楚应该先加还是先乘，而这两种结果显然是不同的，假设儿子区间的值为a，父亲区间已经有了加法标记b和乘法标记c，那么两种不同的运算顺序会得到不同结果</p>
<p>$(a+b)<em>c!=a</em>c+b$</p>
<p>那么有没有办法规定一种固定的运算顺序，使得无论是先给父亲区间加上加法标记还是乘法标记最终得到相同的结果呢？</p>
<p>答案是有的，观察上面不等式两边的式子发现只要在右面的b后面乘上一个c两个式子就相等了，因此我们就可以规定一种运算，永远先乘再加，当添加标记的顺序就是先乘再加时肯定没问题，但是若先添加的加法标记然后添加的乘法标记时怎么办？这时候计算儿子的值时就是<code>儿子的值*乘值+儿子区间长度*增值</code>，假如先加后乘那么儿子的值应该是<code>(儿子的值+儿子区间长度*增值)*乘值</code>，发现了吗？实际和理想只差了一个乘法标记，所以当先添加加法标记再添加乘法标记时，把已经添加的加法标记乘上乘值即可使得两种不同的顺序得到相同的结果，儿子的加法标记更新时就要先乘以父亲乘法标记再加上父亲加法标记，你可能会问为什么有这种情况，向下传递时父亲标记不是被传递给儿子了吗？但传递后还可以再给啊！传递后我再让父亲区间加上或者乘上一个值，这也是合法的，所以当再次经过父亲区间时儿子区间的加法标记还没有乘上父亲的增值，就需要补充上去，而乘法标记只需要乘以父亲乘法标记即可</p>
<h2 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void pushdown(ll u)&#123;</span><br><span class="line">	ll l=u&lt;&lt;1,r=u&lt;&lt;1|1;</span><br><span class="line">	// 儿子的值=儿子的值*父亲的乘法标记+儿子区间*父亲加法标记 </span><br><span class="line">	tr[l].val=(tr[l].val*lazy2[u]%p+(tr[l].r-tr[l].l+1)*lazy1[u]%p)%p;</span><br><span class="line">	tr[r].val=(tr[r].val*lazy2[u]%p+(tr[r].r-tr[r].l+1)*lazy1[u]%p)%p;</span><br><span class="line">	// 儿子加法标记更新，儿子加法标记=儿子加法标记*父亲乘法标记+父亲加法标记 </span><br><span class="line">	lazy1[l]=(lazy1[l]*lazy2[u]%p+lazy1[u])%p;</span><br><span class="line">	lazy1[r]=(lazy1[r]*lazy2[u]%p+lazy1[u])%p;</span><br><span class="line">	//  儿子乘法标记=儿子乘法标记*父亲乘法标记</span><br><span class="line">	lazy2[l]=lazy2[l]*lazy2[u]%p;</span><br><span class="line">	lazy2[r]=lazy2[r]*lazy2[u]%p;</span><br><span class="line">	</span><br><span class="line">	lazy1[u]=0;</span><br><span class="line">	lazy2[u]=1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么不先加后乘呢？因为这样就涉及到了除法运算，就出现了精度问题，会出错。</p>
<h2 id="ACCODE"><a href="#ACCODE" class="headerlink" title="ACCODE"></a>ACCODE</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll SUP=<span class="number">0x800000</span>;</span><br><span class="line"><span class="type">const</span> ll MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-4</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	ll l,r,val;</span><br><span class="line">&#125;tr[MAXN&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="comment">//lazy1加法标记 lazy2乘法标记 </span></span><br><span class="line">ll lazy1[MAXN&lt;&lt;<span class="number">2</span>],lazy2[MAXN&lt;&lt;<span class="number">2</span>],arr[MAXN];</span><br><span class="line">ll n,m,p;</span><br><span class="line"><span class="type">void</span> <span class="title function_">pushup</span><span class="params">(ll u)</span>&#123;</span><br><span class="line">	tr[u].val=(tr[u&lt;&lt;<span class="number">1</span>].val+tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].val)%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">pushdown</span><span class="params">(ll u)</span>&#123;</span><br><span class="line">	ll l=u&lt;&lt;<span class="number">1</span>,r=u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>;</span><br><span class="line">	<span class="comment">// 儿子的值=儿子的值*父亲的乘法标记+儿子区间*父亲加法标记 </span></span><br><span class="line">	tr[l].val=(tr[l].val*lazy2[u]%p+(tr[l].r-tr[l].l+<span class="number">1</span>)*lazy1[u]%p)%p;</span><br><span class="line">	tr[r].val=(tr[r].val*lazy2[u]%p+(tr[r].r-tr[r].l+<span class="number">1</span>)*lazy1[u]%p)%p;</span><br><span class="line">	<span class="comment">// 儿子加法标记更新，儿子加法标记=儿子加法标记*父亲乘法标记+父亲加法标记 </span></span><br><span class="line">	lazy1[l]=(lazy1[l]*lazy2[u]%p+lazy1[u])%p;</span><br><span class="line">	lazy1[r]=(lazy1[r]*lazy2[u]%p+lazy1[u])%p;</span><br><span class="line">	<span class="comment">//  儿子乘法标记=儿子乘法标记*父亲乘法标记</span></span><br><span class="line">	lazy2[l]=lazy2[l]*lazy2[u]%p;</span><br><span class="line">	lazy2[r]=lazy2[r]*lazy2[u]%p;</span><br><span class="line">	</span><br><span class="line">	lazy1[u]=<span class="number">0</span>;</span><br><span class="line">	lazy2[u]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">build</span><span class="params">(ll u,ll l,ll r)</span>&#123;</span><br><span class="line">	lazy1[u]=<span class="number">0</span>;  <span class="comment">//初始化标记 </span></span><br><span class="line">	lazy2[u]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(l==r) tr[u]=&#123;l,r,arr[l]&#125;;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		tr[u]=&#123;l,r&#125;;</span><br><span class="line">		ll mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		build(u&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">		build(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">		pushup(u); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(ll u,ll l,ll r,ll c)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(tr[u].l&gt;=l &amp;&amp; tr[u].r&lt;=r)&#123;</span><br><span class="line">		tr[u].val=(tr[u].val+(tr[u].r-tr[u].l+<span class="number">1</span>)*c%p)%p;  <span class="comment">//区间值加上c </span></span><br><span class="line">		lazy1[u]=(c+lazy1[u])%p;  <span class="comment">//更新加法标记 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		pushdown(u);</span><br><span class="line">		ll mid=(tr[u].l+tr[u].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(l&lt;=mid) add(u&lt;&lt;<span class="number">1</span>,l,r,c);</span><br><span class="line">		<span class="keyword">if</span>(r&gt;mid) add(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,c);</span><br><span class="line">		pushup(u);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">mul</span><span class="params">(ll u,ll l,ll r,ll c)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(tr[u].l&gt;=l &amp;&amp; tr[u].r&lt;=r)&#123;</span><br><span class="line">		tr[u].val=tr[u].val*c%p;  <span class="comment">//区间的值乘上c </span></span><br><span class="line">		lazy1[u]=(lazy1[u]*c)%p;  <span class="comment">//每次更新乘法标记时要顺带着把加法标记也更新了，目的是确定优先级 </span></span><br><span class="line">		lazy2[u]=(lazy2[u]*c)%p;  <span class="comment">//更新乘法标记 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		pushdown(u);</span><br><span class="line">		ll mid=(tr[u].l+tr[u].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(l&lt;=mid) mul(u&lt;&lt;<span class="number">1</span>,l,r,c);</span><br><span class="line">		<span class="keyword">if</span>(r&gt;mid) mul(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,c);</span><br><span class="line">		pushup(u);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">ll <span class="title function_">query</span><span class="params">(ll u,ll l,ll r)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(tr[u].l&gt;=l &amp;&amp; tr[u].r&lt;=r) <span class="keyword">return</span> tr[u].val;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		pushdown(u);</span><br><span class="line">		ll mid=(tr[u].r+tr[u].l)&gt;&gt;<span class="number">1</span>,ret=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(l&lt;=mid) ret=(ret+query(u&lt;&lt;<span class="number">1</span>,l,r))%p;</span><br><span class="line">		<span class="keyword">if</span>(r&gt;mid) ret=(ret+query(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r))%p;</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;p;</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;arr[i];</span><br><span class="line">	build(<span class="number">1</span>,<span class="number">1</span>,n); </span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		ll op,x,y,k;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;op;</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;k;</span><br><span class="line">			mul(<span class="number">1</span>,x,y,k);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>)&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;k;</span><br><span class="line">			add(<span class="number">1</span>,x,y,k);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;query(<span class="number">1</span>,x,y)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>线性基讲解</title>
    <url>/posts/28404220.html</url>
    <content><![CDATA[<blockquote>
<p>线性基常用来解决子集异或问题，可用来求解 “集合元素异或第k大” 问题</p>
</blockquote>
<p>异或和、张成、线性相关、线性基的定义与性质和构造方法均可以参考 <a href="[线性基学习笔记 | Menci&#39;s OI Blog](https://oi.men.ci/linear-basis-notes/">这篇博客</a>)</p>
<p>本文记录我对线性基的理解，线性基本质上就是简化版高斯消元，高斯消元求得是<code>标准化线性基</code>或者叫<code>简化基</code>，即如果一个位置上的数字是1，就会把这一列的1全部消掉，与之相对地，称之为<code>非标准线性基</code>或者<code>部分线性基</code>，标准化线性基是唯一地，而非标准线性基不唯一，线性基包括简化基和部分线性基，网上的线性基构造方法其实就是高斯消元的替代版本。</p>
<p>线性基的优势：</p>
<ol>
<li>支持动态插入，而高斯消元只能求一次</li>
<li>代码量短</li>
</ol>
<h2 id="构造标准线性基的方法："><a href="#构造标准线性基的方法：" class="headerlink" title="构造标准线性基的方法："></a>构造标准线性基的方法：</h2><ol>
<li>高斯消元（a集合就是标准线性基）</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ull = <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ull <span class="title">deg</span><span class="params">(ull num, <span class="type">int</span> deg)</span> </span>&#123; <span class="keyword">return</span> num &amp; (<span class="number">1ull</span> &lt;&lt; deg); &#125;</span><br><span class="line"></span><br><span class="line">ull a[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%llu&quot;</span>, &amp;a[i]);</span><br><span class="line">  <span class="type">int</span> row = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">63</span>; ~col &amp;&amp; row &lt;= n; --col) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = row; i &lt;= n; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">deg</span>(a[i], col)) &#123;</span><br><span class="line">        std::<span class="built_in">swap</span>(a[row], a[i]);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">deg</span>(a[row], col)) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i == row) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">deg</span>(a[i], col)) &#123;</span><br><span class="line">        a[i] ^= a[row];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++row;</span><br><span class="line">  &#125;</span><br><span class="line">  ull ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; row; ++i) &#123;</span><br><span class="line">    ans ^= a[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%llu\n&quot;</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>根据标准线性基的性质直接构造</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAXL = <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LinearBasis</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> a[MAXL + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LinearBasis</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::<span class="built_in">fill</span>(a, a + MAXL + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">long</span> <span class="type">long</span> t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 逆序枚举二进制位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = MAXL; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果 t 的第 j 位为 0，则跳过</span></span><br><span class="line">            <span class="keyword">if</span> (!(t &amp; (<span class="number">1ll</span> &lt;&lt; j))) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果 a[j] != 0，则用 a[j] 消去 t 的第 j 位上的 1</span></span><br><span class="line">            <span class="keyword">if</span> (a[j]) t ^= a[j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 找到可以插入 a[j] 的位置</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 用 a[0...j - 1] 消去 t 的第 [0, j) 位上的 1</span></span><br><span class="line">                <span class="comment">// 如果某一个 a[k] = 0 也无须担心，因为这时候第 k 位不存在于线性基中，不需要保证 t 的第 k 位为 0</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; j; k++) <span class="keyword">if</span> (t &amp; (<span class="number">1ll</span> &lt;&lt; k)) t ^= a[k];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 用 t 消去 a[j + 1...L] 的第 j 位上的 1</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = j + <span class="number">1</span>; k &lt;= MAXL; k++) <span class="keyword">if</span> (a[k] &amp; (<span class="number">1ll</span> &lt;&lt; j)) a[k] ^= t;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 插入到 a[j] 的位置上</span></span><br><span class="line">                a[j] = t;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 不要忘记，结束插入过程</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 此时 t 的第 j 位为 0，继续寻找其最高位上的 1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有插入到任何一个位置上，则表明 t 可以由 a 中若干个元素的异或和表示出，即 t 在 span(a) 中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="P3812-【模板】线性基（求最大异或）"><a href="#P3812-【模板】线性基（求最大异或）" class="headerlink" title="P3812 【模板】线性基（求最大异或）"></a>P3812 【模板】线性基（求最大异或）</h2><p><a href="[P3812 【模板】线性基 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn">原题链接</a>](<a href="https://www.luogu.com.cn/problem/P3812">https://www.luogu.com.cn/problem/P3812</a>))</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXL = <span class="number">64</span>;</span><br><span class="line">ll a[<span class="number">64</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(ll val)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = MAXL - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!((val &gt;&gt; i) &amp; <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span> (a[i]) val ^= a[i];</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (val &gt;&gt; j &amp; <span class="number">1</span>) &#123;</span><br><span class="line">					val ^= a[j];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; MAXL; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (a[j] &gt;&gt; i &amp; <span class="number">1</span>) &#123;</span><br><span class="line">					a[j] ^= val;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			a[i] = val;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">while</span> (n--) &#123;</span><br><span class="line">		<span class="type">long</span> <span class="type">long</span> t;</span><br><span class="line">		cin &gt;&gt; t;</span><br><span class="line">		<span class="built_in">insert</span>(t);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">// 	for (int i = 0; i &lt; MAXL; i++) cout &lt;&lt; a[i] &lt;&lt; &#x27; &#x27;;</span></span><br><span class="line"><span class="comment">// 	cout &lt;&lt; endl;</span></span><br><span class="line">	ll ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAXL; i++) ans ^= a[i];</span><br><span class="line">	cout &lt;&lt; ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Acwing-210-异或运算（求第k大）"><a href="#Acwing-210-异或运算（求第k大）" class="headerlink" title="Acwing 210.异或运算（求第k大）"></a>Acwing 210.异或运算（求第k大）</h2><p><a href="https://www.acwing.com/problem/content/description/212/">原题链接</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXL = <span class="number">64</span>;</span><br><span class="line">ll a[<span class="number">64</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(ll val)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = MAXL - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!((val &gt;&gt; i) &amp; <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span> (a[i]) val ^= a[i];</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (val &gt;&gt; j &amp; <span class="number">1</span>) &#123;</span><br><span class="line">					val ^= a[j];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; MAXL; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (a[j] &gt;&gt; i &amp; <span class="number">1</span>) &#123;</span><br><span class="line">					a[j] ^= val;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			a[i] = val;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span> a);</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="type">long</span> <span class="type">long</span> t;</span><br><span class="line">		cin &gt;&gt; t;</span><br><span class="line">		<span class="built_in">insert</span>(t);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> tail = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAXL; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i]) &#123;</span><br><span class="line">			a[tail++] = a[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	cout &lt;&lt; &quot;a[i]&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//	for (int i = 0; i &lt; tail; i++) &#123;</span></span><br><span class="line"><span class="comment">//		cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"><span class="comment">//	cout &lt;&lt; endl;</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (n &gt; tail) &#123;</span><br><span class="line">		flag = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> q;</span><br><span class="line">	cin &gt;&gt; q;</span><br><span class="line">	<span class="keyword">while</span> (q--) &#123;</span><br><span class="line">		<span class="type">long</span> <span class="type">long</span> k;</span><br><span class="line">		cin &gt;&gt; k;</span><br><span class="line">		<span class="keyword">if</span> (flag) &#123;</span><br><span class="line">			k--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		ll ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">63</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">			<span class="keyword">if</span> (k &gt;&gt; i &amp; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">//				cout &lt;&lt; &quot;test: &quot; &lt;&lt; k &lt;&lt; &quot; &quot; &lt;&lt; i &lt;&lt; endl;</span></span><br><span class="line">				<span class="keyword">if</span> (i &gt;= tail) &#123;</span><br><span class="line">					ans = <span class="number">-1</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				ans ^= a[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; ans &lt;&lt; endl;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> T;</span><br><span class="line">	cin &gt;&gt; T;</span><br><span class="line">	<span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (T--) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; t++ &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">solve</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>线性基</tag>
      </tags>
  </entry>
  <entry>
    <title>计算几何</title>
    <url>/posts/6ce32202.html</url>
    <content><![CDATA[<h1 id="计算几何"><a href="#计算几何" class="headerlink" title="计算几何"></a>计算几何</h1><p><code>皮克定理</code>： 2S=2a+b-2 (S:三角形面积，a三角形内部点的个数，b三角形边上点的个数)，求三角形内点的个数</p>
<p><code>求线段上整数点的个数</code>：gcd(abs(x2-x1),abs(y2-y1))+1</p>
<p><code>判断一个点是否在多变形内部</code>：以这个点向多边形顶点做向量，相邻两两做叉积(左乘右)，若得出的所有结果符号都一样，则在内部</p>
<p><code>计算多边形面积</code>：从原点向多边形顶点做向量，相邻向量做叉积（右乘左）累加求和除以2</p>
<p><code>判断一个点是否在两条直线中间</code>：从两个直线上随便找两个点，从当前点向交点和直线上一点做向量，两向量做叉乘，另外一条直线也是如此，叉乘的两个结果如果符号不同就在中间，否则不在</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title>考研这一年</title>
    <url>/posts/6d71acfd.html</url>
    <content><![CDATA[<blockquote>
<p>2020年，我考研的一年</p>
</blockquote>
<h2 id="1月1日，我正式开始考研"><a href="#1月1日，我正式开始考研" class="headerlink" title="1月1日，我正式开始考研"></a>1月1日，我正式开始考研</h2><p>我开始准备英语长难句，跟刘晓燕老师的语法课，每天跟群里面发的每日一句，坚持背单词，当时用app+实体书结合的方法进行背诵，A4纸的方法尤其有效，记得由于当时还是寒假在家，动力不足，每天有效学习时长可能只有6个小时左右，所以会花很多时间来背诵单词，当时我非常想考一所985院校，但也不清楚自己的实力，不了解考研流程，所以定了重庆大学这个984.5，有了目标，就有了动力，我从没有断过每日单词打卡，这个习惯我一直保持到10月3日，连续打卡301天，这是我考研路上引以为傲的一项战绩。我深知高数的重要性，所以很早就开始跟汤家凤的基础课，买了他的1800，每天下午都会听一会，做点题，但不多，整个寒假也只是过完了前3章（几乎没咋学）</p>
<h2 id="3月初，开学考研步入正轨"><a href="#3月初，开学考研步入正轨" class="headerlink" title="3月初，开学考研步入正轨"></a>3月初，开学考研步入正轨</h2><p>我开始提高每日学习时长，能翘的课都翘了，还发现了一个学习圣地，不需要预约，贼适合考研，强过图书馆一万倍，我把考研书籍搬到教室占位，当时的书籍很少，竟然都不需要书立，当时上午学习英语，其余时间留给数学，记得刚开始英语真题时，感觉题目贼难，文章单词都认识，放在一起就不会，题目也是很坑，当时每道阅读题几乎都要错个两三个，但当时的数学给我感觉很好（因为题目很简单），最喜欢刷那些水题了，流畅无阻，但好景不长，我碰到了660，做660我一度怀疑这本习题集真的是打基础的？<del>事实证明真的不是</del>，刷完660我就开始刷880了，880给我的感觉很不错，题目很多都是思路很常规，但里面有很多细节的题，当然也有很多难题怪题，毕竟属于基础和强化之间的习题集，快做完880时，我们也快放假了，由于疫情原因暑假无法留校，真的搞心态，在家里真的没办法学习，室友们也都不打算租房，我只好到处寻找研友，最后还是和一位高中同学一起租了个寄宿自习室，开始了我的暑期学习。</p>
<h2 id="6月7日，暑期学习开始"><a href="#6月7日，暑期学习开始" class="headerlink" title="6月7日，暑期学习开始"></a>6月7日，暑期学习开始</h2><p>在家里待了一星期，整个人都不好了，开始几天还能投入学习，但是越到后面越不想学，到后面干脆摆烂，原定10天的家庭生活压缩到了6天，第七天一早我就和同学出发前往自习室了，自习室比我想象的要好的多，真的吹爆，焦作六七八自习室，考研二战暑期必选，三个月总费用2100，包含住宿费和自习室费用，宿舍和自习室只隔了一个楼，可以午休真不错，下面就是小吃街，每天吃饭睡觉学习无缝衔接，这种感觉比在学校都好，自习室餐厅饭也很好吃，只有一个缺点就是太贵！开始我还很喜欢在自习室吃，后面价格越来越贵，只好出去外面吃，自习室里面大多数都是本校的，我也看到了很多熟人，每天出去吃饭都能遇到熟人，记得当时最讨厌的就是每周的核酸，因为离核酸点很远，而且人还特多，记得第一次做核酸排了40分钟的队，暑期我完成了高数强化和专业课408的一轮复习，英语阅读也完成了2刷，记得差不多8月的时候，感觉高数和英语都形成了质变，做题感觉明显强于之前，英语阅读已经偶尔错两道道，经常性全对或者错一道，做题时间也压缩在15分钟左右，简单的甚至10分钟即可完成，高数一些难题也可以比较顺畅地做出来，武忠祥的每日一题几乎每次都可以做对，当然强化阶段难题还是更多的，尤其是辅导讲义上，几乎每一道题都不会做，因为太难太偏了，专业课由于打过acm，数据结构毫无压力，因为操作系统之前好好学过，进程那一部分也学的不错，但文件管理之后内容，记得当时一窍不通，由于知识点太多太杂，我当时还买了一盒记号笔，用来画知识点，一盒记号笔到考研结束用完了5支。三个月没从来没有歇过完整的一天，除非当天特别厌学，我会抽出一个下午或者晚上早点回去来给自己放松一下，由于这种高强度的学习，我当时的心情一度很压抑，尤其是下午的时候，焦作还是个火炉城市，夏天异常热，虽然自习室空调不停，但是人的情绪还是特别容易焦躁，到8月份的时候，我有连续一个多星期都没办法静下心来，为了克制这种焦躁的情绪，我尝试了各种方法，比如晚上提前一点结束，去外面跑步，或者约朋友打会乒乓球，不过最有效的方法还是换座位，我属于是那种在一个环境待久了容易腻的人，当进入一个新环境我往往可以提高效率，当时最开心的时光就属于是晚上和朋友在楼顶打乒乓球的时间了，为了让同学们有锻炼身体的机会，自习室机构在楼顶设置了一个健身房，上面搭了一个大棚，对于这点，我真的吹爆，每天40分钟的乒乓球时间足以吹走我一天的疲惫，打完球再去楼底买个小吃，现在想想都觉得爽。这样的生活一直只持续到8.22，由于朋友要开学了，所以我们宿舍4个人出去聚了一餐，又去看了《独行月球》，第二天，朋友走了，我也在9.2返回了学校。进入考研第四阶段。</p>
<h2 id="9月2日，回归校园生活"><a href="#9月2日，回归校园生活" class="headerlink" title="9月2日，回归校园生活"></a>9月2日，回归校园生活</h2><p>告别了暑期学习，但学习不能停，依旧是日复一日的高强度学习，只不过这个时期，我的学习重心也由数学转到了408的学习，我会把一下午的时间都分配给专业课，每天盯着408一道道现在看来如同天书般的题目，我是真的头大，408的学习，我过了至少4轮，真的没有那一门课有408那样五花八门的术语以及错综复杂的知识点，这样的学习持续到10月初，当时的我已经开始由408转向自命题了，这种感觉就是一个天上一个地下，突然看917，那些题就好像是智障一般，出的异常简单，也怪不得往年大量考生可以拿130+，而且当时我的数学也基本成型，各种曾经的难题已经难不倒我，我开始估分，保守估计当时的我做往年真题已经可以拿到380+的分数，因此我开始向往更好的学校，我盯上了四川大学，因为我一直比较喜欢四川，可能是因为电视剧上面的川音很上头吧，但是四川大学去年均分390，我非常害怕，害怕最后发挥不好考不上，尤其是知乎上各种劝退贴，380+被刷一半，更重要的是我本科学校很拉，双非一本，周围没有人敢报考985，我报的学校已经是我已知最好的了，特别慌，就是那种从理性上来看，只要最后正常发挥可以考上，从感性上看考不上的那种难受，这种挣扎持续了一个多星期，那个时候我没事就拿手机去搜四川大学的相关消息，“重大末流985”当初是我看到最多的词条，从开始想上一所985到现在想上一所好的985，无数个夜晚我都想把志愿改了，可惜最后我还是没能战胜心理压力，依旧选择了重大<del>从结果来看报川大是更好的选择</del>。时间来到10月底，我开始给政治投入更多时间，虽然暑假就已经过了一轮政治，但是由于没咋做题，对于知识点的掌握情况不容乐观，肖1000题没几道会的，一度很崩溃。坚持听了一个月的腿姐强化课，政治才有些好转。</p>
<h2 id="12月最后冲刺"><a href="#12月最后冲刺" class="headerlink" title="12月最后冲刺"></a>12月最后冲刺</h2><p>由于疫情影响，河南高校要提前放假，所以舍友都在12月初离校了，只有我和研友独守空巢，这对我们来说是个好消息，我们休息地环境更好了，但是好景不长，由于河南疫情加重，要求所有考生离校，在最后的冲刺时期，一旦没有调整好状态很可能意味着浪费掉一年的时光，我深知此事事关重大，也知道家中环境绝不适合学习，一时间不知所措，<del>当时心中不知道骂了学校多少遍</del>，不过好在考生齐心，向学校提出留校学习，学校最后妥协，允许考生留校，但是需要封控，起初大家都以为一个星期后便可恢复如常，大家也都习惯了，但是每当距离解封还有1天时，总有寝室楼莫名出现感染者，喜提一星期，原定1星期的封闭延长至16天，连续10来天，顿顿大米，看到大米就恶心，吃过的饭盒也不能扔，只能丢在阳台，到后面阳台的垃圾已经堆积成山，难以想象在这种环境下我还要保持每天10个小时的学习。距离考试只剩7天，大家的备战也都如火如荼的进行着，偏偏这个时候，我们宿舍楼出现感染者了，大家都非常慌，不敢与别人有任何接触，一天晚上，邻宿舍的一个同学叫我辅导他一些代码题，我当时犹豫要不要去，心想应该不会那么巧，他现在也没啥症状，应该问题不大，所以晚上我去了，给他讲了1个多小时的题，第二题下午，我收到通知，他，，他发烧了，当时我心里一万个草泥马奔腾而过，我和我室友那几天胆战心惊，害怕自己会中招，不过那几天倒也没事，身体没有任何异样，距离考试仅剩一天，我室友发烧了，38度多，绝了，就挑要考试的时候发烧，考试第一天我倒是没事，上午政治，今年出的题比较难，感觉做的不太好，选择有好几道都不确定，大题也没压中几道，大多数还是抄材料+胡编乱造，下午考英语，题目异常简单，我从来没有做哪一年的英语真题做的如此之顺，我可以肯定阅读全对，最后做完还有半个小时时间，英语考完，我信心大增，第二天醒来，头好晕，完蛋，中招了，不过因为刚刚发烧，头虽然晕，但是不太影响做题，上午数学，做的非常顺利，除了一道选择题不确定以外，其余题目都做出来了，而且做完所有题目还有20分钟，考完我头巨晕，趴下就能睡着的那种，摸了摸头，滚烫滚烫的，拖着疲惫的身体回到了宿舍，吃了几口饭就睡了，最后一门专业课，我其实是不担心的，因为根据往年的题目来看，一般来说917是很简单的，所以我考试的时候并没有绷紧心弦去做题（也有很大一部分原因是头真的很晕），但是做完几道选择题发现不对劲，怎么这么多不会，选择题竟然花了1个小时10分钟，天呐，我当时就慌了，赶紧加快速度，后面大题也很难，没几道会的，最后甚至题目都没做完，后面才知道，我还漏了一道非常简单的8分题目，因为没看到！考完专业课我是真崩溃，估分100分，要知道往年都是135+的，今年的题给我干废了。不过由于其他科目发挥都很好，所以我不担心总分会很低。</p>
<h2 id="出分"><a href="#出分" class="headerlink" title="出分"></a>出分</h2><p>2023.3.21日，怀揣着忐忑地心情，我点开了查分链接，403分。看到这个分数，说实话我并没有多么激动，意料之中的分数，一整年的辛苦，才换来了最后的辉煌，一切都是顺理成章，一切都是理所应当。</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>考研</tag>
      </tags>
  </entry>
  <entry>
    <title>迭代加深算法</title>
    <url>/posts/88061fdd.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul>
<li>关于DFS：<br>DFS算法是沿着搜索树的根节点，一直遍历完该搜索树之后再回溯继续搜索的一种算法。缺点是可能会出现答案在搜索树层数很浅，在靠后的子树中，但由于搜索次序需要遍历完一棵搜索树所有的节点，所以导致效率低下。</li>
<li>关于BFS：<br>BFS算法是沿着搜索树的根节点，按层遍历完该搜索树所有节点的一种算法。缺点是可能会出现答案在搜索树层数很深的地方，导致效率低下。且如果是满二叉树这样的搜索树很可能会使在BFS的过程中队列爆掉。在层数很多的时候会占用很多的空间。</li>
<li>关于迭代加深：<br>迭代加深算法其实是一种结合了DFS和BFS两种算法特点的搜索算法。我们会预设搜索的层数，然后仅在该层数以内进行DFS。这一算法很有效的避免了DFS可能会出现的效率低下的问题。<br>而似乎这样的算法思路和BFS相同，而且由于拓展层数的时候会重复搜索，所以反而更慢了。但其实，迭代加深有效的避免了使用大量空间的问题，相对于普通的BFS也是有优势的。</li>
</ul>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://www.luogu.com.cn/problem/UVA529">链接</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/2024-01-07_20-19-26.jpg" alt="2024-01-07_20-19-26"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> n, maxd, ans[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k &gt; maxd) <span class="keyword">return</span> ans[k - <span class="number">1</span>] == n;</span><br><span class="line">    <span class="keyword">if</span> (ans[k - <span class="number">1</span>] * (<span class="type">long</span> <span class="type">long</span>)<span class="built_in">pow</span>(<span class="number">2</span>, maxd - k + <span class="number">1</span>) &lt; n) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 最优化剪枝：后面每一项最多是前一项的2倍</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; k; j++) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> t = ans[i] + ans[j];</span><br><span class="line">            <span class="keyword">if</span> (t &gt; n) <span class="keyword">break</span>;               <span class="comment">// 可行性剪枝：ans单调递增，如果t&gt;n则后面的j都会大于n；</span></span><br><span class="line">            <span class="keyword">if</span> (t &lt;= ans[k - <span class="number">1</span>]) <span class="keyword">continue</span>;  <span class="comment">// 保证ans单调递增</span></span><br><span class="line">            ans[k] = t;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">dfs</span>(k + <span class="number">1</span>)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ans[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (maxd = <span class="number">0</span>;; maxd++) &#123;<span class="comment">//一点一点加大深度</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">dfs</span>(<span class="number">1</span>)) &#123;</span><br><span class="line">				cout &lt;&lt; maxd &lt;&lt; endl;</span><br><span class="line">				cout &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= maxd; i++)</span><br><span class="line">					cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">                cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>迭代加深</tag>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title>遗传算法</title>
    <url>/posts/9cfaa3ca.html</url>
    <content><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ol>
<li>种群：群体的集合</li>
<li>位串：个体的表示形式。对应于遗传学中的染色体。</li>
<li>基因：位串上的一个元素，S=1011，则其中的1，0，1，1这4个元素分别称为基因。</li>
<li>编码：解空间中的解在遗传算法中的表示形式。从问题的解(solution)到基因型的映射称为编码，<strong>即把一个问题的可行解从其解空间转换到遗传算法的搜索空间的转换方法</strong>。</li>
<li>解码：<strong>遗传算法染色体向问题解的转换</strong>。</li>
<li>适应度：每个个体染色体和优秀染色体的基因序列差值大小</li>
<li>变异：0变1，1变0，概率小 <strong>(搜索与原来相差较小的解)</strong></li>
</ol>
<p><strong>备注：</strong>常见的编码方法有<strong>二进制编码</strong>、<strong>格雷码编码</strong>、 <strong>浮点数编码</strong>、<strong>各参数级联编码</strong>、<strong>多参数交叉编码</strong>等。</p>
<ul>
<li><p>二进制编码：即组成染色体的基因序列是由二进制数表示，具有编码解码简单易用，交叉变异易于程序实现等特点。</p>
</li>
<li><p>格雷编码：两个相邻的数用格雷码表示，其对应的码位只有一个不相同，从而可以提高算法的局部搜索能力。这是格雷码相比二进制码而言所具备的优势。</p>
</li>
<li><p>浮点数编码：是指将个体范围映射到对应浮点数区间范围，精度可以随浮点数区间大小而改变。</p>
</li>
</ul>
<hr>
<p>交叉：<strong>(搜索与原来相差较大的解)</strong></p>
<p>单点交叉：选择一个交叉点，交叉交换</p>
<p>多点交叉：选择两个交叉点，交换中间的基因序列</p>
<p>均匀交叉：不选交叉点，0不交叉，子代1来自父代1，子代2来自父代2；1交叉，子代1来自父代2，子代2来自父代1</p>
<p>洗牌交叉：先打乱基因序列，然后选择交叉点交叉，目的是消除交叉点的选择对于结果的影响</p>
<hr>
<p>选择：</p>
<p>1）轮盘赌：$p(x<em>i)=\frac{f(x_i)}{\sum</em>{i=1}^nf(x_i)}$，表示选择个体的概率，如果适应度函数值为0，则概率为0，就导致无法选择这个个体，违背了任何个体都有概率选择的原则，容易落入局部最优解</p>
<p>2）线性排序选择：</p>
<p>​    a）最差的选择概率：$p_{min}=\frac{2}{n(n+1)}$，</p>
<p>​    b）最好的选择概率：$p_{max}=\frac{2}{(n+1)}$，</p>
<p>​    c）中间的选择概率：$p<em>i=p</em>{min}+(p<em>{max}-p</em>{min})\frac{i-1}{n-1}\forall i\in{1,..,n}/{1,n}$</p>
<h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><p>以Max-cut problem问题为例，即将一个无向图切成2个部分（子图），从而使得2个子图之间的边数最多。</p>
<p><img src="https://pic4.zhimg.com/80/v2-cf6bff4a6302a3411bfb9ea83acea5a7_720w.webp" alt=""></p>
<p><strong>Step 1: 初始解</strong></p>
<p>（1）设置种群的大小，编码染色体，初始种群:</p>
<p>设定种群的大小为10，编码位数为7位（因为有7个节点），初始人口:</p>
<p>S1=7(0001111)，S2=5(0011010)，S3=7(1110000)，S4=7(1011011)<br>S5=7(0101100)，S6=5(0111100)，S7=3(1110011)，S8=4(0011110)，S9=6(0001101)，S10=6(1101001)；</p>
<p>其中，编码方式为：对无向图的每个节点进行编号，把无向图切成两个子图，划为子图1的用1表示，划为子图2的用0表示。</p>
<p>例如S1=7,表示把无向图切成两个子图，两个子图之间的边数为7，此时我们可以把编号为4，5，6，7的顶点划为子图1，把编号为1，2，3的顶点划为子图2，故可编码为0001111，但不唯一(因为两个子图之间的边数为7的切割方式并不唯一)。</p>
<p>（2）定义适应度函数：</p>
<p>$F(X)$计算两部分之间的边数</p>
<p><strong>Step2:选择父代</strong></p>
<p><strong>（用轮盘赌方法从群体中随机选择两个父代）</strong></p>
<p>S4=7（1011011）</p>
<p>S5=7（0101100）</p>
<p><strong>Step3:杂交</strong></p>
<p>对选取的父代进行杂交得到子代，其中杂交方法为若两个父代的同一节点在相同集合中，则保留；否则，对随机分配该节点至任意集合中。</p>
<p>交叉后： 子代=0011110（4）</p>
<p><strong>Step4:变异</strong></p>
<p>设定遗传概率，在0.05的概率下，将子代的某个节点从一个集合移动到另一个集合中。变异后：</p>
<p>子代=0010110(6)</p>
<p><strong>Step5：群体更新</strong></p>
<p>子代=0010110(6)</p>
<p>从S1=7(0001111)，S2=5(0011010)，S3=7(1110000)，S4=7(1011011)，<br>S5=7(0101100)，S6=5(0111100)，S7=3(1110011)，S8=4(0011110)，S9=6(0001101)，S10=6(1101001)</p>
<p>中选取质量最差的个体出来，将这个用子代个体替换掉。</p>
<p>以上5步构成一代，一代一代往前进化，若干代停止。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>启发式算法</tag>
        <tag>遗传算法</tag>
      </tags>
  </entry>
</search>
