<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>01字典树</title>
    <url>/posts/cc730d32.html</url>
    <content><![CDATA[<h1 id="01字典树"><a href="#01字典树" class="headerlink" title="01字典树"></a>01字典树</h1><blockquote>
<p>01字典树: 解决最大异或问题</p>
</blockquote>
<p>和字典树一样，只不过每一个节点的值不再是字符而是01，一个数从高位到低位对应于字典树从根到叶子，一个数二进制有多少位，就应该建几层树，包含根节点的那个编号0</p>
<p>树上的每一个点都有各自的编号，节点有两条边，分别是0和1，开空间时应该多开40倍左右</p>
<h2 id="HDU4825-Xor-Sum"><a href="#HDU4825-Xor-Sum" class="headerlink" title="HDU4825 Xor Sum"></a>HDU4825 Xor Sum</h2><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4825">题目链接</a></p>
<p>这道题数据有点水，说是不超过2^32^，其实连int都没有爆，应该开33层(包含根节点)，但是实际上32层就可以，代码是开了33层</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#pragma G++ optimize(2)</span></span><br><span class="line"><span class="comment">//#pragma G++ optimize(3,&quot;Ofast&quot;,&quot;inline&quot;)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="type">const</span> ll MAXN=<span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> ll MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll SUB=<span class="number">-0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-4</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> E=<span class="built_in">exp</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">int</span> ch[<span class="number">30</span>*MAXN][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> val[<span class="number">30</span>*MAXN];</span><br><span class="line"><span class="type">int</span> tot,t,n,m;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(val,<span class="number">0</span>,<span class="keyword">sizeof</span> val);</span><br><span class="line">    <span class="built_in">memset</span>(ch,<span class="number">0</span>,<span class="keyword">sizeof</span> ch);</span><br><span class="line">    tot=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> v)</span>&#123;</span><br><span class="line">    <span class="type">int</span> u=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">31</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="type">int</span> now=(v&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!ch[u][now]) ch[u][now]=++tot;</span><br><span class="line">        u=ch[u][now];</span><br><span class="line">    &#125;</span><br><span class="line">    val[u]=v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="type">int</span> u=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">31</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="type">int</span> now=(x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(ch[u][now^<span class="number">1</span>]) u=ch[u][now^<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span> u=ch[u][now];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> val[u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="type">int</span> js=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> tmp;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;tmp;</span><br><span class="line">            insert(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Case #&quot;</span>&lt;&lt;++js&lt;&lt;<span class="string">&quot;:\n&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">            <span class="type">int</span> tmp;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;tmp;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;query(tmp)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="Chip-Factory"><a href="#Chip-Factory" class="headerlink" title="Chip Factory"></a>Chip Factory</h2><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=5536">题目链接</a></p>
<p>在一个数组中找出 (s[i]+s[j])^s[k] 最大的值，其中 i、j、k 各不相同。</p>
<p>可以找出任意两个数的和，然后把这两个数从字典树中删除，之后查询最大异或，再添加上，再找，如此往复，输出最大值即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> t,n,tot;</span><br><span class="line"><span class="type">int</span> ch[MAXN*<span class="number">40</span>][<span class="number">2</span>],arr[MAXN],val[MAXN*<span class="number">40</span>];</span><br><span class="line"><span class="type">int</span> num[MAXN*<span class="number">40</span>]; </span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="type">int</span> u=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">31</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="type">int</span> now=(x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!ch[u][now]) ch[u][now]=++tot;</span><br><span class="line">        u=ch[u][now];</span><br><span class="line">        num[u]++;</span><br><span class="line">    &#125;</span><br><span class="line">    val[u]=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="type">int</span> u=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">31</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="type">int</span> now=(x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(ch[u][now^<span class="number">1</span>] &amp;&amp; num[ch[u][now^<span class="number">1</span>]]) u=ch[u][now^<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span> u=ch[u][now];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> val[u]^x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> c)</span>&#123;</span><br><span class="line">    <span class="type">int</span> u=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">31</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">    	<span class="type">int</span> now=(x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">    	num[ch[u][now]]+=c;</span><br><span class="line">    	u=ch[u][now];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">	tot=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">memset</span>(val,<span class="number">0</span>,<span class="keyword">sizeof</span> val);</span><br><span class="line">	<span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="keyword">sizeof</span> num);</span><br><span class="line">	<span class="built_in">memset</span>(ch,<span class="number">0</span>,<span class="keyword">sizeof</span> ch);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ios;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">    	init();</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;arr[i];</span><br><span class="line">            insert(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="type">int</span> cur=arr[i]+arr[j];</span><br><span class="line">                update(arr[i],<span class="number">-1</span>);</span><br><span class="line">                update(arr[j],<span class="number">-1</span>);</span><br><span class="line">                ans=max(ans,query(cur));</span><br><span class="line">                update(arr[i],<span class="number">1</span>);</span><br><span class="line">                update(arr[j],<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="The-xor-longest-Path"><a href="#The-xor-longest-Path" class="headerlink" title="The xor-longest Path"></a>The xor-longest Path</h2><p><a href="http://poj.org/problem?id=3764">题目链接</a></p>
<p>在树上找一段路径（连续）使得边权相异或的结果最大。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/20210507212615.png" alt="image-20210507212604651"></p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">110010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> to,w,next;</span><br><span class="line">&#125;e[MAXN*<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> t,n,tot,cnt,root,ans;</span><br><span class="line"><span class="type">int</span> val[MAXN*<span class="number">32</span>];</span><br><span class="line"><span class="type">int</span> ch[MAXN*<span class="number">32</span>][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> head[MAXN];</span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> c)</span>&#123;</span><br><span class="line">	e[cnt]=&#123;v,c,head[u]&#125;;</span><br><span class="line">	head[u]=cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="type">int</span> u=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">31</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="type">int</span> now=(x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!ch[u][now]) ch[u][now]=++tot;</span><br><span class="line">        u=ch[u][now];</span><br><span class="line">    &#125;</span><br><span class="line">    val[u]=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="type">int</span> u=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">31</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="type">int</span> now=(x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(ch[u][now^<span class="number">1</span>]) u=ch[u][now^<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span> u=ch[u][now];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> val[u]^x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> f,<span class="type">int</span> pre)</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[x];~i;i=e[i].next)&#123;</span><br><span class="line">		<span class="type">int</span> v=e[i].to,w=e[i].w;</span><br><span class="line">		<span class="keyword">if</span>(v==f) <span class="keyword">continue</span>;</span><br><span class="line">		ans=max(ans,query(pre^w));</span><br><span class="line">		insert(pre^w);</span><br><span class="line">		dfs(v,x,pre^w);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(val,<span class="number">0</span>,<span class="keyword">sizeof</span> val);</span><br><span class="line">	<span class="built_in">memset</span>(ch,<span class="number">0</span>,<span class="keyword">sizeof</span> ch);</span><br><span class="line">	<span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span> head);</span><br><span class="line">	ans=<span class="number">0</span>; cnt=<span class="number">0</span>; tot=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ios;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n)!=EOF)&#123;</span><br><span class="line">    	init();</span><br><span class="line">    	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">    		<span class="type">int</span> u,v,w;</span><br><span class="line">    		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">    		add(u,v,w);</span><br><span class="line">    		add(v,u,w);</span><br><span class="line">		&#125;</span><br><span class="line">		insert(<span class="number">0</span>);</span><br><span class="line">		dfs(root,<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">0 1 3</span></span><br><span class="line"><span class="comment">1 2 4</span></span><br><span class="line"><span class="comment">1 3 6</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>01字典树</tag>
      </tags>
  </entry>
  <entry>
    <title>2020summary</title>
    <url>/posts/a53cc33d.html</url>
    <content><![CDATA[<h1 id="2020年度总结"><a href="#2020年度总结" class="headerlink" title="2020年度总结"></a>2020年度总结</h1><blockquote>
<p>转眼间已是2021，想一想我的大学生活已经过去将近一半，真是快呀！总结一下我的2020年叭~</p>
</blockquote>
<h2 id="成就"><a href="#成就" class="headerlink" title="成就"></a>成就</h2><ul>
<li><p>ACM</p>
<ol>
<li>天梯赛(铜奖)</li>
<li>CCPC省赛银奖</li>
</ol>
</li>
<li><p>CET</p>
<ul>
<li>成绩还没出，不过感觉是考的不错</li>
</ul>
</li>
<li>体测<ul>
<li>79，已经非常满意了，只要过了75就满足了~</li>
</ul>
</li>
<li>学业<ul>
<li>比较满足了，相比于上学期确实进步了好多，可能是因为新图书馆建好了的缘故叭~</li>
</ul>
</li>
</ul>
<h2 id="想说的话"><a href="#想说的话" class="headerlink" title="想说的话"></a>想说的话</h2><h3 id="寒假"><a href="#寒假" class="headerlink" title="寒假"></a>寒假</h3><p>​    2020年寒假在家，对视频剪辑，PS，特效制作兴趣比较大，就学了十多天吧，当时还去淘宝上买了好几个教学视频呢，现在都还在百度网盘存着，就是做特效的时候才发现AE对电脑的配置需求太大了！5千多的电脑根本带不起来…CPU在燃烧🔥~最后也是做出来了一个爱情公寓版的开头片，个人感觉还是不错的，做了两天呢！遗憾的是最后失误把源文件了导致图片链接不上了，最后也是啥也没做成，现在也忘了软件咋用了。</p>
<h3 id="接触Hexo"><a href="#接触Hexo" class="headerlink" title="接触Hexo"></a>接触Hexo</h3><p>​    从过年开始疫情就开始了，过年的那两天啥也没干，亲戚也不敢串，都窝在家里，当时一整天有半天多都是躺在被窝里玩游戏或者看爱情公寓5，好慵懒😶~然后就是因为疫情一直没有开学，从2月底开始上网课，记得刚听说要上网课时那天早上还贼兴奋，很早就起来在电脑前面等着看慕课，记得第一节看的是高数，华中农业大学老师讲的真不错，新鲜感也就持续了一个星期，一个星期后再上网课就是不停发呆，不断刷抖音，再后来就接触了Hexo博客，那时我是没有博客的，连CSDN都没有，之前也想过用博客来记录算法，但是总是很懒，不愿意动手，直到我看到了龙佬的Sakura博客，当时感觉贼好看，就决心要搞一下，当时查询了超多的资料，什么也不懂，什么git，GitHub，ssh，hexo，什么都不知道，甚至连markdown都不会😂，真是难为我了！</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/Sucai/20210107130349.png" alt="image-20210107130340716"></p>
<p>最后还是在咸鱼上下单了，更离谱的是那个人最后也没给我搞好！他就差最后一步把GitHub仓库的名字加上后缀.github.io，不过他人还挺好的，给我弄了一个下午，最后还没打算给我要钱，我最后还是给了他15块钱，之后就是疯狂美化，虽然啥也不知道，就按照博客教程一步一步傻瓜式操作，到最后自己都不知道博客文件里面哪些是我自己添加的哪些是自带的，甚至有一次还把一个JS的script误删了，最后导致手机看博客打不开菜单~天知道我是怎么一步一步过来的，那几天甚至睡觉都在想着怎么美化，早上6点多自动从床上弹起来，去看教程，上网课都不能好好上，好的是最后终于做成了，做成的时候我真的是激动呐，还发了B站😂</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/Sucai/20210107131326.png" alt="image-20210107131320660"></p>
<p>真的Hexo带给我太多了！</p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>​    Hexo博客折腾的差不多后就是搞算法了，当时在家里算法也没停下，当时一星期要有3天晚上都要比赛，每次比赛之前都特别紧张，到现在都还是这样…当时真的很菜，连模板题都不会，学长们也是挺负责，会给我们出题解，我们私信他们，他们也会认真回我们，现在想一想真的感谢当时的自己，感谢当时没有放弃。</p>
<h3 id="在家期末考试"><a href="#在家期末考试" class="headerlink" title="在家期末考试"></a>在家期末考试</h3><p>​    再后来就是期末考试了，当时到最后交物理实验报告时，我连物理实验群聊都没加…当时急死我了，补了两天，写的手疼✍，由于网课都没有好好听，当时又挺喜欢看B站，就直接去B站上下学习了，感谢高数叔捞我！🙆推荐大家期末复习看高数叔，当然如果帮到了你们可以考虑赞助一下她们呀。</p>
<h3 id="暑期培训"><a href="#暑期培训" class="headerlink" title="暑期培训"></a>暑期培训</h3><p>​    期末考试完就放暑假了，寒暑假连放，真是百年难遇！然后就去报驾照了，3天看了1300多道题目，之后就是约了考试，一星期过了科目一，之后暑假培训就开始了，就没再练过车，天天在家里刷题，从早上9点左右开始到12点，下午又从2点半到6点，晚上从7点多到9点多，日日如此，每天都在做眼保教程，就那眼睛都感觉疲惫，真是难忘，当时晚上还要讲题，自己也提高了很大，一周一次的积分赛，真是害怕的要死，当提交后看到wrong的胆颤心惊，看到TLE的无奈，以及经过了无数次调试运行后的CORRT，感谢学长们暑假培训对我们的栽培，鞠躬🙏</p>
<h3 id="开学了"><a href="#开学了" class="headerlink" title="开学了"></a>开学了</h3><p>​    之后就开学了！终于开学了，开学后终于一睹了潘大佬的真容，打了第一场组队赛，之后就一直组队，次次躺赢🐉，慢慢的我们也熟悉了，后来老牛也来了，”三只菜鸡齐力下厨”人齐了，之后打了第一场比赛，CCPC国赛，过了三个题，打铁人，打铁魂，打铁人都是人上人，然后是CCPC省赛拿了省二，和省一就差了两名~好遗憾好遗憾啊。之后就是天梯赛，被队友带飞，拿了国三💊，之后就是体测了，上学期的奖学金丢的这么亏这学期必须拿到！跑了一星期的步，做了一星期的引体向上，终于最后过了75</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/Sucai/20210107134157.jpg" alt="IMG_20201125_211213"></p>
<p>​    然后英语四级就要开始了，两星期备考四级，当时真的就是天天泡在图书馆，好恐怖啊，你见过晚上10点的图书馆吗？</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/Sucai/20210107133706.jpg" alt="IMG_20201101_220135">{height=”400” width=”300”}</p>
<p>经过了艰难的两个星期，然后离期末考试就只剩下3个星期了，三星期复习5门课，不！不能叫复习，应该是学习。真是一个奇迹呢，天天泡在图书馆，第一次这么喜欢图书馆！</p>
<p>​    最后考完试就到了现在，这个2020过的也是针不戳，还有最重要的，2020年10月25日我也遇到了我的另一半，感谢小茹陪我走过了这两个月，新的一年，我也会陪着你继续走下去。</p>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>放几张照片吧</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/Sucai/20210107134655.jpg" alt="img06" title="CCPC秦皇岛"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/Sucai/20210107134903.jpg" alt="IMG_20201213_135647" title="和小茹在龙源湖"><img src="https://cdn.jsdelivr.net/gh/uncleacc/Sucai/20210107134712.jpg" alt="IMG_20210105_215227" title="晚上在图书馆"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/Sucai/20210107135013.jpg" alt="IMG_20201212_081333" title="四级考试现场"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/Sucai/20210107135032.jpg" alt="IMG_20201128_202329" title="和队友一起出去玩"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/Sucai/20210107135114.jpg" alt="IMG_20210105_151820" title="校园漫步"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/Sucai/20210107135155.jpg" alt="IMG_20201215_161541" title="做物理实验"></p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>2020</tag>
      </tags>
  </entry>
  <entry>
    <title>2021ICPC训练赛</title>
    <url>/posts/25665b78.html</url>
    <content><![CDATA[<h2 id="Early-Orders"><a href="#Early-Orders" class="headerlink" title="Early Orders"></a>Early Orders</h2><p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/20210308172548.png" alt="image-20210308150507708" style="zoom: 67%;" /></p>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>n个数从中找出一个包含1-k的字典序最小子串，注意子串可以断开，但是相对顺序不能变</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>求得是字典序最小的子串，用一个单调栈维护，从栈底到栈顶依次表示子串的从前到后，为什么用栈呢？考虑子串的先后性，必须先把后面的更新了才能更新前面的，如何维护栈呢？对于栈顶元素，从左往右遍历的过程中如果这个数字比栈顶数字小，而且右面还有栈顶数字，那就可以出栈，还有就是当栈内有一个元素了，这时就不能再往里面塞这个元素，搞一个标记数组标记栈中是否有这个元素</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0) </span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="type">int</span>&gt; st;</span><br><span class="line"><span class="type">bool</span> vis[MAXN];</span><br><span class="line"><span class="type">int</span> ans[MAXN],a[MAXN],pos[MAXN];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="type">int</span> n,m;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">		pos[a[i]]=i;  <span class="comment">//记录这个元素在这个序列中出现的最后位置</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(vis[a[i]]) <span class="keyword">continue</span>;  <span class="comment">//已经入栈了</span></span><br><span class="line">		<span class="keyword">while</span>(!st.empty() &amp;&amp; a[i]&lt;st.top() &amp;&amp; pos[st.top()]&gt;i)&#123;</span><br><span class="line">			vis[st.top()]=<span class="number">0</span>;  <span class="comment">//出栈恢复标记</span></span><br><span class="line">			st.pop();</span><br><span class="line">		&#125;</span><br><span class="line">		st.push(a[i]);</span><br><span class="line">		vis[a[i]]=<span class="number">1</span>;  <span class="comment">//标记这个元素入栈了</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> tail=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!st.empty())&#123;</span><br><span class="line">		ans[++tail]=st.top();  <span class="comment">//倒着输出</span></span><br><span class="line">		st.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=tail;i&gt;=<span class="number">1</span>;i--) <span class="built_in">cout</span>&lt;&lt;ans[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这道题和之前我们学校的招新赛一道题很类似，<a href="https://hpuoj.com/contest/34/">河南理工大学19级新生程序设计大赛：C. 星星选字符串</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/20210308155728.png" alt="image-20210308155726637" style="zoom:67%;" /></p>
<p>题意：在S串中找出包含T串所有字符的长度最短的连续子串</p>
<p>题解：用尺取做，当前区间满足条件了就缩小区间，不满足就扩大，这里需要注意的是最好用左闭右开的方式，因为如果左闭右闭的话，尺取的开始不好初始化左右指针的值，假如S=BA，T=B，那第一次就找到了，这时候l=-1,r=0，而你更新长度时条件是len&gt;r-l+1，这时就多计算了一个+1，因为这时候l所在的位置是空的，它没有占有一个字符所以这个+1就是多余的，所以可以刚开始初始化为l=0,r=0，只要在循环外面判断一次第一个字符就可以了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//左闭右闭</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SUB=<span class="number">-0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> eps=<span class="number">1e-4</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> E=<span class="built_in">exp</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">string</span> s,t; </span><br><span class="line"><span class="built_in">map</span>&lt;<span class="type">char</span>,<span class="type">int</span>&gt; mp,mp2;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;s&gt;&gt;t;</span><br><span class="line">	<span class="type">int</span> len=t.size(),k=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!mp[t[i]])&#123;</span><br><span class="line">			mp[t[i]]=<span class="number">1</span>;</span><br><span class="line">			k++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>,ans=INF,len2=s.size(),lp,rp,cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(r&lt;len2 &amp;&amp; mp[s[r]])&#123;</span><br><span class="line">		mp2[s[r]]++;</span><br><span class="line">		cnt++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(r&lt;len2)&#123;</span><br><span class="line">		<span class="keyword">if</span>(cnt==k)&#123;</span><br><span class="line">			<span class="keyword">if</span>(ans&gt;r-l+<span class="number">1</span>)&#123;</span><br><span class="line">				ans=r-l+<span class="number">1</span>;</span><br><span class="line">				lp=l;</span><br><span class="line">				rp=r;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(mp2[s[l]])&#123;</span><br><span class="line">				mp2[s[l]]--;</span><br><span class="line">				<span class="keyword">if</span>(mp2[s[l]]==<span class="number">0</span>) cnt--;</span><br><span class="line">			&#125;</span><br><span class="line">			l++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			r++;</span><br><span class="line">			<span class="keyword">if</span>(mp[s[r]])&#123;</span><br><span class="line">				mp2[s[r]]++;</span><br><span class="line">				<span class="keyword">if</span>(mp2[s[r]]==<span class="number">1</span>) cnt++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(ans!=INF)<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//左闭右开</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SUB=<span class="number">-0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> eps=<span class="number">1e-4</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> E=<span class="built_in">exp</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">string</span> s,t; </span><br><span class="line"><span class="built_in">map</span>&lt;<span class="type">char</span>,<span class="type">int</span>&gt; mp,mp2;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;s&gt;&gt;t;</span><br><span class="line">	<span class="type">int</span> len=t.size(),k=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!mp[t[i]])&#123;</span><br><span class="line">			mp[t[i]]=<span class="number">1</span>;</span><br><span class="line">			k++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>,ans=INF,len2=s.size(),lp,rp,cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(r&lt;=len2)&#123;</span><br><span class="line">		<span class="keyword">if</span>(cnt==k)&#123;</span><br><span class="line">			<span class="keyword">if</span>(ans&gt;r-l)&#123;</span><br><span class="line">				ans=r-l;</span><br><span class="line">				lp=l;</span><br><span class="line">				rp=r;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(mp2[s[l]])&#123;</span><br><span class="line">				mp2[s[l]]--;</span><br><span class="line">				<span class="keyword">if</span>(mp2[s[l]]==<span class="number">0</span>) cnt--;</span><br><span class="line">			&#125;</span><br><span class="line">			l++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(mp[s[r]])&#123;</span><br><span class="line">				mp2[s[r]]++;</span><br><span class="line">				<span class="keyword">if</span>(mp2[s[r]]==<span class="number">1</span>)cnt++;</span><br><span class="line">			&#125;</span><br><span class="line">			r++;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//		cout&lt;&lt;cnt&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(ans!=INF) <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="comment">//	for(int i=lp;i&lt;rp;i++) cout&lt;&lt;s[i];</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>比赛</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-5 最长回文子串</title>
    <url>/posts/b5949c1f.html</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/c4268e9784f84075b08ed979f60d2f7d.png" alt="img"> 动态规划</p>
<p> <img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/8ce61f447b95410ebd98bb7547c8347a.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string <span class="title function_">longestPalindrome</span><span class="params">(string s)</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="type">int</span> <span class="variable">st</span> <span class="operator">=</span> <span class="number">0</span>, L = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.size();</span><br><span class="line">        bool dp[<span class="number">1100</span>][<span class="number">1100</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i ++) dp[i][i] = <span class="number">1</span>;	<span class="comment">//长度为1的子串都是回文串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= len; i ++) &#123;</span><br><span class="line">   	<span class="comment">//枚举长度</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j + i - <span class="number">1</span> &lt; len; j ++) &#123;</span><br><span class="line">   	<span class="comment">//枚举位置</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> j + i - <span class="number">1</span>;	<span class="comment">//结束位置</span></span><br><span class="line">                <span class="keyword">if</span>(s[j] != s[k]) dp[j][k] = <span class="number">0</span>;	<span class="comment">//如果两端字符不一致不回文</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">                    <span class="keyword">if</span>(i &lt;= <span class="number">3</span>) dp[j][k] = <span class="number">1</span>;	<span class="comment">//长度为3或者2的都是回文</span></span><br><span class="line">                    <span class="keyword">else</span> dp[j][k] = dp[j+<span class="number">1</span>][k-<span class="number">1</span>];	<span class="comment">//由之前状态推过来</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(dp[j][k]) st = j, L = i;	<span class="comment">//更新长度和起始位置</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(st, L);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>01字典树</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-2 两数相加</title>
    <url>/posts/cbf78b69.html</url>
    <content><![CDATA[<p>考察了对链表的使用 </p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/f32296771e0e43e7b64b06a748d3b5da.png" alt="img"> 特别注意的是<strong>在一个自己声明的函数</strong>中<strong>直接定义变量</strong>和<strong>使用new声明</strong>内存分配机制是不一样的，<strong>直接定义是由系统管理内存的分配与回收</strong>，而<strong>new则是由程序员自己分配与回收</strong>，所以在自定义函数中直接定义变量，然后把指针指向此变量会导致在函数结束后内存回收指针指向无效地址的错误，而new则避免了此问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123;</span><br><span class="line">        ListNode *head = nullptr, *tail = nullptr;</span><br><span class="line">        <span class="type">int</span> last=<span class="number">0</span>;	<span class="comment">//保存进位</span></span><br><span class="line">        <span class="keyword">while</span>(l1 || l2) &#123;	<span class="comment">//有一个链表非空则继续计算</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;	<span class="comment">//保存当前和</span></span><br><span class="line">            <span class="keyword">if</span>(l1) sum += l1-&gt;val;</span><br><span class="line">            <span class="keyword">if</span>(l2) sum += l2-&gt;val;</span><br><span class="line">            sum += last;</span><br><span class="line">            last=sum/<span class="number">10</span>;	<span class="comment">//更新进位</span></span><br><span class="line">            <span class="keyword">if</span>(!head) head = tail = <span class="keyword">new</span> <span class="title class_">ListNode</span>(sum%<span class="number">10</span>);	<span class="comment">//没有头结点，所以第一个节点就是结构体节点，需要特判一下</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                tail-&gt;next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(sum%<span class="number">10</span>);</span><br><span class="line">                tail = tail-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l1) l1 = l1-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(l2) l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(last) tail-&gt;next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(last);	<span class="comment">//最后特判是否进位</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>01字典树</tag>
      </tags>
  </entry>
  <entry>
    <title>2021牛客寒假算法基础集训营5</title>
    <url>/posts/505dcdf.html</url>
    <content><![CDATA[<h2 id="B-比武招亲（上）"><a href="#B-比武招亲（上）" class="headerlink" title="B 比武招亲（上）"></a>B<a href="https://ac.nowcoder.com/acm/contest/9985/B"> 比武招亲（上）</a></h2><p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/20210306171528.png" alt="image-20210306171517109" style="zoom:67%;" /></p>
<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定n,m，每次从1-n中挑选出m个数，可以重复挑选，挑选出的数的贡献值等于排序后最大值减去最小值，挑选的序列不同当且仅当两个序列排序后不同，求所有可能的序列的总贡献值？</p>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>可以枚举贡献值，差值一共有n-1种，差值固定了，也就是在m-2个空位中随意放置[min,max]的数，这里有一个坑，也不是随便放的，因为要求排过序后序列不同，也就是放置要求是单调不减，于是可以把+1看成一个隔板，就是在m-2+1个隔板中放置d(差值)个隔板，可是隔板可以连续放置，所以放置一个隔板后空位就会增多！所以答案不是C(m-1,d)，雨巨的想法NB，考虑每一个隔板的左面带有一个空位，那么所有的隔板放完后空位就增加到了m-1+d个，在这些空位中放进去d个隔板，这个时候隔板就不能连续放了，因为每一个隔板左面都带有一个空位，所以每一个隔板左面都必须至少有一个空位，那最左面也不能放了，所以空位变成了m-1+d-1，答案就变成了从m-2+d个空位中放置d个隔板，隔板不能连续放，C(m-2+d,d)，到这里题目就做出来一大半了，组合数复杂度为O(n)，这里的n和m都是1e5，所以每次都算一遍组合数时间就是O(n2)级别的，必定超时，考虑优化组合数，先算出差值为1的答案，然后算差值为2的组合数时在差值为1的基础上*分子*分母的逆元可以把组合数的时间去掉，时复O(n)</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SUB=<span class="number">-0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> eps=<span class="number">1e-4</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> E=<span class="built_in">exp</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line">ll <span class="title function_">ksm</span><span class="params">(ll a,ll b)</span>&#123;</span><br><span class="line">	ll ret=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(b)&#123;</span><br><span class="line">		<span class="keyword">if</span>(b&amp;<span class="number">1</span>) ret=ret*a%MOD;</span><br><span class="line">		a=a*a%MOD;</span><br><span class="line">		b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret%MOD;</span><br><span class="line">&#125;</span><br><span class="line">ll <span class="title function_">inv</span><span class="params">(ll x)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ksm(x,MOD<span class="number">-2</span>)%MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">1</span> || m==<span class="number">1</span>)&#123;  <span class="comment">//特判特殊情况</span></span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ll now=m<span class="number">-2</span>+<span class="number">1</span>,ans=now*(n<span class="number">-1</span>)%MOD;<span class="comment">//先算出差值为1的答案</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n<span class="number">-1</span>;i++)&#123;  <span class="comment">//之后在上一个差值的基础上算这个差值的答案</span></span><br><span class="line">		now=now*(m<span class="number">-2</span>+i)%MOD*inv(i)%MOD;  <span class="comment">//乘上分子和分母的逆元</span></span><br><span class="line">		ans=(ans+now*i%MOD*(n-i)%MOD)%MOD;  <span class="comment">//现在now表示这个差值的种类数记得乘上差值和这个差值下可以取到的区间数量</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>比赛</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-1027最长等差数列</title>
    <url>/posts/b2c9ee6e.html</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/27ba9d758d86403e884e0ebea8971439.png" alt="img"> 和最长上升子序列类似，这里多加了公差的性质，第一种想法是开一个结构体dp一维数组，dp[i].val表示以i位置结尾的最长长度，dp[i].cha表示以i位置结尾的子序列公差，你会发现无法进行状态转移，假设i&lt;j&lt;k，dp[k]被dp[j]更新了，并且更新后长度最大，但这不代表i这个位置就一定不是最长等差序列之一，因为可能dp[i].val和dp[j].val只相差1甚至相同，但两者公差不一样，如果后面再来几个公差和dp[i].cha一样的，而你又没有把k位置给添加到序列中，这个状态没有被考虑，导致错误。 因此需要dp[i][j]表示第i个位置添加到末尾并且公差是j的最长长度。 之后再仿照最长上升子序列进行更新即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> dp[<span class="number">1100</span>][<span class="number">1100</span>];</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">longestArithSeqLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> &#123;</span><br><span class="line">   </span><br><span class="line">        memset(dp,<span class="number">0</span>,sizeof dp);</span><br><span class="line">        <span class="type">int</span> len=nums.size();</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">   </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">   </span><br><span class="line">                dp[i][nums[i]-nums[j]+<span class="number">500</span>]=max(dp[j][nums[i]-nums[j]+<span class="number">500</span>]+<span class="number">1</span>,dp[i][nums[i]-nums[j]+<span class="number">500</span>]);</span><br><span class="line">                res=max(res,dp[i][nums[i]-nums[j]+<span class="number">500</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>01字典树</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-82 含有重复元素集合的组合</title>
    <url>/posts/ea0f870d.html</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/f1cd32f7ea404c54b57b319e0e2fb4ff.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates,vector&lt;<span class="type">int</span>&gt;&amp; ans,<span class="type">int</span> sum,<span class="type">int</span> pos, <span class="type">int</span> &amp;target)</span>&#123;</span><br><span class="line">   </span><br><span class="line">        ans.push_back(candidates[pos]);</span><br><span class="line">        <span class="keyword">if</span>(sum+candidates[pos]==target) res.push_back(ans);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(sum+candidates[pos]&lt;target)&#123;</span><br><span class="line">   </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=pos+<span class="number">1</span>;i&lt;candidates.size();i++)&#123;</span><br><span class="line">   </span><br><span class="line">                <span class="keyword">if</span>(i&gt;pos+<span class="number">1</span> &amp;&amp; candidates[i]==candidates[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                dfs(candidates,ans,sum+candidates[pos],i,target);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.pop_back();</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="title function_">combinationSum2</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">   </span><br><span class="line">        sort(candidates.begin(),candidates.end());</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;candidates.size();i++)&#123;</span><br><span class="line">   </span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; candidates[i]==candidates[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            dfs(candidates,ans,<span class="number">0</span>,i,target);	<span class="comment">//每一次dfs都把以i这个元素作为第一个元素的组合都找出来了，那么后面再以i这个元素作为第一个元素就是重复的</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>01字典树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode162-寻找峰值</title>
    <url>/posts/ac816005.html</url>
    <content><![CDATA[<p> <a href="https://leetcode.cn/problems/find-peak-element/">LeetCode162-寻找峰值</a> 二分找索引，对于mid，如果处于上坡，则答案在右边，如果处于下坡，答案在左边，如果处于低谷，答案任意，如果处于峰顶，即为答案。 注意特判0和nums.szie()-1两个位置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">findPeakElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums.size()-<span class="number">1</span>, mid;</span><br><span class="line">        <span class="type">int</span> res;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">   </span><br><span class="line">            mid = (l + r) / <span class="number">2</span>;</span><br><span class="line"><span class="comment">//            cout &lt;&lt; nums[mid] &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">if</span>((mid == <span class="number">0</span> || nums[mid] &gt; nums[mid - <span class="number">1</span>]) &amp;&amp; (mid == nums.size() - <span class="number">1</span> || nums[mid] &gt; nums[mid + <span class="number">1</span>])) &#123;</span><br><span class="line">   </span><br><span class="line">                res = mid;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((mid == <span class="number">0</span> || nums[mid-<span class="number">1</span>] &lt; nums[mid]) &amp;&amp; (mid &lt; nums.size() - <span class="number">1</span> &amp;&amp; nums[mid] &lt; nums[mid+<span class="number">1</span>])) l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((mid &gt; <span class="number">0</span> &amp;&amp; nums[mid-<span class="number">1</span>] &gt; nums[mid]) &amp;&amp; (mid == nums.size() - <span class="number">1</span> || nums[mid] &gt; nums[mid+<span class="number">1</span>])) r = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>01字典树</tag>
      </tags>
  </entry>
  <entry>
    <title>11. 盛最多水的容器</title>
    <url>/posts/d910afda.html</url>
    <content><![CDATA[<p> <a href="https://leetcode.cn/problems/container-with-most-water/">11. 盛最多水的容器</a> 题目所求即为最大面积，面积=(较短边*两线段距离)，答案即为max{以每一条线段作为较短边的最大面积}，当较短边确定时，两线段距离越长越好，因此考虑双指针从两端向内进行移动 考虑以下状态： 两指针在两端时，对于较短边而言，以此线段为较短边的最大面积就是线段长度乘以两指针位置之差，因此较短边对应的指针就可以向前或向后移动了。 移动后的状态又是以上状态。 因此每次较短边指针移动</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = height.size() - <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">   </span><br><span class="line">            res = max(res, min(height[i], height[j])*(j-i));</span><br><span class="line">            <span class="keyword">if</span>(height[i] &gt; height[j]) j --;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(height[i] &lt; height[j]) i ++;</span><br><span class="line">            <span class="keyword">else</span> i ++,j --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>01字典树</tag>
      </tags>
  </entry>
  <entry>
    <title>15. 三数之和</title>
    <url>/posts/e192590d.html</url>
    <content><![CDATA[<p>先排序，两层for循环，二分寻找-(nums[i]+nums[j])，用map去重 时复：O(n2logn) 算上常数差不多9e8左右 刚好超时 寻找能优化的地方 因为排过序了，如果-(nums[i]+nums[j])&lt;nums[j]就没必要找了，加上这句正好卡过去</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">struct node &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">    bool operator&lt;(const node &amp;o) const &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">return</span> a == o.a ? (b == o.b ? (c &lt; o.c) : b &lt; o.b) : a &lt; o.a;</span><br><span class="line">    &#125;</span><br><span class="line">    node(<span class="type">int</span> ta, <span class="type">int</span> tb, <span class="type">int</span> tc):a(ta),b(tb),c(tc)&#123;</span><br><span class="line">   &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">map&lt;node, bool&gt; vis;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="title function_">threeSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> &#123;</span><br><span class="line">   </span><br><span class="line">        vis.clear();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.size(); i ++) &#123;</span><br><span class="line">   </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; nums.size(); j ++) &#123;</span><br><span class="line">   </span><br><span class="line">                <span class="keyword">if</span>(-(nums[i]+nums[j]) &lt; nums[j]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> lower_bound(nums.begin()+j+<span class="number">1</span>, nums.end(), -(nums[i]+nums[j])) - nums.begin();</span><br><span class="line">                <span class="keyword">if</span>(id != nums.size() &amp;&amp; nums[id] == -(nums[i] + nums[j])) &#123;</span><br><span class="line">   </span><br><span class="line">                    <span class="keyword">if</span>(!vis[node(nums[i], nums[j], nums[id])]) &#123;</span><br><span class="line">   </span><br><span class="line">                    	vis[node(nums[i], nums[j], nums[id])] = <span class="number">1</span>;</span><br><span class="line">                        res.push_back(&#123;</span><br><span class="line">   nums[i], nums[j], nums[id]&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>01字典树</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-80</title>
    <url>/posts/9c90cade.html</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/d1b412323e4d4ad08e5c330fce47d2e4.png" alt="img"></p>
<p>写麻烦了，总之就是双指针，一个快指针一个慢指针</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="type">int</span> len=nums.size();</span><br><span class="line">        <span class="type">int</span> cnt=<span class="number">1</span>,L=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">   </span><br><span class="line">            <span class="keyword">if</span>(nums[i]==nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">   </span><br><span class="line">                <span class="keyword">if</span>(cnt==<span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span> cnt++,L++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">   </span><br><span class="line">                L++;</span><br><span class="line">                cnt=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;L&lt;&lt;endl;</span></span><br><span class="line">        cnt=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">1</span>;i&lt;len &amp;&amp; j&lt;L;i++)&#123;</span><br><span class="line">   </span><br><span class="line">            <span class="keyword">if</span>(nums[i]==nums[i-<span class="number">1</span>] &amp;&amp; cnt==<span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=nums[i-<span class="number">1</span>]) cnt=<span class="number">0</span>;</span><br><span class="line">            nums[j++]=nums[i];</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> L;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>01字典树</tag>
      </tags>
  </entry>
  <entry>
    <title>Git命令</title>
    <url>/posts/b6ef4fe0.html</url>
    <content><![CDATA[<p>.gitnore文件配置忽视规则</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">/文件夹	#忽略此文件夹</span><br><span class="line">!/文件夹  #表示此文件夹不忽略</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git init <span class="comment">//初始化为git仓库</span></span><br><span class="line">git status	<span class="comment">//查看状态</span></span><br><span class="line">git add file1 file2 <span class="comment">//未跟踪或改变文件推送到暂存区</span></span><br><span class="line">git add.	<span class="comment">//添加所有文件到缓存区</span></span><br><span class="line">git commit -m <span class="string">&quot;备注信息&quot;</span>	<span class="comment">//将暂存区的文件提交到本地仓库</span></span><br><span class="line">git remote add origin <span class="string">&quot;https://....git&quot;</span>		<span class="comment">//将本地仓库关联到远程仓库，origin是默认的代表远程仓库在本地的名称</span></span><br><span class="line">git remote -v	<span class="comment">//查看远程仓库在本地的名称及地址</span></span><br><span class="line">git pull --rebase origin master	<span class="comment">//和远程仓库的master分支建立联系</span></span><br><span class="line">git push -u origin master	<span class="comment">//推送到远程仓库，origin代表远程仓库，master代表本地分支</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>01字典树</tag>
      </tags>
  </entry>
  <entry>
    <title>117. 填充每个节点的下一个右侧节点指针 II</title>
    <url>/posts/8dbab94f.html</url>
    <content><![CDATA[<p> <a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/">117. 填充每个节点的下一个右侧节点指针 II</a> 题目有点类似于层序线索化，就是在层序遍历的基础上魔改一下，使得可以获得当前遍历到第几层的信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* left;</span></span><br><span class="line"><span class="comment">    Node* right;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() : val(0), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _left, Node* _right, Node* _next)</span></span><br><span class="line"><span class="comment">        : val(_val), left(_left), right(_right), next(_next) &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(Node *root)</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">if</span>(root == NULL) <span class="keyword">return</span> ;</span><br><span class="line">        queue&lt;Node*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="comment">//cnt:当前正在遍历的这一层已经遍历了几个节点</span></span><br><span class="line">        <span class="comment">//tail:当前正在遍历的这一层一共有几个节点</span></span><br><span class="line">        <span class="comment">//num:下一层一共有几个节点</span></span><br><span class="line">        <span class="comment">//pre:这一层上一个遍历到的节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>, tail = <span class="number">1</span>, num = <span class="number">0</span>;</span><br><span class="line">        Node *pre = NULL;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">   </span><br><span class="line">            Node *u = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span>(pre) pre-&gt;next = u;</span><br><span class="line">            pre = u;</span><br><span class="line">            ++ cnt;</span><br><span class="line">            <span class="keyword">if</span>(u-&gt;left) &#123;</span><br><span class="line">   </span><br><span class="line">                q.push(u-&gt;left);</span><br><span class="line">                ++ num;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(u-&gt;right) &#123;</span><br><span class="line">   </span><br><span class="line">                q.push(u-&gt;right);</span><br><span class="line">                ++ num;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cnt == tail) &#123;</span><br><span class="line">   </span><br><span class="line">                cnt = <span class="number">0</span>;</span><br><span class="line">                tail = num;</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">                u-&gt;next = NULL;</span><br><span class="line">                pre = NULL;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Node* connect(Node* root) &#123;</span><br><span class="line">   </span><br><span class="line">        bfs(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>还有一种简单的写法，直接得出当前层节点个数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* left;</span></span><br><span class="line"><span class="comment">    Node* right;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() : val(0), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _left, Node* _right, Node* _next)</span></span><br><span class="line"><span class="comment">        : val(_val), left(_left), right(_right), next(_next) &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(Node *root)</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">if</span>(root == NULL) <span class="keyword">return</span> ;</span><br><span class="line">        queue&lt;Node*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">   </span><br><span class="line">            Node *pre = NULL;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> q.size();	<span class="comment">//为当前层的总节点数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">   	<span class="comment">//遍历当前层节点</span></span><br><span class="line">                Node *u = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">if</span>(pre) pre-&gt;next = u;</span><br><span class="line">                pre = u;</span><br><span class="line">                <span class="keyword">if</span>(u-&gt;left) q.push(u-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(u-&gt;right) q.push(u-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Node* connect(Node* root) &#123;</span><br><span class="line">   </span><br><span class="line">        bfs(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>01字典树</tag>
      </tags>
  </entry>
  <entry>
    <title>572. 另一棵树的子树</title>
    <url>/posts/7ae49056.html</url>
    <content><![CDATA[<p> <a href="https://leetcode.cn/problems/subtree-of-another-tree/">572. 另一棵树的子树</a> 解法一、暴力遍历每一个子树，比较子树是否相同 时复：O(s * t)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    bool <span class="title function_">judge</span><span class="params">(TreeNode *t1, TreeNode *t2)</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">if</span>(t1-&gt;val != t2-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(bool(t1-&gt;left) ^ bool(t2-&gt;left)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(bool(t1-&gt;right) ^ bool(t2-&gt;right)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(t1-&gt;left &amp;&amp; !judge(t1-&gt;left, t2-&gt;left)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(t1-&gt;right &amp;&amp; !judge(t1-&gt;right, t2-&gt;right)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bool <span class="title function_">isSubtree</span><span class="params">(TreeNode* root, TreeNode* subRoot)</span> &#123;</span><br><span class="line">   </span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">   </span><br><span class="line">            TreeNode *u = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span>(judge(u, subRoot)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(u-&gt;left) q.push(u-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(u-&gt;right) q.push(u-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>解法二、 解出两颗子树的所有前序序列，若t2是t1的子树，则t2的前序序列应为t1的前序序列的子串，利用kmp算法匹配即可，代码中lNull为左子树空的标志，rNull为右子树空的标志 时复：O(s + t)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> lNull, rNull;</span><br><span class="line">    <span class="type">int</span> ne[<span class="number">4100</span>];</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt; &amp;ve)</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> ;</span><br><span class="line">        ve.push_back(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left) dfs(root-&gt;left, ve);</span><br><span class="line">        <span class="keyword">else</span> ve.push_back(lNull);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right) dfs(root-&gt;right, ve);</span><br><span class="line">        <span class="keyword">else</span> ve.push_back(rNull);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">get_next</span><span class="params">(vector&lt;<span class="type">int</span>&gt; v1)</span>&#123;</span><br><span class="line">   </span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = -<span class="number">1</span>;  <span class="comment">//这里j是初始化为-1！</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> v1.size();</span><br><span class="line">        ne[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; len)&#123;</span><br><span class="line">   </span><br><span class="line">            <span class="keyword">if</span>(j == -<span class="number">1</span> || v1[i] == v1[j])&#123;</span><br><span class="line">   </span><br><span class="line">                ++ i; ++ j;</span><br><span class="line">                ne[i] = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> j = ne[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    bool <span class="title function_">kmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;v1, vector&lt;<span class="type">int</span>&gt; &amp;v2)</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> v1.size(), len2 = v2.size();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; len2)&#123;</span><br><span class="line">   </span><br><span class="line">            <span class="keyword">if</span>(j == -<span class="number">1</span> || v1[j] == v2[i])&#123;</span><br><span class="line">   </span><br><span class="line">                ++ i; ++ j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> j = ne[j];</span><br><span class="line">            <span class="keyword">if</span>(j == len1) &#123;</span><br><span class="line">   </span><br><span class="line">                cnt ++;  <span class="comment">// 匹配到</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    bool <span class="title function_">isSubtree</span><span class="params">(TreeNode* root, TreeNode* subRoot)</span> &#123;</span><br><span class="line">   </span><br><span class="line">        lNull = <span class="number">10001</span>, rNull = <span class="number">10002</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; v1, v2;</span><br><span class="line">        dfs(root, v2);</span><br><span class="line">        dfs(subRoot, v1);</span><br><span class="line">        get_next(v1);</span><br><span class="line">        <span class="keyword">return</span> kmp(v1, v2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>解法三、 官方题解给出的哈希做法，感觉很秒</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>01字典树</tag>
      </tags>
  </entry>
  <entry>
    <title>Typora使用配置</title>
    <url>/posts/5655ac3f.html</url>
    <content><![CDATA[<h3 id="取消拼写检查"><a href="#取消拼写检查" class="headerlink" title="取消拼写检查"></a>取消拼写检查</h3><p>默认会检查拼写错误，并在下方给予红线提示。 偏好设置-&gt;拼写检查-&gt;不使用拼写检查</p>
<h3 id="取消自动保存"><a href="#取消自动保存" class="headerlink" title="取消自动保存"></a>取消自动保存</h3><p>偏好设置-&gt;自动保存</p>
<h3 id="取消自动检查更新"><a href="#取消自动检查更新" class="headerlink" title="取消自动检查更新"></a>取消自动检查更新</h3><h3 id="图像上传路径"><a href="#图像上传路径" class="headerlink" title="图像上传路径"></a>图像上传路径</h3><p>偏好设置-&gt;图像-&gt;插入图像时-&gt;复制到指定路径-&gt;设置图片保存路径</p>
<h3 id="开启markdown扩展语法"><a href="#开启markdown扩展语法" class="headerlink" title="开启markdown扩展语法"></a>开启markdown扩展语法</h3><p>偏好设置-&gt;markdown-&gt;markdown扩展语法</p>
<h3 id="代码块显示行号"><a href="#代码块显示行号" class="headerlink" title="代码块显示行号"></a>代码块显示行号</h3><p>偏好设置-&gt;markdown-&gt;代码块</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>01字典树</tag>
      </tags>
  </entry>
  <entry>
    <title>706. 设计哈希映射</title>
    <url>/posts/35f83738.html</url>
    <content><![CDATA[<h2 id="706-设计哈希映射"><a href="#706-设计哈希映射" class="headerlink" title="706. 设计哈希映射"></a>706. 设计哈希映射</h2><p>处理冲突方法采用链表法，利用list</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyHashMap</span> &#123;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;list&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; data;</span><br><span class="line">    <span class="keyword">static</span> const <span class="type">int</span> <span class="variable">base</span> <span class="operator">=</span> <span class="number">769</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">return</span> x % base;</span><br><span class="line">    &#125;</span><br><span class="line">    MyHashMap(): data(base) &#123;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">auto</span> <span class="variable">it</span> <span class="operator">=</span> data[hash(key)].begin(); it != data[hash(key)].end(); it ++) &#123;</span><br><span class="line">   </span><br><span class="line">            <span class="keyword">if</span>((*it).first == key) &#123;</span><br><span class="line">   </span><br><span class="line">                (*it).second = value;</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        data[hash(key)].push_back(make_pair(key, value));</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> hash(key);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">auto</span> <span class="variable">it</span> <span class="operator">=</span> data[h].begin(); it != data[h].end(); it ++) &#123;</span><br><span class="line">   </span><br><span class="line">            <span class="keyword">if</span>((*it).first == key) &#123;</span><br><span class="line">   </span><br><span class="line">                <span class="keyword">return</span> (*it).second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> hash(key);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">auto</span> <span class="variable">it</span> <span class="operator">=</span> data[h].begin(); it != data[h].end(); it ++) &#123;</span><br><span class="line">   </span><br><span class="line">            <span class="keyword">if</span>((*it).first == key) &#123;</span><br><span class="line">   </span><br><span class="line">                data[h].erase(it);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyHashMap object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyHashMap* obj = new MyHashMap();</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;remove(key);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>01字典树</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 48. 旋转图像</title>
    <url>/posts/33a3ea80.html</url>
    <content><![CDATA[<h2 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48. 旋转图像"></a>48. 旋转图像</h2><p>矩阵从外到内，是一圈一圈的，只要能把一圈旋转90度，内层圈找好数据关系，for循环就可以搞定每一圈 对于一圈：对于第一行（除了最后一个元素）而言，只要把这些元素旋转四次就回到了原来位置，所以只要循环四次，把中间遍历到的元素都移到下一次即将遍历的位置即可 如何把当前元素放到下一个即将访问的位置？如果只是简单的覆盖，下一个元素将丢失，容易想到的是用temp存储即将丢失的元素，但这样实现起来有许多细节很难写，用交换实现则特别简单，找一个临时变量，每次都把当前位置和临时变量进行交换，则实现了旋转操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> struct node &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        node(<span class="type">int</span> x, <span class="type">int</span> y) &#123;</span><br><span class="line">   </span><br><span class="line">            <span class="built_in">this</span>-&gt;x = x;</span><br><span class="line">            <span class="built_in">this</span>-&gt;y = y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">static</span> node <span class="title function_">nextP</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">   <span class="comment">// 计算旋转后位置</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">   y, n - x - <span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">work</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> &#123;</span><br><span class="line">    <span class="comment">// 旋转一个元素对应的四个位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix.size(), bx = x, by = y;</span><br><span class="line">        <span class="type">node</span> <span class="variable">np</span> <span class="operator">=</span> nextP(x, y, n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++) &#123;</span><br><span class="line">   </span><br><span class="line">            swap(matrix[np.x][np.y], matrix[bx][by]); <span class="comment">// 交换</span></span><br><span class="line">            x = np.x; y = np.y;</span><br><span class="line">            np = nextP(np.x, np.y, n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n/<span class="number">2</span>; i ++) &#123;</span><br><span class="line">    <span class="comment">// 行</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; n-<span class="number">1</span>-i; j ++) &#123;</span><br><span class="line">    <span class="comment">// 列</span></span><br><span class="line">                work(i, j, matrix);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>01字典树</tag>
      </tags>
  </entry>
  <entry>
    <title>operator的两种用法（重载和隐式类型转换）</title>
    <url>/posts/64415dbc.html</url>
    <content><![CDATA[<h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><p>略</p>
<h2 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h2><h3 id="构造函数的隐式类型转换"><a href="#构造函数的隐式类型转换" class="headerlink" title="构造函数的隐式类型转换"></a>构造函数的隐式类型转换</h3><p>利用operator进行的隐式类型转换成为<strong>operator算子的隐式类型转换</strong>，讲这个之前先了解<strong>构造函数的隐式类型转换</strong>，请看以下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>&#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="type">int</span> val;</span><br><span class="line">		X(<span class="type">int</span> _val) &#123;</span><br><span class="line">   	<span class="comment">//隐式类型转换</span></span><br><span class="line">			val = _val;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">	<span class="type">X</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">2</span>;	<span class="comment">//等价于X m(2);</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>传入<strong>一个参数</strong>初始化类的构造函数就是构造函数的隐式类型转换，可以理解为将int类型转换为X(class)类型</p>
<h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p>如果不想出现这种隐式类型转换，就可以用explict修饰 具体详解请看： <a href="https://blog.csdn.net/weixin_45525272/article/details/105996548">explict详解</a></p>
<h3 id="operator算子的隐式类型转换"><a href="#operator算子的隐式类型转换" class="headerlink" title="operator算子的隐式类型转换"></a>operator算子的隐式类型转换</h3><p>而operator算子的隐式类型转换则是相反的，例如以下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test1</span>&#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">	    Test1(<span class="type">int</span> value):_value(value)&#123;</span><br><span class="line">   </span><br><span class="line">	        cout&lt;&lt;<span class="string">&quot;constructor&quot;</span>&lt;&lt;endl;</span><br><span class="line">	    &#125;</span><br><span class="line">	    ~Test1()&#123;</span><br><span class="line">   </span><br><span class="line">	        cout&lt;&lt;<span class="string">&quot;destructor&quot;</span>&lt;&lt;endl;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span>&#123;</span><br><span class="line">   </span><br><span class="line">	        <span class="keyword">return</span> _value;</span><br><span class="line">	    &#125;</span><br><span class="line">	    bool <span class="title function_">operator</span><span class="params">()</span> (<span class="type">int</span> x) const&#123;</span><br><span class="line">   	<span class="comment">//重载括号</span></span><br><span class="line">	        cout&lt;&lt;<span class="string">&quot;() is overload&quot;</span>&lt;&lt;endl;</span><br><span class="line">	        <span class="keyword">return</span> x &gt; _value;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="comment">//operator在返回类型前面（区分重载），string是返回类型</span></span><br><span class="line">	    operator <span class="title function_">string</span><span class="params">()</span>&#123;</span><br><span class="line">   	<span class="comment">//operator算子隐式类型转换</span></span><br><span class="line">	        cout&lt;&lt;<span class="string">&quot;type convert&quot;</span>&lt;&lt;endl;</span><br><span class="line">	        stringstream sstr;</span><br><span class="line">	        sstr&lt;&lt;_value;</span><br><span class="line">	        <span class="keyword">return</span> sstr.str();</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">	    <span class="type">int</span> _value;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">   </span><br><span class="line">    Test1 <span class="title function_">t</span><span class="params">(<span class="number">10</span>)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">if</span>(t(<span class="number">5</span>))</span><br><span class="line">        cout&lt;&lt;i&lt;&lt;<span class="string">&quot; is greater than &quot;</span>&lt;&lt;t.getValue()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;i&lt;&lt;<span class="string">&quot; is less than &quot;</span>&lt;&lt;t.getValue()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    string <span class="title function_">str</span><span class="params">(t)</span>; <span class="comment">// 将Test1类型转换为string类型</span></span><br><span class="line">    cout&lt;&lt;str&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Test1类型的对象传入string的构造函数，是用了c++构造函数的隐式类型转换特性，虽然string类并没有显式定义参数为Test1的构造函数，但因为其可以隐式转换为string，所以语法上都是合法的。</p>
<p>构造函数的隐式类型转换，是使用一个其他的类型构造当前类的临时对象并用此临时对象来构造当前对象，这种转换必须有构造函数的支持；</p>
<p>operator算子的隐式类型转换，使用当前对象去生成另一个类型的对象（正好与构造函数隐式转换相反），这种转换必须有operator算子的支持。</p>
<p>当然了，构造函数的隐式类型转换有利有弊，类的设计者就起决定性作用了，如果你不想让构造函数发生隐式的类型转换，请在构造函数前加explicit关键字；同时，operator算子声明的隐式类型转换也可以通过一些相应的返回值函数替代，用户的掌控性更好。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>01字典树</tag>
      </tags>
  </entry>
  <entry>
    <title>56. 合并区间</title>
    <url>/posts/2e0786fe.html</url>
    <content><![CDATA[<h2 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a>56. 合并区间</h2><p>双指针，先按照左端点升序排序，对于一个区间，如果可以和后面的合并，则其右端点一定大于后面区间的左端点，且合并后的区间右端点要取两个区间大的右端点，取max，注意边界即可 vector&lt;vector&lt;int&gt;&gt;默认按照第一列的元素从小到大排序，注意如果这里加cmp函数，必须是静态函数，因为sort是全局函数，全局函数不能调用类的成员函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="title function_">merge</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals)</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> intervals.size();</span><br><span class="line">        sort(intervals.begin(), intervals.end());</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">1</span>, mx = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span>(j &lt; n) &#123;</span><br><span class="line">   </span><br><span class="line">            <span class="keyword">if</span>(intervals[j][<span class="number">0</span>] &lt;= mx) &#123;</span><br><span class="line">   </span><br><span class="line">                mx = max(mx, intervals[j][<span class="number">1</span>]);</span><br><span class="line">                j ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">                res.push_back(&#123;</span><br><span class="line">   intervals[i][<span class="number">0</span>], mx&#125;);</span><br><span class="line">                i = j;</span><br><span class="line">                j = i + <span class="number">1</span>;</span><br><span class="line">                mx = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(&#123;</span><br><span class="line">   intervals[i][<span class="number">0</span>], mx&#125;);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>01字典树</tag>
      </tags>
  </entry>
  <entry>
    <title>缓冲区浅析</title>
    <url>/posts/aed25912.html</url>
    <content><![CDATA[<h2 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h2><p>程序运行输入数据时，从键盘的输入先存储到缓冲区，只有当缓冲区满或者输入回车时程序才会真正地从缓冲区读入数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">	<span class="type">int</span> a, b;</span><br><span class="line">	cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>in: 1 2\n 例如这里输入空格时程序没有输出，而是将空格也放入了缓冲区，只有输入回车时，程序才从缓冲区中拿出数据，而<strong>cin遇到回车、空格、tab时会停止读入</strong>，首先拿出1，遇到空格，停止读入，但<strong>空格并未被处理，依旧在缓冲区</strong>，所以下次读入时，先碰到空格，cin会舍弃 <em>刚开始碰到的</em> <strong>空白字符（空格、tab、回车）</strong>，读入2，遇到回车，停止读入，但回车依旧在缓冲区 对于上面话的理解可以看下面代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	cin &gt;&gt; a;</span><br><span class="line">	<span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> getchar();</span><br><span class="line">	cout &lt;&lt; c;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>in_1:1空格回车 in_2:1回车 两种输入方式输出内容不一样，第二种多输出了一个空白行</p>
<p>这篇文章只是浅析缓冲区，缓冲区具体分为三种，全缓冲、行缓冲、不带缓冲，深入理解自行查阅资料</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>01字典树</tag>
      </tags>
  </entry>
  <entry>
    <title>指针笔记（指针数组和指向数组的指针，数组中a和&amp;a的区别等）</title>
    <url>/posts/23a3191d.html</url>
    <content><![CDATA[<h2 id="指针数组和指向数组的指针"><a href="#指针数组和指向数组的指针" class="headerlink" title="指针数组和指向数组的指针"></a>指针数组和指向数组的指针</h2><p>int <em>p[4]和int (</em>p)[4]有何区别？ 前者是一个指针数组，数组大小为4，每一个元素都是一个指向int的指针 后者是指向int[4]类型数组的指针 <img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/43a71c451b20467fac3fc113d84a02e1.png" alt="img"> 以上代码若运行会报如下错误 <img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/05e85d7085f640cfa68b4e2d5794719e.png" alt="img"> main函数中定义的a数组本质是一个指向int[2]的指针，而函数形参则是一个指针数组，即形参的a是一个二维指针，所以会报错类型不匹配 若将形参改为int (*a)[2]则编译通过</p>
<h2 id="数组中a和-amp-a的区别"><a href="#数组中a和-amp-a的区别" class="headerlink" title="数组中a和&amp;a的区别"></a>数组中a和&amp;a的区别</h2><p>假如a是一个一维数组，输出a和&amp;a发现结果相同，都是一维数组首元素的地址，但两者虽然值相同，却是不同的 <img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/9057c28b1d0d4acdbfaa1d2ccb9b0b0b.png" alt="img"> 这段代码是没问题的，但若将第二行的&amp;a改为a，则会报错 <img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/3667b35f35634f0db37c9078454c7fcf.png" alt="img"> 即编译器认为a是int <em>类型的，而&amp;a则是int (</em> )[4]类型的，用大白话讲就是&amp;a编译器可以认出a是一个数组，a则不行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#include <span class="string">&quot;stdio.h&quot;</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line"> <span class="type">int</span> a[<span class="number">5</span>] = &#123;</span><br><span class="line">    <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line"> <span class="type">int</span> *ptr = (<span class="type">int</span> *)(&amp;a + <span class="number">1</span>);</span><br><span class="line"> printf(<span class="string">&quot;%d,%d&quot;</span>, *(a + <span class="number">1</span>), *(ptr - <span class="number">1</span>));</span><br><span class="line"> <span class="comment">/*getchar是用VS编写方便查看输出*/</span></span><br><span class="line"> getchar();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请思考一下上面的输出结果，如果你非常自信了，可以不用往下看 这个题目主要考察&amp;a 和 a</p>
<ul>
<li>a 在这里代表是的数组首元素的地址即 a[0]的首地址，其值为 0x005efda0。 </li>
<li>&amp;a 代表的是数组的首地址，其值为 0x005efda0。 </li>
<li>a+1 的值是 0x005efda0+1*sizeof（int），等于 0x005efda4。 </li>
<li>&amp;a+1 的值是（0x005efda0 +（sizeof（a）= 5*sizeof(int)）= 0x005efdb4 {0xcccccccc, 0xcb626a90, 0x005efdd0, 0x0029200e, 0x00000001}</li>
</ul>
<h2 id="二级指针"><a href="#二级指针" class="headerlink" title="二级指针"></a>二级指针</h2><blockquote>
<p>指向指针的指针</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一些常用的头文件</span></span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">通过引用直接去修改数组里的元素</span></span><br><span class="line"><span class="comment">小技巧：函数写在主函数（main）前面，就不用写函数声明了</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">SetArray</span><span class="params">(<span class="type">int</span> row,<span class="type">int</span> col,<span class="type">int</span>** &amp;Array)</span>&#123;</span><br><span class="line">   <span class="comment">//&amp;是引用符号，得到的是指针地址</span></span><br><span class="line"><span class="comment">//二维指针需要通过一维指针去指向数组</span></span><br><span class="line">	Array = <span class="keyword">new</span> <span class="title class_">int</span>*[row]; <span class="comment">//开辟行空间</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; row;i++)&#123;</span><br><span class="line">   </span><br><span class="line">		Array[i] = <span class="keyword">new</span> <span class="title class_">int</span>[col]; <span class="comment">//开辟列空间</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; col;j++)&#123;</span><br><span class="line">   </span><br><span class="line">			Array[i][j]  = <span class="number">0</span>;<span class="comment">//初始化，也可以将其他数组或是值存进去</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印数组里的内容</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">PrintArray</span><span class="params">(<span class="type">int</span>** Array,<span class="type">int</span> row,<span class="type">int</span> col)</span>&#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; row;i++)&#123;</span><br><span class="line">   </span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; col;j++)&#123;</span><br><span class="line">   </span><br><span class="line">			cout &lt;&lt; Array[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//内存释放：开辟的数组空间用完必须要手动释放，不然会爆内存</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">DeleteArray</span><span class="params">(<span class="type">int</span>** Array,<span class="type">int</span> row)</span>&#123;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; row;i++)&#123;</span><br><span class="line">   </span><br><span class="line">		delete[] Array[i];</span><br><span class="line">	&#125;</span><br><span class="line">	delete Array;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">   </span><br><span class="line">	<span class="type">int</span>** Array = NULL;</span><br><span class="line">	<span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> col = <span class="number">3</span>;</span><br><span class="line">	SetArray(row,col,Array);</span><br><span class="line">	PrintArray( Array,row,col);</span><br><span class="line">	DeleteArray(Array,row);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>01字典树</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客练习赛-C-梦迹</title>
    <url>/posts/82361365.html</url>
    <content><![CDATA[<h2 id="题目：梦迹"><a href="#题目：梦迹" class="headerlink" title="题目：梦迹"></a>题目：梦迹</h2><p>这道题和用树状数组求逆序对那道题目类似，都是把数组值作为树状数组下标，效果等价于权值线段树，本质上是一道树状数组的简单题。 每一个数字为答案的贡献等于getsum(W-num) 因此修改数字时就可以先减去修改前的贡献，加上修改后的贡献，树状数组的维护上，如果数字从a变为b，就把a位置加上-1，b位置加上1即可 考虑答案是否爆int，最差情况是n*(n-1)/2，到1e10，开longlong，其次注意树状数组下标从1开始，而题目a[i]从0开始，因此加上值为1的偏移量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">#define ios ios::sync_with_stdio(<span class="number">0</span>);cin.tie(<span class="number">0</span>);cout.tie(<span class="number">0</span>)</span><br><span class="line">#define endl <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">#define <span class="type">int</span> <span class="type">long</span> <span class="type">long</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">const <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N], tr[N];</span><br><span class="line"><span class="type">int</span> n, q, W;</span><br><span class="line"><span class="type">int</span> <span class="title function_">lowbit</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">modify</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">   </span><br><span class="line">	i ++;</span><br><span class="line">	<span class="keyword">while</span>(i &lt; N) &#123;</span><br><span class="line">   </span><br><span class="line">		tr[i] += val;</span><br><span class="line">		i += lowbit(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getsum</span><span class="params">(<span class="type">int</span> pos)</span> &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	pos ++;</span><br><span class="line">	<span class="keyword">while</span>(pos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">   </span><br><span class="line">		res += tr[pos];</span><br><span class="line">		pos -= lowbit(pos);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">solve</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">	cin &gt;&gt; n &gt;&gt; q &gt;&gt; W;</span><br><span class="line">	<span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">   </span><br><span class="line">		cin &gt;&gt; a[i];</span><br><span class="line">		modify(a[i], <span class="number">1</span>);</span><br><span class="line">		ans += getsum(W - a[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(q --) &#123;</span><br><span class="line">   </span><br><span class="line">		<span class="type">int</span> p, x;</span><br><span class="line">		cin &gt;&gt; p &gt;&gt; x;</span><br><span class="line">		ans -= getsum(W - a[p]);</span><br><span class="line">		modify(a[p], -<span class="number">1</span>);</span><br><span class="line">		modify(x, <span class="number">1</span>);</span><br><span class="line">		ans += getsum(W - x);</span><br><span class="line">		a[p] = x;</span><br><span class="line">		cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125; </span><br><span class="line">signed <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">   </span><br><span class="line">	ios;</span><br><span class="line">	<span class="type">int</span> T;</span><br><span class="line">	T = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(T --) &#123;</span><br><span class="line">   </span><br><span class="line">	    solve();</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>01字典树</tag>
      </tags>
  </entry>
  <entry>
    <title>C++转载的文章</title>
    <url>/posts/d0810907.html</url>
    <content><![CDATA[<p> <a href="https://coolshell.cn/articles/12176.html">C++对象的内存布局</a>  <a href="https://coolshell.cn/articles/12165.html#%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8">C++虚函数表解析</a>  <a href="https://blog.csdn.net/weixin_50866517/article/details/113247374">C++函数指针</a>  <a href="https://www.shuzhiduo.com/A/RnJWOgMvJq/">C++动态绑定和静态绑定</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>01字典树</tag>
      </tags>
  </entry>
  <entry>
    <title>环境配置-转载的文章</title>
    <url>/posts/f4a92650.html</url>
    <content><![CDATA[<h2 id="1-opencv-qt-MinGW"><a href="#1-opencv-qt-MinGW" class="headerlink" title="1. opencv+qt+MinGW"></a>1. opencv+qt+MinGW</h2><p> <a href="https://cxymm.net/article/f9547064141/112427355">click here</a></p>
<h2 id="2-CLion-opencv"><a href="#2-CLion-opencv" class="headerlink" title="2. CLion+opencv"></a>2. CLion+opencv</h2><p> <a href="https://www.jianshu.com/p/cf56d771a934">click here</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM冷知识</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序-防止退化O(n2)(三路排序)</title>
    <url>/posts/be43ae97.html</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p> <a href="https://leetcode.cn/problems/sort-an-array/">click here</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="传统快速排序"><a href="#传统快速排序" class="headerlink" title="传统快速排序"></a>传统快速排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span> ;</span><br><span class="line">	<span class="type">int</span> <span class="variable">bas</span> <span class="operator">=</span> a[l];</span><br><span class="line">	<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l, j = r;</span><br><span class="line">	<span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">   </span><br><span class="line">		<span class="keyword">while</span>(i &lt; j &amp;&amp; a[j] &gt;= bas) j --;</span><br><span class="line">		a[i] = a[j];</span><br><span class="line">		<span class="keyword">while</span>(i &lt; j &amp;&amp; a[i] &lt;= bas) i ++;</span><br><span class="line">		a[j] = a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	a[i] = bas;</span><br><span class="line">	quickSort(a, l, i-<span class="number">1</span>);</span><br><span class="line">	quickSort(a, i+<span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Hack数据1"><a href="#Hack数据1" class="headerlink" title="Hack数据1"></a>Hack数据1</h3><p>严格单调有序的数组 时间复杂度会退化为O(n2) 解决方案：随机化数组或者随机取基准值（而非第一个）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> l + rand() % (r - l + <span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">bas</span> <span class="operator">=</span> a[id];</span><br></pre></td></tr></table></figure>
<h3 id="Hack数据2"><a href="#Hack数据2" class="headerlink" title="Hack数据2"></a>Hack数据2</h3><p>所有数据都相等的数组 时间复杂度会退化为O(n2) 解决方案： <a href="https://blog.csdn.net/Tanyongyin/article/details/114841898">三路排序（详解点击）</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> l + rand()%(r - l + <span class="number">1</span>);</span><br><span class="line">    swap(&amp;a[l], &amp;a[index]);</span><br><span class="line">	<span class="type">int</span> <span class="variable">bas</span> <span class="operator">=</span> a[l];</span><br><span class="line">	<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l, j = r, k = l + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(k &lt;= j) &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">if</span>(a[k] == bas) k ++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[k] &lt; bas) &#123;</span><br><span class="line">   </span><br><span class="line">            swap(&amp;a[k], &amp;a[i]);</span><br><span class="line">            i ++;</span><br><span class="line">            k ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">            swap(&amp;a[k], &amp;a[j]);</span><br><span class="line">            j --;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	quickSort(a, l, i-<span class="number">1</span>);</span><br><span class="line">	quickSort(a, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>* sortArray(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span>* returnSize)&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    quickSort(nums, <span class="number">0</span>, numsSize-<span class="number">1</span>);</span><br><span class="line">    *returnSize = numsSize;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM冷知识</tag>
      </tags>
  </entry>
  <entry>
    <title>高并发浅析</title>
    <url>/posts/565b1d4d.html</url>
    <content><![CDATA[<h2 id="什么是高并发"><a href="#什么是高并发" class="headerlink" title="什么是高并发"></a>什么是高并发</h2><p>高并发指通过设计保证系统能够同时并行处理很多请求，是分布式系统非常重要的概念 评价分布式系统性能的指标有：</p>
<ol>
<li>响应时间：系统对请求做出响应的时间。 </li>
<li>吞吐量：单位时间内处理的请求数量。 </li>
<li>QPS（和吞吐量基本没啥区别）：每秒响应请求数。 </li>
<li>并发用户数：同时承载正常使用系统功能的用户数量。</li>
</ol>
<h2 id="水平扩容和垂直扩容"><a href="#水平扩容和垂直扩容" class="headerlink" title="水平扩容和垂直扩容"></a>水平扩容和垂直扩容</h2><p>那么如何实现高并发呢？ <img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/d6b7cf1a63604dc78036ceeb79fd1d34.png" alt="img"> 上图都是实现高并发的方法，而这里只介绍水平扩容和垂直扩容</p>
<h3 id="垂直扩容"><a href="#垂直扩容" class="headerlink" title="垂直扩容"></a>垂直扩容</h3><p>这是过去一直在使用并且可以马上见效的方法，但是缺点也很致命，垂直扩容有两种方案</p>
<ol>
<li>提升单机硬件配置 例如：增加CPU核数如32核，升级更好的网卡如万兆，升级更好的硬盘如SSD，扩充硬盘容量如2T，扩充系统内存如128G； <li>改善单机架构 例如：使用Cache来减少IO次数，使用异步来增加单服务吞吐量，使用无锁数据结构来减少响应时间； 但是这种方式势必会受到科技的限制，性能有极限，如果想突破这种极限，实现线性上升，就需要水平扩容</li>

</li>
</ol>
<h3 id="水平扩容"><a href="#水平扩容" class="headerlink" title="水平扩容"></a>水平扩容</h3><p>增加服务器数量，把请求尽量均匀地分配到各个服务器上，这也是分布式系统的目标。 举个例子，通常一个域名绑定一个IP，而一个IP对应一个服务器，当很多用户访问，响应速度会变慢，而采用nginx反向代理，把域名绑定到多个IP，利用dns轮询技术实现均衡负载，可以显著提高响应速度，而且没有极限</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM冷知识</tag>
      </tags>
  </entry>
  <entry>
    <title>Git如何推送当前代码到远程仓库</title>
    <url>/posts/d98274c.html</url>
    <content><![CDATA[<h2 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h2><p>（建立在已经配置好用户变量和ssh基础上） 在本地创建git仓库</p>
<blockquote>
<p>git init</p>
</blockquote>
<p>绑定远程仓库，origin是给远程仓库起的别名，也可以起其他名字，但是如果用origin，git push时可以不指出名字，如果用其他名字需要指出名字，git push 名字</p>
<blockquote>
<p>git remote add origin git@github.com:<strong><em>*</em></strong>/test.git</p>
</blockquote>
<p>提交到暂存区，提交所有文件</p>
<blockquote>
<p>git add .</p>
</blockquote>
<p>从暂存区提交到本地仓库</p>
<blockquote>
<p>git commit -m “time”</p>
</blockquote>
<p>从本地仓库推送到远程仓库</p>
<blockquote>
<p>git push</p>
</blockquote>
<h2 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h2><p>与第一种方法不同的只有绑定远程仓库的方法不同</p>
<blockquote>
<p>git clone [远程仓库地址]</p>
</blockquote>
<p>之后的步骤一样，git add. git commit git push</p>
<h2 id="工作区、暂存区、版本库、远程仓库"><a href="#工作区、暂存区、版本库、远程仓库" class="headerlink" title="工作区、暂存区、版本库、远程仓库"></a>工作区、暂存区、版本库、远程仓库</h2><p><img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/587813a177974bbcb166f2fa91cd3b39.png" alt="img"> workspace: 工作区 staging：暂存区 local repository：本地仓库（版本库） remote repository：远程仓库</p>
<h2 id="本地分支名字必须和远程分支名字一样"><a href="#本地分支名字必须和远程分支名字一样" class="headerlink" title="本地分支名字必须和远程分支名字一样"></a>本地分支名字必须和远程分支名字一样</h2><p>本地分支名字必须和远程分支名字一样才能push成功，现在GitHub默认分支为main，而git默认分支为master，这样push上去后GitHub就有两个分支，可以去GitHub把默认分支修改为master</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="查看本地分支"><a href="#查看本地分支" class="headerlink" title="查看本地分支"></a>查看本地分支</h3><p>git branch</p>
<h3 id="创建本地分支"><a href="#创建本地分支" class="headerlink" title="创建本地分支"></a>创建本地分支</h3><p>git branch [name]</p>
<h3 id="修改本地分支名字"><a href="#修改本地分支名字" class="headerlink" title="修改本地分支名字"></a>修改本地分支名字</h3><p>git branch -m [src] [dst]</p>
<h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><p>git checkout [分支名]</p>
<h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><p>git branch -d [分支名]</p>
<h3 id="查看当前状态"><a href="#查看当前状态" class="headerlink" title="查看当前状态"></a>查看当前状态</h3><p>git status</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM冷知识</tag>
      </tags>
  </entry>
  <entry>
    <title>select、poll、epoll（IO多路复用）</title>
    <url>/posts/bc5cfa75.html</url>
    <content><![CDATA[<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>三个模型都是用来判断是否有被监听的socket状态发生改变（读写和异常）</p>
<h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p>首先介绍一下fd_set这个数组，这其实是一个类图，其中每一位表示一个socketfd，哪一位是1表示这一位对应的socket就是被监听的，有三种需要监听的状态，所以就有三个数组，分别是readset，writeset、exceptset，分别监听读写和异常 select原型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> maxfd, fd_set* readset, fd_set* writeset, fd_set* exceptset, </span></span><br><span class="line"><span class="params">const struct timeval* timeout)</span>;&gt;</span><br></pre></td></tr></table></figure>
<ol>
<li>maxfd表示监听的最大fd（给定了范围） </li>
<li>三种状态的数组 </li>
<li>timeout表示超时时间，当timeout是NULL表示select只有监听到状态发生变化才会结束否则被阻塞，timeout是0表示select非阻塞，立刻返回，timeout&gt;0（数据结构内部有int）表示过一定时间后若还未检测到状态变化就结束 </li>
<li>返回值为状态变化的fd数量，若返回-1表示错误</li>
</ol>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>select采用轮询的方法，遍历fd_set的每一位，检查此socket是否有状态变化，若有变化就把这一位置为1，否则置为0，这样操作之后fd_set表示的意义也从“所有socket的列表”变为了“发生状态变化的socket列表”，接下来只需要遍历这个列表即可处理每一种状态，例如有一个socket有读的需求，则遍历到列表中这个fd时就可以调用read函数，当然由于socketfd意义发生变化，每次select前都需要提前备份一下fd_set，之后每次select后再次select，恢复到备份，这样才能保证每一个监听的fd都被遍历到，还需要注意的时timeout每次也需要重置，当select提前结束，此时timeout会变成剩余的时间，下次select需要重新指定</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>由于select采用轮询的方式，而每次发生状态变化的fd只有几个，更多是非活跃状态的fd，遍历全部花费了太多时间 </li>
<li>fd_set内部有最大限制，32位OS最大1024，62位最大2048</li>
</ol>
<h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><p>poll只优化了select的几个点</p>
<ol>
<li>poll采用了新的数据结构代替了fd_set，是一个链表，所以最大限制的说法就不复存在了 </li>
<li>poll返回值为活跃状态的fd链表，而没有修改监听链表，这样就不需要每次恢复到备份了 但是poll还是采用轮询的方式，效果依旧很差</li>
</ol>
<h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>epoll内部采用了红黑树和链表的方式彻底解决了以上问题</p>
<ol>
<li>红黑树保存所有带监听的fd，不需要像轮询那样遍历许多非监听的fd </li>
<li>突破了最大限制 epoll会把发生事件的fd放到链表中，只需遍历链表即可处理每一个事件</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM冷知识</tag>
      </tags>
  </entry>
  <entry>
    <title>红黑树介绍</title>
    <url>/posts/c9f4dad.html</url>
    <content><![CDATA[<p>红黑树就是满足以下特性的二叉树</p>
<ol>
<li>所有节点只有红色和黑色 </li>
<li>红色节点的孩子都是黑色（红色节点不能相邻） </li>
<li>黑色节点到任意叶子节点的简单路径上经过的黑色节点数量相同 </li>
<li>叶子节点不存储值，而且叶子节点都是黑色的 满足这样特性的二叉树高度一定不超过2log(n+1) 下面是证明 如果把红色节点全部删掉，把下面的剩下的所有节点都连接在一起，那么新产生的树就是一颗每个节点最多有四个子节点的树，计算高度可以采用满四叉树的高度来近似计算，即log(n)，而把删除的红色节点加上就是2倍</li>
</ol>
<p>红黑树相较于AVL，其查找效率略低一点，而插入删除效率高出AVL很多，所以当插入删除操作很多时可以使用红黑树</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM冷知识</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt 桌面闹钟提示小程序</title>
    <url>/posts/b3acc6d2.html</url>
    <content><![CDATA[<h2 id="程序运行截图"><a href="#程序运行截图" class="headerlink" title="程序运行截图"></a>程序运行截图</h2><p>倒计时 <img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/5859b6f410aa4b63a2f0c6ebbaf30ea1.png" alt="img"> 闹钟设置界面 <img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/8bdbe197d525459c921f1591001348d9.png" alt="img"> 闹钟弹窗提示+提示音 <img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/d987e900e87345ac9e5a1d62b3dee75c.png" alt="img"></p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p> <a href="https://gitee.com/uncleacc/clock">gitee源码链接</a>  <a href="https://gitee.com/uncleacc/clock-program/releases/tag/1.0">软件打包</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM冷知识</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-寻找两个正序数组的中位数</title>
    <url>/posts/ab7be2e3.html</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p> <a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/">click here</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>此题目是寻找两个数组组合为一个数组后的中位数，我们知道两个数组的长度，中位数是组合后的数组第几个数字我们是知道的，问题就转化为了寻找组合后数组的第k个数字，要求时间复杂度在<strong>log(n)</strong>，明显是二分，但是二分什么呢？一般都是二分两个数组，但这道题不同，需要二分的是k，对于两个数组而言，比较两个数组的第k/2个数字，小的一方前k/2个数字都不会是中位数，可以直接排除，从而快速缩小范围</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> nums1.size(), n = nums2.size();</span><br><span class="line">        <span class="type">int</span> <span class="variable">id1</span> <span class="operator">=</span> <span class="number">0</span>, id2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">   </span><br><span class="line">            <span class="keyword">if</span>(id1 == m) <span class="keyword">return</span> nums2[id2 + k - <span class="number">1</span>];<span class="comment">//边界</span></span><br><span class="line">            <span class="keyword">if</span>(id2 == n) <span class="keyword">return</span> nums1[id1 + k - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(k == <span class="number">1</span>) <span class="keyword">return</span> min(nums1[id1], nums2[id2]);</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> k / <span class="number">2</span>;<span class="comment">//二分</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">newid1</span> <span class="operator">=</span> min(id1 + len - <span class="number">1</span>, m - <span class="number">1</span>), newid2 = min(id2 + len - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(nums1[newid1] &lt; nums2[newid2]) &#123;</span><br><span class="line">   <span class="comment">//缩小范围</span></span><br><span class="line">                k -= newid1 - id1 + <span class="number">1</span>;</span><br><span class="line">                id1 = newid1 + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">                k -= newid2 - id2 + <span class="number">1</span>;</span><br><span class="line">                id2 = newid2 + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">findMedianSortedArrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> nums1.size(), len2 = nums2.size();</span><br><span class="line">        <span class="keyword">if</span>((len1 + len2) &amp; <span class="number">1</span>) <span class="keyword">return</span> find((len1 + len2) / <span class="number">2</span> + <span class="number">1</span>, nums1, nums2);</span><br><span class="line">        <span class="keyword">return</span> (find((len1 + len2) / <span class="number">2</span>, nums1, nums2) + find((len1 + len2)/<span class="number">2</span> + <span class="number">1</span>, nums1, nums2)) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM冷知识</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt 类似vscode和matlab的分屏显示效果</title>
    <url>/posts/4e9af57f.html</url>
    <content><![CDATA[<h2 id="运行截图"><a href="#运行截图" class="headerlink" title="运行截图"></a>运行截图</h2><p>向右分屏 <img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/d12ee987ffbe45ffb733304de299cdbf.png" alt="img"> 多分屏 <img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/744aa251f91a4112a2e6c5cf80d82adf.png" alt="img"> 全屏显示 <img src="C:\Users\60116\Desktop\img\68b7863013584ed097e8932f31b01566.png" alt="img"></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>实现了一个类似vscode和matlab的标签页显示分屏效果，支持鼠标拖拽分屏、全屏显示，可自适应调整大小，程序把要显示的Widget独立出来，可随时替换为其他的用户自定义Widget，例如3d模型、二维画图等</p>
<h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><ol>
<li>加载图片会非常卡，猜测是paintEvent频繁调用而每次绘制图片复杂度高导致 </li>
<li>分屏不能等分分屏，应该不难实现</li>
</ol>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p> <a href="https://gitee.com/uncleacc/qt-tab-page">gitee源码</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM冷知识</tag>
      </tags>
  </entry>
  <entry>
    <title>docker容器使用初体验</title>
    <url>/posts/de5ab824.html</url>
    <content><![CDATA[<p>我们写程序时，都会搭建相关的环境，比如写了一个web，使用了tomcat、nginx等，现在想要把程序部署到云服务器或者在其他电脑上运行，就需要重新部署一遍环境，尤其是项目开源后，上手成本大。</p>
<h2 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。 Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。 容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。 （来源于菜鸟教程）</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>docker依赖于linux内核，因此在windows系统中需要安装Hyper-V（类似于 VMWare 或 VirtualBox）或者WSL，然后进入docker desktop官网下载安装程序，双击运行即可。安装完成后可以在虚拟机中运行命令docker —version检查是否成功安装。</p>
<h3 id="镜像和容器的区别"><a href="#镜像和容器的区别" class="headerlink" title="镜像和容器的区别"></a>镜像和容器的区别</h3><p>Docker 中镜像（Image）和容器（Container）是两个核心概念，它们有以下主要区别：</p>
<ol>
<li>定义和用途： <ul> 
1. 镜像（Image）：镜像是一个只读的文件系统快照，它包含了一个应用程序及其运行环境所需的所有内容，包括代码、库、依赖项、配置等。镜像是用于创建容器的模板，可以看作是一个静态的、不可更改的应用程序打包。 
1. 容器（Container）：容器是一个运行时实例，它是基于镜像创建的，包含了应用程序及其所有依赖项的运行环境。容器可以被启动、停止、删除等，它提供了一个隔离的运行环境，使应用程序能够在不同的容器中运行，而不受主机环境的影响。 
</ul>  </li>
<li>可变性： <ul> 
4. 镜像是不可更改的，一旦创建就不能修改。如果需要对应用程序或环境进行更改，必须创建一个新的镜像。 
4. 容器是可变的，可以在运行时进行修改。你可以进入容器、安装软件、修改配置等，然后保存为新的镜像，以便将更改保存下来。 
</ul>  </li>
<li>生命周期： <ul> 
7. 镜像的生命周期是静态的，它存在于磁盘上并可以被多个容器实例使用。 
7. 容器的生命周期是动态的，它可以被创建、启动、停止和销毁。容器是临时的运行实体。 
</ul>  </li>
<li>资源消耗： <ul> 
10. 镜像通常占用磁盘空间，并且资源消耗较低，因为它们是静态的。 
10. 容器占用系统资源（CPU、内存等），因为它们正在运行应用程序和服务。 
</ul> 

</li>
</ol>
<p>总之，镜像是容器的模板，用于创建容器实例。容器是在镜像基础上运行的可执行实体，具有自己的运行时状态。Docker 的强大之处在于它允许你使用镜像来轻松创建、分发和管理容器，从而实现应用程序的隔离和可移植性。</p>
<h3 id="dockerhub"><a href="#dockerhub" class="headerlink" title="dockerhub"></a>dockerhub</h3><p>Docker Hub 是一个在线的 Docker 镜像仓库和容器注册表服务。它是 Docker 公司提供的官方服务，用于帮助开发人员和运维团队存储、分享和获取 Docker 镜像。Docker Hub 允许用户上传、存储和管理 Docker 镜像。这些镜像可以包含操作系统、应用程序、服务和其他容器化的组件，供其他用户下载和使用，类似于Github仓库。</p>
<p>如果要上传一个镜像，就需要编写dockerfile脚本文件，在这个文件中写入环境配置的命令行。</p>
<h3 id="docker和虚拟机区别"><a href="#docker和虚拟机区别" class="headerlink" title="docker和虚拟机区别"></a>docker和虚拟机区别</h3><p>Docker 和虚拟机是两种不同的虚拟化技术，它们在应用、资源消耗、启动时间和隔离等方面有一些重要区别。以下是 Docker 和虚拟机之间的主要区别： <strong>架构和隔离：</strong> Docker：Docker 使用容器技术，容器共享主机操作系统的内核，但在容器内部提供隔离的用户空间。这意味着容器之间共享操作系统内核，使其轻量且启动迅速。容器之间的隔离通过 Linux 内核的命名空间和控制组技术实现。 虚拟机：虚拟机是完全虚拟化的技术，每个虚拟机都运行自己的操作系统内核。这意味着虚拟机需要更多的资源，并且启动速度较慢，因为它们需要模拟整个操作系统。 <strong>资源消耗：</strong> Docker：由于容器共享主机操作系统的内核，所以 Docker 容器通常比虚拟机更轻量，需要较少的内存和存储资源。 虚拟机：虚拟机通常需要更多的资源，因为每个虚拟机都包含自己的操作系统内核和系统文件。 <strong>启动时间：</strong> Docker：Docker 容器可以在几秒内启动，因为它们不需要启动整个操作系统内核。 虚拟机：虚拟机通常需要更长的时间来启动，因为它们需要模拟和启动整个操作系统。 <strong>应用部署和管理：</strong> Docker：Docker 容器的部署和管理相对简单，可以使用 Docker Compose 和 Kubernetes 等工具来自动化管理多个容器。 虚拟机：虚拟机的部署和管理相对复杂，需要使用虚拟化管理工具来创建、配置和监视虚拟机。 <strong>跨平台支持：</strong> Docker：Docker 容器可以在不同的操作系统上运行，前提是它们都支持 Docker。 虚拟机：虚拟机通常需要适用于特定虚拟化平台的映像，并且不太容易跨平台移植。 <strong>隔离性：</strong> Docker：容器提供了一定程度的隔离，但不如虚拟机隔离得严格。容器之间可以共享操作系统内核，这意味着一些攻击可能会影响多个容器。 虚拟机：虚拟机提供了更强的隔离性，每个虚拟机都有独立的内核和资源，攻击一个虚拟机不会影响其他虚拟机。 根据你的需求和用例，你可以选择使用 Docker 或虚拟机来虚拟化和隔离应用程序。Docker 更适合轻量级、可扩展的应用程序，而虚拟机通常更适合需要更严格隔离或运行不同操作系统的应用程序。在实际应用中，有时也会同时使用 Docker 和虚拟机，以充分利用它们各自的优势。</p>
<h3 id="更改镜像源"><a href="#更改镜像源" class="headerlink" title="更改镜像源"></a>更改镜像源</h3><p>docker默认镜像源速度很慢，可以更改为以下镜像源：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;registry-mirrors&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;https://registry.hub.docker.com&quot;</span>,</span><br><span class="line">        <span class="string">&quot;http://hub-mirror.c.163.com&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://registry.docker-cn.com&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>可以将代码拉取到虚拟机本地，然后把代码上传到docker，进入容器，执行代码，参考以下命令</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">拉取代码</span><br><span class="line">git clone https:<span class="comment">//github.com/oceanbase/miniob.git </span></span><br><span class="line">挂载方式新建一个新容器，-v表示挂载，：前面表示本地文件目录，：后面表示你要在docker 容器中挂载的位置（随意，没有该目录也会新建）</span><br><span class="line">docker run -it -v /usr/lyjps/miniob:/lyjps oceanbase/miniob </span><br><span class="line">执行下面的命令进入容器，并创建bash终端，此时就可以使用Linux终端方式进行一些开发工作</span><br><span class="line">docker exec -it miniob bash</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM冷知识</tag>
      </tags>
  </entry>
  <entry>
    <title>explicit关键字</title>
    <url>/posts/58412853.html</url>
    <content><![CDATA[<h2 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a>explicit</h2><blockquote>
<p>作用: 防止隐式类型转换</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span> &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">double</span> real, imag;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		Complex()&#123;</span><br><span class="line">   </span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		Complex(<span class="type">double</span> _r, <span class="type">double</span> _i): real(_r), imag(_i) &#123;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">   </span><br><span class="line">	<span class="type">Complex</span> <span class="variable">t</span> <span class="operator">=</span> &#123;</span><br><span class="line">   <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码不会报错，因为t = {1, 2}这里发生了隐式类型转换，将{1, 2}转化为了Complex(1, 2)，产生了一个匿名对象，然后把匿名对象赋值给t(这种赋值只是简单的值拷贝操作，假如存在指针，这种操作有浅拷贝的隐患) 但如果在构造函数前面加上explicit关键字，以上代码无法通过编译，因为explicit不允许隐式类型转换，等号右边的类型与左边的类型不符，则编译失败</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM冷知识</tag>
      </tags>
  </entry>
  <entry>
    <title>函数对象以及labbda表达式浅析</title>
    <url>/posts/fc600b6.html</url>
    <content><![CDATA[<h2 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h2><p>函数对象就是仿函数，之所以叫仿函数，是因为使用起来书写形式和调用函数的代码形式很像，之所以叫函数对象，是因为本shi质还是个对象，只不过写这个类是为了使用类似函数的功能。 仿函数就是重载了括号，例如以下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span>&#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="type">int</span> cnt;</span><br><span class="line">		<span class="keyword">void</span> <span class="title function_">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">   </span><br><span class="line">			cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">			++ cnt;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">	myPrint func;</span><br><span class="line">    func(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//    myPrint()(2);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>myPrint类声明的对象就是函数对象，func()本质上是调用成员函数func.operator()(2)，但是由于经过运算符重载后也可以写成func(2)，形式就像是调用函数一样，所以称为函数对象 和普通的函数相比，有很多好处</p>
<ol>
<li>可以在内部保存状态，例如这里cnt记录了函数调用次数 </li>
<li>可以作为参数传递到其他函数（因为其内部有状态），类似函数指针</li>
</ol>
<h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><p>形式如下 其中返回类型可写可不写，编译器可以自动推断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[捕获变量](形参)-&gt;返回类型 &#123;</span><br><span class="line">   </span><br><span class="line">	函数体内容</span><br><span class="line">	<span class="keyword">return</span> 变量;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">	<span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">3</span>, n = <span class="number">4</span>;</span><br><span class="line">	<span class="type">auto</span> <span class="variable">func</span> <span class="operator">=</span> [&amp;m](<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b) &#123;</span><br><span class="line">   </span><br><span class="line">		<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a;</span><br><span class="line">		a = b;</span><br><span class="line">		b = temp;</span><br><span class="line">		m = <span class="number">10</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">	func(a, b);</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; m &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>捕获变量有几种形式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">lambda表达式，从闭包作用域捕获变量而获得状态，分为传值和传引用。</span><br><span class="line">捕获变量登记与函数对象中的示例数据成员。</span><br><span class="line"> [=] 值捕获所有变量</span><br><span class="line"> [&amp;] 引用捕获所有变量</span><br><span class="line"> [&amp;x] 引用捕获x变量</span><br><span class="line"> [x]  值捕获x</span><br><span class="line"> [=,&amp;x] 默认值捕获，x变量通过引用捕获</span><br><span class="line"> [&amp;,x] 默认引用捕获，x通过值捕获</span><br><span class="line"> [<span class="built_in">this</span>] 捕获当前对象，可访问所有共有成员，C++<span class="number">20</span>中不允许隐式捕获<span class="built_in">this</span></span><br><span class="line"> [=,x],[&amp;,&amp;x] 错误，重复指定</span><br><span class="line"> 注意：即便默认要值捕获，全局变量总是使用引用捕获</span><br><span class="line"> 使用初始化捕获表达式表达move捕获</span><br></pre></td></tr></table></figure>
<p>值捕获的变量默认是const不可修改的，如果需要修改，则需要将lambda匿名函数对象用mutable修饰</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">	<span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">	<span class="type">auto</span> <span class="variable">func</span> <span class="operator">=</span> [m]() mutable&#123;</span><br><span class="line">   </span><br><span class="line">		m = <span class="number">2</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM冷知识</tag>
      </tags>
  </entry>
  <entry>
    <title>每日一题-动态规划(从不同类型的物品中各挑选一个，使得最后花费总和等于1000)</title>
    <url>/posts/a6596b9.html</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/189fa5e92dcf4e3482717f3905171ca3.jpeg" alt="img"> 四种类型的物品，每一种类型物品数量都是n，先要从每种类型的物品中挑选一件，使得最后花费总和等于1000 暴力做法10000^4 看到花费总和是1000，很小且固定的数字，肯定有玄机，从这里想应该是用dp，不难想到用dp[i][j]表示前i种类型的物品花费为j的方案数量，思考转移方程： dp[i][j] = dp[i-1][j-A] * js[i][A]，js[i][A]表示i类型的物件花销为A的方案数量，如此只需要枚举j和A，它们的范围就是1000以内</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#define ios ios::sync_with_stdio(<span class="number">0</span>);cin.tie(<span class="number">0</span>);cout.tie(<span class="number">0</span>)</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[<span class="number">5</span>][<span class="number">1100</span>], js[<span class="number">5</span>][<span class="number">11000</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ve[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">    ios;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">   </span><br><span class="line">    	<span class="type">int</span> a, b , c, d;</span><br><span class="line">    	cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;</span><br><span class="line">    	ve[<span class="number">1</span>].push_back(a);</span><br><span class="line">    	ve[<span class="number">2</span>].push_back(b);</span><br><span class="line">    	ve[<span class="number">3</span>].push_back(c);</span><br><span class="line">    	ve[<span class="number">4</span>].push_back(d);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++) &#123;</span><br><span class="line">   </span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; ve[i].size(); j++) &#123;</span><br><span class="line">   </span><br><span class="line">			js[i][ve[i][j]] ++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(auto p : ve[<span class="number">1</span>]) &#123;</span><br><span class="line">   </span><br><span class="line">		dp[<span class="number">1</span>][p] ++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= <span class="number">4</span>; i++) &#123;</span><br><span class="line">   </span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= <span class="number">1000</span>; j++) &#123;</span><br><span class="line">   </span><br><span class="line">			<span class="keyword">if</span>(js[i][j]) &#123;</span><br><span class="line">   </span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> j; k &lt;= <span class="number">1000</span>; k++) &#123;</span><br><span class="line">   </span><br><span class="line">					dp[i][k] += dp[i-<span class="number">1</span>][k-j] * js[i][j];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; dp[<span class="number">4</span>][<span class="number">1000</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">250 250 250 250</span></span><br><span class="line"><span class="comment">156 201 205 400</span></span><br><span class="line"><span class="comment">205 190 100 250</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM冷知识</tag>
      </tags>
  </entry>
  <entry>
    <title>A*算法</title>
    <url>/posts/edfb9eba.html</url>
    <content><![CDATA[<blockquote>
<p>A*算法在求一个点到目标点的最短距离时，可以加快速度，如果使用dijstla是nlogn的时复，但是A*更快，当节点足够多，边足够大时，可能不能求起点到所有点的最短距离，空间不够或者时复顶不住，这个时候A*<strong>或许</strong>能做，A<em>使用了一个启发式函数f()，其含义是节点到终点的估计距离，这个距离可以是曼哈顿距离，可以是实际到终点的最短距离等等，只要满足<em>*估计距离小于等于实际距离</em></em>即可，只要满足了这个，那么用f(u)+dis(u)当作优先队列的排序规则，每次取出最小值，这个点的最短距离就确定了，证明我找不到，<code>画个图可以想一下是有道理的</code></p>
</blockquote>
<h2 id="ACWing-178-第K短路"><a href="#ACWing-178-第K短路" class="headerlink" title="ACWing.178.第K短路"></a><a href="https://www.acwing.com/problem/content/description/180/">ACWing.178.第K短路</a></h2><p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/image-20210907170044220.png" alt="image-20210907170044220"></p>
<p>我看到这道题，不会A<em>之前，我只能想到Knlogn的时复，跑K次dijstla…太菜了，其实更好的是使用BFS，给每一个状态加上一个距离，使用优先队列，每次取出距离最小的点，其实就是dijstla，只不过少了dis数组，这样子做如果不加优化空间和时间都顶不住，所以开一个cnt[]数组记录每一个点被更新了几次，如果一个点已经被更新K次了，之后这个点就没必要再入队了，加上这个优化后，时复和空间复杂度最坏就是Knlogn，<del>但是这道题还是过不去</del>，所以使用A\</em>优化，加上f()函数，表示从终点到节点的最短距离作为近似值，估计值=节点距离起点的距离+距离终点的距离近似值，以估计值作为排序标准，每次取出最小，当终点被第K次取出时返回答案。</p>
<p>需要说明的时这个题目是可能存在重边的，所以必须等一个点把能到的状态都走完，才能判断返回条件。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=h[u.to];~i;i=e[i].next)&#123;</span><br><span class="line">    <span class="type">int</span> v=e[i].to,w=e[i].w;</span><br><span class="line">    <span class="keyword">if</span>(v==ed)&#123;</span><br><span class="line">        K--;</span><br><span class="line">        <span class="keyword">if</span>(K==<span class="number">0</span>) <span class="keyword">return</span> u.d+w;</span><br><span class="line">    &#125;</span><br><span class="line">    pq.push(&#123;v,u.d+w&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个写法是错误的，假如1-&gt;2有很多边权，存边的时候是按照来的顺序存的，所以可能是乱的，除非用vector存边而且边权排序，否则答案不对，还有这道题每条最短路中至少要包含一条边，所以如果终点和起点相同，找的是第K+1条边。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0) </span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">110000</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> to,next,w;</span><br><span class="line">&#125;e[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> to,d;</span><br><span class="line">	<span class="type">bool</span> operator&lt;(<span class="type">const</span> node &amp;o)<span class="type">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> d&gt;o.d;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nb</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> to,d,c;</span><br><span class="line">	<span class="type">bool</span> operator&lt;(<span class="type">const</span> nb &amp;o)<span class="type">const</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(c==o.c) <span class="keyword">return</span> d&gt;o.d;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> c&gt;o.c;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> h[N],rh[N],f[N],cnt[N];</span><br><span class="line"><span class="type">int</span> tot,n,m,st,ed,K;</span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> *h,<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> c)</span>&#123;</span><br><span class="line">	e[tot]=&#123;v,h[u],c&#125;;</span><br><span class="line">	h[u]=tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dij</span><span class="params">(<span class="type">int</span> st)</span>&#123;</span><br><span class="line">	<span class="built_in">priority_queue</span>&lt;node&gt; pq;</span><br><span class="line">	<span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line">	f[st]=<span class="number">0</span>;</span><br><span class="line">	pq.push(&#123;st,<span class="number">0</span>&#125;);</span><br><span class="line">	<span class="keyword">while</span>(!pq.empty())&#123;</span><br><span class="line">		<span class="keyword">auto</span> u=pq.top().to;</span><br><span class="line">		pq.pop();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=rh[u];~i;i=e[i].next)&#123;</span><br><span class="line">			<span class="type">int</span> v=e[i].to,w=e[i].w;</span><br><span class="line">			<span class="keyword">if</span>(f[v]&gt;f[u]+w)&#123;</span><br><span class="line">				f[v]=f[u]+w;</span><br><span class="line">				pq.push(&#123;v,f[v]&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span> st)</span>&#123;</span><br><span class="line">	<span class="built_in">priority_queue</span>&lt;nb&gt; pq;</span><br><span class="line">	pq.push(&#123;st,<span class="number">0</span>,f[st]&#125;);</span><br><span class="line">	<span class="keyword">while</span>(!pq.empty())&#123;</span><br><span class="line">		<span class="keyword">auto</span> u=pq.top();</span><br><span class="line">		pq.pop();</span><br><span class="line">		<span class="keyword">if</span>(cnt[u.to]&gt;=K) <span class="keyword">continue</span>;</span><br><span class="line">		cnt[u.to]++;</span><br><span class="line">		<span class="keyword">if</span>(cnt[u.to]==K &amp;&amp; u.to==ed) <span class="keyword">return</span> u.d;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=h[u.to];~i;i=e[i].next)&#123;</span><br><span class="line">			<span class="type">int</span> v=e[i].to,w=e[i].w;</span><br><span class="line">			<span class="keyword">if</span>(cnt[v]&gt;=K) <span class="keyword">continue</span>;</span><br><span class="line">			pq.push(&#123;v,u.d+w,u.d+w+f[v]&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">	<span class="built_in">memset</span>(rh,<span class="number">-1</span>,<span class="keyword">sizeof</span> rh);</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="type">int</span> u,v,w;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">		add(h,u,v,w);</span><br><span class="line">		add(rh,v,u,w);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;st&gt;&gt;ed&gt;&gt;K;</span><br><span class="line">	<span class="keyword">if</span>(st==ed) K++;</span><br><span class="line">	dij(ed);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;bfs(st);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>A*算法</tag>
      </tags>
  </entry>
  <entry>
    <title>ACM冷知识</title>
    <url>/posts/5ccd823e.html</url>
    <content><![CDATA[<h2 id="int128"><a href="#int128" class="headerlink" title="__int128"></a>__int128</h2><p>C++支持的最大数据类型就是longlong，再大就会爆掉，所以出现了<em>_int128类型，默认gcc是不支持编译的，但是在各大OJ上是可以运行的，\</em>_int128不支持cin、cout，所以需要自己写读入打印函数，也就是传统的快读快写</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ll;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(__int128 &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> y=<span class="number">1</span>;x=<span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(c&lt;<span class="string">&#x27;0&#x27;</span> || c&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>) y=<span class="number">-1</span>;</span><br><span class="line">		c=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(c&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; c&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">		x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		c=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	x*=y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(__int128 x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">		x*=<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;=<span class="number">10</span>) <span class="built_in">print</span>(x/<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __int128 x;</span><br><span class="line">	<span class="built_in">read</span>(x);</span><br><span class="line">	<span class="built_in">print</span>(x); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h2 id="atan2"><a href="#atan2" class="headerlink" title="atan2"></a>atan2</h2><p>函数原型：<code>double atan2(double y,double x)</code></p>
<p>传进去一个向量，返回这个向量相对于x轴正方向的角度值，当向量朝向是y轴以上返回值为正，当向量朝向为y轴以下，返回值为负，所以值域为(-pi,pi]</p>
<h2 id="stoi函数-amp-amp-atoi函数"><a href="#stoi函数-amp-amp-atoi函数" class="headerlink" title="stoi函数 &amp;&amp; atoi函数"></a>stoi函数 &amp;&amp; atoi函数</h2><blockquote>
<p>头文件 cstring</p>
<p>作用：将一个字符串转化为int类型，如果输入小数会省略小数点后面的，负数也可以输入</p>
</blockquote>
<p>atoi: 接受const char *，所以string类型需要调用c_str()转化一下，超过上界返回上界，超出下界返回下界</p>
<p>stoi: 接受const string *，直接传入string即可，超出int范围会报错runerror</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;stoi(s)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&gt;&gt;123</span></span><br><span class="line"><span class="comment">&lt;&lt;123</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="isalpha-islower-isupper-isdigit"><a href="#isalpha-islower-isupper-isdigit" class="headerlink" title="isalpha || islower || isupper || isdigit"></a>isalpha || islower || isupper || isdigit</h2><p>传入字符判断</p>
<p>isalpha： 判断是否为字母</p>
<p>islower:  判断是否为小写字母</p>
<p>isupper： 判断是否为大写字母</p>
<p>isdigit： 判断是否为数字</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM冷知识</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 笔记</title>
    <url>/posts/2da2039a.html</url>
    <content><![CDATA[<h3 id="四区"><a href="#四区" class="headerlink" title="四区"></a>四区</h3><ol>
<li>全局区 静态变量、全局变量、常量 <li>代码区 存储编写的代码，本质就是把代码编译形成的二进制文件放在内存的代码区</li> 
<li>栈区 形参、临时变量（由操作系统负责分配与回收）</li> 
<li>堆区 new的变量（由程序员负责分配与回收）</li>

</li>
</ol>
<h3 id="argc和argv"><a href="#argc和argv" class="headerlink" title="argc和argv"></a>argc和argv</h3><p>如果在命令行中编译运行C或C++文件，可能会传入某些参数，argc为参数的个数，argv为每一个参数的名称 main(int argc, char *argv[]) argv[0]为运行文件的目录地址（第一个参数） argv[1]为传入的第二个参数 … argv[argc-1]为传入的argc个参数 argv[argc]为NULL <img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/5eab799b38fd46d0b0edfca3ccf60cce.png" alt="img"> 图片中hello即为传入的第二个参数</p>
<h3 id="函数的分文件编写"><a href="#函数的分文件编写" class="headerlink" title="函数的分文件编写"></a>函数的分文件编写</h3><ol>
<li>把函数声明放在.h的头文件中 </li>
<li>把函数定义写在.cpp的函数文件中 </li>
<li>在main.cpp中包含了函数声明头文件即可直接使用此函数</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">swap.h</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span>;</span><br><span class="line"></span><br><span class="line">swap.cpp</span><br><span class="line">#include <span class="string">&quot;swap.h&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span> &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> *a;</span><br><span class="line">	*a = *b;</span><br><span class="line">	*b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main.cpp</span><br><span class="line">#include <span class="string">&quot;swap.h&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">	<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">	swap(&amp;a, &amp;b);</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数默认参数"><a href="#函数默认参数" class="headerlink" title="函数默认参数"></a>函数默认参数</h3><blockquote>
<p>若一个形参有默认参数，则此形参的右边所有参数都必须有默认参数，这是防止二义性的出现</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getRadius</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">2</span>, <span class="type">int</span> c = <span class="number">3</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//valid</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getRadius</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">2</span>, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="comment">//invalid</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="class结构"><a href="#class结构" class="headerlink" title="class结构"></a>class结构</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">class 类名 &#123;</span><br><span class="line">   </span><br><span class="line">	访问权限:</span><br><span class="line">		变量</span><br><span class="line">	访问权限:</span><br><span class="line">		方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>访问权限（默认是私有）:</p>
<ol>
<li>public 类内类外都可以访问 <li>protected 类内可以访问，类外不可以访问 派生类可以访问基类的protected，但是不可以访问private</li> 
<li>private 类内可以访问，类外不可以访问</li>

</li>
</ol>
<h3 id="class和struct的区别"><a href="#class和struct的区别" class="headerlink" title="class和struct的区别"></a>class和struct的区别</h3><p>c++的struct除了保留c的所有特性外，还增加了class的所有特性，两者只有一点不同，struct里面的属性默认是public，而class默认是private</p>
<h3 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h3><blockquote>
<p>构造函数：创建对象时会自动调用构造函数，构造函数（与函数名一致）若不定义则系统会默认创建一个空实现的构造函数<br> 析构函数：释放对象内存时会自动调用析构函数，在构造函数前面加上“~”即成为析构函数，若不定义则系统会默认创建一个空实现的析构函数</p>
</blockquote>
<p>析构函数通常用来释放类对象在堆区开辟的空间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">cicle</span> &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		cicle() &#123;</span><br><span class="line">   </span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;这里调用了构造函数&quot;</span> &lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//析构函数</span></span><br><span class="line">		~cicle() &#123;</span><br><span class="line">   </span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;这里调用了析构函数&quot;</span> &lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="拷贝函数"><a href="#拷贝函数" class="headerlink" title="拷贝函数"></a>拷贝函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">circle</span> &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="type">int</span> radius;</span><br><span class="line">		circle(const circle &amp;c) &#123;</span><br><span class="line">   	<span class="comment">//参数形式是固定的，只能这样写const类名 &amp;变量名</span></span><br><span class="line">			radius = c.radius;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;这里调用了拷贝函数&quot;</span> &lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建对象的三种方法"><a href="#创建对象的三种方法" class="headerlink" title="创建对象的三种方法"></a>创建对象的三种方法</h3><blockquote>
<p>如果创建了有参构造函数则不提供默认构造函数<br> 如果创建了拷贝构造函数则不提供其他构造函数</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">circle <span class="title function_">c</span><span class="params">(<span class="number">2</span>)</span>;	<span class="comment">//括号法 </span></span><br><span class="line"><span class="type">circle</span> <span class="variable">c</span> <span class="operator">=</span> circle(<span class="number">2</span>);	<span class="comment">//显示法（circle(2)创建了一个匿名对象），匿名对象会立刻被系统回收掉</span></span><br><span class="line"><span class="type">circle</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">2</span>;	<span class="comment">//隐式转化法（编译器将此语句变成circle c = circle(2)）</span></span><br></pre></td></tr></table></figure>
<h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h3><p>浅拷贝： 简单的变量赋值操作 深拷贝： 在堆区重新申请内存，用指针接受地址</p>
<p>浅拷贝存在的问题：如果在类中函数有申请堆区内存操作，假设创建了类c1，类中指针p接收了new出来的内存地址，又调用拷贝函数创建了c2，c2的p指针内容是由c1的p指针内容拷贝过来的，因此两者指针指向同一块内存区域，若此时c2调用了析构函数，将p指针指向的区域delete掉了，由于c1的p也指向此区域，所以当c1调用析构函数时，就会因为p1指针指向区域已经被释放掉而进行非法操作。解决办法是自定义拷贝函数，重新申请一块新区域，用p指针指向此区域，即深拷贝</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">circle</span> &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="type">int</span> *p;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		circle(<span class="type">int</span> a) &#123;</span><br><span class="line">   </span><br><span class="line">			p = <span class="keyword">new</span> <span class="title class_">int</span>(a);</span><br><span class="line">		&#125;</span><br><span class="line">		circle(const circle &amp;c) &#123;</span><br><span class="line">   	<span class="comment">//拷贝函数如果有new操作特别注意要深拷贝，浅拷贝会出问题</span></span><br><span class="line">			p = <span class="keyword">new</span> <span class="title class_">int</span>(*c.p);</span><br><span class="line">		&#125;</span><br><span class="line">		~circle() &#123;</span><br><span class="line">   		<span class="comment">//释放掉类中new的内存</span></span><br><span class="line">			<span class="keyword">if</span>(p) &#123;</span><br><span class="line">   </span><br><span class="line">				delete p;</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;调用成功&quot;</span> &lt;&lt; endl;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">circle</span> &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="type">int</span> aa, bb, cc;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		circle(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c): aa(a), bb(b), cc(c) &#123;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h3><p>静态成员变量</p>
<ol>
<li>所有对象共享同一份数据 </li>
<li>在编译阶段分配内存 </li>
<li>类内声明，类外初始化（必须）</li>
</ol>
<p>静态成员函数 4. 所有对象共享同一个函数 5. 静态成员函数只能访问静态成员变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">circle</span> &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">static</span> <span class="type">int</span> a;	<span class="comment">//类内声明</span></span><br><span class="line">		<span class="type">int</span> b;</span><br><span class="line">		<span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getB</span><span class="params">()</span> &#123;</span><br><span class="line">   	<span class="comment">//invalid，因为b是非静态变量</span></span><br><span class="line">			<span class="keyword">return</span> b;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> circle::a = <span class="number">1</span>; 	<span class="comment">//类外初始化</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">	circle c;</span><br><span class="line">	circle c2;</span><br><span class="line">	c2.a = <span class="number">3</span>;	<span class="comment">//c2和c共享一份a静态变量</span></span><br><span class="line">	cout &lt;&lt; c.a &lt;&lt; endl; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h3><p>this指针指向被调用的成员函数所指向的对象 this指针不需要定义，直接使用即可 this指针的用途</p>
<ol>
<li>当形参和成员变量同名时，可用this指针来区分 </li>
<li>在类的非静态成员函数中返回对象本身，可使用return *this（链式编程）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span> &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="type">int</span> age;</span><br><span class="line">		person(<span class="type">int</span> age) &#123;</span><br><span class="line">   </span><br><span class="line">			<span class="built_in">this</span>-&gt;age = age;	<span class="comment">//区分形参和成员变量</span></span><br><span class="line">			<span class="comment">//person::age = age;//这种形式也可以</span></span><br><span class="line">		&#125;</span><br><span class="line">		person&amp; addAge(<span class="type">int</span> age) &#123;</span><br><span class="line">   	<span class="comment">//注意返回引用才可以链式编程</span></span><br><span class="line">			<span class="built_in">this</span>-&gt;age += age;</span><br><span class="line">			<span class="keyword">return</span> *<span class="built_in">this</span>;	<span class="comment">//返回调用该函数的对象c</span></span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">	person c;</span><br><span class="line">	c.age = <span class="number">10</span>;</span><br><span class="line">	c.addAge(<span class="number">10</span>).addAge(<span class="number">10</span>).addAge(<span class="number">10</span>);	<span class="comment">//链式编程</span></span><br><span class="line">	cout &lt;&lt; c.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="常成员函数和常对象"><a href="#常成员函数和常对象" class="headerlink" title="常成员函数和常对象"></a>常成员函数和常对象</h3><blockquote>
<p>特例：<strong>mutable</strong>修饰的变量可以被常函数和常对象修改</p>
</blockquote>
<p>在普通成员函数后面括号后面加上const修饰就变成了常成员函数，常成员函数无法修改成员变量，通过两个规则保证</p>
<ol>
<li><strong>常成员函数不能更新对象的数据成员，也不能调用该类中没有用const修饰的成员函数</strong>。这保证了在常成员函数中绝对不会更新数据成员的值。 </li>
<li>如果将一个对象说明为常对象（const对象），<strong>则通过该常对象只能调用它的常成员函数</strong>，而不能调用其他成员函数。这是C++从语法机制上对 const对象 的保护，也是 const对象 唯一的对外接口方式。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span> &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="type">int</span> age;</span><br><span class="line">		<span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> const &#123;</span><br><span class="line">   	<span class="comment">//常成员函数 ，const本质上是在修饰this指针，更改成员变量本质上就是通过对this指针解引用实现 </span></span><br><span class="line"><span class="comment">//			this-&gt;age = age //invalid，不允许修改成员变量 </span></span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>定义对象语句前面加上const修饰即为常对象。 常对象只能调用常函数，无法修改常对象的成员变量和调用常对象的普通成员函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">const person <span class="title function_">p</span><span class="params">()</span>;	<span class="comment">//const修饰要初始化加上一个括号</span></span><br></pre></td></tr></table></figure>
<h3 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h3><blockquote>
<p>作用：让全局函数可以访问到类对象的私有变量和函数<br> 用法：在类中加上一条全局函数声明，再在前面加上friend修饰</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span> &#123;</span><br><span class="line">   </span><br><span class="line">	friend <span class="keyword">void</span> <span class="title function_">func</span><span class="params">(person &amp;p)</span>;	<span class="comment">//友元函数声明</span></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">int</span> age;</span><br><span class="line">		string name;</span><br><span class="line">		string <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">			<span class="keyword">return</span> name;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		person(string name, <span class="type">int</span> age) &#123;</span><br><span class="line">   </span><br><span class="line">			<span class="built_in">this</span>-&gt;name = name;</span><br><span class="line">			<span class="built_in">this</span>-&gt;age = age;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">func</span><span class="params">(person &amp;p)</span> &#123;</span><br><span class="line">   	<span class="comment">//友元函数可以访问私有成员</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;正在访问&quot;</span> &lt;&lt; p.name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p.age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; p.getName() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	cin &gt;&gt; name &gt;&gt; age;</span><br><span class="line">	<span class="type">person</span> <span class="variable">p1</span> <span class="operator">=</span> person(name, age);</span><br><span class="line">	func(p1);	</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">	test();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h3><blockquote>
<p>作用：和友元函数一样，都是让好朋友可以访问自己的私有成员<br> 用法：在类中加上友元类声明，再在前面加上friend修饰</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">rooms</span>;	<span class="comment">//事先声明rooms类，防止location报错找不到rooms类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span> &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">int</span> age;</span><br><span class="line">		string name;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		person(string name, <span class="type">int</span> age) &#123;</span><br><span class="line">   </span><br><span class="line">			<span class="built_in">this</span>-&gt;name = name;</span><br><span class="line">			<span class="built_in">this</span>-&gt;age = age;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">void</span> <span class="title function_">location</span><span class="params">(rooms &amp;r)</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">rooms</span> &#123;</span><br><span class="line">   </span><br><span class="line">	friend <span class="keyword">class</span> <span class="title class_">person</span>;	<span class="comment">//友元类</span></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		string bedRoom;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		string sittingRoom;</span><br><span class="line">		rooms(string a, string b) &#123;</span><br><span class="line">   </span><br><span class="line">			bedRoom = a;</span><br><span class="line">			sittingRoom = b;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> person::location(rooms &amp;r) &#123;</span><br><span class="line">   	<span class="comment">//在类外实现成员函数的定义，这是因为location用到了rooms的成员变量，而person类定义在rooms之前，所以如果location在类内定义的话，编译器不认识bedRoom这个变量，因为此时rooms只是声明了一下，并没有定义内部变量（如果不想这么写，可以直接把rooms定义写在person类定义前面）</span></span><br><span class="line">	cout &lt;&lt; name &lt;&lt; <span class="string">&quot;现在正在&quot;</span> &lt;&lt; r.bedRoom &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">	person <span class="title function_">p</span><span class="params">(<span class="string">&quot;李四&quot;</span>, <span class="number">21</span>)</span>;</span><br><span class="line">	rooms <span class="title function_">r</span><span class="params">(<span class="string">&quot;卧室&quot;</span>, <span class="string">&quot;客厅&quot;</span>)</span>;</span><br><span class="line">	p.location(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="友元成员函数"><a href="#友元成员函数" class="headerlink" title="友元成员函数"></a>友元成员函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">rooms</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span> &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		string name;</span><br><span class="line">		rooms *p; </span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		person(string name);</span><br><span class="line">		<span class="keyword">void</span> <span class="title function_">location</span><span class="params">()</span>;</span><br><span class="line">		</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">rooms</span> &#123;</span><br><span class="line">   </span><br><span class="line">	friend <span class="keyword">void</span> person::location();	<span class="comment">//变得只有这里</span></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		string bedRoom;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		string sittingRoom;</span><br><span class="line">		rooms() &#123;</span><br><span class="line">   </span><br><span class="line">			bedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">			sittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person::person(string name) &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="built_in">this</span>-&gt;name = name;</span><br><span class="line">	p = <span class="keyword">new</span> <span class="title class_">rooms</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> person::location() &#123;</span><br><span class="line">   </span><br><span class="line">	cout &lt;&lt; name &lt;&lt; <span class="string">&quot;现在正在&quot;</span> &lt;&lt; p-&gt;bedRoom &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">	person <span class="title function_">p</span><span class="params">(<span class="string">&quot;李四&quot;</span>)</span>;</span><br><span class="line">	p.location();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>重载依据：</p>
<ol>
<li>形参类型； </li>
<li>参数个数； </li>
<li>形参的顺序； </li>
<li>const，有const 只读，无const可读写 重点说一下const修饰的函数，const只能修饰成员函数，const修饰的函数不能修改成员变量，const修饰的常对象只能调用const修饰的常函数，而非常对象只能调用<strong>重载</strong>的非常函数（但非常函数可以调用没有重载的常函数，也就是只有一个函数名字的常函数）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">T</span> &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="type">int</span> <span class="title function_">disp</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">			cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">char</span> <span class="title function_">disp</span><span class="params">()</span> const&#123;</span><br><span class="line">   </span><br><span class="line">			cout &lt;&lt; <span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">	T t;</span><br><span class="line">	t.disp();</span><br><span class="line">	const T t2;</span><br><span class="line">	t2.disp(); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p>将成员函数名字换成operator”运算符”，即为运算符重载，本质还是编写函数</p>
<h4 id="重载-（加号运算符）"><a href="#重载-（加号运算符）" class="headerlink" title="重载+（加号运算符）"></a>重载+（加号运算符）</h4><p>让两个同类对象对应属性相加</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span> &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="type">int</span> age;</span><br><span class="line">		person(<span class="type">int</span> age) &#123;</span><br><span class="line">   </span><br><span class="line">			<span class="built_in">this</span>-&gt;age = age;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//		person operator+(person p) &#123;	//成员函数重载</span></span><br><span class="line"><span class="comment">//			person temp(0);</span></span><br><span class="line"><span class="comment">//			temp.age = age + p.age;</span></span><br><span class="line"><span class="comment">//			return temp;</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">person operator+(person a, person b) &#123;</span><br><span class="line">   	<span class="comment">//全局函数重载</span></span><br><span class="line">	person <span class="title function_">temp</span><span class="params">(<span class="number">0</span>)</span>;</span><br><span class="line">	temp.age = a.age + b.age;</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">	person <span class="title function_">p1</span><span class="params">(<span class="number">10</span>)</span>;</span><br><span class="line">	person <span class="title function_">p2</span><span class="params">(<span class="number">20</span>)</span>;</span><br><span class="line"><span class="comment">//	person p3 = p1.person(p2);	//成员函数重载，第一种写法</span></span><br><span class="line"><span class="comment">//	person p3 = operator+(p1, p2);	//全局函数重载，第二种写法</span></span><br><span class="line">	<span class="type">person</span> <span class="variable">p3</span> <span class="operator">=</span> p1 + p2;	<span class="comment">//以上两种写法的简化，等价于上面两种</span></span><br><span class="line">	cout &lt;&lt; p3.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="重载-lt-lt-（左移运算符）"><a href="#重载-lt-lt-（左移运算符）" class="headerlink" title="重载&lt;&lt;（左移运算符）"></a>重载&lt;&lt;（左移运算符）</h4><p>输出对象的所有属性值，由于cout在左移运算符左边，所以无法通过成员函数实现，成员函数cout只能在右边</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span> &#123;</span><br><span class="line">   </span><br><span class="line">	friend ostream&amp; operator&lt;&lt;(ostream &amp;out, person &amp;p);	<span class="comment">//友元</span></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">int</span> a, b;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		person(<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">   </span><br><span class="line">			<span class="built_in">this</span>-&gt;a = a;</span><br><span class="line">			<span class="built_in">this</span>-&gt;b = b;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line">ostream&amp; operator&lt;&lt;(ostream &amp;out, person &amp;p) &#123;</span><br><span class="line">   	<span class="comment">//链式编程，只有这样cout&lt;&lt;p之后才可以继续追加输出，cout本质就是一个ostream的对象</span></span><br><span class="line">	out &lt;&lt; p.a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p.b;</span><br><span class="line">	<span class="keyword">return</span> out; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">	person <span class="title function_">p</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span>;</span><br><span class="line">	cout &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="重载自增运算符（递增运算符）"><a href="#重载自增运算符（递增运算符）" class="headerlink" title="重载自增运算符（递增运算符）"></a>重载自增运算符（递增运算符）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">myInteger</span> &#123;</span><br><span class="line">   </span><br><span class="line">	friend ostream&amp; operator&lt;&lt;(ostream &amp;cout, myInteger &amp;o);</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">int</span> num;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		myInteger() &#123;</span><br><span class="line">   </span><br><span class="line">			num = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		myInteger&amp; operator++() &#123;</span><br><span class="line">   </span><br><span class="line">			++ num;</span><br><span class="line">			<span class="keyword">return</span> *<span class="built_in">this</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		myInteger&amp; operator++(<span class="type">int</span>) &#123;</span><br><span class="line">   	<span class="comment">//占位区分前置和后置</span></span><br><span class="line">			<span class="type">myInteger</span> <span class="variable">temp</span> <span class="operator">=</span> *<span class="built_in">this</span>;</span><br><span class="line">			num ++;</span><br><span class="line">			<span class="keyword">return</span> temp;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line">ostream&amp; operator&lt;&lt;(ostream &amp;cout, myInteger &amp;o) &#123;</span><br><span class="line">   </span><br><span class="line">	cout &lt;&lt; o.num;</span><br><span class="line">	<span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">	myInteger a;</span><br><span class="line">	cout &lt;&lt; ++a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; a++ &lt;&lt;endl;</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="重载-（赋值运算符）"><a href="#重载-（赋值运算符）" class="headerlink" title="重载=（赋值运算符）"></a>重载=（赋值运算符）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span> &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="type">int</span> *p;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		person(<span class="type">int</span> t) &#123;</span><br><span class="line">   </span><br><span class="line">			p = <span class="keyword">new</span> <span class="title class_">int</span>(t);</span><br><span class="line">		&#125;</span><br><span class="line">		person(const person &amp;o) &#123;</span><br><span class="line">   	<span class="comment">//重写拷贝函数</span></span><br><span class="line">			p = <span class="keyword">new</span> <span class="title class_">int</span>(*o.p);</span><br><span class="line">		&#125;</span><br><span class="line">		~person() &#123;</span><br><span class="line">   	<span class="comment">//析构函数释放申请空间</span></span><br><span class="line">			<span class="keyword">if</span>(p) &#123;</span><br><span class="line">   </span><br><span class="line">				delete p;</span><br><span class="line">				p = NULL;</span><br><span class="line">			&#125;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;success&quot;</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		person&amp; operator=(person &amp;o) &#123;</span><br><span class="line">   	<span class="comment">//重载=，注意返回当前对象，链式法则</span></span><br><span class="line">			<span class="keyword">if</span>(p) &#123;</span><br><span class="line">   </span><br><span class="line">				delete p;</span><br><span class="line">				p = NULL;</span><br><span class="line">			&#125;</span><br><span class="line">			p = <span class="keyword">new</span> <span class="title class_">int</span>(*o.p);</span><br><span class="line">			<span class="keyword">return</span> *<span class="built_in">this</span>;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">	person <span class="title function_">p1</span><span class="params">(<span class="number">10</span>)</span>;</span><br><span class="line">	person <span class="title function_">p2</span><span class="params">(<span class="number">0</span>)</span>;</span><br><span class="line">	person <span class="title function_">p3</span><span class="params">(<span class="number">0</span>)</span>;</span><br><span class="line">	<span class="type">person</span> <span class="variable">p4</span> <span class="operator">=</span> p3;	<span class="comment">//这里不是=运算符重载，而是调用拷贝函数，因此依旧是浅拷贝，需要自定义拷贝函数，改成深拷贝 </span></span><br><span class="line">	p3 = p2 = p1;</span><br><span class="line">	cout &lt;&lt; p1.p &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p2.p &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p3.p &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p4.p &lt;&lt; endl;	<span class="comment">//查看申请的内存地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="重载关系运算符"><a href="#重载关系运算符" class="headerlink" title="重载关系运算符"></a>重载关系运算符</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span> &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		string name;</span><br><span class="line">		<span class="type">int</span> age;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		person(string name, <span class="type">int</span> age) &#123;</span><br><span class="line">   </span><br><span class="line">			<span class="built_in">this</span>-&gt;name = name;</span><br><span class="line">			<span class="built_in">this</span>-&gt;age = age;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//		bool operator==(person o) &#123;</span></span><br><span class="line">   </span><br><span class="line"><span class="comment">//			if(name == o.name &amp;&amp; age == o.age) return true;</span></span><br><span class="line"><span class="comment">//			return false;</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line">		bool operator&lt;(person o) &#123;</span><br><span class="line">   </span><br><span class="line">			<span class="keyword">if</span>(age &lt; o.age) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		bool operator&gt;(person o) &#123;</span><br><span class="line">   </span><br><span class="line">			<span class="keyword">if</span>(age &gt; o.age) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line">bool operator==(person a, person b) &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">if</span>(a.name == b.name &amp;&amp; a.age == b.age) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">	person <span class="title function_">p1</span><span class="params">(<span class="string">&quot;tom&quot;</span>, <span class="number">16</span>)</span>;</span><br><span class="line">	person <span class="title function_">p2</span><span class="params">(<span class="string">&quot;tom&quot;</span>, <span class="number">15</span>)</span>;</span><br><span class="line">	<span class="keyword">if</span>(p1 == p2) cout &lt;&lt; <span class="string">&quot;same&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(p1 &gt; p2) cout &lt;&lt; <span class="string">&quot;bigger&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;smaller&quot;</span> &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="重载括号运算符"><a href="#重载括号运算符" class="headerlink" title="重载括号运算符"></a>重载括号运算符</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span> &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		string name;</span><br><span class="line">		<span class="type">int</span> age;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		person(string name, <span class="type">int</span> age) &#123;</span><br><span class="line">   </span><br><span class="line">			<span class="built_in">this</span>-&gt;name = name;</span><br><span class="line">			<span class="built_in">this</span>-&gt;age = age;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">void</span> <span class="title function_">operator</span><span class="params">()</span><span class="params">()</span> &#123;</span><br><span class="line">   	<span class="comment">//重载（）运算符</span></span><br><span class="line">			cout &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">	person <span class="title function_">p1</span><span class="params">(<span class="string">&quot;tom&quot;</span>, <span class="number">16</span>)</span>;	</span><br><span class="line">	p1();	<span class="comment">//由于写法类似函数，又名仿函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h4><p>考虑以下情况： 狗是一个类，但狗又可以细分为很多品种，例如边牧、二哈、柯基等，这些细分的品种有狗的共性，但也有自己的特性，这时就体现出继承。 继承方式有三种：(子类会继承所有父类属性，但父类private的属性子类无法访问) public： 不改变从父类继承过来的属性访问权限 protected： 把所有父类非private的属性访问权限设为protected private： 把所有父类非private的属性访问权限设为private <strong>派生类不可以访问基类的私有成员，只能通过函数接口来访问；但是可以访问基类的公共成员和保护成员</strong> 派生类应当使用初始化列表的方式将值传递给基类的构造函数，否则将使用默认的基类构造函数 derived:derived(type1 x, type2 y):base(x, y) {} 首先创建基类对象。 派生类构造函数应通过成员初始化列表将基类信息传递给基类的构造函数。 派生类构造函数应当初始化派生类新增的初始化成员。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">basicClass</span> &#123;</span><br><span class="line">   	<span class="comment">//父类，公共内容</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">void</span> <span class="title function_">header</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;公共头部&quot;</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">void</span> <span class="title function_">footer</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;公共底部&quot;</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">void</span> <span class="title function_">left</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;公共左部&quot;</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JAVA</span> : <span class="keyword">public</span> basicClass &#123;</span><br><span class="line">   	<span class="comment">//继承父类的子类</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">void</span> <span class="title function_">content</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;JAVA课程&quot;</span> &lt;&lt; endl; </span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPP</span> : <span class="keyword">public</span> basicClass &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">void</span> <span class="title function_">content</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;CPP课程&quot;</span> &lt;&lt; endl; </span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Python</span> : <span class="keyword">public</span> basicClass &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">void</span> <span class="title function_">content</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;Python课程&quot;</span> &lt;&lt; endl; </span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">	JAVA a;</span><br><span class="line">	Python b;</span><br><span class="line">	CPP c;</span><br><span class="line">	a.header(); a.content(); a.footer(); a.left(); </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;----------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	b.header(); b.content(); b.footer(); b.left();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;----------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	c.header(); c.content(); c.footer(); c.left();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="同名变量函数"><a href="#同名变量函数" class="headerlink" title="同名变量函数"></a>同名变量函数</h4><p>如果子类和父类有同名变量或者同名函数，则子类会隐藏父类的同名变量和同名函数，想要访问到父类的同名变量或者函数，则必须加上父类的作用域，另外，即使子类和父类的同名函数参数不同，但是子类仍然会隐藏父类的函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">basicClass</span> &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="type">int</span> a;</span><br><span class="line">		<span class="keyword">void</span> <span class="title function_">out</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;basicClass&quot;</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">void</span> <span class="title function_">out</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">   </span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;basicClass &quot;</span> &lt;&lt; k &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JAVA</span> : <span class="keyword">public</span> basicClass &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		JAVA() &#123;</span><br><span class="line">   </span><br><span class="line">			a = <span class="number">100</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> a;</span><br><span class="line">		<span class="keyword">void</span> <span class="title function_">out</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;JAVA&quot;</span> &lt;&lt; endl; </span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">	JAVA a;</span><br><span class="line">	cout &lt;&lt; a.a &lt;&lt; endl;</span><br><span class="line">	a.out();</span><br><span class="line">	cout &lt;&lt; a.basicClass::a &lt;&lt; endl;</span><br><span class="line">	a.basicClass::out();</span><br><span class="line">	a.basicClass::out(<span class="number">2</span>);	<span class="comment">//即使子类同名函数和父类同名函数参数不同，仍然会隐藏父类同名函数 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="多个父类拥有同名变量函数"><a href="#多个父类拥有同名变量函数" class="headerlink" title="多个父类拥有同名变量函数"></a>多个父类拥有同名变量函数</h4><p>子类可以继承多个父类，如果多个父类拥有同名变量或者函数，也需要通过作用域来区分</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">basicClass</span> &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="type">int</span> a;</span><br><span class="line">		basicClass() &#123;</span><br><span class="line">   </span><br><span class="line">			a = <span class="number">100</span>;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">basicClass2</span> &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="type">int</span> a;</span><br><span class="line">		basicClass2() &#123;</span><br><span class="line">   </span><br><span class="line">			a = <span class="number">200</span>;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JAVA</span> : <span class="keyword">public</span> basicClass, <span class="keyword">public</span> basicClass2 &#123;</span><br><span class="line">   </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">	JAVA a;</span><br><span class="line">	cout &lt;&lt; a.basicClass::a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a.basicClass2::a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h4><p>考虑下面情况： 有基类A，B继承于A，C继承于A，D继承于B和C，A中有一份数据，此时D就会同时继承两份一样的数据，要访问这份数据，还要加上作用域。如何解决呢？ 虚继承可以解决此问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">annimal</span> &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="type">int</span> age;</span><br><span class="line">		annimal() &#123;</span><br><span class="line">   </span><br><span class="line">			age = <span class="number">18</span>;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">sleep</span> : virtual <span class="keyword">public</span> annimal &#123;</span><br><span class="line">   </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">tuo</span> : virtual <span class="keyword">public</span> annimal &#123;</span><br><span class="line">   </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">sleepTuo</span> : <span class="keyword">public</span> sleep, <span class="keyword">public</span> tuo &#123;</span><br><span class="line">   </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">	sleepTuo a;</span><br><span class="line">	cout &lt;&lt; sizeof a &lt;&lt; endl;	<span class="comment">//8-&gt;24消耗了内存</span></span><br><span class="line">	cout &lt;&lt; a.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虚继承本质是存储一个指向虚基类的指针，指针指向虚基类表，表中存储一个偏移量，指针地址加上偏移量就是数据存放地址，因此此操作实质上增加了内存消耗，换来的是不用区分作用域。</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p> <a href="https://blog.csdn.net/zhang_si_hang/article/details/126173598">详解</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">annimal</span> &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		virtual <span class="keyword">void</span> <span class="title function_">speak</span><span class="params">()</span> &#123;</span><br><span class="line">   	<span class="comment">//定义为虚函数</span></span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;动物在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">cat</span> : <span class="keyword">public</span> annimal &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">void</span> <span class="title function_">speak</span><span class="params">()</span> &#123;</span><br><span class="line">   	<span class="comment">//重写虚函数</span></span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;猫在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">	cat c;</span><br><span class="line">	annimal &amp;a = c;	<span class="comment">//多态</span></span><br><span class="line">	a.speak();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h4><p>开发项目时最忌讳代码一整个一口气写完，一是可读性差，二是扩展性差 开闭原则即为 扩展开放，修改封闭 多态即可实现这样的目标，下面计算器是一个实例，如果把计算器实现的所有操作都封装在一个类里面，会显得代码都集中在一块，没有体现模块化编程思想，以后想添加新的操作，就要修改计算器类的代码。 如果使用多态，就可以创造一个空实现的基类，要添加操作时，就可以创造一个新类继承此基类，重写虚函数，实现新功能，不需要更改旧代码，只需要添加新代码即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">calculator</span> &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="type">int</span> num1, num2;</span><br><span class="line">		virtual <span class="type">int</span> <span class="title function_">calc</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">subCalculator</span> : <span class="keyword">public</span> calculator &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="type">int</span> <span class="title function_">calc</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">			<span class="keyword">return</span> num1 + num2;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">	calculator *c = <span class="keyword">new</span> <span class="title class_">subCalculator</span>;	<span class="comment">//加法器 </span></span><br><span class="line">	c-&gt;num1 = <span class="number">1</span>;</span><br><span class="line">	c-&gt;num2 = <span class="number">2</span>;</span><br><span class="line">	cout &lt;&lt; c-&gt;calc() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h4><p>以上案例中基类的虚函数函数体其实根本不会用到，写它只是为了过编译，这种情况就可以使用纯虚函数，纯虚函数可以不写函数体，拥有纯虚函数的类称为虚类，而让子类重写此函数，且子类必须重写纯虚函数，否则子类就也为虚类。</p>
<p>虚类无法实例化，即无法创建对象。</p>
<p>只能创建指针或者引用来实现多态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">calculator</span> &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="type">int</span> num1, num2;</span><br><span class="line">		virtual <span class="type">int</span> <span class="title function_">calc</span><span class="params">()</span> = <span class="number">0</span>;	<span class="comment">//纯虚函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><blockquote>
<p>template&lt;class T&gt;：括号里面的就是模板形参，调用模板时没有歧义时可以省略实参，否则需要指明实参类型</p>
</blockquote>
<h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">template&lt;typename T&gt;	<span class="comment">//将T作为一种数据类型</span></span><br><span class="line"><span class="comment">//template&lt;class T&gt;	效果等价于上一句</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">out</span><span class="params">(T &amp;a)</span> &#123;</span><br><span class="line">   </span><br><span class="line">	cout &lt;&lt; a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码调用out函数时会根据传入的参数判断出T的类型，我们也可以在调用时直接指定出类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">out&lt;string&gt;(s);	<span class="comment">//直接指定T为string类型</span></span><br></pre></td></tr></table></figure>
<p>以下是快速排序自写的一个模板</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">template&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(T a[], <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span> ;</span><br><span class="line">	<span class="type">T</span> <span class="variable">bas</span> <span class="operator">=</span> a[l];</span><br><span class="line">	<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l, j = r;</span><br><span class="line">	<span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">   </span><br><span class="line">		<span class="keyword">while</span>(i &lt; j &amp;&amp; a[j] &gt;= bas) j --;</span><br><span class="line">		<span class="keyword">while</span>(i &lt; j &amp;&amp; a[i] &lt;= bas) i ++;</span><br><span class="line">		swap(a[i], a[j]);</span><br><span class="line">	&#125;</span><br><span class="line">	swap(a[l], a[i]);</span><br><span class="line">	sort(a, l, i-<span class="number">1</span>);</span><br><span class="line">	sort(a, i+<span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="调用规则"><a href="#调用规则" class="headerlink" title="调用规则"></a>调用规则</h4><p>调用规则如下:</p>
<ol>
<li>如果函数模板和普通函数都可以实现，优先调用普通函数 </li>
<li>可以通过空模板参数列表来强制调用函数模板 </li>
<li>函数模板也可以发生重载 </li>
<li>如果函数模板可以产性更好的匹配,优先调用函数模板</li>
</ol>
<h4 id="利用具体化模板解决自定义类型的比较问题"><a href="#利用具体化模板解决自定义类型的比较问题" class="headerlink" title="利用具体化模板解决自定义类型的比较问题"></a>利用具体化模板解决自定义类型的比较问题</h4><blockquote>
<p><code>template&lt;&gt;</code>打头，且参数类型具体指名即为具体化模板</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span> &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="type">int</span> age;</span><br><span class="line">		string name;</span><br><span class="line">		person(<span class="type">int</span> age, string name) &#123;</span><br><span class="line">   </span><br><span class="line">			<span class="built_in">this</span>-&gt;age = age;</span><br><span class="line">			<span class="built_in">this</span>-&gt;name = name;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">bool <span class="title function_">compare</span><span class="params">(T &amp;a, T &amp;b)</span> &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">if</span>(a == b) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;&gt;bool <span class="title function_">compare</span><span class="params">(person &amp;a, person &amp;b)</span> &#123;</span><br><span class="line">   	<span class="comment">//具体化模板</span></span><br><span class="line">	<span class="keyword">if</span>(a.age == b.age &amp;&amp; a.name == b.name) <span class="keyword">return</span> <span class="literal">true</span>;	<span class="comment">//如果函数参数和具体化模板参数相同，则会优先调用具体化模板</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">	person <span class="title function_">p1</span><span class="params">(<span class="number">16</span>, <span class="string">&quot;tom&quot;</span>)</span>;</span><br><span class="line">	person <span class="title function_">p2</span><span class="params">(<span class="number">16</span>, <span class="string">&quot;tom&quot;</span>)</span>;</span><br><span class="line">	cout &lt;&lt; compare(p1, p2) &lt;&lt; endl;	<span class="comment">//person类型编译器无法比较</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>try、catch、throw throw(x)：x的类型决定抛出异常的类型，x可以是表达式，也可以是常数或变量，其他类型异常自行百度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="type">double</span> <span class="title function_">fuc</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span> &#123;</span><br><span class="line">       </span><br><span class="line">	<span class="keyword">if</span>(y==<span class="number">0</span>) <span class="keyword">throw</span> <span class="number">0</span>;	<span class="comment">//如果除数为0抛出int类型异常</span></span><br><span class="line">	<span class="keyword">return</span> x/y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">	<span class="type">double</span> res;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">   	<span class="comment">//尝试执行try，出现异常后执行对应catch块中内容</span></span><br><span class="line">		res=fuc(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;The result of x/y is : &quot;</span>&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">		res=fuc(<span class="number">4</span>,<span class="number">0</span>);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">catch</span>(<span class="type">int</span>) &#123;</span><br><span class="line">   </span><br><span class="line">		cerr&lt;&lt;<span class="string">&quot;error of dividing zero.\n&quot;</span>;</span><br><span class="line">		res=fuc(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">		exit(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span>(...) &#123;</span><br><span class="line">   	<span class="comment">//默认异常处理</span></span><br><span class="line">		cerr &lt;&lt; <span class="string">&quot;error&quot;</span> &lt;&lt; endl;	<span class="comment">//与cout无异，只是规范</span></span><br><span class="line">		exit(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="const引用"><a href="#const引用" class="headerlink" title="const引用"></a>const引用</h3><p> <a href="https://blog.csdn.net/holybin/article/details/17558183?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~OPENSEARCH~Rate-1-17558183-blog-115046837.pc_relevant_multi_platform_whitelistv3&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~OPENSEARCH~Rate-1-17558183-blog-115046837.pc_relevant_multi_platform_whitelistv3&amp;utm_relevant_index=1">讲解博客</a></p>
<h3 id="指针常量和常量指针"><a href="#指针常量和常量指针" class="headerlink" title="指针常量和常量指针"></a>指针常量和常量指针</h3><p>指针<strong>常量</strong>int <em>const p 指针的值不能改变，即指向的地址无法改变，但可以修改该地址的值 常量<strong>指针</strong>const int </em>p | int const *p 指针的值可以改变，但指针指向的内容不可以改变，即指向常量的指针</p>
<h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><p>通过inline关键字修饰的函数就是内联函数，分为显式和隐式，<strong>类内定义的成员函数默认为内联函数</strong>，这被称为隐式内联，而在函数头前面加上inline就是显式。 调用函数时，操作系统需要执行转移指令，并把当前地址压栈，还需要把形参赋值给实参，这些操作虽然开销不大，但是若一个函数经常被调用，开销也需要考虑在内，内联函数可以在编译时将该函数的目标代码插入每个调用该函数的地方，和#include有些类似，不需要再执行转移指令了，减少了开销</p>
<h3 id="静态变量和全局变量的区别"><a href="#静态变量和全局变量的区别" class="headerlink" title="静态变量和全局变量的区别"></a>静态变量和全局变量的区别</h3><ol>
<li>单文件时+静态局部变量：在函数内定义静态变量，静态变量定义在全局区而非栈区，所以生命周期不同于局部变量，静态变量一直存在直到程序结束，而局部变量当程序执行过其作用域后，局部变量会被回收，生命也就结束了，静态变量相当于结合了局部变量和全局变量的特点，作用域等于局部变量，生命周期等于全局变量。 </li>
<li>单文件+静态全局变量：等价于全局变量。 </li>
<li>多文件+静态局部变量：静态局部变量和单文件没区别 </li>
<li>多文件+静态全局变量：此时静态全局变量作用域为此文件，不同于全局变量的作用域为所有文件。</li>
</ol>
<p><strong>总结：</strong> 全局变量、局部变量、全局静态变量、局部静态变量的区别。要从分配内存的位置和作用域入手来解释。</p>
<p>全局变量，分配的内存在静态存储区内存上面，其作用域是全局作用域，也就是整个程序的生命周期内都可以使用，同时，有些程序并不是由一个源文件构成的，可能有许多个源文件构成，全局变量只要在一个文件中定义，就可以在其他所有的文件中使用，当然，必须在其他文件使用extern关键字声明该变量。</p>
<p>局部变量，分配内存是分配在栈存储区上的，其作用域也只是在局部函数内，在定义该变量的函数内，只要出了该函数，该局部变量就不再起作用，该变量的生命周期也只是和该函数同在。</p>
<p>全局静态变量，分配的内存与全局变量一样，也是在静态存储内存上，其生命周期也是与整个程序同在的，从程序开始到结束一直起作用，但是与全局变量不同的是，全局静态变量作用域只在定义它的一个源文件内，其他源文件不能使用它。</p>
<p>局部静态变量，分配的内存也是在静态存储内存上的，其第一次初始化后就一直存在直到程序结束，该变量的特点是其作用域只在定义它的函数内可见，出了该函数就不可见了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//	static int a = 0; //同一作用域 不能重复定义</span></span><br><span class="line">	cout &lt;&lt; ++ a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">f2</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> a;</span><br><span class="line">	cout &lt;&lt; ++ a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">	f2();</span><br><span class="line">	f2();</span><br><span class="line">	f1();</span><br><span class="line">	f1();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">输出</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>不同作用域的变量是互不干扰的，即使是静态变量也是如此，上面代码f1和f2函数的a变量存储在不同内存，互不干扰，而且a有记忆（类似全局变量），在之前基础上自增</p>
<h3 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h3><p>extern放在变量或者函数之前，表示变量或者函数的定义在<strong>别的文件</strong>中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。 比如在a文件中有一个全局变量或者全局函数，在b文件中想要使用这个全局变量或者函数，就可以在前面加上extern关键字声明它。 一般应用于以下场景： a.h， a.cpp 在a.cpp中定义了全局变量，a.h中声明此变量，在前面加上extern，其他文件想使用此变量，就可以包含a.h</p>
<h3 id="delete"><a href="#delete" class="headerlink" title="= delete"></a>= delete</h3><p>防止函数被调用，例如需要禁止一个类调用拷贝函数或者赋值函数，可以</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MyClass is neither copyable nor movable.</span></span><br><span class="line">MyClass(const MyClass&amp;) = delete;</span><br><span class="line">MyClass&amp; operator=(const MyClass&amp;) = delete;</span><br></pre></td></tr></table></figure>
<p>更进一步来说，可能是为了： （1）防止隐式转换 （2）希望类不能被拷贝（之前的做法是把类的构造函数定义为private） 关于（1）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestClass</span></span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">    printf(<span class="string">&quot;data: %d\n&quot;</span>, data); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">    TestClass obj;</span><br><span class="line">    obj.func(<span class="number">100</span>);</span><br><span class="line">    obj.func(<span class="number">100.0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是因为隐式转换，把100.0转换为int类型的100导致的。如何防止：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestClass</span></span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">    printf(<span class="string">&quot;data: %d\n&quot;</span>, data); &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">func</span><span class="params">(<span class="type">double</span> data)</span>=delete;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">    TestClass obj;</span><br><span class="line">    obj.func(<span class="number">100</span>);</span><br><span class="line">    obj.func(<span class="number">100.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="左值（引用）和右值（引用）"><a href="#左值（引用）和右值（引用）" class="headerlink" title="左值（引用）和右值（引用）"></a>左值（引用）和右值（引用）</h3><p>左值指在内存中有实体，可以取地址的变量，而右值通常是一个式子，例如 a = b + c a是左值，b+c是右值 而左右值引用就是分别引用左值和右值 int &amp;d = a; int &amp;&amp;e = b + c;</p>
<h3 id="override"><a href="#override" class="headerlink" title="override"></a>override</h3><p>用来提醒编译器这是一个重写基类纯虚函数的函数，编译器会检查基类中是否存在相应的基函数，如果不存在就会报错。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">annimal</span> &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		virtual <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span> = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">dog</span>:<span class="keyword">public</span> annimal &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span> override;</span><br><span class="line"><span class="comment">//		void cry(int) override;	//报错，编译器检测到在基类不存在这种类型的函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> dog::cry() &#123;</span><br><span class="line">   </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;wangwang&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">	dog *d = <span class="keyword">new</span> <span class="title class_">dog</span>;</span><br><span class="line">	d-&gt;cry();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="为什么父类的析构函数需要写成虚函数"><a href="#为什么父类的析构函数需要写成虚函数" class="headerlink" title="为什么父类的析构函数需要写成虚函数"></a>为什么父类的析构函数需要写成虚函数</h3><p>C++的类中，构造函数用于初始化对象及相关操作，构造函数是不能声明为虚函数的，因为在执行构造函数前对象尚未完成创建，虚函数表指针还不存在。 析构函数则用于销毁对象完成时相应的资源释放工作，析构函数可以被声明为虚函数。在继承层次中，基类的析构函数一般建议声明为虚函数。 通过一个例子来说明下基类析构函数声明为虚函数的必要性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">base</span> &#123;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    base() &#123;</span><br><span class="line">   </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;base constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="type">int</span> *b = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    ~base() &#123;</span><br><span class="line">   </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;base destructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">        delete[] b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> *b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">derived</span> : <span class="keyword">public</span> base &#123;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    derived() &#123;</span><br><span class="line">   </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;derived constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="type">int</span> *d = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">8</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    ~derived() &#123;</span><br><span class="line">   </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;derived destructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">        delete[] d;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> *d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">    base *pBase = <span class="keyword">new</span> <span class="title class_">derived</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;---&quot;</span> &lt;&lt; endl;</span><br><span class="line">    delete pBase;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">base constructor</span><br><span class="line">derived constructor</span><br><span class="line">---</span><br><span class="line">base destructor</span><br></pre></td></tr></table></figure>
<p>上面定义了两个类：一个基类base，一个派生类derived。</p>
<p>基类和派生类都分别定义了各自的构造函数和析构函数。</p>
<p>基类和派生类中各有一个int型指针成员变量：</p>
<p>在基类的构造函数中，给指针变量b分配了5个int型空间；基类的析构函数用于将b所指的空间释放掉； 在派生类的构造函数中，指针成员变量d被分配了8个int型空间；派生类的析构函数是为了释放掉d指针所指向的存储空间。 在主函数中创建一个基类类型的指针pBase，指向一个派生类对象，之后释放掉pBase指针所指向的对象的存储空间。</p>
<p>观察程序的运行结果，说明：</p>
<p>首先，基类的构造函数被调用（base constructor）； 其次，派生类的构造函数也被调用（derived constructor）； 最后，基类的析构函数被调用（base destructor）。 但是却没有调用派生类的析构函数，这样会导致d指针所指向的整型存储空间不会被释放，从而造成内存泄漏。</p>
<p>为了解决这个问题，需要将基类的析构函数声明为虚函数。修改如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">virtual ~base() &#123;</span><br><span class="line">   </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;base destructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    delete[] b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">base constructor</span><br><span class="line">derived constructor</span><br><span class="line">---</span><br><span class="line">derived destructor</span><br><span class="line">base destructor</span><br></pre></td></tr></table></figure>
<p>将基类的析构函数声明为虚函数之后，派生类的析构函数也自动成为虚析构函数，在主函数中基类指针pBase指向的是派生类对象，当delete释放pBase指针所指向的存储空间时，</p>
<p>首先执行派生类的析构函数（derived destructor）； 然后执行基类的析构函数（base destructor）。 综上所述，将基类的析构函数设为虚函数，可以保证派生类被正确地释放。</p>
<h3 id="enum-class"><a href="#enum-class" class="headerlink" title="enum class"></a>enum class</h3><p> <a href="https://zhuanlan.zhihu.com/p/501309032">文章链接</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>01字典树</tag>
      </tags>
  </entry>
  <entry>
    <title>AC自动机</title>
    <url>/posts/5c28c80e.html</url>
    <content><![CDATA[<blockquote>
<p> AC自动机以trie为基础，结合了kmp的next数组思想而创造出来的一种数据结构，用来解决多模式串匹配问题</p>
</blockquote>
<h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p><a href="https://www.luogu.com.cn/problem/P3808">P3808 【模板】AC自动机（简单版）</a></p>
<p>给定n个模式串（$n&lt;=1e6$），一个主串s（$s&lt;=1e6$），问主串中包含多少个这些之中的模式串？</p>
<h2 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h2><p>传统做法，利用KMP，O(n)遍历每一个模式串，O(n)匹配是否包含此模式串，复杂度O(n2)</p>
<p>利用AC自动机，先把所有的模式串插入到trie中，接下来预处理一个fail数组，fail[i]表示i节点失配后该去找哪个节点（类似next数组），fail数组的真正含义是<code>当前正在匹配的模式串的后缀和其他所有模式串的前缀可以匹配最大长度的那个模式串</code>，有点绕。<img src="https://oi-wiki.org/string/images/ac-automaton1.png" style="zoom:67%;" /></p>
<p>这张图中的6号节点的fail指针指向7号节点，因为6号节点的后缀s和7号节点的前缀s相同，且匹配长度最大，所以fail[6]=7。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="type">void</span> <span class="title function_">build</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//这里把根节点的儿子节点入队，因为如果只把根节点入队的话会导致根节点失配指针指向自己，那么第一次bfs求儿子节点的fail指针时，儿子的fail也会指向自己</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tr[<span class="number">0</span>][i]) q.push(tr[<span class="number">0</span>][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//利用bfs进行构建</span></span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="type">int</span> u=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tr[u][i])&#123;</span><br><span class="line">                fail[tr[u][i]]=tr[fail[u]][i];</span><br><span class="line">                q.push(tr[u][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> tr[u][i]=tr[fail[u]][i];	<span class="comment">//压缩路径</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/08/20/Rbm5doiqH9hXZKz.png" alt="image-20210820104813489"></p>
<p>预处理出fail数组后即可进行主串匹配，需要注意的是每一个字符都要当作失配字符进行一次不断向fail数组跳跃的过程，过程中记录出现的模式串。</p>
<p>例如</p>
<p>t1: ash</p>
<p>t2: sh</p>
<p>S: ash</p>
<p>匹配时可以直接匹配到ash，但是sh是藏在ash中的，所以在匹配ash的过程中时刻需要看看有没有其他的模式串的前缀和当前字符串的后缀匹配成功的，sh的前缀就和ash的后缀匹配上了，然后发现这正是fail数组的意义，所以每次跳跃到fail[i]即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="built_in">string</span> s)</span>&#123;</span><br><span class="line">    <span class="type">int</span> len=s.size(),u=<span class="number">0</span>,ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        u=tr[u][s[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=u;j &amp;&amp; num[j]!=<span class="number">-1</span>;j=fail[j])&#123;	</span><br><span class="line">            <span class="comment">//每一个字符都当成失配字符算一遍匹配模式串数量</span></span><br><span class="line">            ret+=num[j];</span><br><span class="line">            num[j]=<span class="number">-1</span>;	<span class="comment">//一个模式串被计算过了就要标记一下</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#pragma G++ optimize(2)</span></span><br><span class="line"><span class="comment">//#pragma G++ optimize(3,&quot;Ofast&quot;,&quot;inline&quot;)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span><span class="number">-100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SUB=<span class="number">-0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-4</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> E=<span class="built_in">exp</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AC</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> tr[MAXN][<span class="number">27</span>],num[MAXN],fail[MAXN];	<span class="comment">//tr: 字典树数组、num:记录模式串数量、失配跳转指针</span></span><br><span class="line">	<span class="type">int</span> tot;	<span class="comment">//点编号</span></span><br><span class="line">	<span class="type">void</span> <span class="title function_">insert</span><span class="params">(<span class="built_in">string</span> s)</span>&#123;	<span class="comment">//插入模式串，构建字典树</span></span><br><span class="line">		<span class="type">int</span> p=<span class="number">0</span>,len=s.size();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(!tr[p][s[i]-<span class="string">&#x27;a&#x27;</span>]) tr[p][s[i]-<span class="string">&#x27;a&#x27;</span>]=++tot;</span><br><span class="line">			p=tr[p][s[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		num[p]++;	<span class="comment">//数量加一</span></span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	<span class="type">void</span> <span class="title function_">build</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(tr[<span class="number">0</span>][i]) q.push(tr[<span class="number">0</span>][i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">			<span class="type">int</span> u=q.front();</span><br><span class="line">			q.pop();</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(tr[u][i])&#123;</span><br><span class="line">					fail[tr[u][i]]=tr[fail[u]][i];</span><br><span class="line">					q.push(tr[u][i]);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> tr[u][i]=tr[fail[u]][i];	<span class="comment">//压缩路径</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="built_in">string</span> s)</span>&#123;</span><br><span class="line">		<span class="type">int</span> len=s.size(),u=<span class="number">0</span>,ret=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">			u=tr[u][s[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=u;j &amp;&amp; num[j]!=<span class="number">-1</span>;j=fail[j])&#123;	</span><br><span class="line">			<span class="comment">//每一个字符都当成失配字符算一遍匹配模式串数量</span></span><br><span class="line">				ret+=num[j];</span><br><span class="line">				num[j]=<span class="number">-1</span>;	<span class="comment">//一个模式串被计算过了就要标记一下</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">AC tree;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="comment">// debug;</span></span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">		tree.insert(s);</span><br><span class="line">	&#125;</span><br><span class="line">	tree.build();</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;tree.query(s)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>Shoka主题配置Algolia搜索</title>
    <url>/posts/6a52303e.html</url>
    <content><![CDATA[<blockquote>
<p>原来使用的Sakura主题已经没人维护了，写作时因为没有集成插件很多标签都没有，因此写出来的文章就比较丑，最重要的原因还是shoka这个主题太好看了，个人实在是喜欢(❤ ω ❤)，忍不住就咕哝了两天，在这里记录一下迁移过程遇到最棘手的问题Algolia的配置吧。</p>
</blockquote>
<p>:::success</p>
<p><code>主题优点</code></p>
<p>先给新主题shoka打个广告，继承了许多优秀插件，尤其是写作标签非常多，<a href="https://shoka.lostyu.me/computer-science/note/theme-shoka-doc/special/">写作标签介绍</a>，就光这一点就足够吸引我了，其次就是好看，贼好看，这个布局确实是让人看着赏心悦目，而且配置简单，因为很多东西都集成了，就方便了很多操作。</p>
<p>:::</p>
<p>回归主题，由于以前没用过algolia，导致我还得去网上查资料一点一点学，好在最后弄好了。</p>
<h2 id="Algolia配置"><a href="#Algolia配置" class="headerlink" title="Algolia配置"></a>Algolia配置</h2><ol>
<li><p>首先第一步就是安装hexo-algolia，右击博客根目录输入<code>npm i hexo-algolia</code></p>
</li>
<li><p>打开网页<a href="https://www.algolia.com/">algolia</a>，注册账户，新建一个Indice，名字随便起，然后根据提示完成后续工作，大致就是让你选择根据什么来搜索</p>
</li>
<li><p>之后在左侧导航栏中找到<code>Api Keys</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/Sucai/20201225213848.png" alt="" title="Algolia"></p>
</li>
<li><p>点击All API Keys，然后点击右上角New API Key，新建一个API Key，因为默认给的Only search权限不够只能搜索却不能通过这个API向服务器传输数据，indice选择刚才新建的那个</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/Sucai/20201225214129.png" alt="" title="API"></p>
</li>
<li><p>之后在博客根目录<code>config.yml</code>中，找到<code>algolia</code>的相关配置，然后添加<code>applicationID</code>属性，<code>appID</code>不要删(主题JS需要)，这两个虽然是一样的，但是因为hexo-algolia会自动去config.yml文件中寻找applicationID字眼而不是appID，因此不加上applicationID会报错，之后填上相应的值，这里注意<code>apiKey</code>可以填刚新添加的APIKEY，也可以填这里<code>Search-Only APIKEY</code>，刚才创建的用处不在这里</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/Sucai/20201225220935.png" alt="" title="algolia"></p>
</li>
<li><p>之后在博客根目录右击<code>git bash</code>，输入<code>export HEXO_ALGOLIA_INDEXING_KEY=&quot;你刚才新创建的APIKEY&quot;</code>，这里一定要是你新创建的不能是Search-Only APIKEY，否则权限不够无法上传索引，之后输入<code>hexo algolia</code>，即可成功上传，并在algolia后台中看到上传的索引</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/Sucai/20201225222422.png" alt="" title="algolia"><img src="https://cdn.jsdelivr.net/gh/uncleacc/Sucai/20201225224116.png" alt="" title="索引"></p>
</li>
<li><p>在搜索框中输入即可看到结果了</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/Sucai/20201225223941.png" alt="" title="algolia"></p>
</li>
</ol>
<p>[:heavy_check_mark:完美解决]{.label .success}</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>Algolia是一款很强大的搜索服务，打开<code>Indices</code>，点击<code>configuration</code>，找到<code>Searchable attributes</code>，在里面可以定制搜索凭借，例如你添加了<code>content</code>，之后输入的内容就会去和文章内容进行匹配之后出来结果，还是很强大的，不过如果你添加了content默认hexo-algolia插件是不上传文章内容的，也就是说你必须修改hexo-algolia插件Js内容来上传content，具体操作是打开目录:<code>shoka\node_modules\hexo-algolia\lib</code>，修改<code>command.js</code>，输入关键词var INDEXED_PROPERTIES = [查找，然后在[]中添加要上传的内容，不要删除里面的内容，因为可能会报错！</p>
<p>:::warning</p>
<p>[一定认真阅读主题官方文档！一定认真阅读主题官方文档！一定认真阅读主题官方文档！]{.rainbow}</p>
<p>:::</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>BFS模板题</title>
    <url>/posts/7247b6a5.html</url>
    <content><![CDATA[<p>上一篇文章讲了dfs的记忆化搜索，来看看上一道题 “仙岛求药” </p>
<h2 id="仙岛求药"><a href="#仙岛求药" class="headerlink" title="仙岛求药"></a>仙岛求药</h2><p>少年李逍遥的婶婶病了，王小虎介绍他去一趟仙灵岛，向仙女姐姐要仙丹救婶婶。叛逆但孝顺的李逍遥闯进了仙灵岛，克服了千险万难来到岛的中心，发现仙药摆在了迷阵的深处。迷阵由 M×NM \times NM×N 个方格组成，有的方格内有可以瞬秒李逍遥的怪物，而有的方格内则是安全。现在李逍遥想尽快找到仙药，显然他应避开有怪物的方格，并经过最少的方格，而且那里会有神秘人物等待着他。现在要求你来帮助他实现这个目标。</p>
<p>输入格式</p>
<p>第一行输入两个非零整数 MMM 和 NNN，两者均不大于 202020。MMM 表示迷阵行数, NNN 表示迷阵列数。</p>
<p>接下来有 MMM 行, 每行包含 NNN 个字符,不同字符分别代表不同含义:</p>
<p>1) ‘@’：少年李逍遥所在的位置；2) ‘.’：可以安全通行的方格；3) ‘#’：有怪物的方格；4) ‘*’：仙药所在位置。</p>
<p>输出格式</p>
<p>输出一行，该行包含李逍遥找到仙药需要穿过的最少的方格数目(计数包括初始位置的方块)。如果他不可能找到仙药, 则输出 −1-1−1。</p>
<p>输出时每行末尾的多余空格，不影响答案正确性</p>
<p>样例输入1</p>
<p>8 8<br>.@##…#</p>
<h1 id="…"><a href="#…" class="headerlink" title="….#."></a>….#.</h1><h1 id=""><a href="#" class="headerlink" title=".#.##.."></a>.#.##..</h1><p>..#.###.</p>
<h1 id="…-1"><a href="#…-1" class="headerlink" title=".#…#."></a>.#…#.</h1><p>..###.#.<br>…#.*..<br>.#…###</p>
<p>样例输出1</p>
<p>10</p>
<p>样例输入2</p>
<p>6 5</p>
<p>.*.#.</p>
<p>.#…</p>
<p>..##.</p>
<p>…..</p>
<p>.#…</p>
<p>….@</p>
<p>样例输出2</p>
<p>8</p>
<p>样例输入3</p>
<p>9 6</p>
<p>.#..#. </p>
<p>.#.*.# </p>
<p>.####. </p>
<p>..#… </p>
<p>..#… </p>
<p>..#… </p>
<p>..#… </p>
<h1 id="-1"><a href="#-1" class="headerlink" title=".@."></a>.@.</h1><p>.#..#.</p>
<p>样例输出3</p>
<p>-1</p>
<p>ok，如果直接用dfs做而不加任何优化会TLE，现在我们来用BFS做，BFS和DFS比较，它的优点就是时间快，但相应的空间上也耗损的更多，个人感觉如果仅仅是打ACM，这个特点比较好，毕竟大多数题还是卡时间而不是卡空间，来 see yi see BFS吧</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/20200416093927119.png" alt=""></p>
<p><img src="" alt="https://img-blog.csdnimg.cn/20200416093935363.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FHTklORw==,size_16,color_FFFFFF,t_70"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/20200416093942750.png" alt="https://img-blog.csdnimg.cn/20200416093942750.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FHTklORw==,size_16,color_FFFFFF,t_70"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/20200416093935363.png" alt="https://img-blog.csdnimg.cn/20200416093956703.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FHTklORw==,size_16,color_FFFFFF,t_70"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/20200416094004328.png" alt=""></p>
<p>还是比较容易理解的吧，毕竟只是一个模板没有加任何优化</p>
<p>现在回到上一道题，贴代码：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct node&#123;</span><br><span class="line">	int x,y;</span><br><span class="line">	int step;</span><br><span class="line">	int f;</span><br><span class="line">&#125;que[500];</span><br><span class="line">int vis[30][30];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int m,n,stx,sty,tgx,tgy,head=1,tail=1;  //定义了地图大小，起始坐标，目标坐标，队列的头和尾 </span><br><span class="line">	int Next[4][2]=&#123;&#123;1,0&#125;,&#123;0,1&#125;,&#123;-1,0&#125;,&#123;0,-1&#125;&#125;;//定义了下一步的操作 </span><br><span class="line">	char map[30][30];//定义了地图 </span><br><span class="line">	cin&gt;&gt;m&gt;&gt;n;//输入地图大小 </span><br><span class="line">	for(int i=0;i&lt;m;i++)&#123;</span><br><span class="line">		for(int j=0;j&lt;n;j++)&#123;</span><br><span class="line">			scanf(&quot; %c&quot;,&amp;map[i][j]);//输入地图 </span><br><span class="line">			if(map[i][j]==&#x27;@&#x27;)&#123;//找到起始位置 </span><br><span class="line">				stx=i; sty=j;</span><br><span class="line">			&#125;</span><br><span class="line">			if(map[i][j]==&#x27;*&#x27;)&#123;//找到目标位置 </span><br><span class="line">				tgx=i; tgy=j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	vis[stx][sty]=1;//标记起始位置 </span><br><span class="line">	que[tail].x=stx;//初始化队列 </span><br><span class="line">	que[tail].y=sty; </span><br><span class="line">	que[tail].step=0;//开始位置步数为零 </span><br><span class="line">	que[tail].f=0; </span><br><span class="line">	tail++;       //tail指向队列最后一个元素的下一个位置 </span><br><span class="line">	int tx,ty,flag=0; //定义一个临时坐标和flag判断是否到达目标位置 </span><br><span class="line">	while(head&lt;tail)&#123;</span><br><span class="line">		for(int i=0;i&lt;4;i++)&#123;  //移动坐标 </span><br><span class="line">			tx=que[head].x+Next[i][0];</span><br><span class="line">			ty=que[head].y+Next[i][1];</span><br><span class="line">			if(tx&lt;0||tx&gt;=m||ty&lt;0||ty&gt;=n) continue;//判断边界 </span><br><span class="line">			if(!vis[tx][ty]&amp;&amp;map[tx][ty]!=&#x27;#&#x27;)&#123; //判断当前位置是否走过，当前位置能不能走 </span><br><span class="line">				vis[tx][ty]=1;  //标记此位置已走过 				 </span><br><span class="line">				que[tail].x=tx;  //入队 </span><br><span class="line">				que[tail].y=ty;</span><br><span class="line">				que[tail].f=head;  //新入队的父亲节点是队列的头 </span><br><span class="line">				que[tail].step=que[que[tail].f].step+1; //当前步数等于父亲的步数加一 </span><br><span class="line">				tail++;  //tail后移 </span><br><span class="line">			&#125;</span><br><span class="line">			if(tx==tgx&amp;&amp;ty==tgy)&#123;  //判断是否到到达目标点 </span><br><span class="line">				flag=1;  //更新flag </span><br><span class="line">				break;   //到达目标break </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if(flag==1) break;  //到达目标break </span><br><span class="line">		head++;  //出队，让后面的点进行扩展 </span><br><span class="line">	&#125;</span><br><span class="line">	if(flag==1) cout&lt;&lt;que[tail-1].step&lt;&lt;endl;</span><br><span class="line">	else cout&lt;&lt;&quot;-1&quot;&lt;&lt;endl;	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果您精通STL的容器，可以直接使用STL自带的queue，这里只是模板，自己写一个队列并不难</p>
<blockquote>
<p>制作不易，可否赞助一下我这只小可怜两毛钱呢，小可怜已经连饭都吃不上了（owo）</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>BFS练习</title>
    <url>/posts/3522c2e0.html</url>
    <content><![CDATA[<h2 id="A-Red-and-Black"><a href="#A-Red-and-Black" class="headerlink" title="A - Red and Black"></a>A - Red and Black</h2><blockquote>
<p>There is a rectangular room, covered with square tiles. Each tile is colored either red or black. A man is standing on a black tile. From a tile, he can move to one of four adjacent tiles. But he can’t move on red tiles, he can move only on black tiles.</p>
<p>Write a program to count the number of black tiles which he can reach by repeating the moves described above.</p>
<p><strong>Input</strong></p>
<p>The input consists of multiple data sets. A data set starts with a line containing two positive integers W and H; W and H are the numbers of tiles in the x- and y- directions, respectively. W and H are not more than 20.</p>
<p>There are H more lines in the data set, each of which includes W characters. Each character represents the color of a tile as follows.</p>
<p>‘.’ - a black tile<br>‘#’ - a red tile<br>‘@’ - a man on a black tile(appears exactly once in a data set)</p>
<p>The input consists of multiple data sets. A data set starts with a line containing two positive integers W and H; W and H are the numbers of tiles in the x- and y- directions, respectively. W and H are not more than 20.</p>
<p>There are H more lines in the data set, each of which includes W characters. Each character represents the color of a tile as follows.</p>
<p>‘.’ - a black tile<br>‘#’ - a red tile<br>‘@’ - a man on a black tile(appears exactly once in a data set)</p>
<p><strong>Output</strong></p>
<p>For each data set, your program should output a line which contains the number of tiles he can reach from the initial tile (including itself).</p>
<p><strong>Sample Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;6 9</span><br><span class="line">&gt;....#.</span><br><span class="line">&gt;.....#</span><br><span class="line">&gt;......</span><br><span class="line">&gt;......</span><br><span class="line">&gt;......</span><br><span class="line">&gt;......</span><br><span class="line">&gt;......</span><br><span class="line">&gt;#@...#</span><br><span class="line">&gt;.#..#.</span><br><span class="line">&gt;11 9</span><br><span class="line">&gt;.#.........</span><br><span class="line">&gt;.#.#######.</span><br><span class="line">&gt;.#.#.....#.</span><br><span class="line">&gt;.#.#.###.#.</span><br><span class="line">&gt;.#.#..@#.#.</span><br><span class="line">&gt;.#.#####.#.</span><br><span class="line">&gt;.#.......#.</span><br><span class="line">&gt;.#########.</span><br><span class="line">&gt;...........</span><br><span class="line">&gt;11 6</span><br><span class="line">&gt;..#..#..#..</span><br><span class="line">&gt;..#..#..#..</span><br><span class="line">&gt;..#..#..###</span><br><span class="line">&gt;..#..#..#@.</span><br><span class="line">&gt;..#..#..#..</span><br><span class="line">&gt;..#..#..#..</span><br><span class="line">&gt;7 7</span><br><span class="line">&gt;..#.#..</span><br><span class="line">&gt;..#.#..</span><br><span class="line">&gt;###.###</span><br><span class="line">&gt;...@...</span><br><span class="line">&gt;###.###</span><br><span class="line">&gt;..#.#..</span><br><span class="line">&gt;..#.#..</span><br><span class="line">&gt;0 0</span><br></pre></td></tr></table></figure>
<p><strong>Sample Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;45</span><br><span class="line">&gt;59</span><br><span class="line">&gt;6</span><br><span class="line">&gt;13</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>模板题，没有任何需要注意的地方</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI acos(-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">210</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> x,y,step;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">char</span> Map[N][N];</span><br><span class="line"><span class="type">bool</span> vis[N][N];</span><br><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span> sx,<span class="type">int</span> sy)</span>&#123;</span><br><span class="line">	<span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">	node s=&#123;sx,sy,<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="built_in">queue</span>&lt;node&gt; q;</span><br><span class="line">	q.push(s);</span><br><span class="line">	vis[sx][sy]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		node fr=q.front();q.pop();</span><br><span class="line">		cnt++;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">			node next=&#123;fr.x+dir[i][<span class="number">0</span>],fr.y+dir[i][<span class="number">1</span>],fr.step+<span class="number">1</span>&#125;;</span><br><span class="line">			<span class="keyword">if</span>(next.x&lt;<span class="number">1</span>||next.x&gt;n||next.y&gt;m||next.y&lt;<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(vis[next.x][next.y]||Map[next.x][next.y]==<span class="string">&#x27;#&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">			vis[next.x][next.y]=<span class="number">1</span>;</span><br><span class="line">			q.push(next);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;m&gt;&gt;n)&#123;</span><br><span class="line">		<span class="keyword">if</span>(m==<span class="number">0</span>&amp;n==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">		<span class="type">int</span> sx,sy;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">				<span class="built_in">cin</span>&gt;&gt;Map[i][j];</span><br><span class="line">				<span class="keyword">if</span>(Map[i][j]==<span class="string">&#x27;@&#x27;</span>)&#123;</span><br><span class="line">					sx=i;</span><br><span class="line">					sy=j;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> ans=bfs(sx,sy);</span><br><span class="line">		<span class="keyword">if</span>(ans!=<span class="number">-1</span>) <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;oop!&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="B-Rescue"><a href="#B-Rescue" class="headerlink" title="B - Rescue"></a>B - Rescue</h2><blockquote>
<p>Angel was caught by the MOLIGPY! He was put in prison by Moligpy. The prison is described as a N * M (N, M &lt;= 200) matrix. There are WALLs, ROADs, and GUARDs in the prison.</p>
<p>Angel’s friends want to save Angel. Their task is: approach Angel. We assume that “approach Angel” is to get to the position where Angel stays. When there’s a guard in the grid, we must kill him (or her?) to move into the grid. We assume that we moving up, down, right, left takes us 1 unit time, and killing a guard takes 1 unit time, too. And we are strong enough to kill all the guards.</p>
<p>You have to calculate the minimal time to approach Angel. (We can move only UP, DOWN, LEFT and RIGHT, to the neighbor grid within bound, of course.)</p>
<p><strong>Input</strong></p>
<p>First line contains two integers stand for N and M.</p>
<p>Then N lines follows, every line has M characters. “.” stands for road, “a” stands for Angel, and “r” stands for each of Angel’s friend.</p>
<p>Process to the end of the file.</p>
<p><strong>Output</strong></p>
<p>For each test case, your program should output a single integer, standing for the minimal time needed. If such a number does no exist, you should output a line containing “Poor ANGEL has to stay in the prison all his life.”</p>
<p><strong>Sample Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;7 8</span><br><span class="line">&gt;#.#####.</span><br><span class="line">&gt;#.a#..r.</span><br><span class="line">&gt;#..#x...</span><br><span class="line">&gt;..#..#.#</span><br><span class="line">&gt;#...##..</span><br><span class="line">&gt;.#......</span><br><span class="line">&gt;........</span><br></pre></td></tr></table></figure>
<p><strong>Sample Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;13</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>小小的升级，在x处步数加一，问到a处最少步数，用优先队列就行了，把步数靠前的放前面</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI acos(-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">210</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> x,y,time;</span><br><span class="line">	<span class="type">bool</span> operator &lt; (<span class="type">const</span> node &amp;o) <span class="type">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> o.time&lt;time;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">char</span> Map[N][N];</span><br><span class="line"><span class="type">bool</span> vis[N][N];</span><br><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span> sx,<span class="type">int</span> sy)</span>&#123;</span><br><span class="line">	node s=&#123;sx,sy,<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="built_in">priority_queue</span>&lt;node&gt; q;</span><br><span class="line">	q.push(s);</span><br><span class="line">	vis[sx][sy]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		node fr=q.top();q.pop();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">			node next=&#123;fr.x+dir[i][<span class="number">0</span>],fr.y+dir[i][<span class="number">1</span>],fr.time+<span class="number">1</span>&#125;;</span><br><span class="line">			<span class="keyword">if</span>(next.x&lt;<span class="number">1</span>||next.x&gt;n||next.y&gt;m||next.y&lt;<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(vis[next.x][next.y]||Map[next.x][next.y]==<span class="string">&#x27;#&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(Map[next.x][next.y]==<span class="string">&#x27;x&#x27;</span>) next.time++;</span><br><span class="line">			<span class="keyword">if</span>(Map[next.x][next.y]==<span class="string">&#x27;a&#x27;</span>)&#123;</span><br><span class="line">				<span class="keyword">return</span> next.time;</span><br><span class="line">			&#125;</span><br><span class="line">			vis[next.x][next.y]=<span class="number">1</span>;</span><br><span class="line">			q.push(next);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> INF;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">		<span class="type">int</span> sx,sy;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">				<span class="built_in">cin</span>&gt;&gt;Map[i][j];</span><br><span class="line">				<span class="keyword">if</span>(Map[i][j]==<span class="string">&#x27;r&#x27;</span>)&#123;</span><br><span class="line">					sx=i;</span><br><span class="line">					sy=j;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> ans=bfs(sx,sy);</span><br><span class="line">		<span class="keyword">if</span>(ans!=INF) <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Poor ANGEL has to stay in the prison all his life.&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="C-Battle-City"><a href="#C-Battle-City" class="headerlink" title="C - Battle City"></a>C - Battle City</h2><blockquote>
<p>Many of us had played the game “Battle city” in our childhood, and some people (like me) even often play it on computer now.</p>
<p>What we are discussing is a simple edition of this game. Given a map that consists of empty spaces, rivers, steel walls and brick walls only. Your task is to get a bonus as soon as possible suppose that no enemies will disturb you (See the following picture).</p>
<p>Your tank can’t move through rivers or walls, but it can destroy brick walls by shooting. A brick wall will be turned into empty spaces when you hit it, however, if your shot hit a steel wall, there will be no damage to the wall. In each of your turns, you can choose to move to a neighboring (4 directions, not 8) empty space, or shoot in one of the four directions without a move. The shot will go ahead in that direction, until it go out of the map or hit a wall. If the shot hits a brick wall, the wall will disappear (i.e., in this turn). Well, given the description of a map, the positions of your tank and the target, how many turns will you take at least to arrive there?</p>
<p><strong>Input</strong></p>
<p>The input consists of several test cases. The first line of each test case contains two integers M and N (2 &lt;= M, N &lt;= 300). Each of the following M lines contains N uppercase letters, each of which is one of ‘Y’ (you), ‘T’ (target), ‘S’ (steel wall), ‘B’ (brick wall), ‘R’ (river) and ‘E’ (empty space). Both ‘Y’ and ‘T’ appear only once. A test case of M = N = 0 indicates the end of input, and should not be processed.</p>
<p><strong>Output</strong></p>
<p>For each test case, please output the turns you take at least in a separate line. If you can’t arrive at the target, output “-1” instead.</p>
<p><strong>Sample Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 4</span><br><span class="line">YBEB</span><br><span class="line">EERE</span><br><span class="line">SSTE</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure>
<p><strong>Sample Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>经典坦克大战，R(河流)S(钢铁)过不去，B(砖块)可以过去但是需要多花一秒，于是这个和上一道就是一道题了，只不过多了一条河不能过而已</p>
<h3 id="CODE-1"><a href="#CODE-1" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI acos(-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">410</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> x,y,time;</span><br><span class="line">	<span class="type">bool</span> operator &lt; (<span class="type">const</span> node &amp;o) <span class="type">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> o.time&lt;time;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">char</span> Map[N][N];</span><br><span class="line"><span class="type">bool</span> vis[N][N];</span><br><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span> sx,<span class="type">int</span> sy)</span>&#123;</span><br><span class="line">	node s=&#123;sx,sy,<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="built_in">priority_queue</span>&lt;node&gt; q;</span><br><span class="line">	q.push(s);</span><br><span class="line">	vis[sx][sy]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		node fr=q.top();q.pop();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">			node next=&#123;fr.x+dir[i][<span class="number">0</span>],fr.y+dir[i][<span class="number">1</span>],fr.time+<span class="number">1</span>&#125;;</span><br><span class="line">			<span class="keyword">if</span>(next.x&lt;<span class="number">1</span>||next.x&gt;n||next.y&gt;m||next.y&lt;<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(vis[next.x][next.y]||Map[next.x][next.y]==<span class="string">&#x27;S&#x27;</span>||Map[next.x][next.y]==<span class="string">&#x27;R&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(Map[next.x][next.y]==<span class="string">&#x27;B&#x27;</span>) next.time++;</span><br><span class="line">			<span class="keyword">if</span>(Map[next.x][next.y]==<span class="string">&#x27;T&#x27;</span>)&#123;</span><br><span class="line">				<span class="keyword">return</span> next.time;</span><br><span class="line">			&#125;</span><br><span class="line">			vis[next.x][next.y]=<span class="number">1</span>;</span><br><span class="line">			q.push(next);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m)&#123;</span><br><span class="line">		<span class="keyword">if</span>(n==<span class="number">0</span>&amp;&amp;m==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">		<span class="type">int</span> sx,sy;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">				<span class="built_in">cin</span>&gt;&gt;Map[i][j];</span><br><span class="line">				<span class="keyword">if</span>(Map[i][j]==<span class="string">&#x27;Y&#x27;</span>)&#123;</span><br><span class="line">					sx=i;</span><br><span class="line">					sy=j;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> ans=bfs(sx,sy);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Dungeon-Master"><a href="#Dungeon-Master" class="headerlink" title="Dungeon Master"></a>Dungeon Master</h2><blockquote>
<p>You are trapped in a 3D dungeon and need to find the quickest way out! The dungeon is composed of unit cubes which may or may not be filled with rock. It takes one minute to move one unit north, south, east, west, up or down. You cannot move diagonally and the maze is surrounded by solid rock on all sides.</p>
<p>Is an escape possible? If yes, how long will it take?</p>
<p><strong>Input</strong></p>
<p>The input consists of a number of dungeons. Each dungeon description starts with a line containing three integers L, R and C (all limited to 30 in size).<br>L is the number of levels making up the dungeon.<br>R and C are the number of rows and columns making up the plan of each level.<br>Then there will follow L blocks of R lines each containing C characters. Each character describes one cell of the dungeon. A cell full of rock is indicated by a ‘#’ and empty cells are represented by a ‘.’. Your starting position is indicated by ‘S’ and the exit by the letter ‘E’. There’s a single blank line after each level. Input is terminated by three zeroes for L, R and C.</p>
<p><strong>Output</strong></p>
<p>Each maze generates one line of output. If it is possible to reach the exit, print a line of the form</p>
<p>​    Escaped in x minute(s).</p>
<p>where x is replaced by the shortest time it takes to escape.<br>If it is not possible to escape, print the line</p>
<p>​    Trapped!</p>
<p><strong>Sample Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;3 4 5</span><br><span class="line">&gt;S....</span><br><span class="line">&gt;.###.</span><br><span class="line">&gt;.##..</span><br><span class="line">&gt;###.#</span><br><span class="line"></span><br><span class="line">&gt;#####</span><br><span class="line">&gt;#####</span><br><span class="line">&gt;##.##</span><br><span class="line">&gt;##...</span><br><span class="line"></span><br><span class="line">&gt;#####</span><br><span class="line">&gt;#####</span><br><span class="line">&gt;#.###</span><br><span class="line">&gt;####E</span><br><span class="line"></span><br><span class="line">&gt;1 3 3</span><br><span class="line">&gt;S##</span><br><span class="line">&gt;#E#</span><br><span class="line">&gt;###</span><br><span class="line"></span><br><span class="line">&gt;0 0 0</span><br></pre></td></tr></table></figure>
<p><strong>Sample Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;Escaped in 11 minute(s).</span><br><span class="line">&gt;Trapped!</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>这个题有点意思，是一个三维空间的BFS，一维二维都会了，三维自然是手到擒来了，按着模板写，添加一维就行了</p>
<h3 id="CODE-2"><a href="#CODE-2" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI acos(-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">40</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> x,y,z,time;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> l,n,m;</span><br><span class="line"><span class="type">char</span> Map[N][N][N];</span><br><span class="line"><span class="type">bool</span> vis[N][N][N];</span><br><span class="line"><span class="type">int</span> dir[<span class="number">6</span>][<span class="number">3</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">check</span><span class="params">(node next)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(next.x&lt;<span class="number">1</span>||next.x&gt;n||next.y&gt;m||next.y&lt;<span class="number">1</span>||next.z&lt;<span class="number">1</span>||next.z&gt;l) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span> sx,<span class="type">int</span> sy,<span class="type">int</span> sz)</span>&#123;</span><br><span class="line">	node s=&#123;sx,sy,sz,<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="built_in">queue</span>&lt;node&gt; q;</span><br><span class="line">	q.push(s);</span><br><span class="line">	vis[sz][sx][sy]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		node fr=q.front();q.pop();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">			node next=&#123;fr.x+dir[i][<span class="number">0</span>],fr.y+dir[i][<span class="number">1</span>],fr.z+dir[i][<span class="number">2</span>],fr.time+<span class="number">1</span>&#125;;</span><br><span class="line">			<span class="keyword">if</span>(!check(next)) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(vis[next.z][next.x][next.y]||Map[next.z][next.x][next.y]==<span class="string">&#x27;#&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(Map[next.z][next.x][next.y]==<span class="string">&#x27;E&#x27;</span>)&#123;</span><br><span class="line">				<span class="keyword">return</span> next.time;</span><br><span class="line">			&#125;</span><br><span class="line">			vis[next.z][next.x][next.y]=<span class="number">1</span>;</span><br><span class="line">			q.push(next);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//	ios;</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;l&gt;&gt;n&gt;&gt;m)&#123;</span><br><span class="line">		<span class="keyword">if</span>(l==<span class="number">0</span>&amp;&amp;n==<span class="number">0</span>&amp;&amp;m==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">		<span class="type">int</span> sx,sy,sz;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=l;k++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">					<span class="built_in">cin</span>&gt;&gt;Map[k][i][j];</span><br><span class="line">					<span class="keyword">if</span>(Map[k][i][j]==<span class="string">&#x27;S&#x27;</span>)&#123;</span><br><span class="line">						sx=i;</span><br><span class="line">						sy=j;</span><br><span class="line">						sz=k;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> ans=bfs(sx,sy,sz);</span><br><span class="line">		<span class="keyword">if</span>(ans!=<span class="number">-1</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Escaped in &quot;</span>&lt;&lt;ans&lt;&lt;<span class="string">&quot; minute(s).&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Trapped!&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Catch-That-Cow"><a href="#Catch-That-Cow" class="headerlink" title="Catch That Cow"></a>Catch That Cow</h2><blockquote>
<p>Farmer John has been informed of the location of a fugitive cow and wants to catch her immediately. He starts at a point <em>N</em> (0 ≤ <em>N</em> ≤ 100,000) on a number line and the cow is at a point <em>K</em> (0 ≤ <em>K</em> ≤ 100,000) on the same number line. Farmer John has two modes of transportation: walking and teleporting.</p>
<p>* Walking: FJ can move from any point <em>X</em> to the points <em>X</em> - 1 or <em>X</em> + 1 in a single minute<br>* Teleporting: FJ can move from any point <em>X</em> to the point 2 × <em>X</em> in a single minute.</p>
<p>If the cow, unaware of its pursuit, does not move at all, how long does it take for Farmer John to retrieve it?</p>
<p><strong>Input</strong></p>
<p>Line 1: Two space-separated integers: <em>N</em> and <em>K</em></p>
<p><strong>Output</strong></p>
<p>Line 1: The least amount of time, in minutes, it takes for Farmer John to catch the fugitive cow.</p>
<p><strong>Sample Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;5 17</span><br></pre></td></tr></table></figure>
<p><strong>Sample Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;4</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>毒瘤的一道题目，没什么难度，就是感觉评测机器有问题，同样两段代码，放到函数和写在main函数里面不一样的结果。。。不信你可以试试</p>
<h3 id="CODE-3"><a href="#CODE-3" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> vis[<span class="number">1000001</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> wei;</span><br><span class="line">	<span class="type">int</span> time;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n,k;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">	node start=&#123;n,<span class="number">0</span>&#125;;</span><br><span class="line">	vis[n]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">queue</span>&lt;node&gt;q;</span><br><span class="line">	q.push(start);</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		node tmp=q.front(); q.pop(); </span><br><span class="line">		<span class="keyword">if</span>(tmp.wei==k)&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;tmp.time&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">			node nx;</span><br><span class="line">			<span class="keyword">if</span>(i==<span class="number">0</span>) nx=&#123;tmp.wei+<span class="number">1</span>,tmp.time+<span class="number">1</span>&#125;;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">1</span>) nx=&#123;tmp.wei<span class="number">-1</span>,tmp.time+<span class="number">1</span>&#125;;</span><br><span class="line">			<span class="keyword">else</span> nx=&#123;tmp.wei*<span class="number">2</span>,tmp.time+<span class="number">1</span>&#125;;</span><br><span class="line">			<span class="keyword">if</span>(nx.wei&lt;<span class="number">0</span>||nx.wei&gt;<span class="number">100000</span>||vis[nx.wei]) <span class="keyword">continue</span>;</span><br><span class="line">			vis[nx.wei]=<span class="number">1</span>;</span><br><span class="line">			q.push(nx);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Number-Transformation"><a href="#Number-Transformation" class="headerlink" title="Number Transformation"></a>Number Transformation</h2><blockquote>
<p>In this problem, you are given an integer number <strong>s</strong>. You can transform any integer number <strong>A</strong> to another integer number <strong>B</strong> by adding <strong>x</strong> to <strong>A</strong>. This <strong>x</strong> is an integer number which is a prime factor of <strong>A</strong> (please note that 1 and <strong>A</strong> are not being considered as a factor of <strong>A</strong>). Now, your task is to find the minimum number of transformations required to transform <strong>s</strong> to another integer number <strong>t</strong>.</p>
<p><strong>Input</strong></p>
<p>Input starts with an integer <strong>T (**</strong>≤ 500)**, denoting the number of test cases.</p>
<p>Each case contains two integers: <strong>s (1 ≤ s ≤ 100)</strong> and <strong>t (1 ≤ t ≤ 1000)</strong>.</p>
<p><strong>Output</strong></p>
<p>For each case, print the case number and the minimum number of transformations needed. If it’s impossible, then print <strong>-1</strong>.</p>
<p><strong>Sample Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line"></span><br><span class="line">6 12</span><br><span class="line"></span><br><span class="line">6 13</span><br></pre></td></tr></table></figure>
<p><strong>Sample Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Case 1: 2</span><br><span class="line"></span><br><span class="line">Case 2: -1</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><p>有意思的一道题目，给你两个数a和b，让你不断通过加a的质因子直到和b相等，有意思在哪里？这个质因子不是不变的，当a改变后，a的质因子也会发生改变，所以有两种做法，一个是每次增加都进行一次质因子分解，这也是很快的，根本不会超时，1000以内的任何一个数的质因子数量都是不超过10个的，第二种是开一个二维数组，打一个表，因为这里的b是小于1000的，我们可以开这么大的数组，存储某一个数的质因子，这里用了第二种做法，其实题目也不难，就是题目难以理解</p>
<h3 id="CODE-4"><a href="#CODE-4" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> T,t,s;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX=<span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> vis[MAX];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; vt[MAX];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> x,step;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">2</span>||n==<span class="number">3</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">1</span>||n%<span class="number">6</span>!=<span class="number">1</span>&amp;&amp;n%<span class="number">6</span>!=<span class="number">5</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">5</span>;i*i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(n%i==<span class="number">0</span>||n%(i+<span class="number">2</span>)==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">prime</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;MAX;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;i;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(i%j==<span class="number">0</span>&amp;&amp;check(j)) vt[i].push_back(j);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">bfs</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="built_in">queue</span>&lt;node&gt; q;</span><br><span class="line">	vis[s]=<span class="number">1</span>;</span><br><span class="line">	node start;</span><br><span class="line">	start.x=s; start.step=<span class="number">0</span>;</span><br><span class="line">	q.push(start);</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		node tmp=q.front(); q.pop();</span><br><span class="line">		<span class="keyword">if</span>(tmp.x==t) <span class="keyword">return</span> tmp.step;</span><br><span class="line">		<span class="type">int</span> len=vt[tmp.x].size();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">			node nx;</span><br><span class="line">			nx.x=tmp.x+vt[tmp.x][i];</span><br><span class="line">			nx.step=tmp.step+<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(nx.x&gt;t||vis[nx.x]) <span class="keyword">continue</span>;</span><br><span class="line">			vis[nx.x]=<span class="number">1</span>;</span><br><span class="line">			q.push(nx);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	prime();</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line">	<span class="type">int</span> kase=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(T--)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;s,&amp;t);</span><br><span class="line">		<span class="type">int</span> ans=INF;</span><br><span class="line">		ans=bfs();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Case %d: %d\n&quot;</span>,++kase,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="G-Knight-Moves"><a href="#G-Knight-Moves" class="headerlink" title="G - Knight Moves"></a>G - Knight Moves</h2><blockquote>
<p>A friend of you is doing research on the Traveling Knight Problem (TKP) where you are to find the shortest closed tour of knight moves that visits each square of a given set of n squares on a chessboard exactly once. He thinks that the most difficult part of the problem is determining the smallest number of knight moves between two given squares and that, once you have accomplished this, finding the tour would be easy.<br>Of course you know that it is vice versa. So you offer him to write a program that solves the “difficult” part.</p>
<p>Your job is to write a program that takes two squares a and b as input and then determines the number of knight moves on a shortest route from a to b.</p>
<p><strong>Input</strong></p>
<p>The input file will contain one or more test cases. Each test case consists of one line containing two squares separated by one space. A square is a string consisting of a letter (a-h) representing the column and a digit (1-8) representing the row on the chessboard.</p>
<p><strong>Output</strong></p>
<p>For each test case, print one line saying “To get from xx to yy takes n knight moves.”.</p>
<p><strong>Sample Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;e2 e4</span><br><span class="line">&gt;a1 b2</span><br><span class="line">&gt;b2 c3</span><br><span class="line">&gt;a1 h8</span><br><span class="line">&gt;a1 h7</span><br><span class="line">&gt;h8 a1</span><br><span class="line">&gt;b1 c3</span><br><span class="line">&gt;f6 f6</span><br></pre></td></tr></table></figure>
<p><strong>Sample Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;To get from e2 to e4 takes 2 knight moves.</span><br><span class="line">&gt;To get from a1 to b2 takes 4 knight moves.</span><br><span class="line">&gt;To get from b2 to c3 takes 2 knight moves.</span><br><span class="line">&gt;To get from a1 to h8 takes 6 knight moves.</span><br><span class="line">&gt;To get from a1 to h7 takes 5 knight moves.</span><br><span class="line">&gt;To get from h8 to a1 takes 6 knight moves.</span><br><span class="line">&gt;To get from b1 to c3 takes 1 knight moves.</span><br><span class="line">&gt;To get from f6 to f6 takes 0 knight moves.</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h3><p>只是把上下左右换成了马的走法而已</p>
<h3 id="CODE-5"><a href="#CODE-5" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">char</span> ch1[<span class="number">3</span>],ch2[<span class="number">3</span>];</span><br><span class="line"><span class="type">int</span> vis[<span class="number">9</span>][<span class="number">9</span>],ans;</span><br><span class="line"><span class="type">int</span> dir[<span class="number">8</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">2</span>,<span class="number">1</span>&#125;,&#123;<span class="number">-2</span>,<span class="number">1</span>&#125;,&#123;<span class="number">2</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-2</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">1</span>,<span class="number">-2</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">-2</span>&#125;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> row,col,step;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">bfs</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;node&gt; q;</span><br><span class="line">    node s;</span><br><span class="line">    s.row=ch1[<span class="number">1</span>]-<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    s.col=ch1[<span class="number">0</span>]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    s.step=<span class="number">0</span>;</span><br><span class="line">    vis[s.row][s.col]=<span class="number">1</span>;</span><br><span class="line">    q.push(s);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        node tmp=q.front(); q.pop();</span><br><span class="line">        <span class="keyword">if</span>(tmp.row==(ch2[<span class="number">1</span>]-<span class="string">&#x27;1&#x27;</span>)&amp;&amp;tmp.col==(ch2[<span class="number">0</span>]-<span class="string">&#x27;a&#x27;</span>))&#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp.step&lt;ans) ans=tmp.step;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">           	node nx;</span><br><span class="line">    		nx.row=tmp.row+dir[i][<span class="number">0</span>];</span><br><span class="line">    		nx.col=tmp.col+dir[i][<span class="number">1</span>];</span><br><span class="line">        	<span class="keyword">if</span>(!vis[nx.row][nx.col]&amp;&amp;nx.row&gt;=<span class="number">0</span>&amp;&amp;nx.row&lt;<span class="number">8</span>&amp;&amp;nx.col&gt;=<span class="number">0</span>&amp;&amp;nx.col&lt;<span class="number">8</span>)&#123;</span><br><span class="line">	            vis[nx.row][nx.col]=<span class="number">1</span>;</span><br><span class="line">	            nx.step=tmp.step+<span class="number">1</span>;</span><br><span class="line">	            q.push(nx);</span><br><span class="line">        	&#125;  </span><br><span class="line">       	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;ch1&gt;&gt;ch2)&#123;</span><br><span class="line">        ans=<span class="number">1e9</span>;</span><br><span class="line">	    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">	    bfs();</span><br><span class="line">	    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;To get from &quot;</span>&lt;&lt;ch1&lt;&lt;<span class="string">&quot; to &quot;</span>&lt;&lt;ch2&lt;&lt;<span class="string">&quot; takes &quot;</span>&lt;&lt;ans&lt;&lt;<span class="string">&quot; knight moves.&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="噩梦"><a href="#噩梦" class="headerlink" title="噩梦"></a>噩梦</h2><p><a href="https://www.acwing.com/problem/content/description/179/">题目链接</a></p>
<blockquote>
<p>给定一张N*M的地图，地图中有1个男孩，1个女孩和2个鬼。</p>
<p>字符“.”表示道路，字符“X”表示墙，字符“M”表示男孩的位置，字符“G”表示女孩的位置，字符“Z”表示鬼的位置。</p>
<p>男孩每秒可以移动3个单位距离，女孩每秒可以移动1个单位距离，男孩和女孩只能朝上下左右四个方向移动。</p>
<p>每个鬼占据的区域每秒可以向四周扩张2个单位距离，并且无视墙的阻挡，也就是在第k秒后所有与鬼的曼哈顿距离不超过2k的位置都会被鬼占领。</p>
<p><strong>注意：</strong> 每一秒鬼会先扩展，扩展完毕后男孩和女孩才可以移动。</p>
<p>求在不进入鬼的占领区的前提下，男孩和女孩能否会合，若能会合，求出最短会合时间。</p>
<h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数T，表示共有T组测试用例。</p>
<p>每组测试用例第一行包含两个整数N和M，表示地图的尺寸。</p>
<p>接下来N行每行M个字符，用来描绘整张地图的状况。（注意：地图中一定有且仅有1个男孩，1个女孩和2个鬼）</p>
<h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>每个测试用例输出一个整数S，表示最短会合时间。</p>
<p>如果无法会合则输出-1。</p>
<p>每个结果占一行。</p>
<h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1&lt;n,m&lt;8001&lt;n,m&lt;800</p>
<h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;3</span><br><span class="line">&gt;5 6</span><br><span class="line">&gt;XXXXXX</span><br><span class="line">&gt;XZ..ZX</span><br><span class="line">&gt;XXXXXX</span><br><span class="line">&gt;M.G...</span><br><span class="line">&gt;......</span><br><span class="line">&gt;5 6</span><br><span class="line">&gt;XXXXXX</span><br><span class="line">&gt;XZZ..X</span><br><span class="line">&gt;XXXXXX</span><br><span class="line">&gt;M.....</span><br><span class="line">&gt;..G...</span><br><span class="line">&gt;10 10</span><br><span class="line">&gt;..........</span><br><span class="line">&gt;..X.......</span><br><span class="line">&gt;..M.X...X.</span><br><span class="line">&gt;X.........</span><br><span class="line">&gt;.X..X.X.X.</span><br><span class="line">&gt;.........X</span><br><span class="line">&gt;..XX....X.</span><br><span class="line">&gt;X....G...X</span><br><span class="line">&gt;...ZX.X...</span><br><span class="line">&gt;...Z..X..X</span><br></pre></td></tr></table></figure>
<h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;1</span><br><span class="line">&gt;1</span><br><span class="line">&gt;-1</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h3><p>双向BFS，男孩和女孩轮流BFS，直到两者轨迹有交叉</p>
<h3 id="CODE-6"><a href="#CODE-6" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">810</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">pii boy,girl,ghost[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> vis[N][N],dx[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;,dy[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"><span class="type">bool</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">1</span>||x&gt;n||y&lt;<span class="number">1</span>||y&gt;m||g[x][y]==<span class="string">&#x27;X&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;   </span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(x-ghost[i].first)+<span class="built_in">abs</span>(y-ghost[i].second)&lt;=<span class="number">2</span>*k) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">bfs</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;pii&gt; qb,qg;</span><br><span class="line">    qb.push(boy); qg.push(girl);</span><br><span class="line">    <span class="type">int</span> step=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!qb.empty()||!qg.empty())&#123;</span><br><span class="line">    	step++;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">3</span>;k++)&#123;</span><br><span class="line">    		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>,len=qb.size();j&lt;len;j++)&#123;</span><br><span class="line">    			<span class="type">int</span> x=qb.front().first;</span><br><span class="line">    			<span class="type">int</span> y=qb.front().second;</span><br><span class="line">    			qb.pop();</span><br><span class="line">    			<span class="keyword">if</span>(!check(x,y,step)) <span class="keyword">continue</span>;</span><br><span class="line">    			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">    				<span class="type">int</span> nx=x+dx[i];</span><br><span class="line">    				<span class="type">int</span> ny=y+dy[i];</span><br><span class="line">    				<span class="keyword">if</span>(!check(nx,ny,step)) <span class="keyword">continue</span>;</span><br><span class="line">					<span class="keyword">if</span>(vis[nx][ny]==<span class="number">2</span>) <span class="keyword">return</span> step;</span><br><span class="line">    				<span class="keyword">if</span>(!vis[nx][ny])&#123;</span><br><span class="line">    					vis[nx][ny]=<span class="number">1</span>;</span><br><span class="line">    					qb.push(&#123;nx,ny&#125;);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">1</span>;k++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>,len=qg.size();j&lt;len;j++)&#123;</span><br><span class="line">				<span class="type">int</span> x=qg.front().first;</span><br><span class="line">				<span class="type">int</span> y=qg.front().second;</span><br><span class="line">				qg.pop();</span><br><span class="line">				<span class="keyword">if</span>(!check(x,y,step)) <span class="keyword">continue</span>;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">					<span class="type">int</span> nx=x+dx[i];</span><br><span class="line">					<span class="type">int</span> ny=y+dy[i];</span><br><span class="line">					<span class="keyword">if</span>(!check(nx,ny,step)) <span class="keyword">continue</span>;</span><br><span class="line">					<span class="keyword">if</span>(vis[nx][ny]==<span class="number">1</span>) <span class="keyword">return</span> step;</span><br><span class="line">					<span class="keyword">if</span>(!vis[nx][ny])&#123;</span><br><span class="line">						vis[nx][ny]=<span class="number">2</span>;</span><br><span class="line">						qg.push(&#123;nx,ny&#125;);</span><br><span class="line">					&#125;</span><br><span class="line">					</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">		<span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">				<span class="built_in">cin</span>&gt;&gt;g[i][j];</span><br><span class="line">				<span class="keyword">if</span>(g[i][j]==<span class="string">&#x27;M&#x27;</span>) boy=&#123;i,j&#125;;</span><br><span class="line">				<span class="keyword">if</span>(g[i][j]==<span class="string">&#x27;G&#x27;</span>) girl=&#123;i,j&#125;;</span><br><span class="line">				<span class="keyword">if</span>(g[i][j]==<span class="string">&#x27;Z&#x27;</span>) ghost[cnt++]=&#123;i,j&#125;;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;bfs()&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>win10美化</title>
    <url>/posts/6c8ada9b.html</url>
    <content><![CDATA[<blockquote>
<p>你是否还在为这丑陋的window10界面而叹气(<del>win10界面其实还可以</del>)，你是否还在为怎么美化界面而烦恼？不用叹气，不用烦恼！这篇博客可以解决你的问题</p>
</blockquote>
<p>众所周知，一个简单漂亮的界面对人的心情也是有很大影响的，假如一个人不整理文件，桌面上乱七八糟，什么都往桌面上放，那迟早是受不了的，将来一定有一天你都不想开电脑</p>
<p>先来放一张美化过后的图片吧</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/Sucai/20201210215744.png" alt=""></p>
<p>效果还不错吧</p>
<p>强烈推荐 <a href="https://zhutix.com/">致美化</a>（里面什么都有）</p>
<h2 id="Mydock"><a href="#Mydock" class="headerlink" title="Mydock"></a>Mydock</h2><p>仿MAC-dock栏，<a href="https://www.mydockfinder.com/">官网</a>，随便选择一个下载渠道，下载后安装</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/Sucai/20201210225441.png" alt=""></p>
<p>找到一个空白地方右击可以设置大小，图标，开机启动等等，还可以设置最小化动画</p>
<h2 id="Translucent-汉化版"><a href="#Translucent-汉化版" class="headerlink" title="Translucent(汉化版)"></a>Translucent(汉化版)</h2><p>任务栏透明化，在桌面时可以使任务栏变得透明，点击左下角windows图标，选择所有应用，找到M开头的应用，找到Micrsoft Store，打开后搜索Translucent(汉化版)一定要是汉化版<del>除非您是英语大佬</del></p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/Sucai/20201210225839.png" alt="image-20201210225837762"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/Sucai/20201211080515.png" alt=""></p>
<p>下载就可以了</p>
<h2 id="雨滴皮肤"><a href="#雨滴皮肤" class="headerlink" title="雨滴皮肤"></a>雨滴皮肤</h2><p>雨滴是一款占内存非常小的软件，里面有桌面时钟效果，可以添加到桌面动态时钟</p>
<p>皮肤下载地址: <a href="https://zhutix.com/tag/rainmeter/">Here</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/Sucai/20201211081513.png" alt=""></p>
<p>自行设置效果吧</p>
<p>本人还是觉得简约效果最好:</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/Sucai/20201211081020.png" alt="alt" title="这里是 title"></p>
<h2 id="任务栏图标居中"><a href="#任务栏图标居中" class="headerlink" title="任务栏图标居中"></a>任务栏图标居中</h2><p><img src="https://cdn.jsdelivr.net/gh/uncleacc/Sucai/20201211081650.png" alt=""></p>
<p>找一个安全位置新建一个文件夹，命名为“任务栏”，右击任务栏，选择工具栏&gt;新建工具栏，打开刚才新建的文件夹，之后点击两条竖线可以拖动图标（如果你不能拖动右击看看你是不是把任务栏锁定住了），将新建的工具栏拖动到最左面，然后把图标拖动到中间即可，“任务栏”文件夹中的文件会被展示到任务栏上，可以利用这点添加我的电脑快捷方式和关机.bat，可以更加方便你的操作，其次右击任务栏还可以隐藏图标名字，把任务栏变小，最后锁定住任务栏即可</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/Sucai/20201211081921.png" alt=""></p>
<h2 id="uTools"><a href="#uTools" class="headerlink" title="uTools"></a>uTools</h2><p>百度<code>uTools</code>，下载，按住Alt+Space可以弹出搜索框，可以搜索到电脑里面的各种软件，关键在于里面有很多插件，和Everything搭配使用可以直接代替Everything。如果你是一个有过Linux经历，能敲键盘就绝不动鼠标，那这个就是你的绝佳选择。    </p>
<h2 id="WindowBlinds10"><a href="#WindowBlinds10" class="headerlink" title="WindowBlinds10"></a>WindowBlinds10</h2><p>一款可以更换主题风格的软件，而且其内存占用非常小，而且没有什么Bug，非常稳定，所以推荐这款软件，它可以把你的电脑风格换成Mac的样式，这个自行探索吧，下载链接<code>致美化</code>里面有</p>
<font color="red" size=6>最后不推荐大家使用"Startdocks"，个人就被它折磨的恢复过系统，系统还原点非常重要!</font>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>win10</tag>
      </tags>
  </entry>
  <entry>
    <title>Bellman-ford</title>
    <url>/posts/9012ae67.html</url>
    <content><![CDATA[<h1 id="Bellman-ford"><a href="#Bellman-ford" class="headerlink" title="Bellman-ford"></a>Bellman-ford</h1><blockquote>
<p>用途：</p>
<ol>
<li>判负环</li>
<li>计算含有负权边的最短路径</li>
</ol>
<p>重边不会影响答案，因为Bellman-ford会遍历所有的边</p>
</blockquote>
<h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><p>先存边，Bellman-ford的存边十分随意，什么储存方式都可以，只有一个要求，就是每次都要遍历到所有的边！</p>
<p>既然如此就用一个结构体去存，一个for循环就可以遍历到所有的边了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> u,v,w</span><br><span class="line">&#125;e[MAXN];</span><br></pre></td></tr></table></figure>
<p>算法十分简单，每次只要让所有的边进行一次更新即可，如果不存在负环，那么一个点最多被n-1个点更新(除了自己)，所以外层循环遍历n-1次，内层循环遍历每一条边</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">        <span class="type">int</span> u=e[j].u,v=e[j].v,w=e[j].w;</span><br><span class="line">		dis[v]=min(dis[v],dis[u]+w);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果存在负环，那么经过上面的松弛操作后，一定还有点还可以被松弛，负环可以把环上点能到的所有点的权值都松弛到无限小，遍历所有点，检查是否还有点可以被松弛，如果有，则存在负环，否则不存在。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(dis[e[i].v]&gt;dis[e[i].u]+e[i].w)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="输出路径"><a href="#输出路径" class="headerlink" title="输出路径"></a>输出路径</h3><p>用pre数组保存该节点由谁更新的，初始化时把所有的pre初始化为起点，最后从终点开始往回走，直到走到起点，输出路径。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>Binary Tree</title>
    <url>/posts/e0e2589a.html</url>
    <content><![CDATA[<blockquote>
<p>实验目标：<br>1、创建二叉树<br>2、用非递归算法先中后序遍历二叉树 (难点)<br>3、分别求出二叉树中度为 0、1、2的结点个数<br>4、求出树的高度</p>
<p>参考博客:<br><a href="https://www.cnblogs.com/dolphin0520/archive/2011/08/25/2153720.html">Article_1</a><br><a href="https://www.cnblogs.com/rain-lei/p/3705680.html">Article_2</a> </p>
</blockquote>
<p>难点在于非递归遍历，用栈来模拟递归的过程</p>
<h2 id="二叉树结构"><a href="#二叉树结构" class="headerlink" title="二叉树结构"></a>二叉树结构</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="type">char</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br></pre></td></tr></table></figure>
<h2 id="创建二叉树"><a href="#创建二叉树" class="headerlink" title="创建二叉树"></a>创建二叉树</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CreateBiTree</span><span class="params">(BiTree &amp;t)</span>&#123;</span><br><span class="line">	<span class="type">char</span> ch; <span class="built_in">cin</span>&gt;&gt;ch;</span><br><span class="line">	<span class="keyword">if</span>(ch==<span class="string">&#x27;#&#x27;</span>) t=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		t=new node;</span><br><span class="line">		t-&gt;data=ch;</span><br><span class="line">		CreateBiTree(t-&gt;lchild);  <span class="comment">//创建左子树 </span></span><br><span class="line">		CreateBiTree(t-&gt;rchild);  <span class="comment">//创建右子树 </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Level</span><span class="params">(BiTree L)</span>&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;层序遍历:\n&quot;</span>;</span><br><span class="line">	<span class="keyword">if</span>(!L) <span class="keyword">return</span> ;</span><br><span class="line">	<span class="built_in">queue</span>&lt;BiTree&gt; q;  <span class="comment">//STL队列定义 </span></span><br><span class="line">	q.push(L);</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		BiTree fr=q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="keyword">if</span>(fr) <span class="built_in">cout</span>&lt;&lt;fr-&gt;data&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">		q.push(fr-&gt;lchild);</span><br><span class="line">		q.push(fr-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">preOrder1</span><span class="params">(BinTree *root)</span>     <span class="comment">//递归前序遍历 </span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(root!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;root-&gt;data&lt;&lt;<span class="string">&quot;&quot;</span>;</span><br><span class="line">        preOrder1(root-&gt;lchild);</span><br><span class="line">        preOrder1(root-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h4><p><code>用栈模拟递归</code> </p>
<p>对比递归算法，当递归调用自己时就<code>把当前状态入栈</code>!</p>
<p>操作： 对于当前子树，1.不空就输出根节点并把当前指针入栈，然后更新指针指向左子树，2. 空就更新指针指向栈顶的右子树</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PreOreder</span><span class="params">(BiTree L)</span>&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;前序遍历:\n&quot;</span>;</span><br><span class="line">	<span class="keyword">if</span>(!L) <span class="keyword">return</span> ;</span><br><span class="line">	<span class="built_in">stack</span>&lt;BiTree&gt; st;</span><br><span class="line">	<span class="keyword">while</span>(L || !st.empty())&#123;</span><br><span class="line">		<span class="keyword">while</span>(L)&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;L-&gt;data&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">			st.push(L);</span><br><span class="line">			L=L-&gt;lchild;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!st.empty())&#123;</span><br><span class="line">			L=st.top();</span><br><span class="line">			st.pop();</span><br><span class="line">			L=L-&gt;rchild;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><h4 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">inOrder1</span><span class="params">(BinTree *root)</span>      <span class="comment">//递归中序遍历</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(root!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        inOrder1(root-&gt;lchild);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;root-&gt;data&lt;&lt;<span class="string">&quot;&quot;</span>;</span><br><span class="line">        inOrder1(root-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h4 id="非递归-1"><a href="#非递归-1" class="headerlink" title="非递归"></a>非递归</h4><p>和前序一样，只不过改成在当前节点没有左子树时输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MidOreder</span><span class="params">(BiTree L)</span>&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;中序遍历:\n&quot;</span>;</span><br><span class="line">	<span class="built_in">stack</span>&lt;BiTree&gt; st;</span><br><span class="line">	<span class="keyword">while</span>(L || !st.empty())&#123;</span><br><span class="line">		<span class="keyword">while</span>(L)&#123;</span><br><span class="line">			st.push(L);</span><br><span class="line">			L = L-&gt;lchild;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!st.empty())&#123;</span><br><span class="line">			L = st.top();</span><br><span class="line">			st.pop();</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;L-&gt;data&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">			L=L-&gt;rchild;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><h4 id="递归-2"><a href="#递归-2" class="headerlink" title="递归"></a>递归</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">postOrder1</span><span class="params">(BinTree *root)</span>    <span class="comment">//递归后序遍历</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(root!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        postOrder1(root-&gt;lchild);</span><br><span class="line">        postOrder1(root-&gt;rchild);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;root-&gt;data&lt;&lt;<span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h4 id="非递归-2"><a href="#非递归-2" class="headerlink" title="非递归"></a>非递归</h4><p>后序遍历的非递归实现是三种遍历方式中最难的一种。因为在后序遍历中，要保证左孩子和右孩子都已被访问并且左孩子在右孩子前访问才能访问根结点，这就为流程的控制带来了难题，解决方案如下。</p>
<p>要保证根结点在左孩子和右孩子访问之后才能访问，因此对于任一结点P，先将其入栈。如果P不存在左孩子和右孩子，则可以直接访问它；或者P存在左孩子或者右孩子，但是其左孩子和右孩子都已被访问过了，则同样可以直接访问该结点。若非上述两种情况，则将P的右孩子和左孩子依次入栈，这样就保证了每次取栈顶元素的时候，左孩子在右孩子前面被访问，左孩子和右孩子都在根结点前面被访问。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">也就是模拟递归</span></span><br><span class="line"><span class="comment">对于当前节点，只有当左子树和右子树都访问过或者为空时才能输出当前节点，有一个存在且没有访问过就需要先访问它，而栈是先进后</span></span><br><span class="line"><span class="comment">出，所以入栈顺序先放右子树在放左子树</span></span><br><span class="line"><span class="comment">如何判断是否访问过？</span></span><br><span class="line"><span class="comment">我们可以保存上一个访问的节点pre，如果满足 (p-&gt;right==NULL &amp;&amp; pre==p-&gt;left) || pre=p-&gt;right，那么显然p的孩子都访问</span></span><br><span class="line"><span class="comment">过了，接下来可以访问p </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="type">void</span> <span class="title function_">PostOrder</span><span class="params">(BiTree L)</span>&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;后序遍历:\n&quot;</span>;</span><br><span class="line">	<span class="keyword">if</span>(!L) <span class="keyword">return</span> ;</span><br><span class="line">	<span class="built_in">stack</span>&lt;BiTree&gt; st; </span><br><span class="line">	st.push(L);</span><br><span class="line">	BiTree pre=L;</span><br><span class="line">	<span class="keyword">while</span>(!st.empty())&#123;</span><br><span class="line">		BiTree temp=st.top();</span><br><span class="line">		<span class="keyword">if</span>((!temp-&gt;lchild &amp;&amp; !temp-&gt;rchild) || (!temp-&gt;rchild &amp;&amp; temp-&gt;lchild==pre) || temp-&gt;rchild==pre)&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;temp-&gt;data&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">			pre=temp;</span><br><span class="line">			st.pop();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(temp-&gt;rchild) st.push(temp-&gt;rchild);</span><br><span class="line">			<span class="keyword">if</span>(temp-&gt;lchild) st.push(temp-&gt;lchild);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>求度数简单这里不单独放代码了</p>
<h2 id="全代码"><a href="#全代码" class="headerlink" title="全代码"></a>全代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">实验目标：</span></span><br><span class="line"><span class="comment">1、创建二叉树</span></span><br><span class="line"><span class="comment">2、用非递归算法先中后序遍历二叉树</span></span><br><span class="line"><span class="comment">3、分别求出二叉树中度为 0、1、2的结点个数</span></span><br><span class="line"><span class="comment">4、求出树的高度</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">难点在于非递归遍历，用栈来模拟递归的过程，这里我用了STL里面的栈，只需要知道栈的操作干什么即可，不需要知道原理 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">代码输入方式: 输入一颗树的先序序列，空节点用&quot;#&quot;代替 </span></span><br><span class="line"><span class="comment">参考博客: </span></span><br><span class="line"><span class="comment">https://www.cnblogs.com/dolphin0520/archive/2011/08/25/2153720.html</span></span><br><span class="line"><span class="comment">https://www.cnblogs.com/rain-lei/p/3705680.html </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="type">char</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"><span class="type">int</span> cnt0,cnt1,cnt2,high;</span><br><span class="line"><span class="comment">//递归利用先序遍历方式创建二叉树，空节点用&quot;#&quot;代替 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateBiTree</span><span class="params">(BiTree &amp;t)</span>&#123;</span><br><span class="line">	<span class="type">char</span> ch; <span class="built_in">cin</span>&gt;&gt;ch;</span><br><span class="line">	<span class="keyword">if</span>(ch==<span class="string">&#x27;#&#x27;</span>) t=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		t=new node;</span><br><span class="line">		t-&gt;data=ch;</span><br><span class="line">		CreateBiTree(t-&gt;lchild);  <span class="comment">//创建左子树 </span></span><br><span class="line">		CreateBiTree(t-&gt;rchild);  <span class="comment">//创建右子树 </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">find</span><span class="params">(BiTree t,<span class="type">int</span> h)</span>&#123;  <span class="comment">//传入高度参数 </span></span><br><span class="line">	<span class="keyword">if</span>(!t) <span class="keyword">return</span> ;</span><br><span class="line">	high=max(high,h);  <span class="comment">//以最大高度节点为准 </span></span><br><span class="line">	<span class="keyword">if</span>(t-&gt;lchild &amp;&amp; t-&gt;rchild) cnt2++;  <span class="comment">//度为2 </span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(!t-&gt;lchild &amp;&amp; !t-&gt;rchild) cnt0++;  <span class="comment">//度为0 </span></span><br><span class="line">	<span class="keyword">else</span> cnt1++;  <span class="comment">//度为1 </span></span><br><span class="line">	find(t-&gt;lchild,h+<span class="number">1</span>);  <span class="comment">//左子树 </span></span><br><span class="line">	find(t-&gt;rchild,h+<span class="number">1</span>);  <span class="comment">//右子树 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//层序遍历利用BFS输出 (实验不做要求)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Level</span><span class="params">(BiTree L)</span>&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;层序遍历:\n&quot;</span>;</span><br><span class="line">	<span class="keyword">if</span>(!L) <span class="keyword">return</span> ;</span><br><span class="line">	<span class="built_in">queue</span>&lt;BiTree&gt; q;  <span class="comment">//STL队列定义 </span></span><br><span class="line">	q.push(L);</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		BiTree fr=q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="keyword">if</span>(fr) <span class="built_in">cout</span>&lt;&lt;fr-&gt;data&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">		q.push(fr-&gt;lchild);</span><br><span class="line">		q.push(fr-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">用栈模拟递归 </span></span><br><span class="line"><span class="comment">操作：</span></span><br><span class="line"><span class="comment">对于当前子树根节点，1.如果当前子树不为空就输出子树根节点并把左子树入栈，指针指向左子树，2.为空则pop出栈顶元素，并</span></span><br><span class="line"><span class="comment">将此时栈顶根节点的右子树入栈 </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOreder</span><span class="params">(BiTree L)</span>&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;前序遍历:\n&quot;</span>;</span><br><span class="line">	<span class="keyword">if</span>(!L) <span class="keyword">return</span> ;</span><br><span class="line">	<span class="built_in">stack</span>&lt;BiTree&gt; st;</span><br><span class="line">	<span class="keyword">while</span>(L || !st.empty())&#123;</span><br><span class="line">		<span class="keyword">while</span>(L)&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;L-&gt;data&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">			st.push(L);</span><br><span class="line">			L=L-&gt;lchild;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!st.empty())&#123;</span><br><span class="line">			L=st.top();</span><br><span class="line">			st.pop();</span><br><span class="line">			L=L-&gt;rchild;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">和先序类似，就是先处理完左子树再输出根节点然后把右子树入栈 </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="type">void</span> <span class="title function_">MidOreder</span><span class="params">(BiTree L)</span>&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;中序遍历:\n&quot;</span>;</span><br><span class="line">	<span class="built_in">stack</span>&lt;BiTree&gt; st;</span><br><span class="line">	<span class="keyword">while</span>(L || !st.empty())&#123;</span><br><span class="line">		<span class="keyword">while</span>(L)&#123;</span><br><span class="line">			st.push(L);</span><br><span class="line">			L = L-&gt;lchild;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!st.empty())&#123;</span><br><span class="line">			L = st.top();</span><br><span class="line">			st.pop();</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;L-&gt;data&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">			L=L-&gt;rchild;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">也就是模拟递归</span></span><br><span class="line"><span class="comment">对于当前节点，只有当左子树和右子树都访问过或者为空时才能输出当前节点，有一个存在且没有访问过就需要先访问它，而栈是先进后</span></span><br><span class="line"><span class="comment">出，所以入栈顺序先放右子树在放左子树</span></span><br><span class="line"><span class="comment">如何判断是否访问过？</span></span><br><span class="line"><span class="comment">我们可以保存上一个访问的节点pre，如果满足 (p-&gt;right==NULL &amp;&amp; pre==p-&gt;left) || pre=p-&gt;right，那么显然p的孩子都访问</span></span><br><span class="line"><span class="comment">过了，接下来可以访问p </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="type">void</span> <span class="title function_">PostOrder</span><span class="params">(BiTree L)</span>&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;后序遍历:\n&quot;</span>;</span><br><span class="line">	<span class="keyword">if</span>(!L) <span class="keyword">return</span> ;</span><br><span class="line">	<span class="built_in">stack</span>&lt;BiTree&gt; st; </span><br><span class="line">	st.push(L);</span><br><span class="line">	BiTree pre=L;</span><br><span class="line">	<span class="keyword">while</span>(!st.empty())&#123;</span><br><span class="line">		BiTree temp=st.top();</span><br><span class="line">		<span class="keyword">if</span>((!temp-&gt;lchild &amp;&amp; !temp-&gt;rchild) || (!temp-&gt;rchild &amp;&amp; temp-&gt;lchild==pre) || temp-&gt;rchild==pre)&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;temp-&gt;data&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">			pre=temp;</span><br><span class="line">			st.pop();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(temp-&gt;rchild) st.push(temp-&gt;rchild);</span><br><span class="line">			<span class="keyword">if</span>(temp-&gt;lchild) st.push(temp-&gt;lchild);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Traverse</span><span class="params">(BiTree L)</span>&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>; </span><br><span class="line">	Level(L);  <span class="comment">//层序遍历 </span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	PreOreder(L);  <span class="comment">//前序遍历 </span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	MidOreder(L);  <span class="comment">//中序遍历 </span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	PostOrder(L);  <span class="comment">//后序遍历 </span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	BiTree L;</span><br><span class="line">	CreateBiTree(L);  <span class="comment">//创建二叉树 </span></span><br><span class="line">	Traverse(L);  <span class="comment">//遍历二叉树 </span></span><br><span class="line">	find(L,<span class="number">1</span>);  <span class="comment">//找到二叉树度数为0、1、2的结点数，并得出深度 </span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;树的高度为: &quot;</span>&lt;&lt;high&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;度数为0的节点数量: &quot;</span>&lt;&lt;cnt0&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;度数为1的节点数量: &quot;</span>&lt;&lt;cnt1&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;度数为2的节点数量: &quot;</span>&lt;&lt;cnt2&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>CCPC2021网络赛复赛</title>
    <url>/posts/7a5cad64.html</url>
    <content><![CDATA[<h2 id="Primality-Test"><a href="#Primality-Test" class="headerlink" title="Primality Test"></a><a href="http://acm.hdu.edu.cn/contest/problem?cid=1038&amp;pid=1004">Primality Test</a></h2><p>根据题意可知，求连续两个质数相加除以2向下取整后是否还是质数，因为是连续的两个质数，所以取中位数后一定不会是质数，1除外</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line">LL t , n;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span> , &amp;t);</span><br><span class="line">    <span class="keyword">while</span> (t --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span> , &amp;n);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Nun-Heh-Heh-Aaaaaaaaaaa"><a href="#Nun-Heh-Heh-Aaaaaaaaaaa" class="headerlink" title=" Nun Heh Heh Aaaaaaaaaaa"></a><a href="http://acm.hdu.edu.cn/contest/problem?cid=1038&amp;pid=1006"> Nun Heh Heh Aaaaaaaaaaa</a></h2><p>给定一个字符串，求这个字符串有多少个子序列满足由前缀<strong>nunhehheh</strong>和k个<strong>a</strong>(k&gt;0)组成。</p>
<p>例如nunhehhehaaaaaa就是符合要求的，但是nunhehheh和nunhehhehoooaaa是不符合要求的。</p>
<p>这是一个dp模型，求一个字符串的所有子序列中有多少个s(s是一个字符串)，这里只是多了后缀a，我们先找字符串包含多少个nunhehheh，开一个dp数组，dp[i]表示匹配到匹配到第k个字符出现了前i个字串的数量，例如dp[1]表示出现n的数量，dp[3]表示出现nun的数量，遍历字符串，将对应的字符，dp[i]=(dp[i-1]+dp[i])%mod</p>
<p>最后dp[9]就是出现nunhehheh的数量，用dp[10]表示前缀<strong>nunhehheh</strong>和k个<strong>a</strong>(k&gt;0)组成的字符串数量，考虑给后面加上一个a，那么之前满足条件的字符串可以加a也可以不加，而dp[9]必须加上这个a才能满足条件，所以dp[10]=(dp[10]+dp[9])%mod</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll mod=<span class="number">998244353</span>;</span><br><span class="line">ll dp[<span class="number">20</span>],T;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line">	<span class="keyword">while</span>(T--)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span> dp);</span><br><span class="line">		<span class="built_in">string</span> s;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">		<span class="type">int</span> len=s.size();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(s[i]==<span class="string">&#x27;n&#x27;</span>)&#123;</span><br><span class="line">				dp[<span class="number">1</span>]++;</span><br><span class="line">				dp[<span class="number">3</span>]=(dp[<span class="number">3</span>]+dp[<span class="number">2</span>])%mod;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;u&#x27;</span>) dp[<span class="number">2</span>]=(dp[<span class="number">1</span>]+dp[<span class="number">2</span>])%mod;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;h&#x27;</span>)&#123;	<span class="comment">//这里需要特别注意如果出现连续相同的字符，例如aaaa，那需要先更新最后一个a的答案，因为这里计算出现多少个aaaa，如果当前位置是k，那当前答案是用[1,k-1]出现aaa的数量来更新的，如果先更新前面的a，就会导致使用[1,k]出现的a来更新答案，导致错误</span></span><br><span class="line">				dp[<span class="number">9</span>]=(dp[<span class="number">9</span>]+dp[<span class="number">8</span>])%mod;</span><br><span class="line">				dp[<span class="number">7</span>]=(dp[<span class="number">7</span>]+dp[<span class="number">6</span>])%mod;</span><br><span class="line">				dp[<span class="number">6</span>]=(dp[<span class="number">6</span>]+dp[<span class="number">5</span>])%mod;</span><br><span class="line">				dp[<span class="number">4</span>]=(dp[<span class="number">4</span>]+dp[<span class="number">3</span>])%mod;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;e&#x27;</span>)&#123;</span><br><span class="line">				dp[<span class="number">5</span>]=(dp[<span class="number">4</span>]+dp[<span class="number">5</span>])%mod;</span><br><span class="line">				dp[<span class="number">8</span>]=(dp[<span class="number">8</span>]+dp[<span class="number">7</span>])%mod;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;a&#x27;</span>) dp[<span class="number">10</span>]=(dp[<span class="number">10</span>]*<span class="number">2</span>%mod+dp[<span class="number">9</span>])%mod;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;dp[<span class="number">10</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Kanade-Doesn’t-Want-to-Learn-CG"><a href="#Kanade-Doesn’t-Want-to-Learn-CG" class="headerlink" title=" Kanade Doesn’t Want to Learn CG"></a><a href="http://acm.hdu.edu.cn/contest/problem?cid=1038&amp;pid=1002"> Kanade Doesn’t Want to Learn CG</a></h2><p>分类讨论，数学问题，我用小数写的，但是其实用longlong更好，不会有精度问题</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">int</span> T;</span><br><span class="line"><span class="type">double</span> a,b,c,x0,y0,x1,y1,y2;</span><br><span class="line"><span class="type">double</span> <span class="title function_">f1</span><span class="params">(ll y)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (-b+<span class="built_in">sqrt</span>(b*b<span class="number">-4</span>*a*(c-y0)))/(<span class="number">2</span>*a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> <span class="title function_">f2</span><span class="params">(ll y)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (-b-<span class="built_in">sqrt</span>(b*b<span class="number">-4</span>*a*(c-y0)))/(<span class="number">2</span>*a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> <span class="title function_">work</span><span class="params">(<span class="type">double</span> x)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a*x*x+b*x+c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line">	<span class="keyword">while</span>(T--)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;x0&gt;&gt;x1&gt;&gt;y0&gt;&gt;y1&gt;&gt;y2;</span><br><span class="line">		<span class="keyword">if</span>(work(x0)==y0 || work(x1)==y0) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="type">double</span> p=-b/(<span class="number">2</span>*a);</span><br><span class="line">			<span class="keyword">if</span>(work(p)&lt;=y0 || p&gt;=x1 || (f1(y0)&gt;=x0 &amp;&amp; f1(y0)&lt;=x1)) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(f2(y0)&gt;x0 &amp;&amp; f2(y0)&lt;x1) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">if</span>(work(x1)&lt;=y2 &amp;&amp; f2(y0)&gt;x1 &amp;&amp; f2(y0)&lt;x1+x1-x0) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">				<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更好的代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line">ll a, b, c, xa, xb, ya, yb, yc;</span><br><span class="line"></span><br><span class="line">ll <span class="title function_">changdu</span><span class="params">(ll x)</span>&#123;</span><br><span class="line">    ll res = a * x * x + b * x + c;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    ios;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t --)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; xa &gt;&gt; xb &gt;&gt; ya &gt;&gt; yb &gt;&gt; yc;</span><br><span class="line">        ll lena = changdu(xb), lenb = changdu(<span class="number">0</span> - xa + xb * <span class="number">2</span>), len = changdu(xa);</span><br><span class="line">        <span class="keyword">if</span> (len &lt;= ya) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;No\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (lena == ya || lena &gt; yc) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;No\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (lena &lt; ya) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Yes\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (lenb &gt;= ya) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;No\n&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Yes\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Jumping-Monkey"><a href="#Jumping-Monkey" class="headerlink" title=" Jumping Monkey"></a><a href="http://acm.hdu.edu.cn/contest/problem?cid=1038&amp;pid=1011"> Jumping Monkey</a></h2><p>比赛的时候一直在想从边权大的开始出发，把所有能到达这个点的所有点答案加一，利用线段树去维护，但是到后面块太多了，维护不了，于是就搁置了，正解是从边权小的开始枚举，对于当前点，把和这个点相邻的点都合并到当前点，让当前点作为祖先，循环往复，到最后每一个点距离根节点的距离就是答案，原理就是因为是按照点权从小到大枚举的，因此每一个点都不可能越过根节点到达其他分支的节点，所以一个节点可以到达的节点就是这个点距离和根节点之间的点，也就是距离。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> id,val;</span><br><span class="line">&#125;arr[N];</span><br><span class="line"><span class="type">int</span> T,n,u,v;</span><br><span class="line"><span class="type">int</span> fa[N],ans[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; ve[N];</span><br><span class="line"><span class="type">bool</span> <span class="title function_">cmp</span><span class="params">(node a,node b)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.val&lt;b.val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==fa[x]) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="type">int</span> tmp=fa[x];</span><br><span class="line">		fa[x]=find(fa[x]);</span><br><span class="line">		ans[x]+=ans[tmp];	<span class="comment">//维护距离根节点的距离</span></span><br><span class="line">		<span class="keyword">return</span> fa[x];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		fa[i]=i;</span><br><span class="line">		ans[i]=<span class="number">0</span>;</span><br><span class="line">		ve[i].clear();	</span><br><span class="line">		vis[i]=<span class="number">0</span>;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line">	<span class="keyword">while</span>(T--)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">		init();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">			ve[u].push_back(v);</span><br><span class="line">			ve[v].push_back(u);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;arr[i].val;</span><br><span class="line">			arr[i].id=i;</span><br><span class="line">		&#125;</span><br><span class="line">		sort(arr+<span class="number">1</span>,arr+<span class="number">1</span>+n,cmp);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="type">int</span> now=arr[i].id;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;ve[now].size();j++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(vis[ve[now][j]])&#123;</span><br><span class="line">					<span class="type">int</span> fu=find(ve[now][j]);</span><br><span class="line">					ans[fu]=<span class="number">1</span>;</span><br><span class="line">					fa[fu]=now;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			vis[now]=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			find(i);</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;ans[i]+<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Monopoly"><a href="#Monopoly" class="headerlink" title="Monopoly"></a>Monopoly</h2><p>$a1,a2,a3…an$</p>
<p>首先求一个前缀和，$S=K*pre[n]+pre[i]$，考虑pre[n]大于0的情况，这个时候pre[i]一定小于等于S，对pre[n]取模，发现S和pre[i]同余，也就是求一个pre[i]使得K最小，并且在K相同条件下i尽可能小，考虑维护n个容器，每一个容器对应一个余数，容器中放置所有同余的前缀和，给定一个x就去相对应的容器中二分找到小于等于x的最大前缀，即是答案。</p>
<p>需要特别注意的是，前缀和可能是负数，而给定的x是负数，这个时候x和前缀和是同余的，但是符号相反，这里需要特别处理一下。</p>
<p>如果pre[n]小于0，则所有数字取反即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">ll arr[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;ll&gt; cis[N];</span><br><span class="line"><span class="type">int</span> tot,T;</span><br><span class="line"><span class="built_in">map</span>&lt;ll,<span class="type">int</span>&gt; mp,mp2;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">	mp.clear();</span><br><span class="line">	mp2.clear();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tot;i++) cis[i].clear();</span><br><span class="line">	tot=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line">	<span class="keyword">while</span>(T--)&#123;</span><br><span class="line">		init();</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;arr[i];</span><br><span class="line">			arr[i]+=arr[i<span class="number">-1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		ll sum=arr[n];</span><br><span class="line">		<span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(sum&lt;<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) arr[i]=-arr[i];</span><br><span class="line">			sum=-sum;</span><br><span class="line">			flag=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(!mp2[arr[i]]) mp2[arr[i]]=i;;</span><br><span class="line">		<span class="keyword">if</span>(sum!=<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">				ll now=(arr[i]%sum+sum)%sum;</span><br><span class="line">				<span class="keyword">if</span>(!mp[now]) mp[now]=++tot;</span><br><span class="line">				cis[mp[now]].push_back(arr[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tot;i++) sort(cis[i].begin(),cis[i].end());</span><br><span class="line">		<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">			ll x;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">			<span class="keyword">if</span>(flag) x=-x;</span><br><span class="line">			<span class="keyword">if</span>(x==<span class="number">0</span>)&#123;</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(sum==<span class="number">0</span>)&#123;</span><br><span class="line">				<span class="keyword">if</span>(mp2[x]) <span class="built_in">cout</span>&lt;&lt;mp2[x]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">				<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(!mp[(x%sum+sum)%sum])&#123;</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="type">int</span> now=mp[(x%sum+sum)%sum];</span><br><span class="line">			<span class="keyword">auto</span> it=upper_bound(cis[now].begin(),cis[now].end(),x);</span><br><span class="line">			<span class="keyword">if</span>(it==cis[now].begin()) <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				it--;</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;(x-*it)/sum*n+mp2[*it]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">4 4</span></span><br><span class="line"><span class="comment">1 2 -3 3</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">7</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>比赛</tag>
      </tags>
  </entry>
  <entry>
    <title>CCPC打铁记</title>
    <url>/posts/3099d076.html</url>
    <content><![CDATA[<blockquote>
<p>2020年10月18日，这一天是我第一次打比赛的日子，非常有纪念意义，但是时至今日我才补了这篇文章</p>
</blockquote>
<p>2020年注定是不平凡的一年，突如其来的疫情改变很多人的生活轨迹，原本该在这一年大展拳脚的学长们无奈只能在家里打着练习赛，然而对我们而言，有好也有坏吧，好的是我们有更多时间去提升自己(当然全靠自觉)，坏的是少了许多阅历，不管怎样，终于在2020年8月29日我们开学了，开学后经过一个星期的过渡，又回到了算法的训练中去，在下面也打了许多训练赛，每次都紧紧抱着大佬的大腿，每次成绩也都还不错(不错指的是会的都比较快的做出来了)，然而只要是dp只要是新算法我们就止步于此了</p>
<p>又过了一个月，我们迎来的这一年的CCPC邀请赛，首先是出线问题，最终学长们也都打进去了，我们19级的因为时间还多，机会就都留给学长们了，不过一星期后，老师跟我们说可以办外卡，也可以参赛拿奖，高兴了我一天，当时我以为是线下赛，想着终于可以出去涨涨见识了，然而第二天就丧了，因为疫情，这一年几乎所有比赛都是线上举行的！一下子感觉气氛都不对了，不过毕竟是比赛，比赛前我还是有去多刷题的，然而因为好多新算法都没学，有很多题目都是干瞪眼</p>
<p>终于到了比赛的前一天，这一天有热身赛，而且这一天还有蓝桥杯，我被叫去当监考了，报酬是“管饭”，到了才知道上一年19级也有好多人报了蓝桥杯，顿时心理不平衡了。。。也是无聊的看了一上午手机，就到了中午，饭还行，挺好吃的，吃撑了~，吃完没有睡觉直接去打热身赛了，教师布置的有模有样地，开了热身赛，我们瞬间A了签到题，又过了不久A了第二道，然后就没有然后了。。剩下两道做出来的屈指可数，还得到了俩气球，哈哈哈。晚上我们队伍一起去吃饭，吃完后直接去机房打印板子去了，由于热身赛手推了高中的许多公式，我们打印的板子都集中到了高中数学公式上，能用一个都是赚的！终于这一天结束了，我们约定明天要拿铜牌🥉，晚上11点睡觉，然而我还是失眠了。。12点半才睡着</p>
<p>第二天早早起来，拿上该拿的东西，走向了机房，换上队服，拍了照片，进入系统，熟练的打开了DEV。终于比赛开始了，没有人过题，我们仨只能瞎找，过了两分钟，A题有人过了，我们一看是水题，然后他俩写代码，我就去看下一道了，第二道是一个数学题，然而我看错题了，我把向下取整符号看成了绝对值。。导致我们仨浪费了3分钟的时间整理了一个错误的思路，我背锅，发现向下取整后，潘佬爷瞬间有了思路，他给我们手推样例，看了一会，我也懂了，原以为通过这个规律推出一个数学式子，后来发现通过这个规律直接暴力就可以了，潘佬爷txdy，过了不久A了第二题，然后我们看向了E，正解是双指针(尺取)，而我们先是贪心，后来动规，发现解不出来，就看向了G题，是一个判环的题目，由于之前没学过判环，我们仨都没有把握，潘姥爷提出了标记结点的思路，然后我们俩疯狂造数据，疯狂验证，最终证明这个方法是对的，只不过因为题目有一些小坑，wrong了三发，我们一度怀疑算法有问题~A了3题后我们排名还是排到了两百开外，我们也就止步于此了，第四题我们怎么也不知道怎么做，最后2小时多我们划了，哎，打铁了</p>
<p>然而女队却很幸运，只过了两题，竟然混了一个铜牌，太搞了太搞了，晚上我们聚在一起吃了一顿饭，商量了一下以后的训练，希望我们下次不再打铁，毕竟我们的理想不只是拿一个铜牌💪</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS语法笔记</title>
    <url>/posts/efc0e1f0.html</url>
    <content><![CDATA[<blockquote>
<p>对Web有点兴趣，可能它是可视化的，给我带来的成就感更多吧🐷标签不记了，w3school上都有</p>
</blockquote>
<h2 id="文章转载"><a href="#文章转载" class="headerlink" title="文章转载"></a>文章转载</h2><p>原文链接：<a href="https://www.antmoe.com/posts/fd1c8f75/index.html">Click me</a><br>本人也对其做了少些修改</p>
<h2 id="元素"><a href="#元素" class="headerlink" title="元素"></a>元素</h2><p>CSS元素分为<code>块、行、行内块</code>三种元素，块元素会独占一行、行元素会紧凑着排列、而行内块就是综合两者在行内排列着块。</p>
<ul>
  行内元素特征：<br>
  <li>设置宽高无效</li>
  <li>对margin仅设置左右方向有效，上下无效；padding设置上下左右都有效，即会撑大空间,行内元素尺寸，由内含的内容决定，盒模型中 padding, border 与块级元素并无差异，都是标准的盒模型，但是 margin，却只有水平方向的值，垂直方向并没有起作用。行内元素的水平方向的padding-left,padding-right,margin-left,margin-right 都产生边距效果，但是竖直方向的padding-top,padding-bottom,margin-top,margin-bottom都不会产生边距效果。padding设置上下左右都有效，即会撑大空间但是<em>不会产生边距效果</em>。</li>
  <li>不会自动进行换行</li>
  <br><br>
  块状元素特征: <br>
  <li>能够识别宽高</li>
  <li>margin和padding的上下左右均对其有效</li>
  <li>可以自动换行</li>
  <li>多个块状元素标签写在一起，默认排列方式为从上至下</li>
  <br><br>
  行内块状元素特征: <br>
  <li>不自动换行</li>
  <li>能够识别宽高</li>
  <li>默认排列方式为从左到右</li>
</ul>

<p>以上三种元素可以通过<code>display: ???</code>属性切换类型。</p>
<h2 id="选择器分类"><a href="#选择器分类" class="headerlink" title="选择器分类"></a>选择器分类</h2><ul>
<li>基本选择器:  共有 5 个基本选择器，是 CSS 选择器的最为基本的用法。</li>
<li>层级选择器:  共有 4 个层级选择器。</li>
<li>组合选择器：具有交集和并集两种用法，是将之前基本选择器和层级选择器进行组合。</li>
<li>伪类选择器：允许未包含在 HTML 页面中的状态信息选定位 HTML 元素。</li>
<li>伪元素选择器：定位所有未被包含 HTML 的实体。</li>
</ul>
<h2 id="基本选择器"><a href="#基本选择器" class="headerlink" title="基本选择器"></a>基本选择器</h2><ol>
<li>类型选择器（元素选择器）   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">     font: 12px;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li>类（Class）选择器<br>类选择器前面是“ . ”，类名对应HTML中的class类    <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.demo &#123;</span><br><span class="line">   color: lightcoral;</span><br><span class="line">   font-size: 24px;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
<li>ID 选择器<br>id选择器前面是“ # ”，<code>一个 html 文件中 id 只允许出现一次</code>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#Demo &#123;</span><br><span class="line">  color: lightcoral;</span><br><span class="line">  font-size: 24px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>通配符“ * ”，为HTML中所有元素添加样式  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">  color: lightcoral;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>属性选择器</p>
<ul>
<li>[attr] 属性选择器：通过 HTML 元素的 attr 属性名来定位具体 HTML 元素，把所有title属性的元素全部改变。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[title] &#123;</span><br><span class="line">    color=&quot;red&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>[标签][属性]：将所有特定标签加油特定属性的元素添加样式<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a[href] &#123;color:red;&#125; //对所有加有href的a标签添加样式</span><br></pre></td></tr></table></figure></li>
<li>[标签][属性1][属性2][…]：将同时加有属性1、属性2…的特定标签添加样式<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a[href][title]  &#123;color:red;&#125;</span><br></pre></td></tr></table></figure></li>
<li>根据具体属性值选择<br>除了选择拥有某些属性的元素，还可以进一步缩小选择范围，只选择有特定属性值的元素。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a[href=&quot;http://www.w3school.com.cn/about_us.asp&quot;] &#123;color: red;&#125;</span><br></pre></td></tr></table></figure></li>
<li>根据多个具体属性选择<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a[href=&quot;http://www.w3school.com.cn/&quot;][title=&quot;W3School&quot;] &#123;color: red;&#125;</span><br></pre></td></tr></table></figure></li>
<li>选择 titile 属性包含单词 “flower” 的元素，并设置其样式：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[title~=flower]</span><br><span class="line">&#123; </span><br><span class="line">    background-color:yellow;</span><br><span class="line">&#125;</span><br><span class="line">&lt;p title=&quot;flower nb&quot;&gt;添加成功&lt;/p&gt;</span><br><span class="line">&lt;p title=&quot;nb&quot;&gt;添加失败&lt;/p&gt;</span><br></pre></td></tr></table></figure></li>
<li>选择 lang 属性值以 “en” 开头的元素，并设置其样式：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[lang|=en]</span><br><span class="line">&#123; </span><br><span class="line">background-color:yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>设置 class 属性值以 “test” 开头的所有 div 元素的背景色：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">div[class^=&quot;test&quot;]</span><br><span class="line">&#123;</span><br><span class="line">background:#ffff00;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>设置 class 属性值以 “test” 结尾的所有 div 元素的背景色：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">div[class$=&quot;test&quot;]</span><br><span class="line">&#123;</span><br><span class="line">    background:#ffff00;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>设置 class 属性值包含 “test” 的所有 div 元素的背景色：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">div[class*=&quot;test&quot;]</span><br><span class="line">&#123;</span><br><span class="line">    background:#ffff00;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><blockquote>
<p>优先级就是分配给指定的 CSS 声明的一个权重，它由匹配的选择器中的每一种选择器类型的数值决定。</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<p>例如：a.name权重等于a标签权重加上name类名的权重和，其权重大于.name，所以两者同时存在时前者样式生效</p>
<font color="red" size=3>权重相同，<b>后来者居上</b></font>

<font size=4>!important提高到最高优先级</font>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">  color: blue !important;</span><br><span class="line">&#125;</span><br><span class="line">.demo &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;div class=&quot;demo&quot;&gt;这是一个测试内容.&lt;/div&gt; //最终的颜色为 blue</span><br></pre></td></tr></table></figure>
## 层级选择器
### 层级选择器
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;ancestor1&quot;&gt;</span><br><span class="line">  &lt;div id=&quot;parent1&quot;&gt;</span><br><span class="line">    &lt;div id=&quot;child11&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div id=&quot;child12&quot;&gt;&lt;/div&gt; </span><br><span class="line"></span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div id=&quot;parent2&quot;&gt;</span><br><span class="line">    &lt;div id=&quot;child2&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;ancestor2&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
![](https://tva1.sinaimg.cn/large/832afe33ly1gainbqrpuuj21jj0qi763.jpg)
* 兄弟元素：ancestor1 元素和 ancestor2 元素、parent1 元素和 parent2 元素，以及 child11 元素和 child12 元素。
* 父级与子级元素：
    * 如果 `` 元素是父级元素的话，那 ancestor1 元素和 ancestor2 元素就是子级元素。
    * 如果 ancestor1 元素是父级元素的话，那 parent1 元素和 parent2 元素就是子级元素。
    * 如果 parent1 元素是父级元素的话，那 child11 元素和 child12 元素就是子级元素。
* 祖先与后代元素：
    * 如果 `` 元素是祖先元素的话，那其包含的所有元素都是后代元素。
    * 如果 ancestor1 元素是祖先元素的话，那其包含的所有元素都是后代元素。
    * 如果 parent1 元素是祖先元素的话，那其包含的所有元素都是后代元素。
### 层级选择器种类
* 后代选择器
简单来说，该元素的所有后代元素。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">div span &#123;</span><br><span class="line">      background-color: lightcoral;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;span&gt;Span 1.</span><br><span class="line">      &lt;span&gt;Span 2.&lt;/span&gt;</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;span&gt;Span 3.&lt;/span&gt;</span><br><span class="line"></span><br><span class="line">这样只会影响到div里的span标签，而div外的标签则不会受到影响</span><br></pre></td></tr></table></figure>
* 子级选择器
定位该元素的所有子级元素。并不会影响孙子级元素
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">span&#123;</span><br><span class="line">	color: teal;</span><br><span class="line">&#125;</span><br><span class="line">div&gt;span&#123;</span><br><span class="line">	color: violet;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
* 相邻兄弟选择器
定位与该目标元素拥有同一个父级元素的**下一个**指定元素 <font color="red">不包括当前元素，只包括后边的元素</font>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">#a+li&#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li id=&quot;a&quot;&gt;1sadsada&lt;/li&gt; &lt;!-- 不会变色 --&gt;</span><br><span class="line">    &lt;li&gt;555555&lt;/li&gt;&lt;!-- 变色 --&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>
* 普通兄弟选择器
简单来说就是 p~codep 元素之后的元素

定位与该目标元素拥有同一个父级元素的之后任意指定元素
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  span &#123;</span><br><span class="line">    background-color: lightgreen;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  p~code &#123;</span><br><span class="line">    background-color: lightcoral;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;span&gt;This is not red.&lt;/span&gt;</span><br><span class="line">&lt;p&gt;Here is a paragraph.&lt;/p&gt;</span><br><span class="line">&lt;code&gt;Here is some code.&lt;/code&gt; 会变色</span><br><span class="line">&lt;span&gt;And here is a span.&lt;/span&gt;</span><br></pre></td></tr></table></figure>
## 组合选择器
### 组合（并集）选择器
`h1, h2, h3, h4, h5, h6 { color:blue; }` 同时定义多个标签的属性。
### 组合（交集）选择器
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p.cls &#123;</span><br><span class="line">    color: blueviolet;</span><br><span class="line">&#125;</span><br><span class="line">表示把所有class名为cls的p标签都设置成blueviolet颜色</span><br></pre></td></tr></table></figure>
## 伪类选择器
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* 所有用户指针悬停的按钮 */</span><br><span class="line">button:hover &#123;</span><br><span class="line">  color: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
### 否定伪类选择器
>:not(selector) {
    属性 : 属性值;
}
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;否定伪类选择器&lt;/title&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    .fancy &#123;</span><br><span class="line">      text-shadow: 2px 2px 3px gold;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p:not(.fancy) &#123; /*匹配class名不是fancy的p标签*/</span><br><span class="line">      color: green;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    body :not(p) &#123; /*匹配body中不是p标签的标签*/</span><br><span class="line">      text-decoration: underline;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;p&gt;我是一个段落。&lt;/p&gt;</span><br><span class="line">  &lt;p class=&quot;fancy&quot;&gt;我好看极了！&lt;/p&gt;</span><br><span class="line">  &lt;div&gt;我不是一个段落。&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
## 伪元素选择器
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* CSS3 语法 */</span><br><span class="line">选择器::伪元素 &#123;</span><br><span class="line">  属性 : 属性值;</span><br><span class="line">&#125;</span><br><span class="line">/* CSS2 过时语法 (仅用来支持 IE8) */</span><br><span class="line">选择器:伪元素 &#123;</span><br><span class="line">  属性 : 属性值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<b>伪元素选择器</b>的语法格式为 `::伪元素`，一定不要忘记 ::。伪元素选择器只能和基本选择器配合使用，并且一个选择器只能使用一个伪元素选择器，如果要为一个选择器增加多个伪元素选择器需要分别编写。
### before 和 after
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        a::after&#123;</span><br><span class="line">            content: &quot;→&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        a::before&#123;</span><br><span class="line">            content: &quot;♥&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;a href=&quot;https://antmoe.com&quot;&gt;这是一个测试内容&lt;/a&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
![](https://tva1.sinaimg.cn/large/832afe33ly1gaio8klqf7j20k50iadgw.jpg)
### first-letter
<b>::first-letter</b> 伪元素的作用是为匹配元素的文本内容的第一个字母设置样式内容。 如下示例代码展示了 **::first-letter 伪元素 ** 的用法：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p::first-letter &#123;</span><br><span class="line">  font-size: 130%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
### first-line 伪元素
<b>::first-line</b> 伪元素的作用是为匹配 HTML 元素的文本内容的第一行设置样式内容。 如下示例代码展示了 **::first-line 伪元素 ** 的用法：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.line::first-line&#123;</span><br><span class="line">            background-color: tomato;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
### ::selection 伪元素
<b>::selection</b> 伪元素的作用是匹配用户在 HTML 页面选中的文本内容（比如使用鼠标或其他选择设备选中的部分）设置高亮效果。如下示例代码展示了 **::selection 伪元素 ** 的用法：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p::selection &#123;</span><br><span class="line">    color: gold;</span><br><span class="line">    background-color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
![](https://tva1.sinaimg.cn/large/832afe33ly1gaiohh13mbg20ok0950su.gif)
<blockquote>
<p>注意：&nbsp只有一小部分 CSS 属性可以用于::selection 伪元素：</p>
<ul>
<li>color 属性</li>
<li>background-color 属性</li>
<li>cursor 属性</li>
<li>caret-color 属性</li>
<li>outline 属性</li>
<li>text-decoration 属性</li>
<li>text-emphasis-color 属性</li>
<li>text-shadow 属性</li>
</ul>
</blockquote>
<font color="red" size=5>最后感谢原创！！！支持原创</font>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CPP文件读写</title>
    <url>/posts/96d45fb1.html</url>
    <content><![CDATA[<h1 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h1><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><p><code>#include &lt;fstream&gt;</code></p>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><ul>
<li><p>声明定义：</p>
<ul>
<li>读取：ifstream inFile</li>
<li>写出：ofstream outFile</li>
</ul>
</li>
<li><p>打开文件：inFile.open(“file name”, ios::in)  (ios::in、ios::out、ios::app)</p>
<ul>
<li>判断是否打开成功：bool inFile.is_open()</li>
</ul>
</li>
<li>读出文件一行内容写入string：getline(inFile, str)</li>
<li>string写出到文件：outFile &lt;&lt; str &lt;&lt; endl;</li>
<li>关闭文件：inFile.close</li>
</ul>
<p><code>示例程序:文件夹下所有文件中csdn图片链接提取出来</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *inFolderPath = <span class="string">&quot;C:\\Users\\60116\\Desktop\\_posts\\&quot;</span>;</span><br><span class="line"><span class="comment">// const char *outFolderPath = &quot;C:\\Users\\60116\\Desktop\\out\\&quot;;</span></span><br><span class="line"></span><br><span class="line">vector&lt;string&gt; res;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dealwith</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str.<span class="built_in">find</span>(<span class="string">&quot;csdn&quot;</span>) == string::npos) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pos = str.<span class="built_in">find</span>(<span class="string">&quot;csdn&quot;</span>), startIndex = <span class="number">-1</span>, endIndex = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(pos--) &#123;</span><br><span class="line">        <span class="keyword">if</span>(str.<span class="built_in">substr</span>(pos, <span class="number">5</span>) == <span class="string">&quot;https&quot;</span>) &#123;</span><br><span class="line">            startIndex = pos;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(pos &lt; str.<span class="built_in">size</span>() &amp;&amp; pos++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(str.<span class="built_in">substr</span>(pos, <span class="number">4</span>) == <span class="string">&quot;.png&quot;</span> || str.<span class="built_in">substr</span>(pos, <span class="number">4</span>) == <span class="string">&quot;.jpg&quot;</span>) &#123;</span><br><span class="line">            endIndex = pos + <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(startIndex != <span class="number">-1</span> &amp;&amp; endIndex != <span class="number">-1</span>) &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(str.<span class="built_in">substr</span>(startIndex, endIndex - startIndex));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">(<span class="type">char</span> *inPrefix, <span class="type">char</span> *fileName)</span> </span>&#123;</span><br><span class="line">    res.<span class="built_in">push_back</span>(fileName);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> inFilePath[<span class="number">500</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(inFilePath, inPrefix);</span><br><span class="line">    <span class="built_in">strcat</span>(inFilePath, fileName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// char outFilePath[500];</span></span><br><span class="line">    <span class="comment">// strcpy(outFilePath, outPrefix);</span></span><br><span class="line">    <span class="comment">// strcat(outFilePath, fileName);</span></span><br><span class="line"></span><br><span class="line">    <span class="function">ifstream <span class="title">inFile</span><span class="params">(inFilePath, ios::in)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!inFile.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;in error&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string line;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取文件每一行数据进行处理</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">getline</span>(inFile, line)) &#123;</span><br><span class="line">        <span class="built_in">dealwith</span>(line);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    inFile.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ofstream <span class="title">outFile</span><span class="params">(<span class="string">&quot;C:\\Users\\60116\\Desktop\\out.txt&quot;</span>, ios::out)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!outFile.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;out error&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DIR *dir;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">dirent</span> *ent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((dir = <span class="built_in">opendir</span>(inFolderPath)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((ent = <span class="built_in">readdir</span>(dir)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 忽略 . 和 .. 条目</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(ent-&gt;d_name, <span class="string">&quot;.&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(ent-&gt;d_name, <span class="string">&quot;..&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">char</span> curInFolderPath[<span class="number">500</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(curInFolderPath, inFolderPath);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// char curOutFolderPath[500];</span></span><br><span class="line">            <span class="comment">// strcpy(curOutFolderPath, outFolderPath);</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">work</span>(curInFolderPath, ent-&gt;d_name);</span><br><span class="line"></span><br><span class="line">            ++cnt;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// break;</span></span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;total: &quot;</span> &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">closedir</span>(dir);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;cannot open this dir&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> p: res) &#123;</span><br><span class="line">        outFile &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    outFile.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="遍历文件夹下所有文件"><a href="#遍历文件夹下所有文件" class="headerlink" title="遍历文件夹下所有文件"></a>遍历文件夹下所有文件</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">DIR *dir;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">dirent</span> *ent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((dir = <span class="built_in">opendir</span>(inFolderPath)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((ent = <span class="built_in">readdir</span>(dir)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 忽略 . 和 .. 条目</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(ent-&gt;d_name, <span class="string">&quot;.&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(ent-&gt;d_name, <span class="string">&quot;..&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ++cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;total: &quot;</span> &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">closedir</span>(dir);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;cannot open this dir&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>文件读写</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round</title>
    <url>/posts/682df6fc.html</url>
    <content><![CDATA[<h2 id="A-Cards-for-Friends"><a href="#A-Cards-for-Friends" class="headerlink" title="A. Cards for Friends"></a>A. Cards for Friends</h2><p>给一个宽度和一个长度的蛋糕，只有为长或宽为偶数时才能切一刀数量乘以2，问给定尺寸的蛋糕能否分够k块。</p>
<p>分别对宽和长除2，只要是偶数就除，看看能除几次，得到两个次数相乘就是能分的最大数量，和k比较一下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SUP=<span class="number">0x800000</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-4</span>;</span><br><span class="line"><span class="type">int</span> num[MAXN];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		<span class="type">int</span> w,h,k;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;w&gt;&gt;h&gt;&gt;k;</span><br><span class="line">		<span class="type">int</span> a=<span class="number">1</span>,b=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(w)&#123;</span><br><span class="line">			<span class="keyword">if</span>(w&amp;<span class="number">1</span>) <span class="keyword">break</span>; </span><br><span class="line">			a*=<span class="number">2</span>;</span><br><span class="line">			w/=<span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(h)&#123;</span><br><span class="line">			<span class="keyword">if</span>(h&amp;<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">			b*=<span class="number">2</span>;</span><br><span class="line">			h/=<span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(k&lt;=a*b)  <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="B-Fair-Division"><a href="#B-Fair-Division" class="headerlink" title="B. Fair Division"></a>B. Fair Division</h2><p>给定n个数，每一个数只能是1或2，问能否把n个数分成相等的两部分</p>
<p>1数量为奇数时不可行，1数量为偶数并且2数量为偶数可行，1数量为偶数2数量为奇数不可行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SUP=<span class="number">0x800000</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-4</span>;</span><br><span class="line"><span class="type">int</span> num[MAXN];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		<span class="type">int</span> n;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">		<span class="type">int</span> cnt1=<span class="number">0</span>,cnt2=<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="type">int</span> tmp;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;tmp;</span><br><span class="line">			<span class="keyword">if</span>(tmp==<span class="number">1</span>) cnt1++;</span><br><span class="line">			<span class="keyword">if</span>(tmp==<span class="number">2</span>) cnt2++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(cnt1&amp;<span class="number">1</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(cnt1==<span class="number">0</span> &amp;&amp; cnt2&amp;<span class="number">1</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="C-Long-Jumps"><a href="#C-Long-Jumps" class="headerlink" title="C. Long Jumps"></a>C. Long Jumps</h2><p>给n个数，初始可以从1-n中任意一个位置作为起始位置，从起始开始，每次往右跳a[i]步，并且得到分数a[i]，当跳过n后结束，问最大分数</p>
<p>排序，从后往前遍历，如果当前位置往右跳后没出界则从这个位置开始的分数就是这个位置的数加上以右跳一步落点为起点的分数，过程中取分数最大值，最后输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SUP=<span class="number">0x800000</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-4</span>;</span><br><span class="line"><span class="type">int</span> num[MAXN],sc[MAXN];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		<span class="type">int</span> n,ans=<span class="number">-1</span>;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;num[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">			sc[i]=num[i];</span><br><span class="line">			<span class="keyword">if</span>(i+num[i]&lt;=n) sc[i]+=sc[i+num[i]];</span><br><span class="line">			ans=max(ans,sc[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="D-Even-Odd-Game"><a href="#D-Even-Odd-Game" class="headerlink" title="D. Even-Odd Game"></a>D. Even-Odd Game</h2><p>n个数，两个人轮流选数，a选到偶数加分，b选到奇数加分，加分为a[i]，求a开始必胜还是必败</p>
<p>排序，从后往前选，能加则加，不能加不加，最后比谁分数大</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll SUP=<span class="number">0x800000</span>;</span><br><span class="line"><span class="type">const</span> ll MAXN=<span class="number">2e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-4</span>;</span><br><span class="line">ll num[MAXN];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	ll t;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		ll n;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">		<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;num[i];</span><br><span class="line">		sort(num+<span class="number">1</span>,num+<span class="number">1</span>+n);</span><br><span class="line">		ll sc1=<span class="number">0</span>,sc2=<span class="number">0</span>,t=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(ll i=n;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">			<span class="keyword">if</span>(t==<span class="number">1</span>)&#123;</span><br><span class="line">				<span class="keyword">if</span>(!(num[i]&amp;<span class="number">1</span>)) sc1+=num[i];</span><br><span class="line">				t=<span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">if</span>(num[i]&amp;<span class="number">1</span>) sc2+=num[i];</span><br><span class="line">				t=<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(sc1==sc2) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Tie\n&quot;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(sc1&gt;sc2) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Alice\n&quot;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Bob\n&quot;</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="E-Correct-Placement"><a href="#E-Correct-Placement" class="headerlink" title="E. Correct Placement"></a>E. Correct Placement</h2><p>n组数，每组数都有一个长宽，一组数可以排在另一组数前面，条件是len(pre)&lt;len(now) and wide(pre)&lt;wide(now)或者len(pre)&lt;wide(now) &amp;&amp; wide(pre)&lt;wide(now)，对于每一个数输出一个可以排在这个数前面的数位置，多解随便输出一个位置即可</p>
<p>这道题我觉得解法很巧妙，首先每一组数保证h&gt;w，按照h大小排一下序，当h相同时按w从大到小排，然后从前往后遍历，这样保证了前面的h小于等于当前h了，只要找前面小于当前w的一个数即可，由于输出任意一个，可以维护前缀最小值，直接判断前面最小的是否小于当前w，小于就输出那个位置，否则就没有输出-1，还有需要按照初始时序列顺序输出，所以需要记录顺序，这里有一个坑就是前面的数h有可能等于当前数的h，所以前面排序规则中才让w从大到小排，这样一来，h相等时就找不到小于当前值的w了，就会记成-1</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll SUP=<span class="number">0x800000</span>;</span><br><span class="line"><span class="type">const</span> ll MAXN=<span class="number">2e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-4</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> h,w,id;</span><br><span class="line">&#125;arr[MAXN],ans[MAXN];</span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(node &amp;x)</span>&#123;</span><br><span class="line">	<span class="type">int</span> tmp=x.h;</span><br><span class="line">	x.h=x.w;</span><br><span class="line">	x.w=tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">cmp</span><span class="params">(node a,node b)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(a.h==b.h) <span class="keyword">return</span> a.w&gt;b.w;</span><br><span class="line">	<span class="keyword">return</span> a.h&lt;b.h;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">cmp2</span><span class="params">(node a,node b)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.id&lt;b.id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mi[MAXN];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	ll t;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		<span class="type">int</span> n;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;arr[i].h&gt;&gt;arr[i].w;</span><br><span class="line">			arr[i].id=i;</span><br><span class="line">			<span class="keyword">if</span>(arr[i].h&lt;arr[i].w) swap(arr[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		sort(arr+<span class="number">1</span>,arr+<span class="number">1</span>+n,cmp);</span><br><span class="line">		<span class="built_in">memset</span>(mi,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> mi);</span><br><span class="line">		<span class="type">int</span> p=<span class="number">-1</span>,tail=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			ans[++tail].id=arr[i].id;</span><br><span class="line">			<span class="keyword">if</span>(arr[i].w&gt;mi[i<span class="number">-1</span>]) ans[tail].h=p;</span><br><span class="line">			<span class="keyword">else</span> ans[tail].h=<span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">if</span>(arr[i].w&lt;mi[i<span class="number">-1</span>])&#123;</span><br><span class="line">				p=arr[i].id;</span><br><span class="line">				mi[i]=arr[i].w;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> mi[i]=mi[i<span class="number">-1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		sort(ans+<span class="number">1</span>,ans+<span class="number">1</span>+tail,cmp2);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tail;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(i!=tail) <span class="built_in">cout</span>&lt;&lt;ans[i].h&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;ans[i].h&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>div3</tag>
      </tags>
  </entry>
  <entry>
    <title>Github突然访问不到解决方案</title>
    <url>/posts/37338f48.html</url>
    <content><![CDATA[<blockquote>
<p>小林下午老老实实的写着博客，当完成后网上提交时突然发现连接不上Github，当时还没有意识到问题严重性，因为以前也经常遇到这类问题，网络不好的原因，多试几次就行了，好的，又试了N次，都说找不到仓库，好家伙！这下我傻了，在浏览器上打开Github打不开！！！我懵了，博客部署不上我的博客不久毁于一旦了？不能！！</p>
</blockquote>
<font color="black" size=5>
我不敢保证此教程能完全解决您的问题，因为网上许多教程解决了一些人的问题对我却不适用，我只是分享出我的解决方案
</font>

<h2 id="解决部署问题"><a href="#解决部署问题" class="headerlink" title="解决部署问题"></a>解决部署问题</h2><p>首先明白本地和Github取得联系是通过ssh的这把钥匙链接的，既然连接不上就说明这把钥匙有问题了，打开ssh所在文件夹，打开config文件(如果没有新建一个)，在里面添加如下内容：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">User 此处为你的github账号绑定的邮箱</span><br><span class="line">Hostname ssh.github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/id_rsa</span><br><span class="line">Port 443</span><br></pre></td></tr></table></figure><br>添加以后，再次部署没问题，问题解决👍</p>
<h2 id="解决浏览器访问不到以及ping不通Github"><a href="#解决浏览器访问不到以及ping不通Github" class="headerlink" title="解决浏览器访问不到以及ping不通Github"></a>解决浏览器访问不到以及ping不通Github</h2><p>这个我真的是尝试了好久！！网上有很多教程，别看那么多，其实他们百分之八十都是同样的内容，让你往hosts文件后面加两句话，但是它们却都没有告诉你这俩句话不是对任何人都适用的，可能只是对他一个人有用！首先我们要明白我们为什么访问不到Github，我们上网时网络有一个DNS服务的东西，它会把你访问的那个域名也就是www.<em>**</em>.com的东西转换成IP地址，然后这个IP地址指向所对应的服务器，然后我们就能成功上网，现在访问不到Github就是因为DNS失效了，他不能帮你转换成IP地址或是它转换错了！那么我们就要自己来转换，如何转换呢？电脑里面都有一个叫hosts的文件，这个文件是干嘛的？就是用来解决DNS失效的问题的，hosts文件默认是一堆说明，#号后面是注释的意思，我们就要在这里面填上对应的IP地址和其域名，当你访问对应的域名时计算机会自动帮你转换成前面的IP，这也就是为什么那么多教程让你改hosts文件加这两行的原因</p>
<h2 id="如何改hosts"><a href="#如何改hosts" class="headerlink" title="如何改hosts"></a>如何改hosts</h2><p>登录网址<a href="https://fastly.net.ipaddress.com/github.global.ssl.fastly.net">点击我</a>，在里面找到对应的IP<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMjI0MTk1MzA0MTAx" alt="">hosts文件的更改需要权限，这个如果不会自行百度<br>然后在hosts文件中加上你查到的IP，在后面加上github.com<br>之后登录网址<a href="https://ip.cha127.com/github.global.ssl.fastly.net.html">点击我</a><br>在里面找到对应IP，然后在hosts文件后面添加上对应IP并在后面加上~github.global.ssl.fastly.net~<br><strong>记得域名与IP之间隔一个空格</strong><br>之后再ping github成功了</p>
<h2 id="解决浏览器访问不到github"><a href="#解决浏览器访问不到github" class="headerlink" title="解决浏览器访问不到github"></a>解决浏览器访问不到github</h2><p>ping通后可是浏览器还是访问不到github，只不过错误变了，原来是网页访问不到，现在是<del>您的连接并不安全</del>如何解决这个问题？我在网上找到的<a href="https://blog.csdn.net/sinat_35811978/article/details/80289219">原文</a><br>删除上面让你添加的github.com的那一行，然后再访问就行了…….但是又ping不通了，这个我也不知道为啥，俩者好像没有关系😳，不过能访问就行</p>
<font color="red" size=6>Ending~ 撒花</font>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>ICPC2021网络赛2</title>
    <url>/posts/c35e724f.html</url>
    <content><![CDATA[<h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><h2 id="L-Euler-Function"><a href="#L-Euler-Function" class="headerlink" title="L Euler Function"></a>L Euler Function</h2><p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/image-20210930092043674.png" alt="image-20210930092043674"></p>
<p>题目大意：</p>
<p>给定n个数字，每一个数字不超过100，m次询问</p>
<ol>
<li>把一个区间的所有数字乘以w(w&lt;=100)</li>
<li>求一个区间所有数的欧拉函数和(mod 998244353)</li>
</ol>
<p>首先明白一个性质：</p>
<p>$phi(n)=n/(p1<em>p2</em>p3…)<em>(p1-1)</em>(p2-1)*(p3-1)…$</p>
<p>而n也可以表示为$p1<em>p2</em>p3…$</p>
<p>所以$phi(n)=(p1-1)<em>(p2-1)</em>(p3-1)…$</p>
<p>那么$phi(w*n)$的值怎么求？</p>
<p>把w质因子分解，可以发现如果n和w有同一个质因子c，那么$phi(c<em>n)=phi(n)</em>c$，如果存在一个质因子w有，n没有，那么$phi(c<em>n)=phi(n)</em>(c-1)$，发现w的质因子在要乘的区间中都有，那么这道题就变成了简单的区间乘法，区间询问，但是区间中不一定包含w的所有质因子，所以就要去找到那些不包含w的某个质因子的位置，把这些位置单独拿出来乘以(c-1)，如何找到这些位置呢？</p>
<p>可以考虑开一个vis数组，vis[x]标记一个区间是否都存在质因子x，那么每次做区间乘法时，就可以把w质因子分解，对于每一个质因子c，都去线段树中找，如果一个区间被vis标记了，那么这个区间都存在这个质因子c，就可以直接进行区间修改，否则如果这个区间没有被标记，就向左右子树都找，直到找到这个位置</p>
<p>这里的vis合并时需要遍历25个质因子，进行与的操作，总时复：(O(mlogn*25))，时间快要超时，所以可以把vis数组改成bitset，除以一个32的常数，稳过</p>
<p><code>注意区间乘法lazy数组初始化为1！！！</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls u&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs u&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> arr[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> l,r;</span><br><span class="line">	ll val;</span><br><span class="line">	<span class="built_in">bitset</span>&lt;<span class="number">100</span>&gt; bit;</span><br><span class="line">&#125;tr[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line">ll lazy[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">getphi</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">	<span class="type">int</span> res=x;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(x);i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(x%i==<span class="number">0</span>)&#123;</span><br><span class="line">			res=res*(i<span class="number">-1</span>)/i;</span><br><span class="line">			<span class="keyword">while</span>(x%i==<span class="number">0</span>) x/=i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;<span class="number">1</span>) res=res*(x<span class="number">-1</span>)/x;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> pr[<span class="number">100</span>],tot;</span><br><span class="line"><span class="built_in">bitset</span>&lt;<span class="number">100</span>&gt; st[N];</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">100</span>;i++)&#123;</span><br><span class="line">		<span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;=<span class="built_in">sqrt</span>(i);j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(i%j==<span class="number">0</span>)&#123;</span><br><span class="line">				flag=<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!flag) pr[++tot]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=tot;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(arr[i]%pr[j]==<span class="number">0</span>)&#123;</span><br><span class="line">				st[i][pr[j]]=<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">pushup</span><span class="params">(<span class="type">int</span> u)</span>&#123;</span><br><span class="line">	tr[u].bit=tr[ls].bit&amp;tr[rs].bit;	<span class="comment">//维护标记</span></span><br><span class="line">	tr[u].val=(tr[ls].val+tr[rs].val)%mod;	<span class="comment">//维护区间欧拉函数和</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">pushdown</span><span class="params">(<span class="type">int</span> u)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(lazy[u]!=<span class="number">1</span>)&#123;</span><br><span class="line">		lazy[ls]=lazy[u]*lazy[ls]%mod;</span><br><span class="line">		lazy[rs]=lazy[u]*lazy[rs]%mod;</span><br><span class="line">		tr[ls].val=tr[ls].val*lazy[u]%mod;</span><br><span class="line">		tr[rs].val=tr[rs].val*lazy[u]%mod;</span><br><span class="line">		lazy[u]=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">	lazy[u]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">		tr[u]=&#123;l,r,getphi(arr[l]),st[l]&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		tr[u]=&#123;l,r&#125;;</span><br><span class="line">		build(ls,l,mid);</span><br><span class="line">		build(rs,mid+<span class="number">1</span>,r);</span><br><span class="line">		pushup(u);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> c)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(tr[u].l&gt;=l &amp;&amp; tr[u].r&lt;=r &amp;&amp; tr[u].bit[c])&#123;</span><br><span class="line">		lazy[u]=lazy[u]*c%mod;</span><br><span class="line">		tr[u].val=tr[u].val*c%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(tr[u].l==tr[u].r)&#123;</span><br><span class="line">		tr[u].val=tr[u].val*(c<span class="number">-1</span>)%mod;</span><br><span class="line">		tr[u].bit[c]=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		pushdown(u);</span><br><span class="line">		<span class="type">int</span> mid=tr[u].l+tr[u].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(l&lt;=mid) update(ls,l,r,c);</span><br><span class="line">		<span class="keyword">if</span>(r&gt;mid) update(rs,l,r,c);</span><br><span class="line">		pushup(u);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">ll <span class="title function_">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=tr[u].l &amp;&amp; tr[u].r&lt;=r) <span class="keyword">return</span> tr[u].val;</span><br><span class="line">	pushdown(u);</span><br><span class="line">	<span class="type">int</span> mid=(tr[u].l+tr[u].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	ll res=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=mid) res=(res+query(ls, l, r))%mod;</span><br><span class="line">	<span class="keyword">if</span>(r&gt;mid) res=(res+query(rs, l, r))%mod;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">signed</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;arr[i];</span><br><span class="line">	init();</span><br><span class="line">	build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="type">int</span> op,l,r,w;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;op;</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r&gt;&gt;w;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">25</span>;i++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(w%pr[i]==<span class="number">0</span>)&#123;</span><br><span class="line">					<span class="keyword">while</span>(w%pr[i]==<span class="number">0</span>)&#123;</span><br><span class="line">						w/=pr[i];</span><br><span class="line">						update(<span class="number">1</span>,l,r,pr[i]);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;query(<span class="number">1</span>,l,r)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5 5</span></span><br><span class="line"><span class="comment">5 1 6 2 13</span></span><br><span class="line"><span class="comment">0 5 5 25</span></span><br><span class="line"><span class="comment">0 5 5 18</span></span><br><span class="line"><span class="comment">1 3 5</span></span><br><span class="line"><span class="comment">0 1 3 24</span></span><br><span class="line"><span class="comment">1 3 4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>第二种写法是用并查集维护一个区间中是否所有数字都可以被质因子c整除，$fa[i][j]$表示第i个质因子第j个位置的数字往右最多可以延申到哪一个位置，假如可以延伸到k，那么[当前位置,k-1]的区间的答案可以直接乘以$pr[i]$，然后把第k个位置单独乘以$c-1$，如此往复，去进行区间修改即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls u&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs u&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> arr[N],fa[<span class="number">26</span>][N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> l,r;</span><br><span class="line">	ll val;</span><br><span class="line">&#125; tr[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line">ll lazy[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">getphi</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">	<span class="type">int</span> res=x;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;=<span class="built_in">sqrt</span>(x); i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(x%i==<span class="number">0</span>) &#123;</span><br><span class="line">			res=res*(i<span class="number">-1</span>)/i;</span><br><span class="line">			<span class="keyword">while</span>(x%i==<span class="number">0</span>) x/=i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;<span class="number">1</span>) res=res*(x<span class="number">-1</span>)/x;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">pushup</span><span class="params">(<span class="type">int</span> u)</span> &#123;</span><br><span class="line">	tr[u].val=(tr[ls].val+tr[rs].val)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">pushdown</span><span class="params">(<span class="type">int</span> u)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(lazy[u]!=<span class="number">1</span>) &#123;</span><br><span class="line">		lazy[ls]=lazy[u]*lazy[ls]%mod;</span><br><span class="line">		lazy[rs]=lazy[u]*lazy[rs]%mod;</span><br><span class="line">		tr[ls].val=tr[ls].val*lazy[u]%mod;</span><br><span class="line">		tr[rs].val=tr[rs].val*lazy[u]%mod;</span><br><span class="line">		lazy[u]=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span> &#123;</span><br><span class="line">	lazy[u]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(l==r) tr[u]= &#123;l,r,getphi(arr[l])&#125;;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		tr[u]= &#123;l,r&#125;;</span><br><span class="line">		build(ls,l,mid);</span><br><span class="line">		build(rs,mid+<span class="number">1</span>,r);</span><br><span class="line">		pushup(u);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">ll <span class="title function_">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=tr[u].l &amp;&amp; tr[u].r&lt;=r) <span class="keyword">return</span> tr[u].val;</span><br><span class="line">	pushdown(u);</span><br><span class="line">	<span class="type">int</span> mid=(tr[u].l+tr[u].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	ll res=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=mid) res=(res+query(ls, l, r))%mod;</span><br><span class="line">	<span class="keyword">if</span>(r&gt;mid) res=(res+query(rs, l, r))%mod;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> pr[<span class="number">100</span>],tot;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;=<span class="number">100</span>; i++) &#123;</span><br><span class="line">		<span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>; j&lt;=<span class="built_in">sqrt</span>(i); j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(i%j==<span class="number">0</span>) flag=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!flag) pr[++tot]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=tot; i++) &#123;	<span class="comment">//初始化n个位置的fa数组</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=n; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(arr[j]%pr[i]==<span class="number">0</span>) fa[i][j]=j+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">mul</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> c)</span> &#123;	<span class="comment">//线段树区间乘法</span></span><br><span class="line">	<span class="keyword">if</span>(tr[u].l&gt;=l &amp;&amp; tr[u].r&lt;=r) &#123;</span><br><span class="line">		lazy[u]=lazy[u]*c%mod;</span><br><span class="line">		tr[u].val=tr[u].val*c%mod;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		pushdown(u);</span><br><span class="line">		<span class="type">int</span> mid=tr[u].l+tr[u].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(l&lt;=mid) mul(ls,l,r,c);</span><br><span class="line">		<span class="keyword">if</span>(r&gt;mid) mul(rs,l,r,c);</span><br><span class="line">		pushup(u);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> c,<span class="type">int</span> x)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(x==fa[c][x]) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">return</span> fa[c][x]=find(c,fa[c][x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> c)</span> &#123;	<span class="comment">//[l,r]区间乘以pr[c]</span></span><br><span class="line">	<span class="type">int</span> k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=l; ; i=k+<span class="number">1</span>) &#123;</span><br><span class="line">		k=find(c,i);</span><br><span class="line">		<span class="keyword">if</span>(k&gt;r) &#123;</span><br><span class="line">			mul(<span class="number">1</span>,i,r,pr[c]);	<span class="comment">//最后一个区间特判一下</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span>(k&gt;i) mul(<span class="number">1</span>,i,k<span class="number">-1</span>,pr[c]);</span><br><span class="line">			fa[c][i]=k+<span class="number">1</span>;	<span class="comment">//并查集合并</span></span><br><span class="line">			mul(<span class="number">1</span>,k,k,pr[c]<span class="number">-1</span>);	<span class="comment">//单独相乘</span></span><br><span class="line">			fa[c][k]=k+<span class="number">1</span>;	<span class="comment">//并查集合并</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> w)</span> &#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">25</span>; i++) &#123;	<span class="comment">//第i个质因子有几个乘几次</span></span><br><span class="line">		<span class="keyword">while</span>(w%pr[i]==<span class="number">0</span>) &#123;</span><br><span class="line">			merge(l,r,i);</span><br><span class="line">			w/=pr[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">signed</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;arr[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=<span class="number">25</span>; j++) fa[j][i]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=<span class="number">25</span>; j++) fa[j][n+<span class="number">1</span>]=n+<span class="number">1</span>;	<span class="comment">//因为fa数组指向的位置是(最后一个包含质因子c的下一个位置)，所以n+1也要进行初始化</span></span><br><span class="line">	init();</span><br><span class="line">	build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">	<span class="keyword">while</span>(m--) &#123;</span><br><span class="line">		<span class="type">int</span> op,l,r,w;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;op;</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r&gt;&gt;w;</span><br><span class="line">			update(l,r,w);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;query(<span class="number">1</span>,l,r)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5 5</span></span><br><span class="line"><span class="comment">5 1 6 2 13</span></span><br><span class="line"><span class="comment">0 5 5 25</span></span><br><span class="line"><span class="comment">0 5 5 18</span></span><br><span class="line"><span class="comment">1 3 5</span></span><br><span class="line"><span class="comment">0 1 3 24</span></span><br><span class="line"><span class="comment">1 3 4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="M-Addition"><a href="#M-Addition" class="headerlink" title="M Addition"></a>M Addition</h2><p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/image-20210930102733632.png" alt="image-20210930102733632"></p>
<p>可以借位的模拟题</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> s[N];</span><br><span class="line"><span class="type">int</span> a[N],b[N];</span><br><span class="line"><span class="type">int</span> ans[N];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;s[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;b[i];</span><br><span class="line">	<span class="type">int</span> flag=<span class="number">0</span>,pre;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i] &amp;&amp; b[i])&#123;</span><br><span class="line">				ans[i]=<span class="number">0</span>;</span><br><span class="line">				flag=<span class="number">1</span>;</span><br><span class="line">				pre=s[i];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>((a[i] &amp;&amp; !b[i]) || (!a[i] &amp;&amp; b[i])) ans[i]=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> ans[i]=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(s[i]==pre)&#123;</span><br><span class="line">				<span class="keyword">if</span>(!a[i] &amp;&amp; !b[i]) flag=<span class="number">0</span>;</span><br><span class="line">				<span class="keyword">if</span>((a[i] &amp;&amp; b[i]) || (!a[i] &amp;&amp; !b[i])) ans[i]=<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>((a[i] &amp;&amp; !b[i]) || (!a[i] &amp;&amp; b[i])) ans[i]=<span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">if</span>(a[i] || b[i]) flag=<span class="number">0</span>;</span><br><span class="line">				<span class="keyword">if</span>(a[i] &amp;&amp; b[i]) ans[i]=<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>((a[i] &amp;&amp; !b[i]) || (!a[i] &amp;&amp; b[i])) ans[i]=<span class="number">0</span>;</span><br><span class="line">				<span class="keyword">else</span> ans[i]=<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(i!=n) <span class="built_in">cout</span>&lt;&lt;ans[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;ans[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>线段树+欧拉函数</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP</title>
    <url>/posts/ad32db8f.html</url>
    <content><![CDATA[<blockquote>
<p>暑假学习了KMP，奈何掌握不深，现在又来复习，结果又是从零开始</p>
</blockquote>
<h2 id="什么是KMP？"><a href="#什么是KMP？" class="headerlink" title="什么是KMP？"></a>什么是KMP？</h2><p>现在有一个原字符串，再给你一段模式串，问你在原字符串中是否存在一段子串等于模式串，或者模式串在原串中出现几次？</p>
<p>BF算法，也就是人人都会的指针回朔暴力算法，略过</p>
<p>原串： ABABABAABA  （i）</p>
<p>模式串： ABAA （j）</p>
<p>当匹配时第一个失配的位置是3(下标从0开始)，然后朴素做法是把i和j指针都回朔，但其实可以利用之前已经匹配的信息的，可以找到当前失配字符之前的最大公共前后缀长度，假设长度为k，则s[i-k]…s[i-1]==t[j-k]…t[j-1]，而t[0]…t[k-1]==t[j-k]…t[j-1]，所以s[i-k]..s[i-1]==t[0]…t[k-1]，所以只需要把j移到k位置就可以了，i指针不回朔，这样一来就只要j指针回朔，而且大概率没有回朔到0，省去大量时间，那么问题就来了，怎么找到模式串中每一个位置的k呢？</p>
<p>前面已经说了，k是每一个位置之前字符串(不包括k位置)的最长公共前后缀长度，而公共前后缀与原串无关，只是在模式串中求即可</p>
<h2 id="求解NEXT"><a href="#求解NEXT" class="headerlink" title="求解NEXT"></a>求解NEXT</h2><p>用next[i]表示i位置之前字符串的最长公共前后缀，所以求解next数组其实就是求模式串每一个前缀子串的最大公共前后缀！</p>
<p>ABABABAB</p>
<p>这段字符串的next数组就是：-1 0 0 1 2 3 4 5</p>
<p>先来看代码吧</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">get_next</span><span class="params">(<span class="type">int</span> len)</span>&#123;</span><br><span class="line">	<span class="type">int</span> i=<span class="number">0</span>, j=<span class="number">-1</span>;  <span class="comment">//这里j是初始化为-1！</span></span><br><span class="line">    ne[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;len)&#123;</span><br><span class="line">		<span class="keyword">if</span>(j==<span class="number">-1</span> || ch[i]==ch[j])&#123;</span><br><span class="line">			++i; ++j;</span><br><span class="line">			ne[i]=j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> j=ne[j];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先明白next[i]表示的是t[0]…t[i-1]的最大公共前后缀，是不包括t[i]的！！！</p>
<p>因此next[0]就初始化为-1，然后next[1]一定是0，因为就有一个字符，首先当两个位置字符相同时很好处理，next[i]=j+1，但是当位置字符不一样时为什么j=ne[j]呢？想一下，求next数组本质就是自己和自己匹配嘛(也就是模式串中抽象出来一个模式串)，当两个位置字符失配时，只需要把j移到之前的最大公共前后缀位置就可以了，而最大位置就是next[j]</p>
<p>明白了这个next就求出来了</p>
<font color="red" size=5>需要说明的是，next数组真正有效的部分是从1到n的，也就是原串从0开始，而next数组往后移了一位</font>

<h2 id="求解KMP"><a href="#求解KMP" class="headerlink" title="求解KMP"></a>求解KMP</h2><p>接下来就好办了，和求next差不多的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">kmp</span><span class="params">(<span class="type">int</span> len1, <span class="type">int</span> len2)</span>&#123;</span><br><span class="line">	<span class="type">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>, cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;len2)&#123;</span><br><span class="line">		<span class="keyword">if</span>(j==<span class="number">-1</span> || ch1[j]==ch2[i])&#123;</span><br><span class="line">			++i; ++j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> j=ne[j];</span><br><span class="line">		<span class="keyword">if</span>(j==len1) cnt++;  <span class="comment">// 匹配到</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OK，到这里就讲完了</p>
<h2 id="全代码"><a href="#全代码" class="headerlink" title="全代码"></a>全代码</h2><p>模板题：<a href="https://vjudge.net/contest/388842#problem/H"> <strong>KMP算法</strong></a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> ne[MAXN];</span><br><span class="line"><span class="type">char</span> ch1[MAXN],ch2[MAXN];</span><br><span class="line"><span class="type">void</span> <span class="title function_">get_next</span><span class="params">(<span class="type">int</span> len)</span>&#123;</span><br><span class="line">	<span class="type">int</span> i=<span class="number">0</span>, j=<span class="number">-1</span>;</span><br><span class="line">	ne[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;len)&#123;</span><br><span class="line">		<span class="keyword">if</span>(j==<span class="number">-1</span> || ch1[i]==ch1[j])&#123;</span><br><span class="line">			++i; ++j;</span><br><span class="line">			ne[i]=j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> j=ne[j];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">kmp</span><span class="params">(<span class="type">int</span> len1, <span class="type">int</span> len2)</span>&#123;</span><br><span class="line">	<span class="type">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>, cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;len2)&#123;</span><br><span class="line">		<span class="keyword">if</span>(j==<span class="number">-1</span> || ch1[j]==ch2[i])&#123;</span><br><span class="line">			++i; ++j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> j=ne[j];</span><br><span class="line">		<span class="keyword">if</span>(j==len1) cnt++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;ch1&gt;&gt;ch2;</span><br><span class="line">		<span class="type">int</span> len1=<span class="built_in">strlen</span>(ch1), len2=<span class="built_in">strlen</span>(ch2);</span><br><span class="line">		get_next(len1);</span><br><span class="line">		<span class="type">int</span> cnt=kmp(len1, len2);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;cnt&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>next数组并不是最优的，当一个模式串所有字符都相同，比如T=(aaaaaaaa)，那么求解出来的next数组表示的是当前位置之前字符串的最大前后缀，因为字符都相同，那么所有的i，ne[i]=i-1，但实际上所有字符都是相同的，当前字符失配的话那就可以直接把指针回朔到最前面了，也就是所有的nextval[i]=ne[0]=-1，这样进行下次循环时原串指针直接后移且模式串指针回朔到第一个位置，省去了一个一个位置回朔的时间</p>
<h2 id="求解nextval数组"><a href="#求解nextval数组" class="headerlink" title="求解nextval数组"></a>求解nextval数组</h2><p>当前位置的next数组值为下标的前一个位置的字符如果和当前字符一样，则当前位置的nextval值就是前面位置的nextval值，否则就是当前位置的next数组值，初始化第一个位置的nextval值为-1</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">get_nextval</span><span class="params">(<span class="type">int</span> len)</span>&#123;</span><br><span class="line">	<span class="type">int</span> i=<span class="number">0</span>, j=<span class="number">-1</span>;</span><br><span class="line">	nextval[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;len)&#123;</span><br><span class="line">		<span class="keyword">if</span>(j==<span class="number">-1</span> || ch1[i]==ch1[j])&#123;</span><br><span class="line">			++i; ++j;</span><br><span class="line">            <span class="comment">// 和求解next数组唯一不一样的地方</span></span><br><span class="line">			<span class="keyword">if</span>(ch1[i]!=ch1[j]) nextval[i]=j;  </span><br><span class="line">			<span class="keyword">else</span> nextval[i]=nextval[j]; <span class="comment">//当前位置和next[i]的字符相同时，则不需要回朔到next[i]位置，因为这个位置的字符一定会失配，所以让nextval[i]直接指向nextval[next[i]]，当没有跳步回朔操作时next和nextval值是一样的</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> j=nextval[j];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以先通过求解出next数组，然后求解出nextval数组</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>LCA最小公共祖先</title>
    <url>/posts/98bfed5f.html</url>
    <content><![CDATA[<h2 id="LCA-公共祖先"><a href="#LCA-公共祖先" class="headerlink" title="LCA 公共祖先"></a>LCA 公共祖先</h2><p>什么是最小公共祖先，顾名思义就是俩点最近的公共祖先</p>
<p><img src="https://cdn.luogu.com.cn/upload/pic/2282.png" alt=""></p>
<p>如图所示：</p>
<ol>
<li>2和5的最小公共祖先就是4</li>
<li>2和1的最小公共祖先就是4</li>
<li>3和5的最小公共祖先是1</li>
</ol>
<p>那么怎么求呢？</p>
<p>先介绍两种朴素的做法，<del>也就是超时的做法🐷</del></p>
<p>第一种： <code>向上标记法</code></p>
<p>想求两个点的最小公共祖先可以先从其中一个点往上找父亲结点，直到根节点，把路径标记一下，然后从另一个点开始做同样的操作，当遇到已经标记过的点的时候就停下来，这个点一定是最小公共祖先（ 每次查询时间复杂度：O(n) ）</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">500100</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vt[MAXN];</span><br><span class="line"><span class="type">int</span> fa[MAXN];</span><br><span class="line"><span class="type">bool</span> vis[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> len=vt[u].<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">		<span class="type">int</span> v=vt[u][i];</span><br><span class="line">		<span class="keyword">if</span>(v==fa[u]) <span class="keyword">continue</span>;</span><br><span class="line">		fa[v]=u;</span><br><span class="line">		<span class="built_in">dfs</span>(v);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">	<span class="keyword">while</span>(l)&#123;</span><br><span class="line">		vis[l]=<span class="number">1</span>;</span><br><span class="line">		l=fa[l];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(!vis[r]) r=fa[r];</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> n,m,s;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">		<span class="type">int</span> x,y;</span><br><span class="line">		cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">		vt[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">		vt[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfs</span>(s); <span class="comment">//找到每一个点的父亲结点是谁</span></span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="type">int</span> l,r;</span><br><span class="line">		cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">		cout&lt;&lt;<span class="built_in">lca</span>(l,r)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>
<p>第二种： <code>利用深度法</code></p>
<p>在上面的dfs函数稍微改一下，得到每一个点到根节点的深度（从0开始），当询问两个点的lca时，我们先把深度大的那个点网上搜，直到两个点的深度相同，深度相同后，两个点一起往上搜直到两个点合并到一起，那么这个点就是lca</p>
<h3 id="CODE-1"><a href="#CODE-1" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">500100</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; vt[MAXN];</span><br><span class="line"><span class="type">int</span> fa[MAXN],dep[MAXN];</span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> d)</span>&#123;</span><br><span class="line">	dep[u]=d; <span class="comment">//处理出每一个点的深度</span></span><br><span class="line">	<span class="type">int</span> len=vt[u].size();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">		<span class="type">int</span> v=vt[u][i];</span><br><span class="line">		<span class="keyword">if</span>(v==fa[u]) <span class="keyword">continue</span>;</span><br><span class="line">		fa[v]=u;</span><br><span class="line">		dfs(v,d+<span class="number">1</span>); <span class="comment">//子节点深度加一</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">lca</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(dep[l]&lt;dep[r]) swap(l,r); <span class="comment">//保证l是深度大的那个点</span></span><br><span class="line">	<span class="keyword">while</span>(dep[l]&gt;dep[r]) l=fa[l]; <span class="comment">//从深度大的那个开始往上走</span></span><br><span class="line">	<span class="keyword">while</span>(l!=r)&#123; <span class="comment">//一起往上</span></span><br><span class="line">		l=fa[l];</span><br><span class="line">		r=fa[r];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> n,m,s;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;s;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">		<span class="type">int</span> x,y;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">		vt[x].push_back(y);</span><br><span class="line">		vt[y].push_back(x);</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(s,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="type">int</span> l,r;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;lca(l,r)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>
<h2 id="倍增找LCA"><a href="#倍增找LCA" class="headerlink" title="倍增找LCA"></a>倍增找LCA</h2><p> 详细讲解：</p>
<p><a href="https://www.bilibili.com/video/BV155411h7CG?p=2">视频</a></p>
<p><a href="https://www.cnblogs.com/darlingroot/p/10597611.html">LCA博客讲解</a></p>
<h2 id="P3379-【模板】最近公共祖先（LCA）"><a href="#P3379-【模板】最近公共祖先（LCA）" class="headerlink" title="P3379 【模板】最近公共祖先（LCA）"></a><a href="https://www.luogu.com.cn/problem/P3379">P3379 【模板】最近公共祖先（LCA）</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">500010</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; ve[MAXN];</span><br><span class="line"><span class="type">int</span> dep[MAXN],f[MAXN][<span class="number">22</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa, <span class="type">int</span> d)</span>&#123;  <span class="comment">//找到每一个节点的父亲节点以及深度大小</span></span><br><span class="line">	f[u][<span class="number">0</span>]=fa;  <span class="comment">//每一个节点往上走2^0步就是父亲节点</span></span><br><span class="line">	dep[u]=d;  <span class="comment">//深度</span></span><br><span class="line">	<span class="type">int</span> sz=ve[u].size();  <span class="comment">//遍历后继节点</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;sz;i++)&#123;</span><br><span class="line">		<span class="type">int</span> v=ve[u][i];  </span><br><span class="line">		<span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;  <span class="comment">//记住不能往回走</span></span><br><span class="line">		dfs(v, u, d+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">bz</span><span class="params">(<span class="type">int</span> n)</span>&#123;  <span class="comment">//预处理出每一个节点往上2^i步后到达的节点</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">22</span>;i++)&#123;  <span class="comment">//2^22 &gt; 4e7，能处理最大深度不超过4e7的树</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> u=<span class="number">1</span>;u&lt;=n;u++)&#123;</span><br><span class="line">			f[u][i]=f[f[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];  <span class="comment">//当前节点向上走2^i步就等于先向上走2^(i-1)再向上走2^(i-1)步</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">lca</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(dep[x]&lt;dep[y]) swap(x,y);  <span class="comment">//保证x的深度大于y</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=log2(dep[x]-dep[y]);i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">		<span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;i)&lt;=dep[x]-dep[y]) x=f[x][i]; <span class="comment">//注意dep[x]-dep[y]时刻在变化，也正是因为这个所以dep[x]一定最后和dep[y] </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(x==y) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=log2(dep[x]);i&gt;=<span class="number">0</span>;i--)&#123;  <span class="comment">//此时两个节点的深度相同，就需要一起往上面走</span></span><br><span class="line">		<span class="keyword">if</span>(f[x][i]!=f[y][i])&#123;  <span class="comment">//一起走2^i后不能相同，因为相同了可能导致超过（最近）公共祖先！</span></span><br><span class="line">			x=f[x][i];</span><br><span class="line">			y=f[y][i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//走完后一定到达了最近公共祖先的子节点，因为这种方法本质上就是二分</span></span><br><span class="line">	<span class="keyword">return</span> f[x][<span class="number">0</span>]; <span class="comment">//父节点就是lca</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>); <span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> n,m,s;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;s;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">		<span class="type">int</span> a,b;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">		ve[a].push_back(b);</span><br><span class="line">		ve[b].push_back(a);</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(s,<span class="number">0</span>,<span class="number">0</span>);  <span class="comment">//这里很巧妙哦，假设还有一个0节点，而0是s的父亲节点，这样每一个节点往上走2^i就算走过了根节点也会是0</span></span><br><span class="line">	bz(n);  <span class="comment">//预处理</span></span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="type">int</span> x,y;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;lca(x,y)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-1915-最美字符串数量</title>
    <url>/posts/46a8a662.html</url>
    <content><![CDATA[<h2 id="最美子字符串的数目"><a href="#最美子字符串的数目" class="headerlink" title="最美子字符串的数目"></a><a href="https://leetcode-cn.com/problems/number-of-wonderful-substrings/">最美子字符串的数目</a></h2><p>美丽的字符串定义为该字符串<strong>至多一个</strong>字母出现<strong>奇数</strong>次，给定一个字符串求该字符串包含多少个美丽的子串。（该字符串由前十个小写英文字母组成）</p>
<p>由于只会由前10个字母组成，所以可以把所有的字符当作一个二进制位，0表示该字符出现了偶数次，1代表字符出现了奇数次，那么现在好的状态就变成了0和2^i^，我们从前往后遍历字符串，求一个前缀异或状态，两个前缀异或起来即可得到一段区间的状态，那么问题就转化为了所有的位置前面有多少个状态和当前状态异或后是一个好的状态，如此我们就可以开一个数组cnt[i]记录从起始位置到当前位置i状态出现的次数，ans+=cnt[good^state]即是答案，good是一个好的状态，state是当前状态。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">wonderfulSubstrings</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">		<span class="type">long</span> <span class="type">long</span> res=<span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> cnt[<span class="number">1025</span>];</span><br><span class="line">		<span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span> cnt);</span><br><span class="line">		vector&lt;<span class="type">int</span>&gt; good;</span><br><span class="line">		good.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) good.<span class="built_in">push_back</span>(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">		<span class="type">int</span> len=word.<span class="built_in">size</span>(),state=<span class="number">0</span>;</span><br><span class="line">		cnt[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">			<span class="type">int</span> now=<span class="number">1</span>&lt;&lt;(word[i]-<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">			state^=now;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">auto</span> p:good)&#123;</span><br><span class="line">				res+=cnt[p^state];</span><br><span class="line">			&#125;</span><br><span class="line">			cnt[state]++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>状压+前缀异或和</tag>
      </tags>
  </entry>
  <entry>
    <title>Millionaire Madness</title>
    <url>/posts/8a005a29.html</url>
    <content><![CDATA[<blockquote>
<p>计蒜客之前比赛的一道题目，记录一下</p>
</blockquote>
<h2 id="G-Millionaire-Madness"><a href="#G-Millionaire-Madness" class="headerlink" title="G Millionaire Madness"></a>G Millionaire Madness</h2><blockquote>
<p>A close friend of yours, a duck with financial problems, has requested your help with a matter that will help him pay off his debts. He is the nephew of an extremely wealthy duck, who has a large vault, filled with mountains of coins. This wealthy duck has a certain coin in his possession which has a lot of sentimental value to him. Usually, it is kept under a protective glass dome on a velvet cushion.However, during a recent relocating of the coins in the vault, the special coin was accidentally moved into the vault, leading to an extremely stressful situation for your friend’s uncle. Luckily, the coin has recently been located. Unfortunately, it is completely opposite to the entrance to the vault, and due to the mountains of coins inside the vault, actually reaching the coin is no simple task.He is therefore willing to pay your friend to retrieve this coin, provided that he brings his own equipment to scale the mountains of coins. Your friend has decided he will bring a ladder, but he is still uncertain about its length. While a longer ladder means that he can scale higher cliffs, it also costs more money. He therefore wants to buy the shortest ladder such that he can reach the special coin, so that he has the largest amount of money left to pay off his debts.The vault can be represented as a rectangular grid of stacks of coins of various heights (in meters), with the entrance at the north west corner (the first height in the input, the entrance to the vault is at this height as well) and the special coin at the south east corner (the last height in the input). Your avian companion has figured out the height of the coins in each of these squares. From a stack of coins he can attempt to climb up or jump down to the stack immediately north, west, south or east of it. Because your friend cannot jump or fly (he is a very special kind of duck that even wears clothes), successfully performing a climb of n<em>n</em> meters will require him to bring a ladder of at least n<em>n</em> meters. He does not mind jumping down, no matter the height; he just lets gravity do all the work. </p>
<p><strong>Input</strong></p>
<p>The first line contains two integers: the length M<em>M</em>, and the width N<em>N</em> of the vault, satisfying 1 \leq M,N \leq 10001≤<em>M</em>,<em>N</em>≤1000.The following M<em>M</em> lines each contain N<em>N</em> integers. Each integer specifies the height of the pile of coins in the vault at the corresponding position. (The first line describes the north-most stacks from west to east; the last line describes the south-most stacks from west to east). The heights are given in meters and all heights are at least 00 and at most 10^9109 (yes, your friend’s uncle is very rich). </p>
<p><strong>Output</strong></p>
<p>Output a single line containing a single integer: the length in meters of the shortest ladder that allows you to get from the north west corner to the south east corner.</p>
<h4 id="样例输入1"><a href="#样例输入1" class="headerlink" title="样例输入1"></a>样例输入1</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2 3</span><br><span class="line">6 5 4</span><br><span class="line">7 8 9</span><br></pre></td></tr></table></figure>
<h4 id="样例输出1"><a href="#样例输出1" class="headerlink" title="样例输出1"></a>样例输出1</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>
<h4 id="样例输入2"><a href="#样例输入2" class="headerlink" title="样例输入2"></a>样例输入2</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 4</span><br><span class="line">4 3 2 1</span><br></pre></td></tr></table></figure>
<h4 id="样例输出2"><a href="#样例输出2" class="headerlink" title="样例输出2"></a>样例输出2</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure>
<h4 id="样例输入3"><a href="#样例输入3" class="headerlink" title="样例输入3"></a>样例输入3</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7 5</span><br><span class="line">10 11 12 13 14</span><br><span class="line">11 20 16 17 16</span><br><span class="line">12 10 18 21 24</span><br><span class="line">14 10 14 14 22</span><br><span class="line">16 18 20 20 25</span><br><span class="line">25 24 22 10 25</span><br><span class="line">26 27 28 21 25</span><br></pre></td></tr></table></figure>
<h4 id="样例输出3"><a href="#样例输出3" class="headerlink" title="样例输出3"></a>样例输出3</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h3><p>给定一个矩阵，从第一个点到最后一个点需要的最短梯子长度，从一个数到一个比它大的数需要一个两数之差的梯子长度，需要注意这个梯子可以反复使用，其实就是求从起点到终点的一条路径，这条路径的任意两个相邻数最大的差值最小，问这个差值是多少？</p>
<h3 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h3><p>既然要求从起点到终点最短梯子长度，那可以这样想，求从起点到离终点只有一步的那个点到终点需要的梯子长度和从起点到终点所需的最短梯子长度取大的，同理继续往前推可以知道每一次递推都是由之前的那个点到起点所需最短梯子长度推过来的，因此每次都是求这个点到下一个点的最小梯子长度，如何求最短呢？肯定想到优先队列，而一层一层的往外推则是bfs，因此这道题就出来了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> x,y,v;</span><br><span class="line">    <span class="type">bool</span> operator&lt;(<span class="type">const</span> node &amp; o)<span class="type">const</span>&#123; <span class="comment">//v代表每一个点到起点需要的梯子数量</span></span><br><span class="line">        <span class="keyword">return</span> v&gt;o.v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">priority_queue</span>&lt;node&gt; p;</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">1006</span>][<span class="number">1006</span>];</span><br><span class="line"><span class="type">int</span> arr[<span class="number">1006</span>][<span class="number">1006</span>],dir[<span class="number">4</span>][<span class="number">2</span>]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;,n,m;</span><br><span class="line"><span class="type">int</span> <span class="title function_">bfs</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!p.empty())&#123;</span><br><span class="line">        node d=p.top();</span><br><span class="line">        p.pop();</span><br><span class="line">        <span class="type">int</span> x=d.x,y=d.y,v=d.v;</span><br><span class="line">        <span class="keyword">if</span>(x==n&amp;&amp;y==m) <span class="keyword">return</span> v; <span class="comment">//到达了终点</span></span><br><span class="line">        <span class="keyword">if</span>(vis[x][y]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[x][y]=<span class="number">1</span>; <span class="comment">//记得标记</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;++i)&#123;</span><br><span class="line">            <span class="type">int</span> x1=x+dir[i][<span class="number">0</span>],y1=y+dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(x1&lt;=<span class="number">0</span>||x1&gt;n||y1&lt;=<span class="number">0</span>||y1&gt;m) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> tmp;</span><br><span class="line">            <span class="keyword">if</span>(arr[x1][y1]-arr[x][y]&lt;<span class="number">0</span>) tmp=<span class="number">0</span>; <span class="comment">//这是刚开始如果下一个点比这个点小不能用负数，得用0</span></span><br><span class="line">            <span class="keyword">else</span> tmp=arr[x1][y1]-arr[x][y]; 这段需要的梯子长度</span><br><span class="line">            <span class="type">int</span> v1=max(v,tmp); <span class="comment">//取他们较大的那个</span></span><br><span class="line">            p.push(&#123;x1,y1,v1&#125;); <span class="comment">//放进队列</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ios;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;++j)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;arr[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    p.push(&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;bfs()&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>P1131拯救大兵瑞恩</title>
    <url>/posts/e655dcb8.html</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/20210320104811.png" alt="image-20210320104759568" style="zoom:50%;" /></p>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>从(1,1)出发走到(n,m)，途中有墙有门有钥匙，问最短几步走到右下角。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>利用状态压缩，用二进制位表示第几种钥匙是否持有，利用BFS爆搜，再开一个数组储存状态来记忆化剪枝</p>
<p>实现方法有很多种，可以利用邻接表建边，可以直接利用Next数组表示下一个位置，邻接表利用空间换取了时间，表示墙和门时如果不用邻接表，则需要用map<pair<int,int>,pair<int,int>&gt;这种结构来表示，而邻接表可以用边权来表示，但都是可以过的</p>
<h3 id="CODE1-优先队列"><a href="#CODE1-优先队列" class="headerlink" title="CODE1(优先队列)"></a>CODE1(优先队列)</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SUB=<span class="number">-0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-4</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> E=<span class="built_in">exp</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> x1,y1,x2,y2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> x,y,d,z;</span><br><span class="line">	<span class="type">bool</span> operator&lt;(<span class="type">const</span> Node &amp;o) <span class="type">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> d&gt;o.d;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> n,m,k,p,s;</span><br><span class="line"><span class="type">int</span> Next[<span class="number">4</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span> key[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">pair</span>&lt;pii,pii&gt;,<span class="type">int</span>&gt; wal,dor;</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">20</span>][<span class="number">20</span>][<span class="number">1</span>&lt;&lt;<span class="number">10</span>];</span><br><span class="line"><span class="built_in">priority_queue</span>&lt;Node&gt; q;</span><br><span class="line"><span class="type">int</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">	<span class="type">int</span> tmp=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(key[x][y]) tmp=key[x][y];</span><br><span class="line">	q.push(&#123;x,y,<span class="number">0</span>,tmp&#125;);</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		Node fr=q.top();</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="keyword">if</span>(fr.x==n &amp;&amp; fr.y==m) <span class="keyword">return</span> fr.d;</span><br><span class="line">		<span class="keyword">if</span>(vis[fr.x][fr.y][fr.z]) <span class="keyword">continue</span>;</span><br><span class="line">		vis[fr.x][fr.y][fr.z]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">			<span class="type">int</span> nx=fr.x+Next[i][<span class="number">0</span>];</span><br><span class="line">			<span class="type">int</span> ny=fr.y+Next[i][<span class="number">1</span>];</span><br><span class="line">			<span class="keyword">if</span>(nx&lt;<span class="number">1</span> || nx&gt;n || ny&lt;<span class="number">1</span> || ny&gt;m) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(wal[&#123;&#123;fr.x,fr.y&#125;,&#123;nx,ny&#125;&#125;]) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(dor[&#123;&#123;fr.x,fr.y&#125;,&#123;nx,ny&#125;&#125;] &amp;&amp; ((fr.z&gt;&gt;(dor[&#123;&#123;fr.x,fr.y&#125;,&#123;nx,ny&#125;&#125;]<span class="number">-1</span>))&amp;<span class="number">1</span>)==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="type">int</span> now=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span>(key[nx][ny]) now=key[nx][ny];</span><br><span class="line">			q.push(&#123;nx,ny,fr.d+<span class="number">1</span>,fr.z|now&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;p&gt;&gt;k;</span><br><span class="line">	<span class="keyword">while</span>(k--)&#123;</span><br><span class="line">		<span class="type">int</span> x1,y1,x2,y2,G;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2&gt;&gt;G;</span><br><span class="line">		<span class="keyword">if</span>(G==<span class="number">0</span>)&#123;</span><br><span class="line">			wal[&#123;&#123;x1,y1&#125;,&#123;x2,y2&#125;&#125;]=<span class="number">1</span>;</span><br><span class="line">			wal[&#123;&#123;x2,y2&#125;,&#123;x1,y1&#125;&#125;]=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			dor[&#123;&#123;x1,y1&#125;,&#123;x2,y2&#125;&#125;]=G;</span><br><span class="line">			dor[&#123;&#123;x2,y2&#125;,&#123;x1,y1&#125;&#125;]=G;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=s;i++)&#123;</span><br><span class="line">		<span class="type">int</span> x,y,g;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;g;</span><br><span class="line">		key[x][y]|=(<span class="number">1</span>&lt;&lt;g<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> ans=bfs(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CODE2-dis数组"><a href="#CODE2-dis数组" class="headerlink" title="CODE2(dis数组)"></a>CODE2(dis数组)</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> first x</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> second y</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SUB=<span class="number">-0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-4</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> E=<span class="built_in">exp</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> x,y,state;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> n,m,p,k;</span><br><span class="line"><span class="type">int</span> key[<span class="number">11</span>][<span class="number">11</span>],dis[<span class="number">11</span>][<span class="number">11</span>][<span class="number">1</span>&lt;&lt;<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> Next[<span class="number">4</span>][<span class="number">2</span>]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">bool</span> st[<span class="number">11</span>][<span class="number">11</span>][<span class="number">1</span>&lt;&lt;<span class="number">10</span>];</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">pair</span>&lt;pii,pii&gt;&gt; wal;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">pair</span>&lt;pii,pii&gt;,<span class="type">int</span>&gt; dor;</span><br><span class="line"><span class="built_in">deque</span>&lt;node&gt; dq;</span><br><span class="line"><span class="type">int</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dis);</span><br><span class="line">	dq.push_back(&#123;x,y,<span class="number">0</span>&#125;);</span><br><span class="line">	dis[x][y][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!dq.empty())&#123;</span><br><span class="line">		node now=dq.front();</span><br><span class="line">		dq.pop_front();</span><br><span class="line">		<span class="keyword">if</span>(now.x==n &amp;&amp; now.y==m) <span class="keyword">return</span> dis[n][m][now.state];</span><br><span class="line">		<span class="keyword">if</span>(st[now.x][now.y][now.state]) <span class="keyword">continue</span>;</span><br><span class="line">		st[now.x][now.y][now.state]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(key[now.x][now.y])&#123;</span><br><span class="line">			<span class="keyword">if</span>(dis[now.x][now.y][key[now.x][now.y]|now.state]&gt;dis[now.x][now.y][now.state])&#123;</span><br><span class="line">				dis[now.x][now.y][ key[now.x][now.y] | now.state]=dis[now.x][now.y][now.state];</span><br><span class="line">			&#125;</span><br><span class="line">			now.state|=key[now.x][now.y];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">			<span class="type">int</span> nx=now.x+Next[i][<span class="number">0</span>];</span><br><span class="line">			<span class="type">int</span> ny=now.y+Next[i][<span class="number">1</span>];</span><br><span class="line">			<span class="keyword">if</span>(nx&lt;<span class="number">1</span> || nx&gt;n || ny&lt;<span class="number">1</span> || ny&gt;m) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(wal.count(&#123;&#123;now.x,now.y&#125;,&#123;nx,ny&#125;&#125;)) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(dor[&#123;&#123;now.x,now.y&#125;,&#123;nx,ny&#125;&#125;] &amp;&amp; (( <span class="number">1</span>&lt;&lt;(dor[&#123;&#123;now.x,now.y&#125;,&#123;nx,ny&#125;&#125;]<span class="number">-1</span>) ) &amp; now.state)==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(dis[nx][ny][now.state]&gt;dis[now.x][now.y][now.state]+<span class="number">1</span>)&#123;</span><br><span class="line">				dis[nx][ny][now.state]=dis[now.x][now.y][now.state]+<span class="number">1</span>;				</span><br><span class="line">				dq.push_back(&#123;nx,ny,now.state&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;p&gt;&gt;k;</span><br><span class="line">	<span class="keyword">while</span>(k--)&#123;</span><br><span class="line">		<span class="type">int</span> x1,y1,x2,y2,c;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2&gt;&gt;c;</span><br><span class="line">		<span class="keyword">if</span>(c)&#123;</span><br><span class="line">			dor[&#123;&#123;x1,y1&#125;,&#123;x2,y2&#125;&#125;]=c;</span><br><span class="line">			dor[&#123;&#123;x2,y2&#125;,&#123;x1,y1&#125;&#125;]=c;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			wal.insert(&#123;&#123;x1,y1&#125;,&#123;x2,y2&#125;&#125;);</span><br><span class="line">			wal.insert(&#123;&#123;x2,y2&#125;,&#123;x1,y1&#125;&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> s;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=s;i++)&#123;</span><br><span class="line">		<span class="type">int</span> x,y,g;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;g;</span><br><span class="line">		key[x][y]|=( <span class="number">1</span>&lt;&lt; g<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> ans=bfs(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>P175电路维修</title>
    <url>/posts/564fb150.html</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/20210319205828.png" alt="image-20210319205815067" style="zoom:50%;" /></p>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>如图所示，旋转最少的电线使得左面的电源和发光器相连、</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>考虑把所有电线已经相连的点设为边权为0，没有连接的，比如电线是主对角线，副对角线上的两个点就应该设为边权为1，最后跑一个从左上角到右下角的最短路径，将每一个点映射到一维数组中。</p>
<p>dijstla当然可以做，但是双端队列更高，因为这个图中只有边权为0和1的点，可以把优先队列的log(n)省掉，当遇到边权为0的点时就把点直接添加到队头，遇到边权为1的点放到队尾，并且判断能否更新当前点离起点的距离。</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SUB=<span class="number">-0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-4</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> E=<span class="built_in">exp</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> to,next,w;</span><br><span class="line">&#125;e[MAXN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> head[MAXN],dis[MAXN];</span><br><span class="line"><span class="type">int</span> t,n,tot,m;</span><br><span class="line"><span class="type">bool</span> vis[MAXN];</span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span>&#123;</span><br><span class="line">	e[tot]=&#123;v,head[u],w&#125;;</span><br><span class="line">	head[u]=tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (x<span class="number">-1</span>)*(m+<span class="number">1</span>)+y;</span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> u,d;</span><br><span class="line">	<span class="type">bool</span> operator&lt;(<span class="type">const</span> Node &amp;o) <span class="type">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> d&gt;o.d;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//priority_queue&lt;Node&gt; pq;</span></span><br><span class="line"><span class="comment">//void dij(int s)&#123;</span></span><br><span class="line"><span class="comment">//	memset(vis,0,sizeof vis);</span></span><br><span class="line"><span class="comment">//	memset(dis,0x3f,sizeof(dis));</span></span><br><span class="line"><span class="comment">//	pq.push(&#123;s,0&#125;);</span></span><br><span class="line"><span class="comment">//	dis[s]=0;</span></span><br><span class="line"><span class="comment">//	while(!pq.empty())&#123;</span></span><br><span class="line"><span class="comment">//		Node now=pq.top();</span></span><br><span class="line"><span class="comment">//		pq.pop();</span></span><br><span class="line"><span class="comment">//		if(vis[now.u]) continue;</span></span><br><span class="line"><span class="comment">////		cout&lt;&lt;now.u&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line"><span class="comment">//		vis[now.u]=1;</span></span><br><span class="line"><span class="comment">//		for(int i=head[now.u];~i;i=e[i].next)&#123;</span></span><br><span class="line"><span class="comment">//			int v=e[i].to,w=e[i].w;</span></span><br><span class="line"><span class="comment">//			if(dis[v]&gt;dis[now.u]+w)&#123;</span></span><br><span class="line"><span class="comment">//				dis[v]=dis[now.u]+w;</span></span><br><span class="line"><span class="comment">//				pq.push(&#123;v,dis[v]&#125;);</span></span><br><span class="line"><span class="comment">//			&#125;</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="type">int</span>&gt; dq;</span><br><span class="line"><span class="type">void</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span> s)</span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dis);</span><br><span class="line">	<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">	dq.push_back(s);</span><br><span class="line">	dis[s]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!dq.empty())&#123;</span><br><span class="line">		<span class="type">int</span> fr=dq.front();</span><br><span class="line">		dq.pop_front();</span><br><span class="line">		<span class="keyword">if</span>(vis[fr]) <span class="keyword">continue</span>;</span><br><span class="line">		vis[fr]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=head[fr];~i;i=e[i].next)&#123;</span><br><span class="line">			<span class="type">int</span> v=e[i].to,w=e[i].w;</span><br><span class="line">			<span class="keyword">if</span>(w==<span class="number">0</span>)&#123;</span><br><span class="line">				dis[v]=dis[fr];</span><br><span class="line">				dq.push_front(v);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">if</span>(dis[v]&gt;dis[fr]+w)&#123;</span><br><span class="line">					dis[v]=dis[fr]+w;</span><br><span class="line">					dq.push_back(v);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		tot=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span> head);</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">				<span class="type">char</span> ch;</span><br><span class="line">				<span class="built_in">cin</span>&gt;&gt;ch;</span><br><span class="line">				<span class="keyword">if</span>(ch==<span class="string">&#x27;\\&#x27;</span>)&#123;</span><br><span class="line">					add(get(i,j),get(i+<span class="number">1</span>,j+<span class="number">1</span>),<span class="number">0</span>);</span><br><span class="line">					add(get(i+<span class="number">1</span>,j+<span class="number">1</span>),get(i,j),<span class="number">0</span>);</span><br><span class="line">					add(get(i,j+<span class="number">1</span>),get(i+<span class="number">1</span>,j),<span class="number">1</span>);</span><br><span class="line">					add(get(i+<span class="number">1</span>,j),get(i,j+<span class="number">1</span>),<span class="number">1</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span>&#123;</span><br><span class="line">					add(get(i,j+<span class="number">1</span>),get(i+<span class="number">1</span>,j),<span class="number">0</span>);</span><br><span class="line">					add(get(i+<span class="number">1</span>,j),get(i,j+<span class="number">1</span>),<span class="number">0</span>);</span><br><span class="line">					add(get(i,j),get(i+<span class="number">1</span>,j+<span class="number">1</span>),<span class="number">1</span>);</span><br><span class="line">					add(get(i+<span class="number">1</span>,j+<span class="number">1</span>),get(i,j),<span class="number">1</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		bfs(get(<span class="number">1</span>,<span class="number">1</span>));</span><br><span class="line">		<span class="keyword">if</span>(dis[get(n+<span class="number">1</span>,m+<span class="number">1</span>)]==INF) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;NO SOLUTION\n&quot;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;dis[get(n+<span class="number">1</span>,m+<span class="number">1</span>)]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>双端队列+BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>P340通信线路</title>
    <url>/posts/ef84d4b4.html</url>
    <content><![CDATA[<h2 id="340-通信线路"><a href="#340-通信线路" class="headerlink" title="340. 通信线路"></a>340. 通信线路</h2><h3 id="分层图做法"><a href="#分层图做法" class="headerlink" title="分层图做法"></a>分层图做法</h3><p>建k+1层图，相邻两层图之间权值为0，代表免费升级，在一层图里面跑就去找最大值，最后的答案就是第k+1层的dis[n]也就是dis[(k+1)*n]，注意的是这样的做法只有在边数大于k时成立，当全部边都可以免费升级时，会出现问题，还没有跑到最后一层图就到达终点了，这时就会往回跑，导致边权增加，就会出错，所以需要把层与层之间的终点连接起来，使它们可以免费互相到达</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SUB=<span class="number">-0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-4</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> E=<span class="built_in">exp</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> to,next,w;</span><br><span class="line">&#125;e[<span class="number">10000010</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> u,d;</span><br><span class="line">	<span class="type">bool</span> operator&lt;(<span class="type">const</span> Node &amp;o)<span class="type">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> d&gt;o.d;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> head[MAXN];</span><br><span class="line"><span class="type">int</span> dis[MAXN];</span><br><span class="line"><span class="type">int</span> n,p,k,tot;</span><br><span class="line"><span class="built_in">priority_queue</span>&lt;Node&gt; pq;</span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span>&#123;</span><br><span class="line">	e[tot]=&#123;v,head[u],w&#125;;</span><br><span class="line">	head[u]=tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dij</span><span class="params">(<span class="type">int</span> s)</span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dis);</span><br><span class="line">	pq.push(&#123;s,<span class="number">0</span>&#125;);</span><br><span class="line">	dis[s]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!pq.empty())&#123;</span><br><span class="line">		Node now=pq.top();</span><br><span class="line">		pq.pop();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=head[now.u];~i;i=e[i].next)&#123;</span><br><span class="line">			<span class="type">int</span> v=e[i].to,w=e[i].w;</span><br><span class="line">			<span class="keyword">if</span>(dis[v]&gt;max(dis[now.u],w))&#123;</span><br><span class="line">				dis[v]=max(dis[now.u],w);</span><br><span class="line">				pq.push(&#123;v,dis[v]&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span> head);</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;p&gt;&gt;k;</span><br><span class="line">	<span class="keyword">while</span>(p--)&#123;</span><br><span class="line">		<span class="type">int</span> u,v,w;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">		add(u,v,w);</span><br><span class="line">		add(v,u,w);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=k;j++)&#123;</span><br><span class="line">			add(u+(j<span class="number">-1</span>)*n,v+j*n,<span class="number">0</span>);</span><br><span class="line">			add(v+(j<span class="number">-1</span>)*n,u+j*n,<span class="number">0</span>);</span><br><span class="line">			add(u+j*n,v+j*n,w);</span><br><span class="line">			add(v+j*n,u+j*n,w);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">		add(i*n,(i+<span class="number">1</span>)*n,<span class="number">0</span>);  <span class="comment">//把终点连成一体 </span></span><br><span class="line">	&#125;</span><br><span class="line">	dij(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(dis[(k+<span class="number">1</span>)*n]!=INF)<span class="built_in">cout</span>&lt;&lt;dis[(k+<span class="number">1</span>)*n]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="二分做法"><a href="#二分做法" class="headerlink" title="二分做法"></a>二分做法</h3><p>题目求的就是第k+1大最小，一看求较大值最小，就要想到二分，二分答案，验证答案，标记大于验证值的边权为1，小于等于的为0，求起点到终点的最短路径，路径和小于等于k时即满足要求，否则不满足</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SUB=<span class="number">-0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-4</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> E=<span class="built_in">exp</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> to,next,w;</span><br><span class="line">&#125;e[MAXN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> u,d;</span><br><span class="line">	<span class="type">bool</span> operator&lt;(<span class="type">const</span> Node &amp;o)<span class="type">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> d&gt;o.d;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> head[MAXN],dis[MAXN];</span><br><span class="line"><span class="type">int</span> n,p,k,tot;</span><br><span class="line"><span class="built_in">priority_queue</span>&lt;Node&gt; pq;</span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span>&#123;</span><br><span class="line">	e[tot]=&#123;v,head[u],w&#125;;</span><br><span class="line">	head[u]=tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dis);</span><br><span class="line">	dis[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">	pq.push(&#123;<span class="number">1</span>,<span class="number">0</span>&#125;);</span><br><span class="line">	<span class="keyword">while</span>(!pq.empty())&#123;</span><br><span class="line">		Node now=pq.top();</span><br><span class="line">		pq.pop();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=head[now.u];~i;i=e[i].next)&#123;</span><br><span class="line">			<span class="type">int</span> v=e[i].to,w=e[i].w&gt;x?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span>(dis[v]&gt;dis[now.u]+w)&#123;</span><br><span class="line">				dis[v]=dis[now.u]+w;</span><br><span class="line">				pq.push(&#123;v,dis[v]&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(dis[n]&lt;=k) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span> head);</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;p&gt;&gt;k;</span><br><span class="line">	<span class="keyword">while</span>(p--)&#123;</span><br><span class="line">		<span class="type">int</span> u,v,w;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">		add(u,v,w);</span><br><span class="line">		add(v,u,w);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">1000000</span>,ans=INF,mid;</span><br><span class="line">	<span class="keyword">while</span>(r&gt;=l)&#123;</span><br><span class="line">		mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(check(mid))&#123;</span><br><span class="line">			ans=mid;</span><br><span class="line">			r=mid<span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> l=mid+<span class="number">1</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(ans!=INF) <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="动态规划做法"><a href="#动态规划做法" class="headerlink" title="动态规划做法"></a>动态规划做法</h3><p>从起点到终点的一条路径中最多有k条免费升级，那给dis数组多加一维表示从起点到这个点已经免费升级几条边了，数组值依旧表示这个状态需要升级的最大值</p>
<p>转移方程：</p>
<blockquote>
<p>若在这条边不使用机会：dis[y, p] = min(dis[y, p], max(dis[x, p], w))<br>若在这条边使用机会：dis[y, p+1] = min(dis[y, p+1], dis[x, p])</p>
</blockquote>
<p>题解中很多都用SPFA，但这道题目都是正权，dijistla就可以，省了常数的时间，更新dis数组时变成转移方程就可以了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SUB=<span class="number">-0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-4</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> E=<span class="built_in">exp</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> to,next,w;</span><br><span class="line">&#125;e[MAXN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> u,c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> head[MAXN],dis[<span class="number">1100</span>][<span class="number">1010</span>];</span><br><span class="line"><span class="type">int</span> n,m,tot,k;</span><br><span class="line"><span class="built_in">queue</span>&lt;Node&gt; pq;</span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span>&#123;</span><br><span class="line">	e[tot]=&#123;v,head[u],w&#125;;</span><br><span class="line">	head[u]=tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dij</span><span class="params">(<span class="type">int</span> s)</span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dis);</span><br><span class="line">	pq.push(&#123;s,<span class="number">0</span>&#125;);</span><br><span class="line">	dis[s][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!pq.empty())&#123;</span><br><span class="line">		Node now=pq.front();</span><br><span class="line">		pq.pop();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=head[now.u];~i;i=e[i].next)&#123;</span><br><span class="line">			<span class="type">int</span> v=e[i].to,w=e[i].w;</span><br><span class="line">			<span class="keyword">if</span>(dis[v][now.c]&gt;max(dis[now.u][now.c],w))&#123;</span><br><span class="line">				dis[v][now.c]=max(dis[now.u][now.c],w);</span><br><span class="line">				pq.push(&#123;v,now.c&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(now.c+<span class="number">1</span>&lt;=k &amp;&amp; dis[v][now.c+<span class="number">1</span>]&gt;dis[now.u][now.c])&#123;</span><br><span class="line">				dis[v][now.c+<span class="number">1</span>]=dis[now.u][now.c];</span><br><span class="line">				pq.push(&#123;v,now.c+<span class="number">1</span>&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span> head);</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="type">int</span> u,v,w;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">		add(u,v,w);</span><br><span class="line">		add(v,u,w);</span><br><span class="line">	&#125;</span><br><span class="line">	dij(<span class="number">1</span>);</span><br><span class="line">	<span class="type">int</span> ans=INF;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=k;i++)&#123;</span><br><span class="line">		ans=min(ans,dis[n][i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(ans!=INF)<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>P341最优贸易</title>
    <url>/posts/83ce6fe2.html</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/20210318220038.png" alt="image-20210318220033300" style="zoom:50%;" /></p>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>n个城市，从1到n点，有有向边，也有无向边，每个城市都有宝石价格，从一个点买一个宝石，再在后面走的点卖出，问最多赚多少钱？</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>对每一个路径求一个前缀最小值和后缀最大值，对每一个点后缀减去前缀取最大值即是答案，细节就是，求后缀可以反建图，开一个rhead数组</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">500000</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> to,next;</span><br><span class="line">&#125;e[MAXN];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="type">int</span> head[MAXN],val[MAXN],mi[MAXN],mx[MAXN],rhead[MAXN];</span><br><span class="line"><span class="type">int</span> n,m,tot,s,flag=<span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> head[])</span>&#123;</span><br><span class="line">	e[tot]=&#123;v,head[u]&#125;;</span><br><span class="line">	head[u]=tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">spfa</span><span class="params">(<span class="type">int</span> s)</span>&#123;</span><br><span class="line">	q.push(s);</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		<span class="type">int</span> fr=q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="type">int</span> i=flag==<span class="number">0</span>?head[fr]:rhead[fr];</span><br><span class="line">		<span class="keyword">for</span>( ;~i;i=e[i].next)&#123;</span><br><span class="line">			<span class="type">int</span> v=e[i].to;</span><br><span class="line">			<span class="keyword">if</span>(!flag &amp;&amp; min(mi[fr],val[v])&lt;mi[v])&#123;</span><br><span class="line">				mi[v]=min(mi[fr],val[v]);</span><br><span class="line">				q.push(v);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(flag &amp;&amp; max(mx[fr],val[v])&gt;mx[v])&#123;</span><br><span class="line">				mx[v]=max(mx[fr],val[v]);</span><br><span class="line">				q.push(v);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span> head);</span><br><span class="line">	<span class="built_in">memset</span>(rhead,<span class="number">-1</span>,<span class="keyword">sizeof</span> rhead);</span><br><span class="line">	<span class="built_in">memset</span>(mi,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> mi);</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;val[i];</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="type">int</span> u,v,o;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v&gt;&gt;o;</span><br><span class="line">		add(u,v,head);</span><br><span class="line">		add(v,u,rhead);</span><br><span class="line">		<span class="keyword">if</span>(o==<span class="number">2</span>)&#123;</span><br><span class="line">			add(v,u,head);</span><br><span class="line">			add(u,v,rhead);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	mi[<span class="number">1</span>]=val[<span class="number">1</span>];</span><br><span class="line">	mx[n]=val[n];</span><br><span class="line">	spfa(<span class="number">1</span>);</span><br><span class="line">	flag=<span class="number">1</span>;</span><br><span class="line">	spfa(n);</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) ans=max(ans,mx[i]-mi[i]);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>P342道路与航线</title>
    <url>/posts/86e7fea8.html</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/20210318200510.png" alt="image-20210318200457249" style="zoom:50%;" /></p>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定t个点，r条道路，p条航线，和一个起点，道路可互相到达，航线只能单向到达，且航线的权值可能为负数，问从起点到各个点的最小距离是多少？若不可到达输出“NO PATH”</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>把所有道路相连的点组成联通块，给他们编上号，从起点所在的联通块往后跑一个拓扑排序，连通块内跑dijstla，松弛时发现松驰的点和当前点不在一个连通块内，则把更新的点所在的联通块入度-1，大致思路是这样，但是还是有许多细节问题</p>
<ol>
<li>为什么一开始要加入入度为0的点？<ul>
<li>因为要保证拓扑序列的进行。假设s所在块编号为a，a连向块c，块b连向块c，且块a块b不相连。此时，如果你不加入入度为0的点，那么b块就不会访问到，c的入度也就不会减到0，也就不会访问到。</li>
</ul>
</li>
<li>判断无解为什么不写出==inf？<ul>
<li>因为有坑1的存在。还是上面那个例子，再加2个条件：<ol>
<li>块d-&gt;块b，块a与块d不相连。</li>
<li>d到b的路为负边权<ul>
<li>此时显然应该块b、d里所有的点都是NOPATH，而且dis都为inf。但其实在用块d内的点更新块b时，会松弛成功，因为存在负边权。所以无解时不一定dis就为inf</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li>对每一个连通块跑最短路时，不知道那个点作为起点，理论上是最小的那个点，但是考虑到可能从一个联通块到当前联通块距离比较小，但是从起点所在的联通块到当前联通块距离较大，但是两条路不相交，即不可互相到达，这样会导致起点到这个联通块的路径反而消失了，所以把所有点放到优先队列里才是合适的做法</li>
</ol>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">500000</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> to,next,w;</span><br><span class="line">&#125;e[MAXN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> u,d;</span><br><span class="line">	<span class="type">bool</span> operator&lt;(<span class="type">const</span> Node &amp;o)<span class="type">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> d&gt;o.d;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> head[MAXN],dis[MAXN],id[MAXN],in[MAXN];</span><br><span class="line"><span class="type">int</span> n,r,p,s,tot,bcnt;</span><br><span class="line"><span class="type">bool</span> vis[MAXN];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; ve[MAXN];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="built_in">priority_queue</span>&lt;Node&gt; pq;</span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span>&#123;</span><br><span class="line">	e[tot]=&#123;v,head[u],w&#125;;</span><br><span class="line">	head[u]=tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">	ve[bcnt].push_back(x);</span><br><span class="line">	id[x]=bcnt;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[x];~i;i=e[i].next)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!id[e[i].to]) dfs(e[i].to);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dij</span><span class="params">(<span class="type">int</span> s)</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> i:ve[s]) pq.push(&#123;i,dis[i]&#125;);</span><br><span class="line">	<span class="keyword">while</span>(!pq.empty())&#123;</span><br><span class="line">		Node now=pq.top();</span><br><span class="line">		pq.pop();</span><br><span class="line">		<span class="keyword">if</span>(vis[now.u]) <span class="keyword">continue</span>;</span><br><span class="line">		vis[now.u]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=head[now.u];~i;i=e[i].next)&#123;</span><br><span class="line">			<span class="type">int</span> v=e[i].to,w=e[i].w;</span><br><span class="line">			<span class="keyword">if</span>(dis[v]&gt;dis[now.u]+w)&#123;</span><br><span class="line">				dis[v]=dis[now.u]+w;</span><br><span class="line">				<span class="keyword">if</span>(id[v]==id[now.u]) pq.push(&#123;v,dis[v]&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(id[v]!=id[now.u])&#123;</span><br><span class="line">				in[id[v]]--;</span><br><span class="line">				<span class="keyword">if</span>(in[id[v]]==<span class="number">0</span>) q.push(id[v]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">tupo</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dis);</span><br><span class="line">	dis[s]=<span class="number">0</span>;</span><br><span class="line">	q.push(id[s]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=bcnt;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!in[i]) q.push(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		<span class="type">int</span> fr=q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		dij(fr);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span> head);</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;r&gt;&gt;p&gt;&gt;s;</span><br><span class="line">	<span class="keyword">while</span>(r--)&#123;</span><br><span class="line">		<span class="type">int</span> u,v,w;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">		add(u,v,w);</span><br><span class="line">		add(v,u,w);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!id[i])&#123;</span><br><span class="line">			bcnt++;</span><br><span class="line">			dfs(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(p--)&#123;</span><br><span class="line">		<span class="type">int</span> u,v,w;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">		add(u,v,w);</span><br><span class="line">		in[id[v]]++;</span><br><span class="line">	&#125;</span><br><span class="line">	tupo();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(dis[i]&gt;INF/<span class="number">2</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;NO PATH&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;  <span class="comment">//可能存在到不了的点却被负权边更新了</span></span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;dis[i]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>PPT上例题(含倍增)</title>
    <url>/posts/f79e8551.html</url>
    <content><![CDATA[<blockquote>
<p>PPT上面的好多题都做不了，ACWING上的题要报名才能做，Codeforces 1000C搜不出来，就做了剩下的，不过二维差分前缀和早就掌握了</p>
</blockquote>
<h2 id="ACWING-797-差分"><a href="#ACWING-797-差分" class="headerlink" title="ACWING-797. 差分"></a>ACWING-797. 差分</h2><p>超级模板</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> val[MAXN],cha[MAXN];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n,m;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;val[i];</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="type">int</span> l,r,c;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r&gt;&gt;c;</span><br><span class="line">		cha[l]+=c; cha[r+<span class="number">1</span>]-=c; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		cha[i]+=cha[i<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">if</span>(i!=n) <span class="built_in">cout</span>&lt;&lt;val[i]+cha[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;val[i]+cha[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>
<h2 id="洛谷-海底高铁"><a href="#洛谷-海底高铁" class="headerlink" title="洛谷-海底高铁"></a>洛谷-海底高铁</h2><p>算出每两个城市的往返次数，然后贪心一下，找到最小的，这道题之前做过，当时第一次就AC了，这道题应该不难</p>
<h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll; </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> A[MAXN],B[MAXN],C[MAXN],X[MAXN],cha[MAXN];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	ios;</span><br><span class="line">    <span class="type">int</span> n,m; <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">cin</span>&gt;&gt;X[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">    	<span class="built_in">cin</span>&gt;&gt;A[i]&gt;&gt;B[i]&gt;&gt;C[i];</span><br><span class="line">    	A[i]+=A[i<span class="number">-1</span>];</span><br><span class="line">    	B[i]+=B[i<span class="number">-1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m<span class="number">-1</span>;i++)&#123;</span><br><span class="line">		<span class="type">int</span> l=min(X[i],X[i+<span class="number">1</span>]);</span><br><span class="line">		<span class="type">int</span> r=max(X[i],X[i+<span class="number">1</span>]);</span><br><span class="line">		cha[l]++; cha[r]--;</span><br><span class="line">	&#125;</span><br><span class="line">	ll sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">		cha[i]+=cha[i<span class="number">-1</span>];</span><br><span class="line">		ll t1=cha[i]*(A[i]-A[i<span class="number">-1</span>]);</span><br><span class="line">		ll t2=cha[i]*(B[i]-B[i<span class="number">-1</span>])+C[i];</span><br><span class="line">		sum+=min(t1,t2);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="倍增-amp-amp-ST表"><a href="#倍增-amp-amp-ST表" class="headerlink" title="倍增&amp;&amp;ST表"></a>倍增&amp;&amp;ST表</h2><p>首先明白倍增是一种思想而不是模板，它与ST并没有必然的联系，不是主要有倍增就必然出现ST，做倍增题一定要明白是对什么倍增的，通常就是对区间长度或者距离倍增，使用倍增通常有(RMQ)即区间最值查询(第二道题)，以及LAC这个还没学，ST表的核心是找到ST的递推关系，从小往大推，直到打完所有表，时间复杂度是O(mlogn)，m为结点数量，n是走的步数(2^0,2^1…)， <code>2^20</code> 就已经超过 <code>1e6</code> 了，<code>2^64</code> 大于 <code>1e20</code>，所以logn是非常小的，最多几十次，复杂度记乎可以看成O(N*10)</p>
<h3 id="AtCoder-abc167-d"><a href="#AtCoder-abc167-d" class="headerlink" title="AtCoder - abc167_d"></a>AtCoder - abc167_d</h3><p>一道图上倍增的题目，别看这个1e18很大，它的log级别比64还小，用倍增做时间复杂度变成了O(NlongM)，就是2e6的样子<br>这里st表很直接，储存的就是跳了N此后到达位置，特别特别需要注意的是查询千万不能用( 1 &lt;&lt; i )，这是特别大的数字，我不明白为啥m是ll，就算把( 1 &lt;&lt; i )转化为ll类型再进行与操作还是不行，ll不是64位的吗？范围应该是够的，奇怪，不过以后最好让m右移这样不会爆int，当然也可以用while遍历每一位</p>
<h4 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">2e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> st[maxn][<span class="number">70</span>],a[maxn];</span><br><span class="line"><span class="type">int</span> n,pos=<span class="number">1</span>;</span><br><span class="line">ll m;</span><br><span class="line"><span class="type">void</span> <span class="title function_">bz</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> len=log2(m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) st[i][<span class="number">0</span>]=a[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)&#123;</span><br><span class="line">			st[j][i]=st[st[j][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">	bz();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">64</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="number">1</span>&amp;(m&gt;&gt;i))&#123;</span><br><span class="line">			pos=st[pos][i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;pos&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="ACWING-1270-数列区间最大值"><a href="#ACWING-1270-数列区间最大值" class="headerlink" title="ACWING-1270. 数列区间最大值"></a>ACWING-1270. 数列区间最大值</h3><p>一道模板RMQ题目，这道题ST储存的是每一段区间的最值，倍增的是区间长度，就这道题而言，一段区间的最大值可以由这段区间从中间分开的两端区间的最值的合并，而且每一个数都是可以用2进制表示的，那么就一定用st表中的数相加得到</p>
<p>st[i][j]表示从i这一点开始数2^j^个数的最值，即往后数2^(j-1)^个数的最值</p>
<h4 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0) </span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> st[MAXN][<span class="number">22</span>],a[MAXN];</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) st[i][<span class="number">0</span>]=a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;(<span class="number">1</span>&lt;&lt;j)&lt;=n;j++)&#123;<span class="comment">//区间长度不能超过n</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>&lt;=n;i++)&#123;</span><br><span class="line">            st[i][j]=max(st[i][j<span class="number">-1</span>],st[i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)][j<span class="number">-1</span>]); <span class="comment">//我这里卡了好久，倍增的是区间长度，而st储存的是最值，所以max第二个st第一个括号应该是倍增后的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="type">int</span> r,l;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        <span class="type">int</span> k=log2(r-l+<span class="number">1</span>); <span class="comment">//注意，最后查询将两个区间最值合并</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;max(st[l][k],st[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k])&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="牛客竞赛-15429-倍增"><a href="#牛客竞赛-15429-倍增" class="headerlink" title="牛客竞赛- 15429 倍增"></a>牛客竞赛- 15429 倍增</h3><p>这道题卡了一天，还是由于我对倍增理解不深，这道题是对往后分2^j^段倍增的，ST表储存的是分成2^j^段对多能到达的距离，讲解全在代码里了</p>
<h4 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> n,m,k;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> st[MAXN][<span class="number">21</span>],book[MAXN],sum[MAXN];</span><br><span class="line"><span class="comment">//这里st存的是往右最多走到的距离 </span></span><br><span class="line"><span class="comment">//这里 st表的关系是：一个点往右分成2^j段最多到达的点==先分成2^(j-1)到达的点再往后走2^(j-1) </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		st[i][<span class="number">0</span>]=upper_bound(sum+<span class="number">1</span>,sum+<span class="number">1</span>+n,sum[i<span class="number">-1</span>]+k)-sum;<span class="comment">//很巧妙的sum[i-1]+k，分成一段最多可以到那个数 </span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;(<span class="number">1</span>&lt;&lt;i)&lt;=n;i++)<span class="comment">//当每一个数都小于k并且每两个相邻的数都大于k时就分成了n份，这也是最多分成n份 </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;<span class="comment">//记录从每一个点开始分成(2^i)段对多到达哪一个点 </span></span><br><span class="line">        	st[j][i]=st[st[j][i<span class="number">-1</span>]][i<span class="number">-1</span>];<span class="comment">//st的关系 </span></span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">1</span>;</span><br><span class="line">	 <span class="comment">//这里必须从大到小，因为要分最小段的数量，</span></span><br><span class="line">	<span class="comment">//所以要尽可能让点往右走，从大到小去试，同理当分成最多段时就要从小到大 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">20</span>;st[l][<span class="number">0</span>]&lt;=r;i--)&#123;<span class="comment">//从当前点分成一段当可以到达的点不能超过r </span></span><br><span class="line">		<span class="keyword">if</span>(st[l][i]&lt;=r&amp;&amp;st[l][i])&#123;<span class="comment">//往右最多不能超过r </span></span><br><span class="line">			l=st[l][i];<span class="comment">//更新当前位置 </span></span><br><span class="line">			ans+=(<span class="number">1</span>&lt;&lt;i);<span class="comment">//加上当前分成的段的数量 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="type">int</span> t; <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">		sum[i]=t+sum[i<span class="number">-1</span>];<span class="comment">//前缀和优化将区间和查询优化为O(1) </span></span><br><span class="line">		book[i]=book[i<span class="number">-1</span>]+(t&gt;k);<span class="comment">//很巧妙的前缀和，记录前i个数中大于k的数有几个 </span></span><br><span class="line">	&#125;</span><br><span class="line">	init();</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="type">int</span> l,r;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r;</span><br><span class="line">		<span class="keyword">if</span>(book[r]-book[l<span class="number">-1</span>]&gt;<span class="number">0</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Chtholly&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;<span class="comment">//若[l,r]有数大于k则不可能，直接输出 </span></span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;query(l,r)&lt;&lt;<span class="string">&quot;\n&quot;</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<font color="red" size=4>
做了这三道倍增题感觉对倍增有了新的认识，但是我还是处理不好ST和倍增的关系，经常处理不好ST之间的关系，真的感觉自己好菜😢
</font>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title>Philosopher‘s Walk(大模拟+爆搜)</title>
    <url>/posts/d641c02f.html</url>
    <content><![CDATA[<h1 id="ICPC训练赛-Philosopher‘s-Walk"><a href="#ICPC训练赛-Philosopher‘s-Walk" class="headerlink" title="ICPC训练赛-Philosopher‘s Walk"></a>ICPC训练赛-Philosopher‘s Walk</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/20210415121221.png" alt="image-20210415121210364" style="zoom:50%;" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/20210415121232.png" alt="image-20210415121231522" style="zoom:50%;" /></p>
<p>如图所示，给定这样的一个n阶图形，每次从左下角开始走，问走了m步后的位置坐标？</p>
<p>这个图是有规律可循的，定义f(i)是i阶图的样子，那么f(i+1)就是四个f(i)拼成的，上面两个和f(i)一样，左下角是f(i)顺时针旋转90度得到，右下角是f(i)逆时针旋转90度得到，因此可以定一个dfs函数返回的是坐标，不管这个图形是否旋转，我们只求这个图形没有旋转，也就是正着放时走m步的坐标，即使它旋转了，这个坐标也只不过是换了一个角度而已，我们是知道图形的尺寸的，那就可以根据这个尺寸来推出这个点的坐标</p>
<h2 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,m; </span><br><span class="line">pii <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==<span class="number">1</span>) <span class="keyword">return</span> &#123;<span class="number">1</span>,<span class="number">1</span>&#125;;  <span class="comment">//一阶方阵直接返回坐标(1,1)</span></span><br><span class="line">	x/=<span class="number">2</span>;  </span><br><span class="line">	<span class="type">int</span> res=x*x;  <span class="comment">//算出1/4的尺寸有多少个小方格</span></span><br><span class="line">	<span class="keyword">if</span>(m&gt;<span class="number">3</span>*res)&#123;  <span class="comment">//如果在第4个子图内</span></span><br><span class="line">		m-=<span class="number">3</span>*res;  <span class="comment">//减一下步数</span></span><br><span class="line">		pii tmp=dfs(x);  <span class="comment">//得到在这个小子图(正着放)左下角开始跑m步的坐标</span></span><br><span class="line">		<span class="keyword">return</span> &#123;x*<span class="number">2</span>-tmp.second+<span class="number">1</span>,x-tmp.first+<span class="number">1</span>&#125;;  <span class="comment">//核心，尽管跑出来的是正着放的坐标，但是可以转化为在当前图形的坐标</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(m&gt;<span class="number">2</span>*res)&#123;</span><br><span class="line">		m-=<span class="number">2</span>*res;</span><br><span class="line">		pii tmp=dfs(x);</span><br><span class="line">		<span class="keyword">return</span> &#123;x+tmp.first,x+tmp.second&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(m&gt;res)&#123;</span><br><span class="line">		m-=res;</span><br><span class="line">		pii tmp=dfs(x);</span><br><span class="line">		<span class="keyword">return</span> &#123;tmp.first,x+tmp.second&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		pii tmp=dfs(x);</span><br><span class="line">		<span class="keyword">return</span> &#123;tmp.second,tmp.first&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    pii ans=dfs(n);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans.first&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;ans.second&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Sakura Theme美化</title>
    <url>/posts/7d649817.html</url>
    <content><![CDATA[<h3 id="https-www-jianshu-com-p-e378b320c184"><a href="#https-www-jianshu-com-p-e378b320c184" class="headerlink" title="https://www.jianshu.com/p/e378b320c184"></a><a href="https://www.jianshu.com/p/e378b320c184">https://www.jianshu.com/p/e378b320c184</a></h3><p>超级详细的一个网址</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈01背包和完全背包</title>
    <url>/posts/e4f859ea.html</url>
    <content><![CDATA[<blockquote>
<p>今天做了查并集和01背包结合的一道题，致使我对背包开始了学习</p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>背包问题属于动态规划里面的一大块内容，包括九讲，本文主要讲01背包和完全背包</p>
<p>两个背包差别在于01背包每一个物品只能选一次，完全背包则可以选无限次，只要背包容积足够</p>
<h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><p><strong>结合题目进行讲解</strong></p>
<p>01背包问题</p>
<p>有 NN 件物品和一个容量是 VV 的背包。每件物品只能使用一次。</p>
<p>第 ii 件物品的体积是 vi，价值是 wi。</p>
<p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>输出最大价值。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行两个整数，N，VN，V，用空格隔开，分别表示物品数量和背包容积。</p>
<p>接下来有 NN 行，每行两个整数 vi,wi，用空格隔开，分别表示第 ii 件物品的体积和价值。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一个整数，表示最大价值。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><script type="math/tex; mode=display">
0<N,V≤1000
0<vi,wi≤1000</script><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 5</span><br><span class="line">1 2</span><br><span class="line">2 4</span><br><span class="line">3 4</span><br><span class="line">4 5</span><br></pre></td></tr></table></figure>
<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这是一道01背包模板题</p>
<p>首先从二维开始，我们用dp[i] [j]表示前i个物品当体积为j时最大收益，那么<code>dp[0][j]</code>和<code>dp[i][0]</code>就都为0，分别对应二维数组的第一行和第一列，接下来就从这两列一步一步往最后推，当碰到第i个物品，我们有两个选择，选或者不选，假若背包装不下，那么不选，<code>dp[i][j]=dp[i-1][j]</code>，假若能装下，应该考虑装它是否能使利益最大化，所以应该在装和不装之间取大的，<code>dp[i][j]=max(dp[i-1][j],dp[i-1][j-w[i]]+v[i])</code>，注意这里装不一定比不装收益高，因为可能前几件价值大，第i件价值小，选择了第i件就舍弃了前面价值大的。</p>
<p>详细分析<a href="https://blog.csdn.net/qq_37767455/article/details/99086678">点击我</a></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e3</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> dp[MAXN][MAXN],w[MAXN],c[MAXN]; </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ios;</span><br><span class="line">    <span class="type">int</span> n,v;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;c[i]&gt;&gt;w[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=v;j++)&#123;</span><br><span class="line">    		<span class="keyword">if</span>(j&gt;=c[i]) dp[i][j]=max(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j-c[i]]+w[i]);</span><br><span class="line">    		<span class="keyword">else</span> dp[i][j]=dp[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="comment">//两种写法都一样</span></span><br><span class="line">    	    <span class="comment">//dp[i][j]=dp[i-1][j];</span></span><br><span class="line">    		<span class="comment">//if(j&gt;=c[i]) dp[i][j]=max(dp[i][j],dp[i-1][j-c[i]]+w[i]);            </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;dp[n][v]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="降维"><a href="#降维" class="headerlink" title="降维"></a>降维</h3><p>这个时间复杂的是O(NV)的，已经是最优了，但是空间还可以优化，观察上面的递推公式，当前前i个物品的状态只与前i-1个物品的状态有关，也就是在图上只与正上方和左上方有关，而这两个状态是已知的，因此可以用滚动数组从前往后推，也可以用一维数组从后往前推(<code>必须从后往前推，否则前一次循环保存下来的值将会被修改，从而造成推后面时用的值发生改变</code>)</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e3</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> dp[MAXN],w[MAXN],c[MAXN]; </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ios;</span><br><span class="line">    <span class="type">int</span> n,v;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;c[i]&gt;&gt;w[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="type">int</span> j=v;j&gt;=c[i];j--)&#123;</span><br><span class="line">    	   dp[j]=max(dp[j],dp[j-c[i]]+w[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;dp[v]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><p>完全背包其实和01背包是超级相似的</p>
<p>其公式的推导可见<a href="https://www.acwing.com/video/945/">闫式DP分析法</a>，利用数学公式直接推出完全背包公式：<code>dp[i][j]=max(dp[i-1][j],dp[i][j-w[i]]+v[i])</code>，这个公式和01背包只有最后max第二部分的i-1换成了i，当降维后，01背包和完全背包就只有一个差别，倒着推和正着推😂</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> dp[N],w[N],c[N]; </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ios;</span><br><span class="line">    <span class="type">int</span> n,v;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;c[i]&gt;&gt;w[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=c[i];j&lt;=v;j++)&#123;</span><br><span class="line">            dp[j]=max(dp[j],dp[j-c[i]]+w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;dp[v]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title>bitset</title>
    <url>/posts/9dd4d1cb.html</url>
    <content><![CDATA[<h1 id="bitset"><a href="#bitset" class="headerlink" title="bitset"></a>bitset</h1><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>这个东西相当于一个bool数组，int是32位表示一个数，而这个32位表示32个数，每一位只能存1或者0，这就使得可以开的空间是int的32倍，时间复杂度为（位数）N/W(计算机常数一般为32)，而访问其中某一位时间复杂度为O(1)，这个的用处多用于数组开不下1e9以上的空间，用unordered_map插入时复O(logn)级别，就可以用bitset优化时间为O(1)</p>
<h3 id="定义与初始化"><a href="#定义与初始化" class="headerlink" title="定义与初始化"></a>定义与初始化</h3><p>使用bitset类型需<code>#include&lt;bitset&gt;</code></p>
<p>bitset类型在定义时就需要指定所占的空间，例如</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bitset</span>&lt;<span class="number">233</span>&gt;bit;</span><br></pre></td></tr></table></figure>
<p>bitset类型可以用string和整数初始化（整数转化成对应的二进制）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">bitset</span>&lt;<span class="number">23</span>&gt;bit (<span class="built_in">string</span>(<span class="string">&quot;11101001&quot;</span>));</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;bit&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    bit=<span class="number">233</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;bit&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">00000000000000011101001</span></span><br><span class="line"><span class="number">00000000000000011101001</span></span><br></pre></td></tr></table></figure>
<h2 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h2><p>bitset支持所有<strong>位运算</strong></p>
<p>使用这个来进行位运算要比数组模拟位运算快32倍</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bitset</span>&lt;<span class="number">23</span>&gt;bita(<span class="built_in">string</span>(<span class="string">&quot;11101001&quot;</span>));</span><br><span class="line"><span class="built_in">bitset</span>&lt;<span class="number">23</span>&gt;bitb(<span class="built_in">string</span>(<span class="string">&quot;11101000&quot;</span>));</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;(bita^bitb)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//输出00000000000000000000001 </span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bitset</span>&lt;<span class="number">23</span>&gt;bita(<span class="built_in">string</span>(<span class="string">&quot;11101001&quot;</span>));</span><br><span class="line"><span class="built_in">bitset</span>&lt;<span class="number">23</span>&gt;bitb(<span class="built_in">string</span>(<span class="string">&quot;11101000&quot;</span>));</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;(bita|bitb)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//输出00000000000000011101001</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bitset</span>&lt;<span class="number">23</span>&gt;bita(<span class="built_in">string</span>(<span class="string">&quot;11101001&quot;</span>));</span><br><span class="line"><span class="built_in">bitset</span>&lt;<span class="number">23</span>&gt;bitb(<span class="built_in">string</span>(<span class="string">&quot;11101000&quot;</span>));</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;(bita&amp;bitb)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//输出00000000000000011101000</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bitset</span>&lt;<span class="number">23</span>&gt;bit(<span class="built_in">string</span>(<span class="string">&quot;11101001&quot;</span>));</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;(bit&lt;&lt;<span class="number">5</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//输出00000000001110100100000</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bitset</span>&lt;<span class="number">23</span>&gt;bit(<span class="built_in">string</span>(<span class="string">&quot;11101001&quot;</span>));</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;(bit&gt;&gt;<span class="number">5</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//输出00000000000000000000111</span></span><br></pre></td></tr></table></figure>
<h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><p>对于一个叫做bit的bitset：</p>
<ul>
<li>bit.size()       返回大小（位数）</li>
<li>bit.count()     返回1的个数</li>
<li>bit.any()       返回是否有1</li>
<li>bit.none()      返回是否没有1</li>
<li>bit.set()       全都变成1</li>
<li>bit.set(p)      将第p + 1位变成1（bitset是从第0位开始的！） </li>
<li>bit.set(p, x)   将第p + 1位变成x</li>
<li>bit.reset()     全都变成0</li>
<li>bit.reset(p)    将第p + 1位变成0</li>
<li>bit.flip()      全都取反</li>
<li>bit.flip(p)     将第p + 1位取反</li>
<li>bit.to_ulong()  返回它转换为unsigned long的结果，如果超出范围则报错</li>
<li>bit.to_ullong() 返回它转换为unsigned long long的结果，如果超出范围则报错</li>
<li>bit.to_string() 返回它转换为string的结果</li>
</ul>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://ac.nowcoder.com/acm/contest/11160/D">https://ac.nowcoder.com/acm/contest/11160/D</a></p>
<p>利用bitset可以卡过去</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="type">const</span> ll MAXN=<span class="number">1e6</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> ll MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll SUB=<span class="number">-0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll eps=<span class="number">1e-4</span>;</span><br><span class="line">ll n,m;</span><br><span class="line">ll a[MAXN],b[MAXN]; </span><br><span class="line"><span class="built_in">unordered_map</span>&lt;ll,ll&gt; mp;</span><br><span class="line"><span class="built_in">bitset</span>&lt;<span class="number">1</span>&lt;&lt;<span class="number">30</span>&gt; bt;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;b[i];</span><br><span class="line">		bt.<span class="built_in">set</span>(b[i]);</span><br><span class="line">		mp[b[i]]++;</span><br><span class="line">	&#125;</span><br><span class="line">	ll ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(ll j=<span class="number">0</span>;j&lt;<span class="number">30</span>;j++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(ll k=j+<span class="number">1</span>;k&lt;<span class="number">30</span>;k++)&#123;</span><br><span class="line">				ll now=(<span class="number">1</span>&lt;&lt;j)+(<span class="number">1</span>&lt;&lt;k);</span><br><span class="line">				<span class="keyword">if</span>(bt[a[i]^now]) ans+=mp[a[i]^now];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>bitset优化</tag>
      </tags>
  </entry>
  <entry>
    <title>博弈论</title>
    <url>/posts/12bcd26e.html</url>
    <content><![CDATA[<p><strong>注意注意注意：</strong> 异或运算符优先级比等于还要低！！！！二进制的运算符尽量都加上括号</p>
<ol>
<li>必胜状态后继节点一定有必败</li>
<li>必败状态后继都是必胜</li>
</ol>
<h2 id="巴什博弈"><a href="#巴什博弈" class="headerlink" title="巴什博弈"></a>巴什博弈</h2><blockquote>
<p>数上博弈<br><strong>俩人轮流取数，一次可以取走1到m个数，假如有m+1个数，则第一个人怎么取第二个人都可以一次取走，</strong><br><strong>第二个人就赢了，现在有x个数，这x个数可能是m+1的倍数，也可能不是，假设不是，那么那么第一个人</strong><br><strong>就可以第一次取s个数，把m+1这个必败状态给对方，假如是，则自己就是必败了</strong><br><code>x=n*(m+1)+s</code></p>
</blockquote>
<h3 id="Brave-game-HDU1846"><a href="#Brave-game-HDU1846" class="headerlink" title="Brave game (HDU1846)"></a>Brave game (HDU1846)</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="type">int</span> mod=a%(b+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(mod&gt;=<span class="number">1</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;first&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;second&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h3 id="Public-Sale-HDU2149"><a href="#Public-Sale-HDU2149" class="headerlink" title="Public Sale (HDU2149)"></a>Public Sale (HDU2149)</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;b&gt;&gt;a)&#123;</span><br><span class="line">        <span class="type">int</span> mod=b%(a+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(a&gt;=b)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=b;i&lt;=a;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i!=a) <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span>(mod&gt;=<span class="number">1</span>) <span class="built_in">cout</span>&lt;&lt;mod&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;none&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<blockquote>
<p>图上巴什博弈问题，终结点为必败点，由终结点去推其他店直到推出起点的属性，最后找规律</p>
<ol>
<li><strong>只能走到必胜点的是必败点</strong></li>
<li><strong>可以走到必败点的是必胜点</strong></li>
</ol>
<p><strong>注意：</strong>这里的必败必胜表示的是从这个点开始走的属性而不是走到这个点的属性</p>
</blockquote>
<h3 id="kiki’s-game-HDU2147"><a href="#kiki’s-game-HDU2147" class="headerlink" title="kiki’s game (HDU2147)"></a>kiki’s game (HDU2147)</h3><p><img src="https://img-blog.csdn.net/20140429205410484?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSUFjY2VwdGVk/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>这道题只要n或者m有一个偶数则起点就是必胜点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> n,m;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m)&#123;</span><br><span class="line">		<span class="keyword">if</span>(n==<span class="number">0</span> &amp;&amp; m==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span>(!(n&amp;<span class="number">1</span>) || !(m&amp;<span class="number">1</span>)) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Wonderful!&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;What a pity!&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="斐波那契博弈"><a href="#斐波那契博弈" class="headerlink" title="斐波那契博弈"></a>斐波那契博弈</h2><p>当n是一个斐波那契数的时候必胜或者必输，所以对于一道题可以从小推个十来个数，看看必胜或者必输的点如果正好符合斐波那契数列则可以尝试用这种方法</p>
<h3 id="取石子游戏-HDU2516"><a href="#取石子游戏-HDU2516" class="headerlink" title="取石子游戏 (HDU2516)"></a>取石子游戏 (HDU2516)</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> fbi[<span class="number">51</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	fbi[<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">	fbi[<span class="number">2</span>]=<span class="number">3</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=<span class="number">44</span>;i++) fbi[i]=fbi[i<span class="number">-1</span>]+fbi[i<span class="number">-2</span>]; <span class="comment">//注意用二分的话必须尺寸必须正好后面不能有0</span></span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123;</span><br><span class="line">		<span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		<span class="type">int</span> x=lower_bound(fbi+<span class="number">1</span>,fbi+<span class="number">1</span>+<span class="number">44</span>,n)-fbi;</span><br><span class="line">		<span class="keyword">if</span>(fbi[x]==n) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Second win&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;First win&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="威佐夫博弈"><a href="#威佐夫博弈" class="headerlink" title="威佐夫博弈"></a>威佐夫博弈</h2><p>这个博弈的证明是非常非常复杂的，而且没啥用，所以只需要记住结论会判断哪一个状态是奇异状态，也就是必败状态就可以了</p>
<p>结论：(判断一个状态是否为奇异状态) </p>
<script type="math/tex; mode=display">
\frac{(\sqrt{5}+1)}{2}*(y-x)=x</script><p>满足上面等式则该状态是奇异状态</p>
<h3 id="取石子游戏"><a href="#取石子游戏" class="headerlink" title="取石子游戏"></a>取石子游戏</h3><p>两堆石子，每次可以从两堆石子取走相等数量的石子，或者从一堆中取走任意数量的石子，谁最后没有石子取谁就输了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">	<span class="type">int</span> x=(b-a)*(<span class="built_in">sqrt</span>(<span class="number">5</span>)+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span>(x==a) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a,b;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b)&#123;</span><br><span class="line">		<span class="keyword">if</span>(a&gt;b) swap(a,b);</span><br><span class="line">		<span class="keyword">if</span>(check(a,b)) <span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Nim游戏"><a href="#Nim游戏" class="headerlink" title="Nim游戏"></a>Nim游戏</h2><h3 id="Being-a-Good-Boy-in-Spring-Festival（HDU1850）"><a href="#Being-a-Good-Boy-in-Spring-Festival（HDU1850）" class="headerlink" title="Being a Good Boy in Spring Festival（HDU1850）"></a>Being a Good Boy in Spring Festival（HDU1850）</h3><p>有n堆扑克牌，每堆扑克牌数量为ai，两个人轮流取，每个人可以取走一堆中任意数量的扑克牌，最后没人有牌取就输了</p>
<p>典型nim游戏，奇异局势为当前剩下的所有扑克牌每一堆的数量的异或等于0，即</p>
<script type="math/tex; mode=display">
a1 \oplus a2 \oplus a3 \oplus a4 ...=0(n>=i>=1)</script><p>计算第一步有多少中方式转化为奇异局势，就是用异或和去和a数组中每一个数一一进行异或，就相当于减去了这个数，然后判断得数是否小于a[i]，当小于a[i]则表示可以把a[i]通过异或转变成为除了这个数以外其他数的异或和，就变成了奇异局势</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> a[<span class="number">1000100</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123;</span><br><span class="line">		<span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		<span class="type">int</span> nim=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">			nim^=a[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(nim==<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="type">int</span> k=nim^a[i];</span><br><span class="line">			<span class="keyword">if</span>(k&lt;a[i]) cnt++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;cnt&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="SG函数"><a href="#SG函数" class="headerlink" title="SG函数"></a>SG函数</h2><p><a href="https://www.cnblogs.com/DWVictor/p/10235851.html"><strong>参考文章</strong></a></p>
<p>所谓SG函数其实本质上就是打表，算出每一个点是否为必败情况</p>
<p> 首先定义mex(minimal excludant)运算，这是施加于一个集合的运算，表示最小的不属于这个集合的非负整数。例如mex{0,1,2,4}=3、mex{2,3,5}=0、mex{}=0。</p>
<p> 对于任意状态 x ， 定义 SG(x) = mex(S),其中 S 是 x 后继状态的SG函数值的集合。如 x 有三个后继状态分别为 SG(a),SG(b),SG(c)，那么SG(x) = mex{SG(a),SG(b),SG(c)}。 这样 集合S 的终态必然是空集，所以SG函数的终态为 SG(x) = 0,当且仅当 x 为必败点P时。</p>
<p><strong>【实例】取石子问题</strong></p>
<p>有1堆n个的石子，每次只能取{ 1, 3, 4 }个石子，先取完石子者胜利，那么各个数的SG值为多少？</p>
<p>SG[0]=0，f[]={1,3,4},</p>
<p>x=1 时，可以取走1 - f{1}个石子，剩余{0}个，所以 SG[1] = mex{ SG[0] }= mex{0} = 1;</p>
<p>x=2 时，可以取走2 - f{1}个石子，剩余{1}个，所以 SG[2] = mex{ SG[1] }= mex{1} = 0;</p>
<p>x=3 时，可以取走3 - f{1,3}个石子，剩余{2,0}个，所以 SG[3] = mex{SG[2],SG[0]} = mex{0,0} =1;</p>
<p>x=4 时，可以取走4-  f{1,3,4}个石子，剩余{3,1,0}个，所以 SG[4] = mex{SG[3],SG[1],SG[0]} = mex{1,1,0} = 2;</p>
<p>x=5 时，可以取走5 - f{1,3,4}个石子，剩余{4,2,1}个，所以SG[5] = mex{SG[4],SG[2],SG[1]} =mex{2,0,1} = 3;</p>
<p>以此类推…..</p>
<p>  x    0 1 2 3 4 5 6 7 8….</p>
<p>SG[x]  0 1 0 1 2 3 2 0 1….</p>
<p>由上述实例我们就可以得到SG函数值求解步骤，那么计算1~n的SG函数值步骤如下：</p>
<p>1、使用 数组f 将 可改变当前状态 的方式记录下来。</p>
<p>2、然后我们使用 另一个数组 将当前状态x 的后继状态标记。</p>
<p>3、最后模拟mex运算，也就是我们在标记值中 搜索 未被标记值 的最小值，将其赋值给SG(x)。</p>
<p>4、我们不断的重复 2 - 3 的步骤，就完成了 计算1~n 的函数值。</p>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//f[N]:可改变当前状态的方式，N为方式的种类，f[N]要在getSG之前先预处理</span></span><br><span class="line"><span class="comment">//SG[]:0~n的SG函数值</span></span><br><span class="line"><span class="comment">//S[]:为x后继状态的集合</span></span><br><span class="line"><span class="type">int</span> f[N],SG[MAXN],S[MAXN];</span><br><span class="line"><span class="type">void</span>  <span class="title function_">getSG</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="built_in">memset</span>(SG,<span class="number">0</span>,<span class="keyword">sizeof</span>(SG));</span><br><span class="line">    <span class="comment">//因为SG[0]始终等于0，所以i从1开始</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="comment">//每一次都要将上一状态 的 后继集合 重置</span></span><br><span class="line">        <span class="built_in">memset</span>(S,<span class="number">0</span>,<span class="keyword">sizeof</span>(S));</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span>; f[j] &lt;= i &amp;&amp; j &lt;= N; j++)</span><br><span class="line">            S[SG[i-f[j]]] = <span class="number">1</span>;  <span class="comment">//将后继状态的SG函数值进行标记</span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>;; j++) <span class="keyword">if</span>(!S[j])&#123;   <span class="comment">//查询当前后继状态SG值中最小的非零值</span></span><br><span class="line">            SG[i] = j;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一道题如果会打SG表这道题就做出来了，<del>但是就是打不出来😭</del>，就算空间不够，不能纯打SG表也可以根据SG表求规律的，给你那么多的数据总不会求不出来巴</p>
<p>再看一道经典例题：<a href="https://vjudge.net/contest/396428#problem/H">Nim or not Nim?</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 1000 + 10</span></span><br><span class="line"><span class="comment">//int sg[MAXN];</span></span><br><span class="line"><span class="comment">//bool vis[MAXN];</span></span><br><span class="line"><span class="comment">//void init(int n)&#123;</span></span><br><span class="line"><span class="comment">//	sg[0]=0;</span></span><br><span class="line"><span class="comment">//	sg[1]=1;</span></span><br><span class="line"><span class="comment">//	for(int i=2;i&lt;=n;i++)&#123;</span></span><br><span class="line"><span class="comment">//		memset(vis,0,sizeof vis);</span></span><br><span class="line"><span class="comment">//		for(int j=1;j&lt;=i;j++)&#123;</span></span><br><span class="line"><span class="comment">//			vis[sg[i-j]]=1;</span></span><br><span class="line"><span class="comment">//			if(j!=i) vis[sg[i-j]^sg[j]]=1;</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"><span class="comment">//		for(int j=0;;j++)&#123;</span></span><br><span class="line"><span class="comment">//			if(!vis[j])&#123;</span></span><br><span class="line"><span class="comment">//				sg[i]=j;</span></span><br><span class="line"><span class="comment">//				break;</span></span><br><span class="line"><span class="comment">//			&#125;</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sg</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x%<span class="number">4</span>==<span class="number">0</span>) <span class="keyword">return</span> x<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(x%<span class="number">4</span>==<span class="number">3</span>) <span class="keyword">return</span> x+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>); <span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>); </span><br><span class="line"><span class="comment">//    init(100);</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">    	<span class="type">int</span> n;</span><br><span class="line">    	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    	<span class="type">int</span> c=<span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="type">int</span> tmp;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;tmp;</span><br><span class="line">			c^=sg(tmp); </span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">if</span>(c==<span class="number">0</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Bob&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Alice&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title>倍增与tarjan求解lca</title>
    <url>/posts/8c7b4dc1.html</url>
    <content><![CDATA[<blockquote>
<p><strong>倍增</strong></p>
<p>以倍增方式向上跳，时间复杂度是O(q*logn)</p>
<p><strong>tarjan</strong></p>
<p>树上算法，实现过程通过dfs+并查集来离线求出lca(最近公共祖先)，时间复杂度O(n+q)，n是结点数，q是查询数</p>
</blockquote>
<h2 id="算法实现过程"><a href="#算法实现过程" class="headerlink" title="算法实现过程"></a>算法实现过程</h2><p><strong>倍增算法流程:</strong></p>
<ol>
<li><p>用一个dfs得出每一个点的父亲节点还有它的深度，用数组保存起来，其中保存父亲的数组用dp[i][j]表示，意义是i节点向上跳2^j^步后到达的节点，父亲节点保存在dp[i][0]中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa,<span class="type">int</span> d)</span>&#123;  <span class="comment">//得到每一个点的深度和父亲节点</span></span><br><span class="line">	dp[u][<span class="number">0</span>]=fa;</span><br><span class="line">	dep[u]=d;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u];~i;i=e[i].next)&#123;</span><br><span class="line">		<span class="type">int</span> v=e[i].to;</span><br><span class="line">		<span class="keyword">if</span>(v!=fa) dfs(v,u,d+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后倍增预处理出每一个节点向上跳2^i^步到的的节点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bz</span><span class="params">()</span>&#123; <span class="comment">//预处理</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">22</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> u=<span class="number">1</span>;u&lt;=n;u++)&#123;</span><br><span class="line">			dp[u][i]=dp[dp[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>求两个点的lca时，先让深度小的跳到两个点深度相同的位置，如果跳后两个点重合则这个位置就是lca，否则两个点一起往上跳，直到lca的儿子节点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(dep[u]&lt;dep[v]) <span class="built_in">swap</span>(u,v);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="built_in">log2</span>(dep[u]-dep[v]);i&gt;=<span class="number">0</span>;i--)&#123;  <span class="comment">//跳到相同深度</span></span><br><span class="line">		<span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;i)&lt;=dep[u]-dep[v]) u=dp[u][i]; <span class="comment">//注意dep[x]-dep[y]时刻在变化，也正是因为这个所以dep[x]一定最后和dep[y]相等</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(u==v) <span class="keyword">return</span> u;  <span class="comment">//节点重合即lca</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="built_in">log2</span>(dep[u]);i&gt;=<span class="number">0</span>;i--)&#123;  <span class="comment">//一起往上跳</span></span><br><span class="line">		<span class="keyword">if</span>(dp[u][i]!=dp[v][i])&#123;  <span class="comment">//保证不会跳过lca，但同样的也不能跳到lca了，回跳到lca的儿子结点</span></span><br><span class="line">			u=dp[u][i];</span><br><span class="line">			v=dp[v][i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[u][<span class="number">0</span>];  <span class="comment">//父亲节点即为lca </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>tarjan算法流程：</strong></p>
<ol>
<li><p>保存用两个图去存树和查询关系图</p>
</li>
<li><p>对这棵树进行dfs搜索，从根开始，搜索到一个点把这个点标记，直到把当前结点的<code>所有子树都被标记并和它们的父亲结点合并</code>后，再查询哪些结点和当前结点有查询关系，对于这些结点如果已经被标记过了，那么这个节点的祖先就是这两个点的最近公共祖先(这里是难点)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">tarjan</span><span class="params">(<span class="type">int</span> u)</span>&#123;</span><br><span class="line">	vis[u]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u];~i;i=e[i].next)&#123;</span><br><span class="line">		<span class="type">int</span> v=e[i].to;</span><br><span class="line">		<span class="keyword">if</span>(vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">		tarjan(v);  <span class="comment">//到这里u结点还没有向上合并</span></span><br><span class="line">		fa[v]=u;  <span class="comment">//合并下一个结点和当前结点</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>当得出两个点的Lca后储存答案到lca数组中，因为查询关系图是无向图，不知道dfs搜索时顺序如何，需要给每一条查询关系图的边编个号，把lca答案储存到偶数或者奇数下标内</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ans=find(v);</span><br><span class="line"><span class="keyword">if</span>(ve[u][i].id%<span class="number">2</span>) lca[ve[u][i].id+<span class="number">1</span>]=ans;</span><br><span class="line"><span class="keyword">else</span> lca[ve[u][i].id]=ans;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>为什么和当前点有查询关系的那个点被标记后那个点的祖先就是最近公共祖先呢？</p>
<p>无非就两种情况，用u表示当前结点，v表示另一个点，因为v被标记过，说明v一定在u之前被访问过，那么v要不就是在u的子树中，这种情况v的祖先就是u，<code>因为u还没有向上合并(u以下的所有子树都已经合并完成了)</code>，要不就是不和u在一个分支里，那么dfs一定是经过u和v的lca结点的，这时两个点的路径连线就是一个角，角的顶点就是lca</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><a href="https://www.luogu.com.cn/problem/P3379">链接</a></p>
<h3 id="tarjan"><a href="#tarjan" class="headerlink" title="tarjan"></a>tarjan</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">500100</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> to,next;</span><br><span class="line">&#125;e[MAXN&lt;&lt;<span class="number">1</span>];  <span class="comment">//无向边记得开两倍空间</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xxx</span>&#123;</span>  <span class="comment">//关系图的编号要储存下来</span></span><br><span class="line">	<span class="type">int</span> to,id;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;xxx&gt; ve[MAXN];  <span class="comment">//存储关系图</span></span><br><span class="line"><span class="type">bool</span> vis[MAXN];</span><br><span class="line"><span class="type">int</span> fa[MAXN],head[MAXN],lca[MAXN*<span class="number">2</span>];  <span class="comment">//两倍查询关系无向图</span></span><br><span class="line"><span class="type">int</span> tot;</span><br><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==fa[x]) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">return</span> fa[x]=find(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span>&#123;</span><br><span class="line">	e[tot].to=v;</span><br><span class="line">	e[tot].next=head[u];</span><br><span class="line">	head[u]=tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">tarjan</span><span class="params">(<span class="type">int</span> u)</span>&#123;</span><br><span class="line">	vis[u]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u];~i;i=e[i].next)&#123;</span><br><span class="line">		<span class="type">int</span> v=e[i].to;</span><br><span class="line">		<span class="keyword">if</span>(vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">		tarjan(v);</span><br><span class="line">		fa[v]=u;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> sz=ve[u].size();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;sz;i++)&#123;</span><br><span class="line">		<span class="type">int</span> v=ve[u][i].to;</span><br><span class="line">		<span class="keyword">if</span>(vis[v])&#123;</span><br><span class="line">			<span class="type">int</span> ans=find(v);</span><br><span class="line">			<span class="keyword">if</span>(ve[u][i].id%<span class="number">2</span>) lca[ve[u][i].id+<span class="number">1</span>]=ans;</span><br><span class="line">			<span class="keyword">else</span> lca[ve[u][i].id]=ans;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">	tot=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		fa[i]=i;</span><br><span class="line">		head[i]=<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n,m,s;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;s;</span><br><span class="line">	init(n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">		<span class="type">int</span> u,v;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">		add(u,v);</span><br><span class="line">		add(v,u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="type">int</span> u,v;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">		ve[u].push_back(&#123;v,i*<span class="number">2</span><span class="number">-1</span>&#125;);  <span class="comment">//注意这里放进去这条边的编号</span></span><br><span class="line">		ve[v].push_back(&#123;u,i*<span class="number">2</span>&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	tarjan(s);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;  <span class="comment">//输出偶数下标的lca数组</span></span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;lca[i*<span class="number">2</span>]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>
<h3 id="倍增"><a href="#倍增" class="headerlink" title="倍增"></a>倍增</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">500500</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> to,next;</span><br><span class="line">&#125;e[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> head[MAXN],dep[MAXN],dp[MAXN][<span class="number">25</span>];</span><br><span class="line"><span class="type">int</span> tot,n,m,s;</span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span>&#123;</span><br><span class="line">	e[tot].to=v;</span><br><span class="line">	e[tot].next=head[u];</span><br><span class="line">	head[u]=tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa,<span class="type">int</span> d)</span>&#123;  <span class="comment">//得到每一个点的深度和父亲节点</span></span><br><span class="line">	dp[u][<span class="number">0</span>]=fa;</span><br><span class="line">	dep[u]=d;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u];~i;i=e[i].next)&#123;</span><br><span class="line">		<span class="type">int</span> v=e[i].to;</span><br><span class="line">		<span class="keyword">if</span>(v!=fa) dfs(v,u,d+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">bz</span><span class="params">()</span>&#123; <span class="comment">//预处理</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">22</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> u=<span class="number">1</span>;u&lt;=n;u++)&#123;</span><br><span class="line">			dp[u][i]=dp[dp[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">lca</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(dep[u]&lt;dep[v]) swap(u,v);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=log2(dep[u]-dep[v]);i&gt;=<span class="number">0</span>;i--)&#123;  <span class="comment">//跳到相同深度</span></span><br><span class="line">		<span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;i)&lt;=dep[u]-dep[v]) u=dp[u][i]; <span class="comment">//注意dep[x]-dep[y]时刻在变化，也正是因为这个所以dep[x]一定最后和dep[y]相等</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(u==v) <span class="keyword">return</span> u;  <span class="comment">//节点重合即lca</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=log2(dep[u]);i&gt;=<span class="number">0</span>;i--)&#123;  <span class="comment">//一起往上跳</span></span><br><span class="line">		<span class="keyword">if</span>(dp[u][i]!=dp[v][i])&#123;  <span class="comment">//保证不会跳过lca，但同样的也不能跳到lca了，回跳到lca的儿子结点</span></span><br><span class="line">			u=dp[u][i];</span><br><span class="line">			v=dp[v][i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[u][<span class="number">0</span>];  <span class="comment">//父亲节点即为lca </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;s;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++) head[i]=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">		<span class="type">int</span> u,v;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">		add(u,v);</span><br><span class="line">		add(v,u);</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(s,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">	bz();</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="type">int</span> u,v;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;lca(u,v)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title>查并集</title>
    <url>/posts/1f0cd9a2.html</url>
    <content><![CDATA[<p>查并集也是一种比较常用的算法，有必要掌握<br>下面文章转载于CSDN上的一篇博客，我觉得写的很详细，就把它贴出来吧<br>地址：<a href="https://blog.csdn.net/Hacker_ZhiDian/article/details/60965556">https://blog.csdn.net/Hacker_ZhiDian/article/details/60965556</a></p>
<p>基础</p>
<p>对于今天要总结的算法，我想先通过一道题目来看一下：</p>
<p>假设现在我有一个任务交给你：要求你查看 id 为 x 和 id 为 y 的两个人是不是朋友，<br>在一开始我会在第一行中输入 3 个数字 n、m 、k。<br>n 是代表总人数。<br>接下来 m 行，每一行我会输入两个数字： Xi 、 Yi， 代表 id 为 Xi 和 id 为 Yi 的两个人是朋友（注意：朋友的朋友也是朋友），<br> 接下来 k 行，每一行我也会输入两个数字： a 和 b ，代表我要你查询 id 为 a 和 id 为 b 的两个人是不是朋友，<br> 如果这两个人是朋友，那么在一行中输出“yes”否则在一行中输出“no”。<br> 数据约束：0 &lt; n, m, k &lt; 10000， 所有人的 id 都是正整数，并且 id 不会超过 n </p>
<p>样例输入：</p>
<pre><code>7 5 4
1 3 
2 4
3 4
1 4
5 6
1 4
2 3
2 5
6 7
</code></pre><p>样例输出：</p>
<pre><code>yes
yes
no
no
</code></pre><p>在上面的题目中，如果没有说“朋友的朋友也是朋友”这句话，那么就好办了，我们直接用一个二维数组来记录每一组朋友的信息，然后进行筛选就行了。但是有了这句话，我们就不能简单的用二维数组来解决了。那么怎么解决呢？</p>
<p>首先，我们可以这样想，我们先把所有的人看成独立的群体，也就是说每个人的朋友只有他自己，那么这样的话一开始就有 n 个朋友圈，之后当题目数据输入的时候我们将输入的 id 所代表的的两个人所在的两个朋友圈合并成一个大的朋友圈，那么在这个合并之后的朋友圈中，所有的人两两都是朋友（朋友的朋友也是朋友），不断重复上面的合并过程，直到题目中给的 m 行的朋友对数据全部都合并完成。之后要判断两个人是不是朋友只需要判断他们是不是在同一个朋友圈里面就可以了。</p>
<p>我们用题目中给出的数据来模拟这个过程，先看代码：</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;
const int N = 10010;

int f[N];

/*
* 将表示朋友圈的数组初始化，即将所有人的“朋友祖先”都设置为自己的 id ，
* 于是就有了 n 个不同的朋友圈 
*/
void init(int n) &#123;
    for(int i = 1; i &lt;= n; i++) &#123;
        f[i] = i;
    &#125;
&#125;

// 得到 id 为 v 的人的“朋友祖先”的 id 
int getFriend(int v) &#123;  
    if(f[v] == v) &#123;
        return v;
    &#125;
    /*
    * 如果发现“朋友祖先”不是自己，那么他肯定被合并到别的朋友圈里面去了，
    * 那么继续调用这个函数来找这个朋友圈里面的“朋友祖先”，
    * 并且在这个过程中将找到的人都设置为同一个“朋友祖先”（因为都在同一个朋友圈里面） 
    */
    return f[v] = getFriend(f[v]);
&#125;

// 将两个人所在的两个朋友圈合并为一个朋友圈 
void merge(int a, int b) &#123;
    int t1 = getFriend(a); // 得到左边的人的“朋友祖先” 
    int t2 = getFriend(b); // 得到右边的人的“朋友祖先” 
    /* 这里我们制定一个“靠左原则”：一旦发现两个人的“朋友祖先”不一样，
    * 那么右边那个人的“朋友祖先”的“朋友祖先”设置为左边的人的“朋友祖先”，
    * 当然，也可以制定“靠右原则” 
    */ 
    if(t1 != t2) &#123;  
        f[t2] = t1;
    &#125;
&#125;

int main() &#123;
    int n, m, k;
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;
    int x, y;
    init(n);

    for(int i = 0; i &lt; m; i++) &#123;
        cin &gt;&gt; x &gt;&gt; y;
        merge(x, y);
    &#125; 
    for(int i = 0; i &lt; k; i++) &#123;
        cin &gt;&gt; x &gt;&gt; y;
        // 如果两个人的“朋友祖先”不相同，证明他们不在同一个朋友圈内，也就不是朋友
        if(getFriend(x) != getFriend(y)) &#123;
            cout &lt;&lt; &quot;no&quot; &lt;&lt; endl; 
        &#125; else &#123;
            cout &lt;&lt; &quot;yes&quot; &lt;&lt; endl;
        &#125;
    &#125;

    return 0;
&#125; 
</code></pre><p>用图来模拟这一过程：</p>
<p><img src="https://img-blog.csdn.net/20170309180913015?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSGFja2VyX1poaURpYW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>如果不能理解可以把例题数据带进去代码中自己模拟一遍就知道了，最后我们来看一下运行结果：<br><img src="https://img-blog.csdn.net/20170309184447706?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSGFja2VyX1poaURpYW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>我们可以加一段代码来输出合并之后的数组情况：</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;
const int N = 10010;

int f[N];

/*
* 将表示朋友圈的数组初始化，即将所有人的“朋友祖先”都设置为自己的 id ，
* 于是就有了 n 个不同的朋友圈 
*/
void init(int n) &#123;
    for(int i = 1; i &lt;= n; i++) &#123;
        f[i] = i;
    &#125;
&#125;

// 得到 id 为 v 的人的“朋友祖先”的 id 
int getFriend(int v) &#123;  
    if(f[v] == v) &#123;
        return v;
    &#125;
    /*
    * 如果发现“朋友祖先”不是自己，那么他肯定被合并到别的朋友圈里面去了，
    * 那么继续调用这个函数来找这个朋友圈里面的“朋友祖先”，
    * 并且在这个过程中将找到的人都设置为同一个“朋友祖先”（因为都在同一个朋友圈里面） 
    */
    return f[v] = getFriend(f[v]);
&#125;

// 将两个人所在的两个朋友圈合并为一个朋友圈 
void merge(int a, int b) &#123;
    int t1 = getFriend(a); // 得到左边的人的“朋友祖先” 
    int t2 = getFriend(b); // 得到右边的人的“朋友祖先” 
    /* 这里我们制定一个“靠左原则”：一旦发现两个人的“朋友祖先”不一样，
    * 那么右边那个人的“朋友祖先”的“朋友祖先”设置为左边的人的“朋友祖先”，
    * 当然，也可以制定“靠右原则” 
    */ 
    if(t1 != t2) &#123;  
        f[t2] = t1;
    &#125;
&#125;

int main() &#123;
    int n, m, k;
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;
    int x, y;
    init(n);

    for(int i = 0; i &lt; m; i++) &#123;
        cin &gt;&gt; x &gt;&gt; y;
        merge(x, y);
    &#125;

    /*
    * 输出合并之后的数组情况
    */
    for(int i = 1; i &lt;= n; i++) &#123;
        if(i != 1) &#123;
            cout &lt;&lt; &quot; &quot;;
        &#125;
        cout &lt;&lt; f[i];
    &#125;
    cout &lt;&lt; endl;

    for(int i = 0; i &lt; k; i++) &#123;
        cin &gt;&gt; x &gt;&gt; y;
        // 如果两个人的“朋友祖先”不相同，证明他们不在同一个朋友圈内，也就不是朋友
        if(getFriend(x) != getFriend(y)) &#123;
            cout &lt;&lt; &quot;no&quot; &lt;&lt; endl; 
        &#125; else &#123;
            cout &lt;&lt; &quot;yes&quot; &lt;&lt; endl;
        &#125;
    &#125;

    return 0;

&#125; 
</code></pre><p>结果：</p>
<p><img src="https://img-blog.csdn.net/20170309185244123?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSGFja2VyX1poaURpYW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>和我们在纸上模拟的结果一样，一共有三个朋友圈。<br>这个时候当数组某个位置的值等于其所在下标的时候，id 等于这个值的人就是这个朋友圈的“朋友祖先”， 有多少个“朋友祖先”就有多少个朋友圈。</p>
<p>Ok，其实上面说的这种算法思想就是查并集，其标准的描述也是通过树和森林来定义的：在一个森林中有很多棵不同的树，我们通过一些信息来将一些不同的分开的树合并成一棵大的树。在这道题目中，一开始森林中有 7 棵不同根节点的树，树的根节点在这道题目中就相当于“朋友祖先”（7 个朋友圈，每个朋友圈中只有一个人，即为他自己，也是每个朋友圈的“朋友祖先”），通过题中所给的信息不断合并朋友圈（合并森林中不同的树），合并结束之后森林中树的棵树或者不同的树的根节点的个数（“朋友祖先”的个数）就是朋友圈的个数。</p>
<p>好了，查并集的基本思想就总结到这里了，如果你想更深入的了解其优化，那么请往下看：<br>优化</p>
<p>我们在刚刚合并两个不同的朋友圈为一个大朋友圈的时候，我们制定了一个“靠左原则”，即为将右边的朋友圈作为子圈合并到左边那个朋友圈中，那么现在假设我们有这么两个朋友圈：</p>
<p><img src="https://img-blog.csdn.net/20180305120413608?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSGFja2VyX1poaURpYW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>
<p>如果说现在我们要 合并下标为 1 的人所在的朋友圈 和 下标为 2 的人所在的朋友圈，按照我们刚刚定制的 “靠左原则”，此时我们应该把 朋友圈2 作为朋友圈1 的子圈并且合并到 朋友圈1 中。也就是执行一次我们上面代码中的 merge(1, 2) ，对那么合并之后的朋友圈就是：</p>
<p><img src="https://img-blog.csdn.net/20180305122202998?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSGFja2VyX1poaURpYW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>
<p>祖先坐标改变的部分我用红字表出来了。那么接下来，如果此时我要找出下标为 4 的人所在的朋友圈的祖先，因为此时两个朋友圈已经合并成一个了， 我们调用 getFriend(1) ，首先会查找到 3 ，然后是 2 ，然后是 1。也就是说此时我们要向上递归查找 3 次才能找到。这个效率相对来说不算高。那么问题在哪呢？其实是在我们合并两个朋友圈的时候定制的“靠左原则”。对于上面那种情况，我们明明应该将左边的朋友圈合并到右边的朋友圈效率才更高，此时合并的结果应该是：</p>
<p><img src="https://img-blog.csdn.net/20180305122440975?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSGFja2VyX1poaURpYW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>
<p>此时再查找下标为 4 的人所在的朋友圈就只需要向上递归 2 次就可以了。那么我们应该如何确定合并朋友圈的方式呢？可能到这里你已经想到了：将高度较小的那一个朋友圈作为子圈合并到高度较大的朋友圈。那么我们怎么获取每个朋友圈的高度呢？我们可以用一个数组来保存每个朋友圈的高度，在合并的时候比较两个朋友圈的高度来确定合并方式，合并完成之后调整一下合并后的朋友圈高度。 在上面代码的基础上，我们给出实现代码：</p>
<pre><code>int high[N]; // 一个全局数组。保存每个朋友圈的高度，初始时都是 0 

// 省略其他代码......

/**
* 将两个人所在的两个朋友圈合并为一个朋友圈 
* 这里通过两个朋友圈的高度来决定合并方式 
*/
void merge(int a, int b) &#123;
    int t1 = getFriend(a); // 得到左边的人的“朋友祖先” 
    int t2 = getFriend(b); // 得到右边的人的“朋友祖先” 
    // 两个人的“朋友祖先”不一样，合并两个朋友圈 
    if(t1 != t2) &#123;  
        // 如果左边的朋友圈的高度大于右边的朋友圈的高度，
        // 那么将右边的朋友圈合并到左边的朋友圈中 
        if (high[t1] &gt; high[t2]) &#123;
            f[t2] = t1;
        // 否则就把左边的朋友圈合并到右边的朋友圈中 
        &#125; else &#123;
            f[t1] = t2;
            // 如果当前两个朋友圈的高度相等，那么合并之后的朋友圈高度要加一
            if (high[t1] == high[t2]) &#123;
                high[t2]++;
            &#125;
        &#125;
    &#125;
&#125;

// 省略其他代码......
</code></pre><p>为了方便，我就只给出 merge 函数，因为只有 merge 函数改变了，其它函数都没变。<br>merge 函数里面有一句注释：// 如果当前两个朋友圈的高度相等，那么合并之后的朋友圈高度要加一 。这句话可能会有点难理解，看一幅图就知道了：</p>
<p><img src="https://img-blog.csdn.net/20180305125346468?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSGFja2VyX1poaURpYW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>
<p>因为代码中设定的每个朋友圈初始高度为 0，,所以为了统一，图中也设置只有一个人的朋友圈高度为 0，这里注意一下。经过这样优化之后，我们的查并集的效率就很高了。</p>
<p>最后，我们来看一下程序的运行结果：</p>
<p><img src="https://img-blog.csdn.net/20180305125905988?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSGFja2VyX1poaURpYW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>
<p>结果依然是 3 个朋友圈，并且之后判断两个人是否是同一个朋友圈的结果也是对的，但是每个朋友圈祖先的编号却和原来不一样，这其实是因为我们修改了合并两个朋友圈的方式，即从原来的“靠左原则”变成了“比较朋友圈高度原则”。</p>
<p>最后还是贴一下优化之后的完整代码：</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;
const int N = 10010;

int f[N];
int high[N]; // 保存每个朋友圈的高度，初始时都是 0 

/*
* 将表示朋友圈的数组初始化，即将所有人的“朋友祖先”都设置为自己的 id ，
* 于是就有了 n 个不同的朋友圈 
*/
void init(int n) &#123;
    for(int i = 1; i &lt;= n; i++) &#123;
        f[i] = i;
    &#125;
&#125;

// 得到 id 为 v 的人的“朋友祖先”的 id 
int getFriend(int v) &#123;  
    if(f[v] == v) &#123;
        return v;
    &#125;
    /*
    * 如果发现“朋友祖先”不是自己，那么他肯定被合并到别的朋友圈里面去了，
    * 那么继续调用这个函数来找这个朋友圈里面的“朋友祖先”，
    * 并且在这个过程中将找到的人都设置为同一个“朋友祖先”（因为都在同一个朋友圈里面） 
    */
    return f[v] = getFriend(f[v]);
&#125;

/**
* 将两个人所在的两个朋友圈合并为一个朋友圈 
* 这里通过两个朋友圈的高度来决定合并方式 
*/
void merge(int a, int b) &#123;
    int t1 = getFriend(a); // 得到左边的人的“朋友祖先” 
    int t2 = getFriend(b); // 得到右边的人的“朋友祖先” 
    // 两个人的“朋友祖先”不一样，合并两个朋友圈 
    if(t1 != t2) &#123;  
        // 如果左边的朋友圈的高度大于右边的朋友圈的高度，
        // 那么将右边的朋友圈合并到左边的朋友圈中 
        if (high[t1] &gt; high[t2]) &#123;
            f[t2] = t1;
        // 否则就把左边的朋友圈合并到右边的朋友圈中 
        &#125; else &#123;
            f[t1] = t2;
            // 如果当前两个朋友圈的高度相等，那么合并之后的朋友圈高度要加一， 
            if (high[t1] == high[t2]) &#123;
                high[t2]++;
            &#125;
        &#125;
    &#125;
&#125;

int main() &#123;
    int n, m, k;
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;
    int x, y;
    init(n);

    for(int i = 0; i &lt; m; i++) &#123;
        cin &gt;&gt; x &gt;&gt; y;
        merge(x, y);
    &#125;

    /*
    * 输出合并之后的数组情况
    */
    for(int i = 1; i &lt;= n; i++) &#123;
        if(i != 1) &#123;
            cout &lt;&lt; &quot; &quot;;
        &#125;
        cout &lt;&lt; f[i];
    &#125;
    cout &lt;&lt; endl;

    for(int i = 0; i &lt; k; i++) &#123;
        cin &gt;&gt; x &gt;&gt; y;
        // 如果两个人的“朋友祖先”不相同，证明他们不在同一个朋友圈内，也就不是朋友
        if(getFriend(x) != getFriend(y)) &#123;
            cout &lt;&lt; &quot;no&quot; &lt;&lt; endl; 
        &#125; else &#123;
            cout &lt;&lt; &quot;yes&quot; &lt;&lt; endl;
        &#125;
    &#125;

    return 0;

&#125; 
</code></pre><h2 id="模板题"><a href="#模板题" class="headerlink" title="模板题"></a>模板题</h2><p>地址：<a href="https://nanti.jisuanke.com/t/T1260">https://nanti.jisuanke.com/t/T1260</a></p>
<p>宗教信仰</p>
<p>世界上有许多宗教，你感兴趣的是你学校里的同学信仰多少种宗教。你的学校有 nnn 名学生（0&lt;n≤500000 &lt; n \le 500000&lt;n≤50000），你不太可能询问每个人的宗教信仰，因为他们不太愿意透露。但是当你同时找到 222 名学生，他们却愿意告诉你他们是否信仰同一宗教，你可以通过很多这样的询问估算学校里的宗教数目的上限。你可以认为每名学生只会信仰最多一种宗教。<br>输入格式</p>
<p>输入包括多组数据。每组数据的第一行包括 nnn 和 mmm，0≤m≤n(n−1)/20 \le m \le n(n-1)/20≤m≤n(n−1)/2，其后 mmm 行每行包括两个数字 iii 和 jjj，表示学生 iii 和学生 jjj 信仰同一宗教，学生被标号为 111 至 nnn。</p>
<p>输入以一行 n=m=0n = m = 0n=m=0 作为结束。<br>输出格式</p>
<p>对于每组数据，先输出它的编号（从 111 开始），接着输出学生信仰的不同宗教的数目上限。</p>
<p>输出时每行末尾的多余空格，不影响答案正确性<br>样例输入</p>
<pre><code>10 9
1 2
1 3
1 4
1 5
1 6
1 7
1 8
1 9
1 10
10 4
2 3
4 5
4 8
5 8
0 0
</code></pre><p>样例输出</p>
<pre><code>Case 1: 1
Case 2: 7
</code></pre><p>AC代码：</p>
<pre><code>#include&lt;iostream&gt;
using namespace std;
const int N=50010;
int f[N];
int res=0;
void init(int n)&#123;
    for(int i=1;i&lt;=n;i++)&#123;
        f[i]=i;
    &#125;
&#125;
int getfriend(int v)&#123;
    if(f[v]==v) return v;
    else return f[v]=getfriend(f[v]);
&#125;
void merge(int a,int b)&#123;

    int x=getfriend(a);
    int y=getfriend(b);
    if(x!=y)&#123;
        f[y]=x;
        res++;
    &#125;
&#125;
int main()
&#123;
    int n,m,k=0,x,y;
    while(1)&#123;
        res=0;
        k++;
        cin&gt;&gt;n&gt;&gt;m;
        if(n==0&amp;&amp;m==0) break;
        init(n);
        for(int i=1;i&lt;=m;i++)&#123;
            cin&gt;&gt;x&gt;&gt;y;
            merge(x,y);
        &#125;
        cout&lt;&lt;&quot;Case &quot;&lt;&lt;k&lt;&lt;&quot;: &quot;;
        cout&lt;&lt;n-res&lt;&lt;endl;        
    &#125;

    return 0;
&#125;
</code></pre><blockquote>
<p>制作不易，您的赞助是我最大的动力，谢谢观看（owo）</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>差分</title>
    <url>/posts/a0b0b7bd.html</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>题目：</p>
<p>输入一个长度为n的整数序列。<br>接下来输入m个操作，每个操作包含三个整数l, r, c，表示将序列中[l, r]之间的每个数加上c。<br>请你输出进行完所有操作后的序列。</p>
<p>输入格式</p>
<p>第一行包含两个整数n和m。<br>第二行包含n个整数，表示整数序列。<br>接下来m行，每行包含三个整数l，r，c，表示一个操作。</p>
<p>输出格式</p>
<p>共一行，包含n个整数，表示最终序列。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>对一个区间内的数加C，如果暴力加，会浪费很多时间，我们可以开一个新数组用于差分操作，数组下标就代表数轴上的每一个数，每次给定一个区间，把以区间左端点未下标的数组值加上C，而以（区间右端点+1）为下标的数组值减去C，进行m次操作后，再求一次前缀和并加上原来数组的值就是进行区间操作后的数组，参考下图：<br><img src="差分/0.jpg" alt=""></p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int a[100],b[100];  //例题，开的很小，你可以开大</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">//	freopen(&quot;test.txt&quot;,&quot;r&quot;,stdin); </span><br><span class="line">	int n,m;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line">//		b[i]+=a[i];</span><br><span class="line">//		b[i+1]-=a[i];  //也可以初始化b数组就加上a数组的值，如果这样做了，下面就不能加a数组的值了</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">		int l,r,c;</span><br><span class="line">		cin&gt;&gt;l&gt;&gt;r&gt;&gt;c;</span><br><span class="line">		b[l]+=c;</span><br><span class="line">		b[r+1]-=c;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=1;i&lt;=n;i++) b[i]+=b[i-1]; //前缀和</span><br><span class="line">	for(int i=1;i&lt;=n;i++) cout&lt;&lt;b[i]+a[i]&lt;&lt;&quot; &quot;;  //一定要记得加上原数组的值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>复杂度： O(N)，小于1e8的数据量都可以过</p>
</blockquote>
<p>很简单的算法吧（owo）</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces div4</title>
    <url>/posts/6b47ae8.html</url>
    <content><![CDATA[<p><blockquote>
唯一一场每道题都有思路的比赛，感觉还行，虽然有思路不代表能AC，不过还是很开心的，因为除了E题的桶没想到外其他都是自力更生做出来的😊   
</blockquote><br><img src="https://cdn.jsdelivr.net/gh/uncleacc/Sucai/8~1.webp" alt=""></p>
<h2 id="A-Sum-of-Round-Numbers"><a href="#A-Sum-of-Round-Numbers" class="headerlink" title="A Sum of Round Numbers"></a>A Sum of Round Numbers</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>签到题，就是遍历数的每一位，求出非0的位数有几位，然后int一个v=1，之后没走一个数v*=10，然后当一位数不等于0时就乘上v就行了，这道题用字符串应该更简单，但是我想试试用while，练练手</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#define ios ios::sync_with_stdio(0)</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN=1e4+100;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	int t,k;</span><br><span class="line">	cin&gt;&gt;t;</span><br><span class="line">	while(t--)&#123;</span><br><span class="line">		cin&gt;&gt;k;</span><br><span class="line">		int cnt=0,x=k,v=1;</span><br><span class="line">		while(k/10)&#123;</span><br><span class="line">			int tt=k%10;</span><br><span class="line">			if(tt!=0) cnt++;</span><br><span class="line">			k/=10;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;cnt+1&lt;&lt;endl;</span><br><span class="line">		while(x/10)&#123;</span><br><span class="line">			int tt=x%10;</span><br><span class="line">			if(x/10&amp;&amp;tt!=0) cout&lt;&lt;tt*v&lt;&lt;&quot; &quot;;</span><br><span class="line">			x/=10; v*=10;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;(x%10)*v&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="B-Same-Parity-Summands"><a href="#B-Same-Parity-Summands" class="headerlink" title="B - Same Parity Summands"></a>B - Same Parity Summands</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>这道题是给你一个a和b，让你用b个同为偶数或者奇数的数加起来等于a，输出这些数，刚开始我一直在找规律，感觉很麻烦，找了半小时也没涵盖所有情况，后来发现直接暴力枚举就行了，我们可以考虑极端，当都为奇数时，让除了最后一个数以外的数都是1，然后最后一个数=a-(b-1)，加起来正好等于a，同理都为偶数时，让除了最后一个数以外的数全部变成2，最后一个数为n-2*(k-1)，条件都不符合输出NO<del>想通这个就AC了</del></p>
<h3 id="CODE-1"><a href="#CODE-1" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#define ios ios::sync_with_stdio(0)</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN=1e4+100;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	int t,k,n;</span><br><span class="line">	cin&gt;&gt;t;</span><br><span class="line">	while(t--)&#123;</span><br><span class="line">		cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">		int m=n-(k-1);</span><br><span class="line">		if(m&gt;0&amp;&amp;m%2)&#123;</span><br><span class="line">			cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;</span><br><span class="line">			for(int i=0;i&lt;k-1;i++)&#123;</span><br><span class="line">				cout&lt;&lt;1&lt;&lt;&quot; &quot;;</span><br><span class="line">			&#125;</span><br><span class="line">			cout&lt;&lt;m&lt;&lt;endl;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		m=n-2*(k-1);</span><br><span class="line">		if(m&gt;0&amp;&amp;m%2==0)&#123;</span><br><span class="line">			cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;</span><br><span class="line">			for(int i=0;i&lt;k-1;i++)&#123;</span><br><span class="line">				cout&lt;&lt;2&lt;&lt;&quot; &quot;;</span><br><span class="line">			&#125;</span><br><span class="line">			cout&lt;&lt;m&lt;&lt;endl;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="C-K-th-Not-Divisible-by-n"><a href="#C-K-th-Not-Divisible-by-n" class="headerlink" title="C - K-th Not Divisible by n"></a>C - K-th Not Divisible by n</h2><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>看题目就知道大意，不被n整除的第K个数，首先我们清楚被N整除的数之间的数数量一定是相同的，比如能整除8的：8 16 24…数之间都相差8，那这就是一个找规律嘛，用“%”找到该数在一段区间的那个位置，然后用“/”找到在第几个区间就行了</p>
<h3 id="CODE-2"><a href="#CODE-2" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#define ios ios::sync_with_stdio(0)</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN=1e4+100;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	int t,k,n;</span><br><span class="line">	cin&gt;&gt;t;</span><br><span class="line">	while(t--)&#123;</span><br><span class="line">		int a,b;</span><br><span class="line">		cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">		int k=b%(a-1);</span><br><span class="line">		if(k==0)&#123;</span><br><span class="line">			cout&lt;&lt;(b/(a-1)*a)-1&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">		else cout&lt;&lt;(b/(a-1)*a)+k&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="D-Alice-Bob-and-Candies"><a href="#D-Alice-Bob-and-Candies" class="headerlink" title="D. Alice, Bob and Candies"></a>D. Alice, Bob and Candies</h2><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>这道题好长啊，我第一眼就被吓住了，<del>不战而屈人之兵，不过狠下心来读一读，发现就是一个双向指针往中间合拢，</del>好像这叫双向队列~~，再多定义几个变量记录每次每个人吃多少，每个人上次吃了多少，就是一个模拟，只要能写对条件，就能AC了</p>
<h3 id="CODE-3"><a href="#CODE-3" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#define ios ios::sync_with_stdio(0)</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN=1e4;</span><br><span class="line">int val[MAXN];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	int t; cin&gt;&gt;t;</span><br><span class="line">	while(t--)&#123;</span><br><span class="line">		int n,pa=0,pb=0,flg=0;; cin&gt;&gt;n;</span><br><span class="line">		int sum=0;</span><br><span class="line">		for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">			cin&gt;&gt;val[i];</span><br><span class="line">			sum+=val[i];</span><br><span class="line">		&#125;</span><br><span class="line">		int ea=0,eb=0,cnt=1,sa,sb,head=1,tail=n;</span><br><span class="line">		while(tail-head&gt;=0)&#123;</span><br><span class="line">			sa=0; sb=0;</span><br><span class="line">			if(flg==0&amp;&amp;sum-ea-eb&gt;pb)&#123;</span><br><span class="line">				while(sa&lt;=pb)&#123;</span><br><span class="line">					sa+=val[head];</span><br><span class="line">					ea+=val[head];</span><br><span class="line">					head++; </span><br><span class="line">				&#125;</span><br><span class="line">				pa=sa; flg=1; cnt++;</span><br><span class="line">				continue;</span><br><span class="line">			&#125;</span><br><span class="line">			if(flg==1&amp;&amp;sum-ea-eb&gt;pa)&#123;</span><br><span class="line">				while(sb&lt;=pa)&#123;</span><br><span class="line">					sb+=val[tail];</span><br><span class="line">					eb+=val[tail];</span><br><span class="line">					tail--;</span><br><span class="line">				&#125;</span><br><span class="line">				pb=sb; flg=0; cnt++;</span><br><span class="line">				continue;</span><br><span class="line">			&#125;</span><br><span class="line">			cnt++;</span><br><span class="line">			if(flg==0)&#123;</span><br><span class="line">				ea+=sum-ea-eb;</span><br><span class="line">				break;</span><br><span class="line">			&#125;else&#123;</span><br><span class="line">				eb+=sum-ea-eb;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;cnt-1&lt;&lt;&quot; &quot;&lt;&lt;ea&lt;&lt;&quot; &quot;&lt;&lt;eb&lt;&lt;&quot; &quot;&lt;&lt;endl;</span><br><span class="line">	&#125; </span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">双向队列超级简单，水题</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">deque&lt;int&gt; dq;</span><br><span class="line">int main()</span><br><span class="line">&#123;	</span><br><span class="line">	int t;</span><br><span class="line">	cin&gt;&gt;t;</span><br><span class="line">	while(t--)&#123;</span><br><span class="line">		dq.clear();</span><br><span class="line">		int n; cin&gt;&gt;n;</span><br><span class="line">		for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">			int temp; cin&gt;&gt;temp;</span><br><span class="line">			dq.push_back(temp);</span><br><span class="line">		&#125;</span><br><span class="line">		ll pa=0,pb=0,suma=0,sumb=0,res=1,ansa=0,ansb=0,cnt=0;</span><br><span class="line">		while(!dq.empty())&#123;</span><br><span class="line">			cnt++;</span><br><span class="line">			suma=sumb=0;</span><br><span class="line">			if(res&amp;1)&#123;</span><br><span class="line">				while(suma&lt;=pb&amp;&amp;!dq.empty())&#123;</span><br><span class="line">					suma+=dq.front();</span><br><span class="line">					dq.pop_front();</span><br><span class="line">				&#125;</span><br><span class="line">				ansa+=suma; </span><br><span class="line">				pa=suma;</span><br><span class="line">			&#125;else&#123;</span><br><span class="line">				while(sumb&lt;=pa&amp;&amp;!dq.empty())&#123;</span><br><span class="line">					sumb+=dq.back();</span><br><span class="line">					dq.pop_back();</span><br><span class="line">				&#125;</span><br><span class="line">				ansb+=sumb;</span><br><span class="line">				pb=sumb;</span><br><span class="line">			&#125;</span><br><span class="line">			res++;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;cnt&lt;&lt;&quot; &quot;&lt;&lt;ansa&lt;&lt;&quot; &quot;&lt;&lt;ansb&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="E-Special-Elements"><a href="#E-Special-Elements" class="headerlink" title="E. Special Elements"></a>E. Special Elements</h2><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>最好理解的一道题目🌝也是我唯一一道看了题解的题目😂一个前缀和，这道题数据量很小，只有8000，直接装进桶里就行了，而我就是没想到，一直在纠结怎么降低复杂度（好菜啊）求出每一个区间的和看看这个和对应的桶编号里面装没装数，<del>其实是道水题</del></p>
<h3 id="CODE-4"><a href="#CODE-4" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#define ios ios::sync_with_stdio(0)</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN=1e4;</span><br><span class="line">int val[MAXN],book[MAXN];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	int t; cin&gt;&gt;t;</span><br><span class="line">	while(t--)&#123;</span><br><span class="line">		memset(book,0,sizeof book);</span><br><span class="line">		memset(val,0,sizeof val);</span><br><span class="line">		int n; cin&gt;&gt;n;</span><br><span class="line">		for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">			cin&gt;&gt;val[i];</span><br><span class="line">			book[val[i]]++;</span><br><span class="line">			val[i]+=val[i-1];</span><br><span class="line">		&#125;</span><br><span class="line">		int cnt=0;</span><br><span class="line">		for(int i=0;i&lt;n-1;i++)&#123;</span><br><span class="line">			for(int j=i+2;j&lt;=n;j++)&#123;</span><br><span class="line">				int sum=val[j]-val[i];</span><br><span class="line">//				cout&lt;&lt;sum&lt;&lt;&#x27; &#x27;&lt;&lt;book[sum]&lt;&lt;endl;</span><br><span class="line">				if(sum&lt;=n&amp;&amp;book[sum])&#123;</span><br><span class="line">					cnt+=book[sum]; 					</span><br><span class="line">					book[sum]=0;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">	&#125; </span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="F-Binary-String-Reconstruction"><a href="#F-Binary-String-Reconstruction" class="headerlink" title="F - Binary String Reconstruction"></a>F - Binary String Reconstruction</h2><h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><p>又是思维题，给你一个n0,n1,n2让你构造一个二进制序列，这个序列子序列中00的个数为n0，01或10的个数为n1，11的个数为n2，首先n0和n2的序列容易构造，因为只包含一个数字，n1我们可以定义顺序为1010…n1=1:10 n1=2:101 n1=3:1010，每次增加一个数，单独构造容易，合起来难，三个序列合起来中间肯定会多出一些，所以只要在本上演算一下，再把多出的那一部分去掉就行了，然后我构造的序列顺序是n0n2n1，感觉这样构造简单🐶说实话我交代码时都没敢想能AC，因为感觉没考虑全，但是测试几组数据发现能过就抱着试一试的态度交上去了，结果A了:smile:</p>
<h3 id="CODE-5"><a href="#CODE-5" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#define ios ios::sync_with_stdio(0)</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN=1e4;</span><br><span class="line">int val[MAXN],book[MAXN];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	int t; cin&gt;&gt;t;</span><br><span class="line">	while(t--)&#123;</span><br><span class="line">		int n0,n1,n2;</span><br><span class="line">		string ans;</span><br><span class="line">		cin&gt;&gt;n0&gt;&gt;n1&gt;&gt;n2;</span><br><span class="line">		for(int i=1;i&lt;=n0+1;i++)&#123;</span><br><span class="line">			if(n1!=0||n1==0&amp;&amp;n2==0) ans+=&quot;0&quot;;</span><br><span class="line">		&#125;</span><br><span class="line">		for(int i=1;i&lt;=n2;i++)&#123;</span><br><span class="line">			ans+=&quot;1&quot;;</span><br><span class="line">		&#125;</span><br><span class="line">		for(int i=1;i&lt;=n1;i++)&#123;</span><br><span class="line">			if(i%2) ans+=&quot;1&quot;;</span><br><span class="line">			else ans+=&quot;0&quot;;</span><br><span class="line">		&#125;</span><br><span class="line">		if(n0==0&amp;&amp;n1==0) ans+=&quot;1&quot;;</span><br><span class="line">		cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">	&#125; </span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="G-Special-Permutation"><a href="#G-Special-Permutation" class="headerlink" title="G - Special Permutation"></a>G - Special Permutation</h2><h3 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h3><p>说实话我不知道这道题为啥放在最后，<del>感觉难度并不大，反而挺简单的</del>🌚就是让你构造一个相邻两个数之差的绝对值在2到4的区间内（闭区间），我们只要把奇偶分开就行了，但是我有一个疑问，我的思路是把偶数写在前面奇数的倒序列放在后面，例如：<br>8：2 4 6 8 7 5 3 1<br>很明显只有中间不符合条件，所以只动中间就行了，让7和5（奇数序列的前两个）交换：<br>8：2 4 6 8 5 7 3 1（满足条件）<br>再举个例子：<br>9：2 4 6 8 9 7 5 3 1<br>还是只动中间，因为9比8（奇数第一个和偶数最后一个）大所以让5跑到9中间（奇数第3个移动到奇数和偶数序列之间）：<br>9：2 4 6 8 5 9 7 3 1（满足条件）<br>这样的思路我仔细想了想感觉没毛病，就交了，结果wrong了？我不服气，发现中间可能是换行的问题，又交又wrong…<br><img src="https://cdn.jsdelivr.net/gh/uncleacc/Sucai/5~1.webp" alt=""><br>我枯了，为啥？<br>后来换思路：<br>给2 4 1 3的序列两边添加数，先左后右轮换添加，例如：   </p>
<ol>
<li>8：2 4 1 3  </li>
<li>8：5 2 4 1 3  </li>
<li>8：5 2 4 1 3 6  </li>
<li>8：7 5 2 4 1 3 6  </li>
<li>8：7 5 2 4 1 3 6 8<br>完成~，交了AC了。。AC后看了测试数据发现我原来的代码测试数据1应该是对的啊！希望网友那位可以为我解惑（不胜感激）<br><img src="https://cdn.jsdelivr.net/gh/uncleacc/Sucai/7~1.webp" alt=""></li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/Sucai/6~1.webp" alt=""></p>
<h3 id="wrong-CODE"><a href="#wrong-CODE" class="headerlink" title="wrong CODE"></a>wrong CODE</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#define ios ios::sync_with_stdio(0)</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN=1e4;</span><br><span class="line">void swap(int &amp;a,int &amp;b)&#123;</span><br><span class="line">	int t=a;</span><br><span class="line">	a=b;</span><br><span class="line">	b=t;</span><br><span class="line">&#125;</span><br><span class="line">int val[MAXN],book[MAXN];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	int t; cin&gt;&gt;t;</span><br><span class="line">	while(t--)&#123;</span><br><span class="line">		memset(val,0,sizeof val); </span><br><span class="line">		int n; cin&gt;&gt;n;</span><br><span class="line">		if(n==2||n==3)&#123;</span><br><span class="line">			cout&lt;&lt;-1&lt;&lt;endl;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		int tail=0;</span><br><span class="line">		for(int i=2;i&lt;=n;i+=2)&#123;</span><br><span class="line">			val[++tail]=i;</span><br><span class="line">		&#125;</span><br><span class="line">		int flag=tail;</span><br><span class="line">		int p=n%2?n:n-1;</span><br><span class="line">		for(int i=p;i&gt;=1;i-=2)&#123;</span><br><span class="line">			val[++tail]=i;</span><br><span class="line">		&#125;</span><br><span class="line">		if(val[flag+1]&lt;val[flag]) swap(val[flag+1],val[flag+2]);</span><br><span class="line">		else&#123;</span><br><span class="line">			for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">				if(i==flag+1)&#123;</span><br><span class="line">					printf(&quot;%d%c&quot;,val[flag+3],i==n?&#x27;\n&#x27;:&#x27; &#x27;);</span><br><span class="line">				&#125;</span><br><span class="line">				if(i==flag+3)&#123;</span><br><span class="line">					continue;</span><br><span class="line">				&#125;</span><br><span class="line">				printf(&quot;%d%c&quot;,val[i],i==n?&#x27;\n&#x27;:&#x27; &#x27;);</span><br><span class="line">			&#125;</span><br><span class="line">			if(n==5) cout&lt;&lt;endl;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		for(int i=1;i&lt;=n;i++) printf(&quot;%d%c&quot;,val[i],i==n?&#x27;\n&#x27;:&#x27; &#x27;);</span><br><span class="line">	&#125; </span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AC-CODE"><a href="#AC-CODE" class="headerlink" title="AC CODE"></a>AC CODE</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">string ans;</span><br><span class="line">void bd(int n)&#123;</span><br><span class="line">	if(n&lt;=9)&#123;</span><br><span class="line">		ans=(char)(n+&#x27;0&#x27;)+ans;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		while(n!=0)&#123;</span><br><span class="line">			char c=(char)(n%10+&#x27;0&#x27;);</span><br><span class="line">			ans=c+ans;</span><br><span class="line">			n/=10;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void pd(int n)&#123;</span><br><span class="line">		if(n&lt;=9)&#123;</span><br><span class="line">		ans+=(char)(n+&#x27;0&#x27;);</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		char ch[2000];</span><br><span class="line">		int tail=0;</span><br><span class="line">		while(n!=0)&#123;</span><br><span class="line">			char c=(char)(n%10+&#x27;0&#x27;);</span><br><span class="line">			ch[++tail]=c;</span><br><span class="line">			n/=10;</span><br><span class="line">		&#125;</span><br><span class="line">		for(int i=tail;i&gt;=1;i--)&#123;</span><br><span class="line">			ans+=ch[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int t; cin&gt;&gt;t;</span><br><span class="line">	while(t--)&#123;</span><br><span class="line">		ans.clear();</span><br><span class="line">		int n; cin&gt;&gt;n;</span><br><span class="line">		if(n&lt;=3)&#123;</span><br><span class="line">			puts(&quot;-1&quot;);</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		ans+=&quot;2 4 1 3&quot;;</span><br><span class="line">		int flag=1;</span><br><span class="line">		for(int i=5;i&lt;=n;i++)&#123;</span><br><span class="line">			if(i%2)&#123;</span><br><span class="line">				ans=&quot; &quot;+ans;</span><br><span class="line">				bd(i);</span><br><span class="line">			&#125;</span><br><span class="line">			else&#123;</span><br><span class="line">				ans+=&quot; &quot;;</span><br><span class="line">				pd(i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Ending~撒花<font color="red" size=6>不要白嫖了，留下一个赞吧👍<font></p>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>比赛</tag>
      </tags>
  </entry>
  <entry>
    <title>dfs记忆化搜索</title>
    <url>/posts/b58a3aa9.html</url>
    <content><![CDATA[<p>今天学习了记忆化搜索，也练习了许多题，我果然是一个蒟蒻（qwq）</p>
<p>希望下面的讲解对您有所帮助</p>
<h2 id="仙岛求药"><a href="#仙岛求药" class="headerlink" title="仙岛求药"></a>仙岛求药</h2><p>少年李逍遥的婶婶病了，王小虎介绍他去一趟仙灵岛，向仙女姐姐要仙丹救婶婶。叛逆但孝顺的李逍遥闯进了仙灵岛，克服了千险万难来到岛的中心，发现仙药摆在了迷阵的深处。迷阵由 M×NM \times NM×N 个方格组成，有的方格内有可以瞬秒李逍遥的怪物，而有的方格内则是安全。现在李逍遥想尽快找到仙药，显然他应避开有怪物的方格，并经过最少的方格，而且那里会有神秘人物等待着他。现在要求你来帮助他实现这个目标。</p>
<p>输入格式</p>
<p>第一行输入两个非零整数 MMM 和 NNN，两者均不大于 202020。MMM 表示迷阵行数, NNN 表示迷阵列数。</p>
<p>接下来有 MMM 行, 每行包含 NNN 个字符,不同字符分别代表不同含义:</p>
<p>1) ‘@’：少年李逍遥所在的位置；2) ‘.’：可以安全通行的方格；3) ‘#’：有怪物的方格；4) ‘*’：仙药所在位置。</p>
<p>输出格式</p>
<p>输出一行，该行包含李逍遥找到仙药需要穿过的最少的方格数目(计数包括初始位置的方块)。如果他不可能找到仙药, 则输出 −1-1−1。</p>
<p>输出时每行末尾的多余空格，不影响答案正确性</p>
<p>样例输入1</p>
<p>8 8<br>.@##…#</p>
<h1 id="…"><a href="#…" class="headerlink" title="….#."></a>….#.</h1><h1 id=""><a href="#" class="headerlink" title=".#.##.."></a>.#.##..</h1><p>..#.###.</p>
<h1 id="…-1"><a href="#…-1" class="headerlink" title=".#…#."></a>.#…#.</h1><p>..###.#.<br>…#.*..<br>.#…###</p>
<p>样例输出1</p>
<p>10</p>
<p>样例输入2</p>
<p>6 5</p>
<p>.*.#.</p>
<p>.#…</p>
<p>..##.</p>
<p>…..</p>
<p>.#…</p>
<p>….@</p>
<p>样例输出2</p>
<p>8</p>
<p>样例输入3</p>
<p>9 6</p>
<p>.#..#. </p>
<p>.#.*.# </p>
<p>.####. </p>
<p>..#… </p>
<p>..#… </p>
<p>..#… </p>
<p>..#… </p>
<h1 id="-1"><a href="#-1" class="headerlink" title=".@."></a>.@.</h1><p>.#..#.</p>
<p>样例输出3</p>
<p>-1</p>
<p>这是一道典型的搜索题目，不过如果你只贴上dfs的模板指定是过不了的，必须进行优化，但是使用BFS的话就直接可以过了，BFS我下一篇文章讲有，我们知道dfs的思路是不撞南墙不回头，但其实有些路径走到一半就知道这是一条不归路了，我们可以用一个数组来储存到达每一个坐标点的最短路径，当搜索的时候如果现在的步数加一大于到达下一个坐标位置的最短路径，则无需继续，直接改变方向，贴代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">char a[25][25];  //地图</span><br><span class="line">int step[25][25];  //记录每一个走到的位置的最短路径</span><br><span class="line">int dx[5]=&#123;1,0,0,-1&#125;;  //下一个位置</span><br><span class="line">int dy[5]=&#123;0,1,-1,0&#125;;</span><br><span class="line">int n,m;  //地图大小</span><br><span class="line">bool flag = false;  //标记</span><br><span class="line">void dfs(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">    if(a[x][y]==&#x27;*&#x27;)&#123;  //到达终点返回</span><br><span class="line">        flag = true;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;4;i++)&#123;</span><br><span class="line">//就是优化到这里了，加了一个判断如果当前位置的步数+1 &gt; 下一个位置的最小步数，就不用走了否则就更新下一个位置的最小步数</span><br><span class="line"></span><br><span class="line">        int tx=x+dx[i];</span><br><span class="line">        int ty=y+dy[i];</span><br><span class="line">        if(tx&gt;=0 &amp;&amp; tx&lt;n &amp;&amp; ty&lt;m &amp;&amp; ty&gt;=0 &amp;&amp; a[tx][ty]!=&#x27;#&#x27;&amp;&amp; step[x][y]+1&lt;step[tx][ty])&#123;</span><br><span class="line">            step[tx][ty] = step[x][y]+1;  //更新这个位置的最小坐标</span><br><span class="line">        	dfs(tx,ty);  //继续搜索下一位置</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int qx,zx,qy,zy;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">        for(int j=0;j&lt;m;j++)</span><br><span class="line">            step[i][j]=1&lt;&lt;30; //初始化每一个坐标的最小路径，初始值很大</span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">        for(int j=0;j&lt;m;j++)&#123;</span><br><span class="line">            cin &gt;&gt; a[i][j];</span><br><span class="line">            if(a[i][j]==&#x27;@&#x27;)&#123;</span><br><span class="line">                qx = i; qy = j; //找到起始位置，把起始位置的最短路径设置为0</span><br><span class="line">                step[qx][qy]=0;</span><br><span class="line">            &#125;</span><br><span class="line">            if(a[i][j]==&#x27;*&#x27;)&#123;  //找到终点</span><br><span class="line">                zx = i; zy = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(qx,qy);</span><br><span class="line">    if(flag)</span><br><span class="line">        cout &lt;&lt; step[zx][zy];</span><br><span class="line">    else</span><br><span class="line">        cout &lt;&lt; &quot;-1&quot;;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="滑雪"><a href="#滑雪" class="headerlink" title="滑雪"></a>滑雪</h2><p>Description<br>Michael喜欢滑雪百这并不奇怪， 因为滑雪的确很刺激。可是为了获得速度，滑的区域必须向下倾斜，而且当你滑到坡底，你不得不再次走上坡或者等待升降机来载你。Michael想知道载一个区域中最长底滑坡。区域由一个二维数组给出。数组的每个数字代表点的高度。下面是一个例子 </p>
<p> 1  2  3  4 5</p>
<p>16 17 18 19 6</p>
<p>15 24 25 20 7</p>
<p>14 23 22 21 8</p>
<p>13 12 11 10 9</p>
<p>一个人可以从某个点滑向上下左右相邻四个点之一，当且仅当高度减小。在上面的例子中，一条可滑行的滑坡为24-17-16-1。当然25-24-23-…-3-2-1更长。事实上，这是最长的一条。</p>
<p>Input</p>
<p>输入的第一行表示区域的行数R和列数C(1 &lt;= R,C &lt;= 100)。下面是R行，每行有C个整数，代表高度h，0&lt;=h&lt;=10000。</p>
<p>Output</p>
<p>输出最长区域的长度。</p>
<p>Sample Input</p>
<p>5 5</p>
<p>1 2 3 4 5</p>
<p>16 17 18 19 6</p>
<p>15 24 25 20 7</p>
<p>14 23 22 21 8</p>
<p>13 12 11 10 9</p>
<p>Sample Output</p>
<p>25</p>
<p>Source<br>SHTSC 2002</p>
<p>解题思路：</p>
<p>记忆化搜索比普通的搜索效率要高，已经搜索过的就不用再搜索了，有DP的思想.step[i][j] 保存的是当前坐标i,j可以到达的最大距离（不包括自己），比如3 2 1，当前是3，那么可以到达的最大距离为2，对于每个坐标，可以上下左右四个方向搜索，取距离最大的那个，作为该坐标的step[][]。记忆化搜索这里体现的就是当搜索到某一个坐标时，该坐标的step[][]已经有值（搜索过了），且肯定是最优的，那么直接返回该step[][]值就可以了。</p>
<p>代码：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=110;</span><br><span class="line">int map[maxn][maxn];</span><br><span class="line">int step[maxn][maxn];</span><br><span class="line">int Next[][2]=&#123;&#123;1,0&#125;,&#123;0,1&#125;,&#123;-1,0&#125;,&#123;0,-1&#125;&#125;;</span><br><span class="line">int m,n;</span><br><span class="line">int judge(int x,int y)&#123;</span><br><span class="line">	if(x&gt;=0&amp;&amp;x&lt;m&amp;&amp;y&gt;=0&amp;&amp;y&lt;n) return 1;</span><br><span class="line">	else return 0;</span><br><span class="line">&#125;</span><br><span class="line">int dfs(int x,int y)&#123;</span><br><span class="line">	if(step[x][y]) return step[x][y];</span><br><span class="line">	for(int i=0;i&lt;4;i++)&#123;</span><br><span class="line">		int tx=x+Next[i][0];</span><br><span class="line">		int ty=y+Next[i][1];</span><br><span class="line">		if(judge(tx,ty)&amp;&amp;map[tx][ty]&lt;map[x][y])&#123;</span><br><span class="line">			int temp=dfs(tx,ty)+1;</span><br><span class="line">			step[x][y]=max(temp,step[x][y]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return step[x][y];</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int ans=0;</span><br><span class="line">	cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line">	for(int i=0;i&lt;m;i++)&#123;</span><br><span class="line">		for(int j=0;j&lt;n;j++)&#123;</span><br><span class="line">			cin&gt;&gt;map[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=0;i&lt;m;i++)&#123;</span><br><span class="line">		for(int j=0;j&lt;n;j++)&#123;</span><br><span class="line">			step[i][j]=dfs(i,j);</span><br><span class="line">			if(ans&lt;step[i][j]) ans=step[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans+1&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>制作不易，各位老板，可否赏小可怜2毛钱呢（owo），感谢各位老板</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>dfs记忆化搜索</title>
    <url>/posts/b58a3aa9.html</url>
    <content><![CDATA[<blockquote>
<p>dfs标记的位置太重要了，放在不同位置产生的效果都有巨大的差别，记录今天的一些dfs记忆化搜索题目</p>
</blockquote>
<h2 id="A-Function-Run-Fun"><a href="#A-Function-Run-Fun" class="headerlink" title="A- Function Run Fun"></a>A- Function Run Fun</h2><p><a href="https://vjudge.net/contest/387584#problem/A">题目链接</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">using namespace std;</span><br><span class="line">ll used[50][50][50];</span><br><span class="line">ll w(int x,int y,int z)&#123;</span><br><span class="line">	if(x&lt;=0||y&lt;=0||z&lt;=0) return 1;</span><br><span class="line">	if(x&gt;20||y&gt;20||z&gt;20) return w(20,20,20);</span><br><span class="line">	if(used[x][y][z]) return used[x][y][z];</span><br><span class="line">	if(x&lt;y&amp;&amp;y&lt;z) return used[x][y][z]=w(x,y,z-1)+w(x,y-1,z-1)-w(x,y-1,z);</span><br><span class="line">	return used[x][y][z]=w(x-1,y,z)+w(x-1,y-1,z)+w(x-1,y,z-1)-w(x-1,y-1,z-1);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int a,b,c;</span><br><span class="line">	while(cin&gt;&gt;a&gt;&gt;b&gt;&gt;c)&#123;</span><br><span class="line">		if(a==-1&amp;&amp;b==-1&amp;&amp;c==-1) break;</span><br><span class="line">		memset(used,0,sizeof used);</span><br><span class="line">		printf(&quot;w(%d, %d, %d) = %lld\n&quot;,a,b,c,w(a,b,c));</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>
<h2 id="B-滑雪"><a href="#B-滑雪" class="headerlink" title="B- 滑雪"></a>B- 滑雪</h2><p><a href="https://vjudge.net/contest/387584#problem/B">题目链接</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span><br><span class="line">typedef long long ll;</span><br><span class="line">using namespace std;</span><br><span class="line">int G[110][110],step[110][110];</span><br><span class="line">int Next[4][2]=&#123;1,0,0,1,-1,0,0,-1&#125;;</span><br><span class="line">int r,c;</span><br><span class="line">int dfs(int x,int y)&#123;</span><br><span class="line">	if(step[x][y]) return step[x][y];</span><br><span class="line">	step[x][y]=1; //因为记忆化搜索要判断该点是否为零，所以初始化要放到这里</span><br><span class="line">	for(int i=0;i&lt;4;i++)&#123;</span><br><span class="line">		int nx=x+Next[i][0];</span><br><span class="line">		int ny=y+Next[i][1];</span><br><span class="line">		if(nx&gt;=1&amp;&amp;nx&lt;=r&amp;&amp;ny&gt;=1&amp;&amp;ny&lt;=c&amp;&amp;G[nx][ny]&lt;G[x][y])&#123;</span><br><span class="line">			step[x][y]=max(step[x][y],dfs(nx,ny)+1); </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return step[x][y];</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	cin&gt;&gt;r&gt;&gt;c;</span><br><span class="line">	for(int i=1;i&lt;=r;i++)&#123;</span><br><span class="line">		for(int j=1;j&lt;=c;j++)&#123;</span><br><span class="line">			cin&gt;&gt;G[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	int maxn=-1;</span><br><span class="line">	for(int i=1;i&lt;=r;i++)&#123;</span><br><span class="line">		for(int j=1;j&lt;=c;j++)&#123;</span><br><span class="line">			maxn=max(maxn,dfs(i,j));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;maxn&lt;&lt;&#x27;\n&#x27;;</span><br><span class="line">	return 0;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>
<h2 id="C-漫步校园"><a href="#C-漫步校园" class="headerlink" title="C- 漫步校园"></a>C- 漫步校园</h2><p><a href="https://vjudge.net/contest/387584#problem/C">题目链接</a></p>
<p>这道题涉及到求每一个点到某一点的最短路径，听着很耳熟吧，没错就是dijistla算法！这不过这个是通过矩阵给你了，但是性质没变，依旧是用一个bfs，只不过找一个点的邻接点方式变成了上下左右！依旧是通过最小点去更新其他点，可以看以下两段代码，优化后时间31ms，没优化46ms，朴素版本的没有采用标记法，虽然答案一样，但是其走了许多不必要走的点，这些点的最短路径已经确定了，根本不可能更新但还是去比较了，浪费了时间</p>
<p>记忆化搜索在递归的过程中已经算出来了许多点的值，以后的递归过程中当用这个点的值时可以直接返回</p>
<h3 id="优化-CODE"><a href="#优化-CODE" class="headerlink" title="优化 CODE"></a>优化 CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> x,y,step;</span><br><span class="line">	<span class="type">bool</span> operator &lt; (<span class="type">const</span> node &amp;o) <span class="type">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> step&gt;o.step;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> G[<span class="number">110</span>][<span class="number">110</span>],dis[<span class="number">110</span>][<span class="number">110</span>],vis[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line">ll used[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="type">int</span> Next[<span class="number">4</span>][<span class="number">2</span>]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="built_in">priority_queue</span>&lt;node&gt; pq;</span><br><span class="line"><span class="type">void</span> <span class="title function_">bfs</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(!pq.empty()) pq.pop();</span><br><span class="line">	<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">	<span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dis);</span><br><span class="line">	node s=&#123;n,n,G[n][n]&#125;;</span><br><span class="line">	pq.push(s);</span><br><span class="line">	dis[n][n]=G[n][n];</span><br><span class="line">	<span class="keyword">while</span>(!pq.empty())&#123;</span><br><span class="line">		node tmp=pq.top(); pq.pop();</span><br><span class="line">		<span class="keyword">if</span>(vis[tmp.x][tmp.y]) <span class="keyword">continue</span>; <span class="comment">//已经确定最短路径的点</span></span><br><span class="line">		vis[tmp.x][tmp.y]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">			<span class="type">int</span> nx=tmp.x+Next[i][<span class="number">0</span>];</span><br><span class="line">			<span class="type">int</span> ny=tmp.y+Next[i][<span class="number">1</span>];</span><br><span class="line">			<span class="keyword">if</span>(nx&lt;<span class="number">1</span>||nx&gt;n||ny&lt;<span class="number">1</span>||ny&gt;n) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(dis[tmp.x][tmp.y]+G[nx][ny]&lt;dis[nx][ny])&#123;</span><br><span class="line">				dis[nx][ny]=dis[tmp.x][tmp.y]+G[nx][ny];</span><br><span class="line">				pq.push(&#123;nx,ny,dis[nx][ny]&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">ll <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123; <span class="comment">//注意ll</span></span><br><span class="line">	<span class="keyword">if</span>(used[x][y]) <span class="keyword">return</span> used[x][y]; </span><br><span class="line">	used[x][y]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">		<span class="type">int</span> nx=x+Next[i][<span class="number">0</span>];</span><br><span class="line">		<span class="type">int</span> ny=y+Next[i][<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span>(nx&lt;<span class="number">1</span>||nx&gt;n||ny&lt;<span class="number">1</span>||ny&gt;n) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(dis[x][y]&gt;dis[nx][ny])&#123;</span><br><span class="line">			used[x][y]+=dfs(nx,ny); <span class="comment">//一个点的所有走法等于它周围所有点的走法之和</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> used[x][y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">				<span class="built_in">cin</span>&gt;&gt;G[i][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		bfs();</span><br><span class="line"><span class="comment">//		for(int i=1;i&lt;=n;i++)&#123;</span></span><br><span class="line"><span class="comment">//			for(int j=1;j&lt;=n;j++)&#123;</span></span><br><span class="line"><span class="comment">//				if(j!=n) cout&lt;&lt;dis[i][j]&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line"><span class="comment">//				else cout&lt;&lt;dis[i][j]&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line"><span class="comment">//			&#125;</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line">		<span class="built_in">memset</span>(used,<span class="number">0</span>,<span class="keyword">sizeof</span> used);</span><br><span class="line">		used[n][n]=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;dfs(<span class="number">1</span>,<span class="number">1</span>)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>
<h3 id="朴素-CODE"><a href="#朴素-CODE" class="headerlink" title="朴素 CODE"></a>朴素 CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> G[<span class="number">110</span>][<span class="number">110</span>],dis[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line">ll used[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="type">int</span> Next[<span class="number">4</span>][<span class="number">2</span>]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="built_in">queue</span>&lt;node&gt; q;</span><br><span class="line"><span class="type">void</span> <span class="title function_">bfs</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(!q.empty()) q.pop();</span><br><span class="line">	<span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dis);</span><br><span class="line">	node s=&#123;n,n&#125;;</span><br><span class="line">	q.push(s);</span><br><span class="line">	dis[n][n]=G[n][n];</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		node tmp=q.front(); q.pop();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">			<span class="type">int</span> nx=tmp.x+Next[i][<span class="number">0</span>];</span><br><span class="line">			<span class="type">int</span> ny=tmp.y+Next[i][<span class="number">1</span>];</span><br><span class="line">			<span class="keyword">if</span>(nx&lt;<span class="number">1</span>||nx&gt;n||ny&lt;<span class="number">1</span>||ny&gt;n) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(dis[tmp.x][tmp.y]+G[nx][ny]&lt;dis[nx][ny])&#123;</span><br><span class="line">				dis[nx][ny]=dis[tmp.x][tmp.y]+G[nx][ny];</span><br><span class="line">				q.push(&#123;nx,ny&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">ll <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(used[x][y]) <span class="keyword">return</span> used[x][y];</span><br><span class="line">	ll sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">		<span class="type">int</span> nx=x+Next[i][<span class="number">0</span>];</span><br><span class="line">		<span class="type">int</span> ny=y+Next[i][<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span>(nx&lt;<span class="number">1</span>||nx&gt;n||ny&lt;<span class="number">1</span>||ny&gt;n) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(dis[x][y]&gt;dis[nx][ny])&#123;</span><br><span class="line">			sum+=dfs(nx,ny);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	used[x][y]=sum;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">				<span class="built_in">cin</span>&gt;&gt;G[i][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		bfs();</span><br><span class="line">		<span class="built_in">memset</span>(used,<span class="number">0</span>,<span class="keyword">sizeof</span> used);</span><br><span class="line">		used[n][n]=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;dfs(<span class="number">1</span>,<span class="number">1</span>)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>
<h2 id="E-Zipper"><a href="#E-Zipper" class="headerlink" title="E  Zipper"></a>E  Zipper</h2><p><a href="https://vjudge.net/contest/387584#problem/E">题目链接</a></p>
<p>感觉是一道难题，可能是对我来说吧，这道题不能简单的遍历，当前两个字符串出现相同字符时，没有办法确定该字符在第三个字符串中的位置，例如样例2： <code>cat tree catrtee</code> 人眼第一眼看都以为输出no，但是仔细想一想，如果cat的t是最后一个t那么这就是可行的，这种判断是哪个t的操作普通遍历是不可行的，这种题目就有dp的思想，首先我们判断前两个字符串的首字母和最后一个字符串的首字母相同否，因为第三个字符串如果可以由前俩字符串组成，那么里面的所有字符要不是第一个字符串里的要不是第二个里面的，假若最后一个字符串的首字母既不是A里面的也不是B里面的，那一定是不可行的，若是A或B里面的，就分为3种情况</p>
<ol>
<li>假若是A里面的不是B里面的，那么A的第一个字符和C的第一个字符就可以同时去掉了！问题就变成了判断A(除了第一个字符)和B是否能组成C(除了第一个字符)，这就把问题分成了子问题，</li>
<li>假若是B里面的不是A里面的，性质同第一种情况</li>
<li>同时是A又是B里面的，这样就要分两种情况去走了，例如样例2<code>cat tree catrtee</code>，首先我们把t当作是第一个的t，然后再当作第二个的，分别看看能否有解，只要有一个有解就说明是可行的</li>
</ol>
<p>这种子问题和原问题性质一样的题目就可以用递归去解，写一个dfs函数，三个参数分别是ABC的当前下标，什么时候结束呢？当前两个字符串的下标移到了最后就说明该解可行，标记flag返回就行了。</p>
<p>但是还没完，到这里还没用记忆化搜索，这样会超时，为什么用到了记忆化搜索？例如：<code>ttt ttt tttttt</code>，这是一组数据，因为里面每一个字符都相同，那么就都要分两种情况去搜索，有很多种情况都是重复搜索的，例如：<code>tt tt tttt</code>，既可以由<code>ttt tt ttttt</code>，转化过来也可以由<code>tt ttt ttttt</code>转化过来，那么就被计算了两次，那么就可以存下运算结果，标记这种情况已经算过了，以后再到这种情况直接返回</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="built_in">string</span> s1,s2,s3;</span><br><span class="line"><span class="type">int</span> n,len1,len2,len3,flag;</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">500</span>][<span class="number">500</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> pos1,<span class="type">int</span> pos2,<span class="type">int</span> pos3)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(pos1==len1&amp;&amp;pos2==len2)&#123; <span class="comment">//找到可行解</span></span><br><span class="line">		flag=<span class="number">1</span>; <span class="comment">//标记</span></span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(s1[pos1]!=s3[pos3]&amp;&amp;s2[pos2]!=s3[pos3]) <span class="keyword">return</span> ; <span class="comment">//C字符串字符一定是A或者B里的一个，不是则不可行</span></span><br><span class="line">	<span class="keyword">if</span>(vis[pos1][pos2]) <span class="keyword">return</span> ; <span class="comment">//记忆化搜索标记</span></span><br><span class="line">	vis[pos1][pos2]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(s1[pos1]==s3[pos3]) dfs(pos1+<span class="number">1</span>,pos2,pos3+<span class="number">1</span>); <span class="comment">//分两种情况</span></span><br><span class="line">	<span class="keyword">if</span>(s2[pos2]==s3[pos3]) dfs(pos1,pos2+<span class="number">1</span>,pos3+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="type">int</span> t,kase=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;s1&gt;&gt;s2&gt;&gt;s3;</span><br><span class="line">		len1=s1.size();</span><br><span class="line">		len2=s2.size();</span><br><span class="line">		len3=s3.size();</span><br><span class="line">		flag=<span class="number">0</span>;</span><br><span class="line">		dfs(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>); </span><br><span class="line">		<span class="keyword">if</span>(flag) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Data set &quot;</span>&lt;&lt;++kase&lt;&lt;<span class="string">&quot;: yes&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Data set &quot;</span>&lt;&lt;++kase&lt;&lt;<span class="string">&quot;: no&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>
<h2 id="G-FatMouse-and-Cheese"><a href="#G-FatMouse-and-Cheese" class="headerlink" title="G- FatMouse and Cheese"></a>G- FatMouse and Cheese</h2><p><a href="https://vjudge.net/contest/387584#problem/G">题目链接</a></p>
<p>和B滑雪很相似，代码一些细节很重要，标注部分，采用此方式速度甚至会快一些</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> G[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line">ll used[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="type">int</span> Next[<span class="number">4</span>][<span class="number">2</span>]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">ll <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(used[x][y]) <span class="keyword">return</span> used[x][y];</span><br><span class="line">	used[x][y]=G[x][y]; <span class="comment">//每一个点的初始分数都是它本身，这个不能放到主函数进行，因为会影响上一句if的判断，实际上这是一句细思极秒的操作，这个操作避免了许多临界问题</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=m;k++)&#123;</span><br><span class="line">			<span class="type">int</span> nx=x+k*Next[i][<span class="number">0</span>];</span><br><span class="line">			<span class="type">int</span> ny=y+k*Next[i][<span class="number">1</span>];</span><br><span class="line">			<span class="keyword">if</span>(nx&lt;<span class="number">1</span>||nx&gt;n||ny&lt;<span class="number">1</span>||ny&gt;n) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(G[nx][ny]&gt;G[x][y])&#123;</span><br><span class="line">				used[x][y]=max(used[x][y],dfs(nx,ny)+G[x][y]); <span class="comment">//这个点往下走后这个点就不会再用了，换句话说就是由这个点拓展出去的点不会反过来拓展该点，因此可以直接在循环里面更新其最值</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> used[x][y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m)&#123;</span><br><span class="line">		<span class="keyword">if</span>(n==<span class="number">-1</span>&amp;&amp;m==<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">				<span class="built_in">cin</span>&gt;&gt;G[i][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">memset</span>(used,<span class="number">0</span>,<span class="keyword">sizeof</span> used);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;dfs(<span class="number">1</span>,<span class="number">1</span>)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>集训</tag>
      </tags>
  </entry>
  <entry>
    <title>二进制补码</title>
    <url>/posts/ccdf9d65.html</url>
    <content><![CDATA[<p>这道题看百度上的题解把我看蒙了，想了半天没想通，直到我看见在计算机中负数是用补码来表示的，我才恍然大悟，咋把这个给忘了（抓狂）<br><img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/20200703225037185.png" alt=""></p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>蒜头君有一个 int\text{int}int 的整数，输出它的 323232 位二进制补码。</p>
<p>输入格式</p>
<p>一个整型整数。</p>
<p>输出格式</p>
<p>输出一行，即该整数的补码表示。</p>
<p>输出时每行末尾的多余空格，不影响答案正确性</p>
<p>样例输入：</p>
<p>7</p>
<p>样例输出</p>
<p>00000000000000000000000000000111</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>做这道题就是明白一点：计算机中负数用补码来表示，因为整数补码是本身，所以这道题其实就是输出一个数在计算机中的二进制形式，超级简单了</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
using namespace std;
int map1[110][110],map2[110][110];
int main()
&#123;
  int n;
  cin&gt;&gt;n;
  for(int i=31;i&gt;=0;i--)&#123;
    cout&lt;&lt;((n&gt;&gt;i)&amp;1); //输出这一位的数
  &#125;
&#125;
</code></pre><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p><a href="https://zhidao.baidu.com/question/1370612947989125499.html">传送门</a></p>
<h3 id="i的作用"><a href="#i的作用" class="headerlink" title="%i的作用"></a>%i的作用</h3><p>%i和%d区别在scanf中，%i功能更强大，能根据输入的形式转换成十进制并赋值给变量，比如下面程序：</p>
<pre><code>int n;
  scanf(&quot;%i&quot;,&amp;n);
  cout&lt;&lt;n;
&#125;
</code></pre><p>输入0X10，输出16,输入0010输出8(八进制)</p>
<blockquote>
<p>c语言不能直接表示二进制,没有数字前缀表示</p>
<h3 id="itoa函数"><a href="#itoa函数" class="headerlink" title="itoa函数"></a>itoa函数</h3><p><a href="https://baike.baidu.com/item/itoa%E5%87%BD%E6%95%B0/3260813?fr=aladdin">传送门</a></p>
</blockquote>
<p>C语言中可以用%o %d/%i %x输出8 10 16进制的数但是没有二进制的输出字符，但是有itoa的函数，</p>
<blockquote>
<p>注意: 计算机中负数用补码表示，所以itoa函数求出的负数也是补码形式</p>
</blockquote>
<p>函数原型：</p>
<pre><code>char *itoa( int value, char *string,int radix); [1] 
原型说明：
value：欲转换的数据。
string：目标字符串的地址。
radix：转换后的进制数，可以是10进制、16进制等。
</code></pre><p>参考代码：</p>
<p>1</p>
<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
int main(void)
&#123;
    int number = 12345;
    char string[32];
    itoa(number, string, 10);
    printf(&quot;integer = %d string = %s\n&quot;, number, string);
    return 0;
&#125;
</code></pre><p>2</p>
<pre><code>/* itoa example */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
int main ()&#123;
    int i;
    char buffer[33];
    printf (&quot;Enter a number: &quot;);
    scanf (&quot;%d&quot;,&amp;i);    //输入整数i
    itoa (i,buffer,10);    //将i转化为10进制数，存到buffer中
    printf (&quot;decimal: %s\n&quot;,buffer);    //输出打印buffer
    itoa (i,buffer,16);    //将i转化为16进制数，存到buffer中
    printf (&quot;hexadecimal: %s\n&quot;,buffer);    //输出打印buffer
    itoa (i,buffer,2);    //将i转化为2进制数，存到buffer中
    printf (&quot;binary: %s\n&quot;,buffer);    //输出打印buffer
    return 0;&#125;
OUTPUT:
Enter a number: 1750
decimal: 1750
hexadecimal: 6d6
binary: 11011010110
</code></pre><blockquote>
<p>注意事项</p>
</blockquote>
<p>itoa() 函数有3个参数：第一个参数是要转换的数字，第二个参数是要写入转换结果的目标字符串，第三个参数是转移数字时所用的基数(进制)。在上例中，转换基数为10，就意味着以10为转换进制。10：十进制；2：二进制…</p>
<p>itoa 并不是一个标准的C函数，它是Windows特有的，如果要写跨平台的程序，请用sprintf。</p>
<p>标准库中有sprintf，功能比这个更强，用法跟printf类似：</p>
<p>char str[255];</p>
<p>sprintf(str, “%x”, 100); //将100转为16进制表示的字符串。</p>
<p>下列函数也可以将相应类型的整数转换为字符串：</p>
<figure class="highlight plaintext"><figcaption><span>*ultoa(unsigned long value,char *string,int radix)</span></figcaption><table><tr><td class="code"><pre><span class="line">　　将无符号整型数value转换成字符串并返回该字符串,radix为转换时所用基数</span><br><span class="line">　　char *ltoa(long value,char *string,int radix)</span><br><span class="line">　　将长整型数value转换成字符串并返回该字符串,radix为转换时所用基数</span><br><span class="line">　　char *itoa(int value,char *string,int radix)</span><br><span class="line">　　将整数value转换成字串存入string,radix为转换所用基数.</span><br><span class="line">　　double atof(char *nptr)</span><br><span class="line">　　将字符串nptr转换成双精度数,并返回这个数,错误返回0</span><br><span class="line">　　int atoi(char *nptr)</span><br><span class="line">　　将字符串nptr转换成整型数, 并返回这个数,错误返回0</span><br><span class="line">　　long atol(char *nptr)</span><br><span class="line">　　将字符串nptr转换成长整型数,并返回这个数,错误返回0</span><br><span class="line">　　double strtod(char *str,char **endptr)</span><br><span class="line">　　将字符串str转换成双精度数,并返回这个数,</span><br><span class="line">　　long strtol(char *str,char **endptr,int base)</span><br><span class="line">　　将字符串str转换成长整型数, 并返回这个数</span><br></pre></td></tr></table></figure>
<p>ok,又11点多了，哎！啥也不是</p>
]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title>飞翔的小鸟C语言小游戏</title>
    <url>/posts/3e57986e.html</url>
    <content><![CDATA[<blockquote>
<p>今天有些疲倦，不想学习，就去网上学习做了一个小游戏，如果你是网友，没接触过图形库，要先安装esayx库，网上有许多，在这里不贴了，素材地址： <a href="https://pan.baidu.com/s/1GWnLePCiLcxlJHOaBKEeaA">https://pan.baidu.com/s/1GWnLePCiLcxlJHOaBKEeaA</a> 密码：pmzq 💪</p>
</blockquote>
<ul>
<li>成品视频: <a href="https://www.bilibili.com/video/BV1354y1Q7iB">Here</a><center>
<font color="black" size=4>
希望该文章能帮助到您
</font>
<font color="red" size=5>
不要白嫖了！！！留下您的评论吧
</font>
</center>
<center>
<font color="green" size=2>
谁能帮我测试一下下面的赏是不是出错了😘
</font>
</center>

</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">1.创建一个可视化窗口</span><br><span class="line">2.显示一张背景图</span><br><span class="line">*/</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;graphics.h&gt;</span><br><span class="line">#include &lt;conio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">#include &lt;mmsystem.h&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line">#pragma comment(lib,&quot;winmm.lib&quot;)</span><br><span class="line"></span><br><span class="line">IMAGE mybird[2];//给图片起名字</span><br><span class="line">IMAGE BG;//背景图片</span><br><span class="line">IMAGE overimg[2];//游戏结束图片</span><br><span class="line">IMAGE up[2];//上面柱子</span><br><span class="line">IMAGE down[2];//下面柱子</span><br><span class="line"></span><br><span class="line">struct bird &#123;//鸟的属性</span><br><span class="line">    int x, y;</span><br><span class="line">    int speed;</span><br><span class="line">&#125;;</span><br><span class="line">struct zhuzi &#123;</span><br><span class="line">    int x, y;//起始坐标</span><br><span class="line">    int h;//高度</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bird flybird = &#123; 124,304,100 &#125;;//初始化鸟</span><br><span class="line">void loadresource() &#123;</span><br><span class="line">    loadimage(&amp;BG, &quot;飞翔的小鸟/background.bmp&quot;);//背景</span><br><span class="line">    loadimage(&amp;mybird[0], &quot;飞翔的小鸟/birdy.bmp&quot;, 48, 48);</span><br><span class="line">    loadimage(&amp;mybird[1], &quot;飞翔的小鸟/bird.bmp&quot;, 48, 48);</span><br><span class="line">    loadimage(&amp;overimg[0], &quot;飞翔的小鸟/endy.bmp&quot;);</span><br><span class="line">    loadimage(&amp;overimg[1], &quot;飞翔的小鸟/end.bmp&quot;);</span><br><span class="line">    loadimage(&amp;up[0], &quot;飞翔的小鸟/upy.bmp&quot;);</span><br><span class="line">    loadimage(&amp;up[1], &quot;飞翔的小鸟/up.bmp&quot;);</span><br><span class="line">    loadimage(&amp;down[0], &quot;飞翔的小鸟/downy.bmp&quot;);</span><br><span class="line">    loadimage(&amp;down[1], &quot;飞翔的小鸟/down.bmp&quot;);</span><br><span class="line">&#125;</span><br><span class="line">void drawbird(int x,int y) &#123;</span><br><span class="line">    //SCAND的方式贴掩码图</span><br><span class="line">    putimage(x, y, &amp;mybird[0], SRCAND);</span><br><span class="line">    //SRCPAINT的方式贴背景图</span><br><span class="line">    putimage(x, y, &amp;mybird[1], SRCPAINT);</span><br><span class="line">&#125;</span><br><span class="line">//多线程处理音乐因为直接在按键函数里面写会有画面停顿感</span><br><span class="line">DWORD WINAPI playmusic(LPVOID lpParamer) &#123;</span><br><span class="line">    mciSendString(&quot;open 飞翔的小鸟/jump.mp3&quot;, 0, 0, 0);</span><br><span class="line">    mciSendString(&quot;play 飞翔的小鸟/jump.mp3 wait&quot;, 0, 0, 0);</span><br><span class="line">    mciSendString(&quot;close 飞翔的小鸟/jump.mp3&quot;, 0, 0, 0);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">//撞击柱子</span><br><span class="line">DWORD WINAPI playMusic1(LPVOID lpParamer) &#123; //多线程</span><br><span class="line">    mciSendString(&quot;open 飞翔的小鸟/hit.mp3&quot;, 0, 0, 0); </span><br><span class="line">    mciSendString(&quot;play 飞翔的小鸟/hit.mp3 wait&quot;, 0, 0, 0);</span><br><span class="line">    mciSendString(&quot;close 飞翔的小鸟/hit.mp3&quot;, 0, 0, 0);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">DWORD WINAPI playMusic2(LPVOID lpParamer) &#123; //多线程</span><br><span class="line">    mciSendString(&quot;open 飞翔的小鸟/gameover.mp3&quot;, 0, 0, 0);</span><br><span class="line">    mciSendString(&quot;play 飞翔的小鸟/gameover.mp3 wait&quot;, 0, 0, 0);</span><br><span class="line">    mciSendString(&quot;close 飞翔的小鸟/gameover.mp3&quot;, 0, 0, 0);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">//结束动画</span><br><span class="line">void Gameover() &#123;</span><br><span class="line">    //图片初始位置</span><br><span class="line">    int x = 50;</span><br><span class="line">    int y = 608;</span><br><span class="line">    while (y &gt;= 240) &#123;</span><br><span class="line">        putimage(0, 0, &amp;BG);</span><br><span class="line">        putimage(x, y, &amp;overimg[0], SRCAND);</span><br><span class="line">        putimage(x, y, &amp;overimg[1], SRCPAINT);</span><br><span class="line">        y -= 50;</span><br><span class="line">        Sleep(50);</span><br><span class="line">    &#125;</span><br><span class="line">    CreateThread(NULL, NULL, playMusic2, NULL, NULL, NULL);</span><br><span class="line">    Sleep(5000);</span><br><span class="line">&#125;</span><br><span class="line">//撞击地板或是天花板</span><br><span class="line">int hitfloor() &#123;</span><br><span class="line">    if (flybird.y &lt;= 0 || flybird.y &gt;= (608 - 96)) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">//撞到柱子</span><br><span class="line">int hitPillar(zhuzi myPillar[]) &#123;  //撞到柱子</span><br><span class="line">    for (int i = 0; i &lt; 3; ++i) &#123;</span><br><span class="line">        if ((flybird.x+48) &gt;= myPillar[i].x &amp;&amp; (flybird.x+48) &lt;= myPillar[i].x + 52|| </span><br><span class="line">            flybird.x &gt;= myPillar[i].x &amp;&amp; flybird.x &lt;= myPillar[i].x + 52)</span><br><span class="line">        &#123;</span><br><span class="line">            if (flybird.y+12 &lt;= myPillar[i].h || flybird.y+12 &gt;= (512 - 320 + myPillar[i].h)||</span><br><span class="line">                (flybird.y+36) &lt;= myPillar[i].h || (flybird.y+36) &gt;= (512 - 320 + myPillar[i].h))</span><br><span class="line">            &#123;</span><br><span class="line">                CreateThread(NULL, NULL, playMusic1, NULL, NULL, NULL);</span><br><span class="line">                return 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">//用户按键处理</span><br><span class="line">void keydown(zhuzi pillar[]) &#123;</span><br><span class="line">    /*</span><br><span class="line">        mciSendString(&quot;指令&quot;,0,0,0)</span><br><span class="line">        指令:</span><br><span class="line">            open: 打开</span><br><span class="line">            play: 播放</span><br><span class="line">            pause: 暂停</span><br><span class="line">            wait: 等待</span><br><span class="line">            stop: 暂停</span><br><span class="line">            close: 关闭</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    char userkey = _getch();</span><br><span class="line">    switch (userkey) &#123;</span><br><span class="line">    case &#x27; &#x27;:</span><br><span class="line">        for (int i = 1; i &lt;= flybird.speed - 30; i++) &#123;</span><br><span class="line">            flybird.y -= 1;</span><br><span class="line">            if (hitPillar(pillar)) Gameover();</span><br><span class="line">        &#125;</span><br><span class="line">        CreateThread(NULL, NULL, playmusic, NULL, NULL, NULL);</span><br><span class="line">        break;</span><br><span class="line">    case&#x27;z&#x27;: case&#x27;Z&#x27;:</span><br><span class="line">            char c;</span><br><span class="line">            while (c = _getch()) &#123;</span><br><span class="line">                if (c == &#x27;z&#x27; || c == &#x27;Z&#x27;) break;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">    default:</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void initpillar(zhuzi pillar[], int i) &#123;</span><br><span class="line">    pillar[i].h = rand() % 100 + 160;//最低高度160，最大259，[160,259]</span><br><span class="line">    pillar[i].x = 288;</span><br><span class="line">    pillar[i].y = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void drawpillar(zhuzi pillar) &#123;</span><br><span class="line">    putimage(pillar.x, 0, 52, pillar.h, &amp;down[0], 0, 320 - pillar.h, SRCAND);//柱子宽度为52</span><br><span class="line">    putimage(pillar.x, 0, 52, pillar.h, &amp;down[1], 0, 320 - pillar.h, SRCPAINT);</span><br><span class="line">    putimage(pillar.x, 512 - (320 - pillar.h), 52, 320 - pillar.h, &amp;up[0], 0, 0, SRCAND);</span><br><span class="line">    putimage(pillar.x, 512 - (320 - pillar.h), 52, 320 - pillar.h, &amp;up[1], 0, 0, SRCPAINT);</span><br><span class="line">&#125;</span><br><span class="line">void xiazhui(zhuzi pillar[]) &#123;</span><br><span class="line">    for (int i = 1; i &lt;= 5; i++) &#123;</span><br><span class="line">        flybird.y += 1;</span><br><span class="line">        if (hitfloor() || hitPillar(pillar)) Gameover();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    initgraph(288, 608);</span><br><span class="line">    srand((unsigned int)time(NULL));</span><br><span class="line">    zhuzi pillar[3];//柱子英文pillar,窗口大小只能容下三根柱子</span><br><span class="line">    for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">        initpillar(pillar, i);</span><br><span class="line">        //让柱子之间有差距</span><br><span class="line">        pillar[i].x = 288 + i * 150;//柱子之间间距150</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    loadresource();</span><br><span class="line">    putimage(0, 0, &amp;BG);</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        putimage(0, 0, &amp;BG);</span><br><span class="line">        drawbird(flybird.x, flybird.y);</span><br><span class="line">        xiazhui(pillar);</span><br><span class="line">        for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">            pillar[i].x -= 10;</span><br><span class="line">            if (pillar[i].x &lt; (-52 - 150)) &#123;</span><br><span class="line">                initpillar(pillar, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">            drawpillar(pillar[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        //一定判断按键是否存在</span><br><span class="line">        if (_kbhit())&#123;</span><br><span class="line">            keydown(pillar);</span><br><span class="line">        &#125;</span><br><span class="line">        if (hitfloor() || hitPillar(pillar)) &#123;</span><br><span class="line">            Gameover();//这里不break可以无限播放Gameover动画</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        Sleep(50);</span><br><span class="line">    &#125;</span><br><span class="line">    closegraph();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>小游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>高精加减乘除</title>
    <url>/posts/b98ecf14.html</url>
    <content><![CDATA[<h2 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> <span class="title function_">add</span><span class="params">(<span class="built_in">string</span> a,<span class="built_in">string</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.size() &gt; b.size()) swap(a,b);</span><br><span class="line">    b.insert(b.begin(),<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = b.size()<span class="number">-1</span>,j = a.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--,j--)&#123;</span><br><span class="line">        <span class="type">int</span> cur;</span><br><span class="line">        <span class="keyword">if</span>(j&gt;=<span class="number">0</span>) cur = (a[j]-<span class="string">&#x27;0&#x27;</span>) + (b[i]-<span class="string">&#x27;0&#x27;</span>) + t;</span><br><span class="line">        <span class="keyword">else</span> cur = (b[i] - <span class="string">&#x27;0&#x27;</span>) +t;</span><br><span class="line">        b[i] = (cur%<span class="number">10</span>) + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        t = cur/<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> idx = b.find_first_not_of(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> idx != <span class="number">-1</span>? b.substr(idx): <span class="string">&quot;0&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> <span class="title function_">sub</span><span class="params">(<span class="built_in">string</span> a,<span class="built_in">string</span> b)</span>&#123;</span><br><span class="line">    <span class="comment">//a大b小</span></span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = a.size()<span class="number">-1</span>,j = b.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--,j--)&#123;</span><br><span class="line">        <span class="type">int</span> up = <span class="number">0</span>,down = <span class="number">0</span>;</span><br><span class="line">        up = (a[i]-<span class="string">&#x27;0&#x27;</span>) + t; t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(j&gt;=<span class="number">0</span>) down = (b[j]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>(up &lt; down) up+=<span class="number">10</span>,t = <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> cur = up-down;</span><br><span class="line">        a[i] = cur+<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> idx = a.find_first_not_of(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> idx != <span class="number">-1</span>? a.substr(idx) : <span class="string">&quot;0&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="乘法（高精度乘高精度）"><a href="#乘法（高精度乘高精度）" class="headerlink" title="乘法（高精度乘高精度）"></a>乘法（高精度乘高精度）</h2><pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
using namespace std;
int r[50000],r_a[50000],r_b[50000];
int main()
&#123;
  string a,b;
  int len,res=0,cnt=0,k; //cnt进位，res保存每位数相乘结果 
  cin&gt;&gt;a&gt;&gt;b;
  for(int i=1;i&lt;=a.size();i++) r_a[i]=a[i-1]-&#39;0&#39;;
  for(int i=1;i&lt;=b.size();i++) r_b[i]=b[i-1]-&#39;0&#39;;
  len=b.size()+a.size()-1;  //给长度初始化为两个数位数之和 
  for(int i=a.size();i&gt;=1;i--)&#123;
    cnt=0; res=0; k=a.size()-i+1;  //k给r数组计数 
    for(int j=b.size();j&gt;=1;j--)&#123;
      res=r_a[i]*r_b[j]+cnt+r[k];//每一位数相乘有进位就进位 ,这
                    //里计算每一位数字乘积的时候 ，
                    //一定要加上上一次该位置的数 
      cnt=res/10;  //刷新进位 
      r[k++]=res%10;
      if(j==1&amp;&amp;cnt)&#123;
        r[k++]=cnt;//如果每次最后进位了就要在r数组中向后移动一个位置填上该数 
      &#125;
      if(j==1&amp;&amp;i==1&amp;&amp;cnt)    len++;//若最后进位长度要加一  
    &#125;
  &#125;
  while(len&gt;1&amp;&amp;r[len]==0) len--;
  for(int i=len;i&gt;=1;i--)&#123;
    cout&lt;&lt;r[i];
  &#125;
  return 0;
&#125;
</code></pre><h2 id="乘法（高精度乘低精度）"><a href="#乘法（高精度乘低精度）" class="headerlink" title="乘法（高精度乘低精度）"></a>乘法（高精度乘低精度）</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> <span class="title function_">mul</span><span class="params">(<span class="built_in">string</span> a,ll b)</span>&#123;</span><br><span class="line">    <span class="built_in">string</span> c = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    ll t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = a.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span> || t;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=<span class="number">0</span>) t += (a[i]-<span class="string">&#x27;0&#x27;</span>)*b;</span><br><span class="line">        c += (t%<span class="number">10</span>) +<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        t/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(c.begin(),c.end());</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="大数乘大数-高精度乘高精度"><a href="#大数乘大数-高精度乘高精度" class="headerlink" title="大数乘大数(高精度乘高精度)"></a>大数乘大数(高精度乘高精度)</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10000</span>],b[<span class="number">10000</span>],ans[<span class="number">10000</span>];<span class="comment">//注意全局变量 </span></span><br><span class="line"><span class="built_in">string</span> x,y;</span><br><span class="line"><span class="type">int</span> len1,len2,pos;</span><br><span class="line"><span class="type">void</span> <span class="title function_">change</span><span class="params">(<span class="built_in">string</span> x,<span class="built_in">string</span> y)</span>&#123;<span class="comment">//接受字符串更换成int数组 </span></span><br><span class="line">	len1=x.size(),len2=y.size();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len1;i++) a[i]=x[len1-i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len2;i++) b[i]=y[len2-i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span> *<span class="title function_">hpre</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> b[])</span>&#123; <span class="comment">//接受int数组结果储存于ans数组 </span></span><br><span class="line">	<span class="keyword">if</span>((len1==<span class="number">1</span>&amp;&amp;a[<span class="number">1</span>]==<span class="number">0</span>)||(len2==<span class="number">1</span>&amp;&amp;b[<span class="number">1</span>]==<span class="number">0</span>))&#123;</span><br><span class="line">		ans[++pos]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> jin=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">//注意低位在前 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len1;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=len2;j++)&#123;</span><br><span class="line">			pos=j+i<span class="number">-1</span>;</span><br><span class="line">			<span class="type">int</span> x=a[i]*b[j]+ans[pos];</span><br><span class="line">			jin=x/<span class="number">10</span>;</span><br><span class="line">			<span class="keyword">if</span>(jin) ans[pos+<span class="number">1</span>]+=jin;</span><br><span class="line">			ans[pos]=x%<span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> ans[])</span>&#123;<span class="comment">//输出ans数组 </span></span><br><span class="line">	<span class="keyword">if</span>(ans[pos+<span class="number">1</span>]!=<span class="number">0</span>) <span class="built_in">cout</span>&lt;&lt;ans[pos];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=pos;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;ans[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="除法（高精度除低精度）"><a href="#除法（高精度除低精度）" class="headerlink" title="除法（高精度除低精度）"></a>除法（高精度除低精度）</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> <span class="title function_">div</span><span class="params">(<span class="built_in">string</span> a,ll b)</span>&#123;</span><br><span class="line">    <span class="built_in">string</span> c = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    ll cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;a.size();i++)&#123;</span><br><span class="line">        cur = cur*<span class="number">10</span> + (a[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        c += to_string(cur/b);</span><br><span class="line">        cur %= b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> idx = c.find_first_not_of(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> idx!=<span class="number">-1</span> ? c.substr(idx) : <span class="string">&quot;0&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="大数取模"><a href="#大数取模" class="headerlink" title="大数取模"></a>大数取模</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mod</span><span class="params">(<span class="type">char</span> str[],<span class="type">int</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> number[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(str);i++)</span><br><span class="line">    	number[i]=str[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(str);i++)<span class="comment">//大数取模就是按照每一位取模,不断重复</span></span><br><span class="line">    &#123;</span><br><span class="line">        sum=((<span class="type">long</span> <span class="type">long</span>)sum*<span class="number">10</span>+number[i])%c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="比较大小"><a href="#比较大小" class="headerlink" title="比较大小"></a>比较大小</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">cmp</span><span class="params">(<span class="built_in">string</span> a,<span class="built_in">string</span> b)</span>&#123;</span><br><span class="line">    <span class="type">int</span> idx1 = a.find_first_not_of(<span class="string">&#x27;0&#x27;</span>),idx2 = b.find_first_not_of(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    a = idx1!=<span class="number">-1</span>? a.substr(idx1) : <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    b = idx2!=<span class="number">-1</span>? b.substr(idx2) : <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(a.size() != b.size()) <span class="keyword">return</span> a.size() &gt;= b.size();</span><br><span class="line">    <span class="keyword">return</span> a&gt;=b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>告诉你个秘密点击下面的赏字就能赞助我了哦（owo）</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>高精</tag>
      </tags>
  </entry>
  <entry>
    <title>皇后问题</title>
    <url>/posts/c4be8714.html</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>题目描述</p>
<p>一个如下的 6×6 的跳棋棋盘，有六个棋子被放置在棋盘上，使得每行、每列有且只有一个，每条对角线（包括两条主对角线的所有平行线）上至多有一个棋子。</p>
<p><img src="https://cdn.luogu.com.cn/upload/pic/60.png" alt=""></p>
<p>上面的布局可以用序列 2 4 6 1 3 5 来描述，第 i 个数字表示在第 i 行的相应位置有一个棋子，如下：</p>
<p>行号 1 2 3 4 5 6</p>
<p>列号 2 4 6 1 3 5</p>
<p>这只是棋子放置的一个解。请编一个程序找出所有棋子放置的解。<br>并把它们以上面的序列方法输出，解按字典顺序排列。<br>请输出前 333 个解。最后一行是解的总个数。</p>
<p>输入格式</p>
<p>一行一个正整数 n，表示棋盘是 n×n 大小的。</p>
<p>输出格式</p>
<p>前三行为前三个解，每个解的两个数字之间用一个空格隔开。第四行只有一个数字，表示解的总数。<br>输入输出样例</p>
<p>输入 #1</p>
<p>6</p>
<p>输出 #1</p>
<p>2 4 6 1 3 5</p>
<p>3 6 2 5 1 4</p>
<p>4 1 5 2 6 3</p>
<p>4</p>
<p>说明/提示</p>
<p>【数据范围】<br>对于 100%100\%100% 的数据，6≤n≤136 \le n \le 136≤n≤13。</p>
<p>题目翻译来自NOCOW。</p>
<p>USACO Training Section 1.5</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int col[20],l[100],r[100],a[100],n,cnt;</span><br><span class="line">void queen(int i)&#123;</span><br><span class="line">	if(i&gt;n)&#123;</span><br><span class="line">		if(cnt&lt;3) for(int j=1;j&lt;=n;j++) printf(&quot;%d%c&quot;,a[j],j==n?&#x27;\n&#x27;:&#x27; &#x27;);</span><br><span class="line">		cnt++; return;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">		if(!col[j]&amp;&amp;!l[n-i+j]&amp;&amp;!r[i+j-1])&#123;</span><br><span class="line">			a[i]=j;</span><br><span class="line">			col[j]=1; l[n-i+j]=1; r[i+j-1]=1;</span><br><span class="line">			queen(i+1);</span><br><span class="line">			col[j]=0; l[n-i+j]=0; r[i+j-1]=0;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return ;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	queen(1);</span><br><span class="line">	cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>基础算法练习</title>
    <url>/posts/d2d64791.html</url>
    <content><![CDATA[<h2 id="A-前M大的数"><a href="#A-前M大的数" class="headerlink" title="A 前M大的数"></a>A 前M大的数</h2><p>暴力累加每两组数，再排序输出前M个<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#define ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0) </span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN=3e3+100;</span><br><span class="line">int v1[MAXN],v2[5000000];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">//	ios;</span><br><span class="line">    int n,m;</span><br><span class="line">	while(scanf(&quot;%d %d&quot;,&amp;n,&amp;m)!=EOF)&#123;</span><br><span class="line">		for(int i=1;i&lt;=n;i++) cin&gt;&gt;v1[i];</span><br><span class="line">		int tail=0;</span><br><span class="line">		for(int i=1;i&lt;n;i++)&#123;</span><br><span class="line">			for(int j=i+1;j&lt;=n;j++)&#123;</span><br><span class="line">				v2[++tail]=v1[i]+v1[j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		sort(v2+1,v2+1+tail);</span><br><span class="line">		int len=tail-m;</span><br><span class="line">		for(int i=tail;i&gt;len;i--)&#123;</span><br><span class="line">			if(i!=len+1) cout&lt;&lt;v2[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">			else cout&lt;&lt;v2[i]&lt;&lt;&#x27;\n&#x27;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="B-稳定排序"><a href="#B-稳定排序" class="headerlink" title="B 稳定排序"></a>B 稳定排序</h2><p>注意sort不是稳定的，用stable_sort排再一一比较<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#define ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0) </span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN=3e3+100;</span><br><span class="line">struct node&#123;</span><br><span class="line">	int score;</span><br><span class="line">	string name;</span><br><span class="line">&#125;stu[400],stu2[400];</span><br><span class="line">bool cmp(node a,node b)&#123;</span><br><span class="line">	return a.score&gt;b.score;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">//	ios;</span><br><span class="line">    int n;</span><br><span class="line">	while(scanf(&quot;%d&quot;,&amp;n)!=EOF)&#123;</span><br><span class="line">		for(int i=1;i&lt;=n;i++) cin&gt;&gt;stu[i].name&gt;&gt;stu[i].score;</span><br><span class="line">		for(int i=1;i&lt;=n;i++) cin&gt;&gt;stu2[i].name&gt;&gt;stu2[i].score;</span><br><span class="line">		stable_sort(stu+1,stu+1+n,cmp);</span><br><span class="line">		int flag=0,book=0;</span><br><span class="line">		for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">			if(stu[i].score!=stu2[i].score)&#123;</span><br><span class="line">				flag=1;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">			if(stu[i].name!=stu2[i].name)&#123;</span><br><span class="line">				book=1;</span><br><span class="line">				break;</span><br><span class="line">			&#125; </span><br><span class="line">		&#125; </span><br><span class="line">		if(flag==1)&#123;</span><br><span class="line">			cout&lt;&lt;&quot;Error&quot;&lt;&lt;endl;</span><br><span class="line">			for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">				cout&lt;&lt;stu[i].name&lt;&lt;&quot; &quot;&lt;&lt;stu[i].score&lt;&lt;endl;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			if(book==1)&#123;</span><br><span class="line">				cout&lt;&lt;&quot;Not Stable&quot;&lt;&lt;endl;</span><br><span class="line">				for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">					cout&lt;&lt;stu[i].name&lt;&lt;&quot; &quot;&lt;&lt;stu[i].score&lt;&lt;endl;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;else cout&lt;&lt;&quot;Right&quot;&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="C-开门人和关门人"><a href="#C-开门人和关门人" class="headerlink" title="C 开门人和关门人"></a>C 开门人和关门人</h2><p>技巧在于时间可以用字符串来代替，因为时间长度都是一样的<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#define ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0) </span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN=3e3+100;</span><br><span class="line">struct node&#123;</span><br><span class="line">	string name,qt,ht;</span><br><span class="line">&#125;stu[4000];</span><br><span class="line">bool cmp(node a,node b)&#123;</span><br><span class="line">	return a.qt&lt;b.qt;</span><br><span class="line">&#125;</span><br><span class="line">bool cmp1(node a,node b)&#123;</span><br><span class="line">	return a.ht&gt;b.ht;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">//	ios;</span><br><span class="line">    int n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	while(n--)&#123;</span><br><span class="line">		int m; cin&gt;&gt;m;</span><br><span class="line">		for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">			cin&gt;&gt;stu[i].name&gt;&gt;stu[i].qt&gt;&gt;stu[i].ht;</span><br><span class="line">		&#125; </span><br><span class="line">		sort(stu+1,stu+1+m,cmp);</span><br><span class="line">		cout&lt;&lt;stu[1].name&lt;&lt;&quot; &quot;;</span><br><span class="line">		sort(stu+1,stu+1+m,cmp1);</span><br><span class="line">		cout&lt;&lt;stu[1].name&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="D-EXCEL排序"><a href="#D-EXCEL排序" class="headerlink" title="D EXCEL排序"></a>D EXCEL排序</h2><p>注意字典序排序不是长的字符串大于短的字符串，而是一个个比较，遇到第一个不同的那个大那个字符串就大，当每个字符都一样则谁长谁大，strcmp也是如此<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN=1e5+100;</span><br><span class="line">struct node&#123;</span><br><span class="line">	string name,id;</span><br><span class="line">	int score;</span><br><span class="line">&#125;stu[MAXN]; </span><br><span class="line">bool cmp(node a,node b)&#123;</span><br><span class="line">	return a.id&lt;b.id;</span><br><span class="line">&#125;</span><br><span class="line">bool cmp1(node a,node b)&#123;</span><br><span class="line">	if(a.name==b.name) return a.id&lt;b.id;</span><br><span class="line">	return a.name&lt;b.name;</span><br><span class="line">&#125;</span><br><span class="line">bool cmp2(node a,node b)&#123;</span><br><span class="line">	if(a.score==b.score) return a.id&lt;b.id;</span><br><span class="line">	return a.score&lt;b.score;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n,c,kase=0;</span><br><span class="line">	while(cin&gt;&gt;n&gt;&gt;c)&#123;</span><br><span class="line">		if(n==0) break;</span><br><span class="line">		for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">			stu[i].id.clear();</span><br><span class="line">			stu[i].name.clear();</span><br><span class="line">		&#125;</span><br><span class="line">		for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">			cin&gt;&gt;stu[i].id&gt;&gt;stu[i].name&gt;&gt;stu[i].score;</span><br><span class="line">		&#125;</span><br><span class="line">		if(c==1) sort(stu,stu+n,cmp);</span><br><span class="line">		if(c==2) sort(stu,stu+n,cmp1);</span><br><span class="line">		if(c==3) sort(stu,stu+n,cmp2);</span><br><span class="line">		printf(&quot;Case %d:\n&quot;,++kase);</span><br><span class="line">		for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">			cout&lt;&lt;stu[i].id&lt;&lt;&quot; &quot;&lt;&lt;stu[i].name&lt;&lt;&quot; &quot;&lt;&lt;stu[i].score&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="E-A-B"><a href="#E-A-B" class="headerlink" title="E - {A} + {B}"></a>E - {A} + {B}</h2><p>用一个set来存，或者用桶标记,或者用unique去重<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#define ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0) </span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN=1e5+100;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">//	ios;</span><br><span class="line">	int n,m;</span><br><span class="line">    while(cin&gt;&gt;n&gt;&gt;m)&#123;</span><br><span class="line">    	set&lt;int&gt; st;</span><br><span class="line">    	for(int i=0;i&lt;n+m;i++)&#123;</span><br><span class="line">    		int t; cin&gt;&gt;t;</span><br><span class="line">    		st.insert(t);</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;*st.begin();</span><br><span class="line">		st.erase(st.begin());</span><br><span class="line">		while(!st.empty())&#123;</span><br><span class="line">			cout&lt;&lt;&quot; &quot;&lt;&lt;*st.begin(); </span><br><span class="line">			st.erase((st.begin()));</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="F-水果"><a href="#F-水果" class="headerlink" title="F - 水果"></a>F - 水果</h2><p>因为这道题涉及到求和的问题，直接用数组来做的话我觉得非常难输出，用map挺简单的，就是不熟练<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct node&#123;</span><br><span class="line">	map&lt;string,int&gt; mp;</span><br><span class="line">&#125;; </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	map&lt;string,node&gt; ma;</span><br><span class="line">	map&lt;string,node&gt;::iterator it;</span><br><span class="line">	map&lt;string,int&gt;::iterator mpit;</span><br><span class="line">	string f,p;</span><br><span class="line">	int cnt;</span><br><span class="line">	int n,t;</span><br><span class="line">	cin&gt;&gt;t;</span><br><span class="line">	while(t--)&#123;</span><br><span class="line">		ma.clear();</span><br><span class="line">		cin&gt;&gt;n;</span><br><span class="line">		while(n--)&#123;</span><br><span class="line">			cin&gt;&gt;f&gt;&gt;p&gt;&gt;cnt;</span><br><span class="line">			ma[p].mp[f]+=cnt;</span><br><span class="line">		&#125;</span><br><span class="line">		for(it=ma.begin();it!=ma.end();it++)&#123;</span><br><span class="line">			cout&lt;&lt;it-&gt;first&lt;&lt;endl;</span><br><span class="line">			for(mpit=it-&gt;second.mp.begin();mpit!=it-&gt;second.mp.end();mpit++)&#123;</span><br><span class="line">				cout&lt;&lt;&quot;   |----&quot;&lt;&lt;mpit-&gt;first&lt;&lt;&quot;(&quot;&lt;&lt;mpit-&gt;second&lt;&lt;&quot;)&quot;&lt;&lt;endl;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if(t!=0) cout&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="G-不重复数字"><a href="#G-不重复数字" class="headerlink" title="G - 不重复数字"></a>G - 不重复数字</h2><p>用桶标记或者用map性质一样，都是桶标记的思想<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#define ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0) </span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN=1e5+100;</span><br><span class="line">int val[MAXN];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">//	ios;</span><br><span class="line">	int t;</span><br><span class="line">	cin&gt;&gt;t;</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">    	map&lt;int,int&gt; st;</span><br><span class="line">    	int n,maxx=-1e9,tail=0;</span><br><span class="line">    	cin&gt;&gt;n;</span><br><span class="line">    	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">    		int tt; cin&gt;&gt;tt;</span><br><span class="line">    		maxx=max(maxx,tt);</span><br><span class="line">    		val[++tail]=tt;</span><br><span class="line">    		st[tt]=1;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;val[1];</span><br><span class="line">		st[val[1]]=0;</span><br><span class="line">    	for(int i=2;i&lt;=tail;i++)&#123;</span><br><span class="line">    		if(st[val[i]])&#123;</span><br><span class="line">    			cout&lt;&lt;&#x27; &#x27;&lt;&lt;val[i];</span><br><span class="line">    			st[val[i]]=0;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="H-表达式括号匹配"><a href="#H-表达式括号匹配" class="headerlink" title="H - 表达式括号匹配"></a>H - 表达式括号匹配</h2><p>用栈遇到一个左括号就入栈，遇到一个右括号如果栈里有元素就出栈，最后看看栈是否为空<br>昨天代码写的有问题，有一点xiao bug，改了一下，这没问题了<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	string sh;</span><br><span class="line">	cin&gt;&gt;sh;</span><br><span class="line">	stack&lt;char&gt; st;</span><br><span class="line">	for(int i=0;i&lt;sh.size();i++)&#123;</span><br><span class="line">		if(sh[i]==&#x27;(&#x27;) st.push(sh[i]);</span><br><span class="line">		if(sh[i]==&#x27;)&#x27;)&#123;</span><br><span class="line">			if(st.empty())&#123;</span><br><span class="line">				cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;</span><br><span class="line">				return 0;</span><br><span class="line">			&#125;else&#123;</span><br><span class="line">				st.pop();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if(!st.empty()) cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;</span><br><span class="line">	else cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="I-合并果子"><a href="#I-合并果子" class="headerlink" title="I - 合并果子"></a>I - 合并果子</h2><p>每次合并最小的两个代价最小，每次排序合并，直到最后剩一堆<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int a[1001];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int t;</span><br><span class="line">	cin&gt;&gt;t;</span><br><span class="line">	while(t--)&#123;</span><br><span class="line">		int n;</span><br><span class="line">		cin&gt;&gt;n;</span><br><span class="line">		for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i];</span><br><span class="line">		sort(a,a+n);</span><br><span class="line">		long long sum=0;</span><br><span class="line">		int head=0;</span><br><span class="line">		while(head+1&lt;n)&#123;</span><br><span class="line">			sum+=a[head]+a[head+1];</span><br><span class="line">			a[head+1]+=a[head];</span><br><span class="line">			if(a[head+1]&gt;a[head+2]) sort(a+head+1,a+n);</span><br><span class="line">			head++;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="J-Covered-Points-Count"><a href="#J-Covered-Points-Count" class="headerlink" title="J - Covered Points Count"></a>J - Covered Points Count</h2><p>这道题用了离散化和差分，我这里还不熟，俩星期前我专门做了几道这种题，当时明白了，过了俩星期又忘了，现在还有些迷<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxn=2e5+100;</span><br><span class="line">struct node&#123;</span><br><span class="line">	ll x,y;</span><br><span class="line">&#125;p[maxn];</span><br><span class="line">ll a[maxn&lt;&lt;1],b[maxn&lt;&lt;1],c[maxn];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	ios::sync_with_stdio(false);</span><br><span class="line">	int n,tail=0; cin&gt;&gt;n;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;p[i].x&gt;&gt;p[i].y;</span><br><span class="line">		a[++tail]=p[i].x;</span><br><span class="line">		a[++tail]=p[i].y+1; </span><br><span class="line">	&#125;</span><br><span class="line">	sort(a+1,a+1+tail);</span><br><span class="line">	int len=unique(a+1,a+1+tail)-a-1;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		int x=lower_bound(a+1,a+1+len,p[i].x)-a;</span><br><span class="line">		int y=lower_bound(a+1,a+1+len,p[i].y+1)-a;</span><br><span class="line">		b[x]++;b[y]--;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=1;i&lt;=len;i++)&#123;</span><br><span class="line">		b[i]+=b[i-1];</span><br><span class="line">		c[b[i]]+=a[i+1]-a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=1;i&lt;=n;i++) printf(&quot;%lld%c&quot;,c[i],i==n?&#x27;\n&#x27;:&#x27; &#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="K-Ignatius-and-the-Princess-IV"><a href="#K-Ignatius-and-the-Princess-IV" class="headerlink" title="K - Ignatius and the Princess IV"></a>K - Ignatius and the Princess IV</h2><p>非常水的题<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxn=2e5+100;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n;</span><br><span class="line">	while(cin&gt;&gt;n)&#123;</span><br><span class="line">		map&lt;int,int&gt; mp;</span><br><span class="line">		int temp=n;</span><br><span class="line">		while(n--)&#123;</span><br><span class="line">			int t; cin&gt;&gt;t;</span><br><span class="line">			mp[t]++;</span><br><span class="line">		&#125;</span><br><span class="line">		map&lt;int,int&gt;::iterator it;</span><br><span class="line">		for(it=mp.begin();it!=mp.end();it++)&#123;</span><br><span class="line">			if(it-&gt;second&gt;=(temp+1)/2)&#123;</span><br><span class="line">				cout&lt;&lt;it-&gt;first&lt;&lt;endl;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="L-Stones"><a href="#L-Stones" class="headerlink" title="L - Stones"></a>L - Stones</h2><p>这道题用优先队列模拟，主要是排列方式如何自定义，这个我今天才学，只会个基础<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">typedef pair&lt;int,int&gt; pr;</span><br><span class="line">struct node&#123;</span><br><span class="line">	int pos,dis;</span><br><span class="line">	friend bool operator &lt;(const node a,const node b)&#123;</span><br><span class="line">		if(a.pos==b.pos) return a.dis&gt;b.dis;</span><br><span class="line">		return a.pos&gt;b.pos;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int t;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">	while(t--)&#123;</span><br><span class="line">		priority_queue&lt;node&gt; oq;</span><br><span class="line">		int n; </span><br><span class="line">		scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">		for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">			node r;</span><br><span class="line">			scanf(&quot;%d %d&quot;,&amp;r.pos,&amp;r.dis);</span><br><span class="line">			oq.push(r);</span><br><span class="line">		&#125;</span><br><span class="line">		int cnt=1;</span><br><span class="line">		node y;</span><br><span class="line">		while(!oq.empty())&#123;</span><br><span class="line">			node x=oq.top();</span><br><span class="line">			oq.pop();</span><br><span class="line">			if(cnt&amp;1)&#123;</span><br><span class="line">				y.pos=x.pos+x.dis;;</span><br><span class="line">				y.dis=x.dis;</span><br><span class="line">				oq.push(y);</span><br><span class="line">			&#125;</span><br><span class="line">			cnt++;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%d\n&quot;,y.pos);</span><br><span class="line">	&#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="M-SnowWolf’s-Wine-Shop"><a href="#M-SnowWolf’s-Wine-Shop" class="headerlink" title="M - SnowWolf’s Wine Shop"></a>M - SnowWolf’s Wine Shop</h2><p>做了无数遍的题<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxn=2e5+100;</span><br><span class="line">multiset&lt;int&gt; mt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int t; cin&gt;&gt;t; int kase=0;</span><br><span class="line">	while(t--)&#123;</span><br><span class="line">		mt.clear();</span><br><span class="line">		printf(&quot;Case %d:\n&quot;,++kase);</span><br><span class="line">		int n,q,y;</span><br><span class="line">		cin&gt;&gt;n&gt;&gt;q&gt;&gt;y;</span><br><span class="line">		for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">			int tt; cin&gt;&gt;tt;</span><br><span class="line">			mt.insert(tt);</span><br><span class="line">		&#125;</span><br><span class="line">		while(q--)&#123;</span><br><span class="line">			int v; cin&gt;&gt;v;</span><br><span class="line">			auto it=mt.lower_bound(v);</span><br><span class="line">			if(it==mt.end()||*it-y&gt;v) printf(&quot;-1\n&quot;);</span><br><span class="line">			else&#123;</span><br><span class="line">				printf(&quot;%d\n&quot;,*it);</span><br><span class="line">				mt.erase(it);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="N-Alice-Bob-and-Candies"><a href="#N-Alice-Bob-and-Candies" class="headerlink" title="N - Alice, Bob and Candies"></a>N - Alice, Bob and Candies</h2><p>双指针模拟，以前不自信，总是不敢用STL，现在发现所谓STL也不过如此，加上我两分钟写好的双向队列代码🐷<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">deque&lt;int&gt; dq;</span><br><span class="line">int main()</span><br><span class="line">&#123;	</span><br><span class="line">	int t;</span><br><span class="line">	cin&gt;&gt;t;</span><br><span class="line">	while(t--)&#123;</span><br><span class="line">		dq.clear();</span><br><span class="line">		int n; cin&gt;&gt;n;</span><br><span class="line">		for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">			int temp; cin&gt;&gt;temp;</span><br><span class="line">			dq.push_back(temp);</span><br><span class="line">		&#125;</span><br><span class="line">		ll pa=0,pb=0,suma=0,sumb=0,res=1,ansa=0,ansb=0,cnt=0;</span><br><span class="line">		while(!dq.empty())&#123;</span><br><span class="line">			cnt++;</span><br><span class="line">			suma=sumb=0;</span><br><span class="line">			if(res&amp;1)&#123;</span><br><span class="line">				while(suma&lt;=pb&amp;&amp;!dq.empty())&#123;</span><br><span class="line">					suma+=dq.front();</span><br><span class="line">					dq.pop_front();</span><br><span class="line">				&#125;</span><br><span class="line">				ansa+=suma; </span><br><span class="line">				pa=suma;</span><br><span class="line">			&#125;else&#123;</span><br><span class="line">				while(sumb&lt;=pa&amp;&amp;!dq.empty())&#123;</span><br><span class="line">					sumb+=dq.back();</span><br><span class="line">					dq.pop_back();</span><br><span class="line">				&#125;</span><br><span class="line">				ansb+=sumb;</span><br><span class="line">				pb=sumb;</span><br><span class="line">			&#125;</span><br><span class="line">			res++;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;cnt&lt;&lt;&quot; &quot;&lt;&lt;ansa&lt;&lt;&quot; &quot;&lt;&lt;ansb&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#define ios ios::sync_with_stdio(0)</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN=1e4;</span><br><span class="line">int val[MAXN];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	int t; cin&gt;&gt;t;</span><br><span class="line">	while(t--)&#123;</span><br><span class="line">		int n,pa=0,pb=0,flg=0;; cin&gt;&gt;n;</span><br><span class="line">		int sum=0;</span><br><span class="line">		for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">			cin&gt;&gt;val[i];</span><br><span class="line">			sum+=val[i];</span><br><span class="line">		&#125;</span><br><span class="line">		int ea=0,eb=0,cnt=1,sa,sb,head=1,tail=n;</span><br><span class="line">		while(tail-head&gt;=0)&#123;</span><br><span class="line">			sa=0; sb=0;</span><br><span class="line">			if(flg==0&amp;&amp;sum-ea-eb&gt;pb)&#123;</span><br><span class="line">				while(sa&lt;=pb)&#123;</span><br><span class="line">					sa+=val[head];</span><br><span class="line">					ea+=val[head];</span><br><span class="line">					head++; </span><br><span class="line">				&#125;</span><br><span class="line">				pa=sa; flg=1; cnt++;</span><br><span class="line">				continue;</span><br><span class="line">			&#125;</span><br><span class="line">			if(flg==1&amp;&amp;sum-ea-eb&gt;pa)&#123;</span><br><span class="line">				while(sb&lt;=pa)&#123;</span><br><span class="line">					sb+=val[tail];</span><br><span class="line">					eb+=val[tail];</span><br><span class="line">					tail--;</span><br><span class="line">				&#125;</span><br><span class="line">				pb=sb; flg=0; cnt++;</span><br><span class="line">				continue;</span><br><span class="line">			&#125;</span><br><span class="line">			cnt++;</span><br><span class="line">			if(flg==0)&#123;</span><br><span class="line">				ea+=sum-ea-eb;</span><br><span class="line">				break;</span><br><span class="line">			&#125;else&#123;</span><br><span class="line">				eb+=sum-ea-eb;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;cnt-1&lt;&lt;&quot; &quot;&lt;&lt;ea&lt;&lt;&quot; &quot;&lt;&lt;eb&lt;&lt;&quot; &quot;&lt;&lt;endl;</span><br><span class="line">	&#125; </span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="O-Special-Elements"><a href="#O-Special-Elements" class="headerlink" title="O - Special Elements"></a>O - Special Elements</h2><p>div4的那道桶标记，用前缀和把复杂度将为O(1)，就做出来了<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#define ios ios::sync_with_stdio(0)</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN=1e4;</span><br><span class="line">int val[MAXN],book[MAXN];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	int t; cin&gt;&gt;t;</span><br><span class="line">	while(t--)&#123;</span><br><span class="line">		memset(book,0,sizeof book);</span><br><span class="line">		memset(val,0,sizeof val);</span><br><span class="line">		int n; cin&gt;&gt;n;</span><br><span class="line">		for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">			cin&gt;&gt;val[i];</span><br><span class="line">			book[val[i]]++;</span><br><span class="line">			val[i]+=val[i-1];</span><br><span class="line">		&#125;</span><br><span class="line">		int cnt=0;</span><br><span class="line">		for(int i=0;i&lt;n-1;i++)&#123;</span><br><span class="line">			for(int j=i+2;j&lt;=n;j++)&#123;</span><br><span class="line">				int sum=val[j]-val[i];</span><br><span class="line">//				cout&lt;&lt;sum&lt;&lt;&#x27; &#x27;&lt;&lt;book[sum]&lt;&lt;endl;</span><br><span class="line">				if(sum&lt;=n&amp;&amp;book[sum])&#123;</span><br><span class="line">					cnt+=book[sum]; 					</span><br><span class="line">					book[sum]=0;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">	&#125; </span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="P-Max-Sum"><a href="#P-Max-Sum" class="headerlink" title="P - Max Sum"></a>P - Max Sum</h2><p>这道题有点dp的味道，我觉得有点难，反正我没做出来，查了以前的代码才懂了，不过说实话这思路稍微把题目变一下我不知道还能做出来不能，这道题很坑的是用C++可以过，G++不行<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#define ios ios::sync_with_stdio(0)</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN=1e5+100;</span><br><span class="line">int val[MAXN];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	int t,kase=0; cin&gt;&gt;t;</span><br><span class="line">	while(t--)&#123;</span><br><span class="line">		memset(val,0,sizeof val);</span><br><span class="line">		int n; cin&gt;&gt;n;</span><br><span class="line">		for(int i=1;i&lt;=n;i++) cin&gt;&gt;val[i];</span><br><span class="line">		int summax=-1e9,b=0,e=0,k=1,sum=0; </span><br><span class="line">		for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">			sum+=val[i];</span><br><span class="line">			if(sum&gt;summax)&#123;</span><br><span class="line">				b=k;</span><br><span class="line">				e=i;</span><br><span class="line">				summax=sum;</span><br><span class="line">			&#125;</span><br><span class="line">			if(sum&lt;0)&#123;</span><br><span class="line">				sum=0;</span><br><span class="line">				k=i+1;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;Case %d:\n&quot;,++kase);</span><br><span class="line">		cout&lt;&lt;summax&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;&quot; &quot;&lt;&lt;e&lt;&lt;endl;</span><br><span class="line">//		printf(&quot;Case %d:\n%d %d %d\n&quot;,++kase,summax,b,e);</span><br><span class="line">		if(t!=0) printf(&quot;\n&quot;);</span><br><span class="line">//		if(t!=0) cout&lt;&lt;endl; </span><br><span class="line">	&#125; </span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以后尽量都用scanf和printf吧，这两个最稳定，不会报稀奇古怪的错误，然后记得字典序比较不是长的大于短的，记得字典序的排列方式，当用容器时一定记得判断容器中有没有元素，有了再pop，sort是不稳定排序，cin和cout配套,scanf和printf配套，两者不要混用</p>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>基础算法练习</tag>
      </tags>
  </entry>
  <entry>
    <title>基础算法2(快速幂，二分)</title>
    <url>/posts/8f3622b8.html</url>
    <content><![CDATA[<blockquote>
<p>发现了一些快速幂上的小问题，可以说很细节的问题了，导致我第一题巨水的一道题wrong了5次！！当时都懵了，感觉代码一点毛病都没有🐷（菜是原罪）</p>
</blockquote>
<font color="red">
把这次我在快速幂模板上踩的坑说一下，看下面两段代码
</font>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">代码一</span><br><span class="line">ll qpow(ll a,ll b)&#123;</span><br><span class="line">	if(b==0) return 1;</span><br><span class="line">	ll ans=qpow(a,b&gt;&gt;1)%MOD;</span><br><span class="line">	ans*=ans%MOD;</span><br><span class="line">	if(b&amp;1) ans*=a%MOD;</span><br><span class="line">	return ans%MOD;</span><br><span class="line">&#125;</span><br><span class="line">代码二</span><br><span class="line">ll qpow(ll a,ll b)&#123;</span><br><span class="line">	if(b==0) return 1;</span><br><span class="line">	ll ans=qpow(a,b&gt;&gt;1)%MOD;</span><br><span class="line">	ans=ans*ans%MOD;</span><br><span class="line">	if(b&amp;1) ans=ans*a%MOD;</span><br><span class="line">	return ans%MOD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<font color="red">
看着这两段代码没啥区别，就是把ans=ans*ans改成了ans*=ans，如果没有取模的话这俩没有任何区别，但是一旦取模就是AC和wrong的天壤之别，为什么？首先看ans*=ans%MOD这一段首先计算ans%MOD，我们要保证的是ans计算完必须要比MOD小，因为取余嘛！但是这一段代码先算ans%MOD的话，可能算出来的数跟MOD相差无几，再乘以ans的话就大于MOD了，直接升天，最后debug时真的直接就忽略了这个🙃
</font>

<h2 id="Pseudoprime-numbers"><a href="#Pseudoprime-numbers" class="headerlink" title="Pseudoprime numbers"></a>Pseudoprime numbers</h2><p><strong>题意:</strong>  </p>
<p>如果p是非质数，算a^p^%p是否==a，是的话输出yes否则输出no，否则输出no</p>
<p><del>很水的题，我在坑里跳了5次，，一直以为是cin，cout又在捣鬼，换了几次一直爆零</del></p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">ll MOD;</span><br><span class="line">ll qpow(ll a,ll b)&#123;</span><br><span class="line">	if(b==0) return 1;</span><br><span class="line">	ll ans=qpow(a,b&gt;&gt;1)%MOD;</span><br><span class="line">	ans=ans*ans%MOD;</span><br><span class="line">	if(b&amp;1) ans=ans*a%MOD;</span><br><span class="line">	return ans%MOD;</span><br><span class="line">&#125;</span><br><span class="line">int jug(ll p)&#123;</span><br><span class="line">	for(int i=2;i*i&lt;=p;i++)&#123;</span><br><span class="line">		if(p%i==0) return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	ll p,a;</span><br><span class="line">	while(scanf(&quot;%lld %lld&quot;,&amp;p,&amp;a)!=EOF )&#123;</span><br><span class="line">		if(a==p&amp;&amp;p==0) break;</span><br><span class="line">		MOD=p;</span><br><span class="line">		if(jug(p)) printf(&quot;no\n&quot;);</span><br><span class="line">		else&#123;</span><br><span class="line">			if(qpow(a,p)==a) printf(&quot;yes\n&quot;);</span><br><span class="line">			else printf(&quot;no\n&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Raising-Modulo-Numbers"><a href="#Raising-Modulo-Numbers" class="headerlink" title="Raising Modulo Numbers"></a>Raising Modulo Numbers</h2><p><strong>题意</strong><br>T组，M，H小组</p>
<p>每小组给出a，b的值，求a1^b1^+ a2^b2^+ …+an^bn^之和mod M的值</p>
<h3 id="CODE-1"><a href="#CODE-1" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">ll MOD;</span><br><span class="line">ll qpow(ll a, ll n) &#123;</span><br><span class="line">    ll res=1;</span><br><span class="line">    while(n)&#123;</span><br><span class="line">        if(n&amp;1) res=res*a%MOD;</span><br><span class="line">        a=a*a%MOD;</span><br><span class="line">        n&gt;&gt;=1;</span><br><span class="line">    &#125;</span><br><span class="line">    return res%MOD ;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	ll t,m,h; scanf(&quot;%lld&quot;,&amp;t);</span><br><span class="line">	while(t--)&#123;</span><br><span class="line">		scanf(&quot;%lld%lld&quot;,&amp;m,&amp;h);</span><br><span class="line">		ll sum=0;</span><br><span class="line">		MOD=m;</span><br><span class="line">		for(int i=1;i&lt;=h;i++)&#123;</span><br><span class="line">			ll a1,a2; scanf(&quot;%lld %lld&quot;,&amp;a1,&amp;a2);</span><br><span class="line">			sum+=qpow(a1,a2);</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%lld\n&quot;,sum%MOD);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Key-Set"><a href="#Key-Set" class="headerlink" title="Key Set"></a>Key Set</h2><p><strong>题意</strong><br>给你一个具有n个元素的集合S{1,2,…,n}，问集合S的非空子集中元素和为偶数的非空子集有多少个取模1000000007。<br><strong>解</strong><br>找规律，公式2^(n-1)^-1</p>
<h3 id="CODE-2"><a href="#CODE-2" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">ll MOD=1000000007;</span><br><span class="line">ll qpow(ll a, ll n) &#123;</span><br><span class="line">    ll res=1;</span><br><span class="line">    while(n)&#123;</span><br><span class="line">        if(n&amp;1) res=res*a%MOD;</span><br><span class="line">        a=a*a%MOD;</span><br><span class="line">        n&gt;&gt;=1;</span><br><span class="line">    &#125;</span><br><span class="line">    return res ;</span><br><span class="line">&#125;</span><br><span class="line">int jug(ll p)&#123;</span><br><span class="line">	for(int i=2;i*i&lt;=p;i++)&#123;</span><br><span class="line">		if(p%i==0) return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	ll a,t; scanf(&quot;%lld&quot;,&amp;t);</span><br><span class="line">	while(t--)&#123;</span><br><span class="line">		scanf(&quot;%lld&quot;,&amp;a);</span><br><span class="line">		a-=1;</span><br><span class="line">		printf(&quot;%lld\n&quot;,qpow(2,a)-1);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Distribution-money"><a href="#Distribution-money" class="headerlink" title="Distribution money"></a>Distribution money</h2><p><strong>题意</strong><br>随意排队领薪金，如果一个人领的超过其他人的总和那么这个人将受到惩罚输出这个人的工号，如果没人领的薪金超过其他人的总和输出-1<br><strong>解</strong><br>总共薪金是n，某个人可能领x，那么其他人的总和就是n-x，如果x&gt;n-x即x&gt;n/2，那么这个人领的薪金就超过其他人输出这个人的工号  </p>
<h3 id="CODE-3"><a href="#CODE-3" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int MAXN=1e4+100;</span><br><span class="line">ll MOD;</span><br><span class="line">ll qpow(ll a, ll n) &#123;</span><br><span class="line">    ll res=1;</span><br><span class="line">    while(n)&#123;</span><br><span class="line">        if(n&amp;1) res=res*a%MOD;</span><br><span class="line">        a=a*a%MOD;</span><br><span class="line">        n&gt;&gt;=1;</span><br><span class="line">    &#125;</span><br><span class="line">    return res%MOD ;</span><br><span class="line">&#125;</span><br><span class="line">int b[MAXN];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n,maxx=-1e9,id;</span><br><span class="line">	while(~scanf(&quot;%d&quot;,&amp;n))&#123;</span><br><span class="line">		memset(b,0,sizeof b);</span><br><span class="line">		id=-1;</span><br><span class="line">		for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">			int t;</span><br><span class="line">			scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">			b[t]++;</span><br><span class="line">		&#125; </span><br><span class="line">		for(int i=1;i&lt;=MAXN-10;i++)&#123;</span><br><span class="line">			if(b[i]&gt;n/2)&#123;</span><br><span class="line">				id=i;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%d\n&quot;,id);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Rightmost-Digit"><a href="#Rightmost-Digit" class="headerlink" title="Rightmost Digit"></a>Rightmost Digit</h2><p><strong>题意</strong><br>是输出一个数的几次方最右面的数字<br><strong>解</strong><br>快速幂对10取余</p>
<h3 id="CODE-4"><a href="#CODE-4" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">ll MOD=10;</span><br><span class="line">ll qpow(ll a, ll n) &#123;</span><br><span class="line">    ll res=1;</span><br><span class="line">    while(n)&#123;</span><br><span class="line">        if(n&amp;1) res=res*a%MOD;</span><br><span class="line">        a=a*a%MOD;</span><br><span class="line">        n&gt;&gt;=1;</span><br><span class="line">    &#125;</span><br><span class="line">    return res ;</span><br><span class="line">&#125;</span><br><span class="line">int jug(ll p)&#123;</span><br><span class="line">	for(int i=2;i*i&lt;=p;i++)&#123;</span><br><span class="line">		if(p%i==0) return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	ll a,t; scanf(&quot;%lld&quot;,&amp;t);</span><br><span class="line">	while(t--)&#123;</span><br><span class="line">		scanf(&quot;%lld&quot;,&amp;a);</span><br><span class="line">		printf(&quot;%lld\n&quot;,qpow(a,a));</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="人见人爱A-B"><a href="#人见人爱A-B" class="headerlink" title="人见人爱A^B"></a>人见人爱A^B</h2><p><strong>题意</strong><br>不说了<br><strong>解</strong><br>略  </p>
<h3 id="CODE-5"><a href="#CODE-5" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">ll MOD=1000;</span><br><span class="line">ll qpow(ll a, ll n) &#123;</span><br><span class="line">    ll res=1;</span><br><span class="line">    while(n)&#123;</span><br><span class="line">        if(n&amp;1) res=res*a%MOD;</span><br><span class="line">        a=a*a%MOD;</span><br><span class="line">        n&gt;&gt;=1;</span><br><span class="line">    &#125;</span><br><span class="line">    return res ;</span><br><span class="line">&#125;</span><br><span class="line">int jug(ll p)&#123;</span><br><span class="line">	for(int i=2;i*i&lt;=p;i++)&#123;</span><br><span class="line">		if(p%i==0) return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	ll p,a;</span><br><span class="line">	while(scanf(&quot;%lld %lld&quot;,&amp;a,&amp;p)!=EOF )&#123;</span><br><span class="line">		if(a==p&amp;&amp;p==0) break;</span><br><span class="line">		printf(&quot;%lld\n&quot;,qpow(a,p));</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Trailing-Zeroes-III"><a href="#Trailing-Zeroes-III" class="headerlink" title="Trailing Zeroes (III)"></a>Trailing Zeroes (III)</h2><p><strong>题意</strong><br>给你一个数n，问你最小的哪个数的阶层包含n个零<br><strong>解</strong><br>这道题是最难的一道了！！<del>我也不会，上网查了才知道</del>  </p>
<p>首先我们要知道一个数的阶层中0的个数由谁来提供？一定是由2乘5得来的0，哎不对呀！4乘5不是也能得到0吗？对！但是4不也是由2乘2得来的吗？所以n的阶层中0的个数就是由1~n的因子中2和5的数量决定的，再仔细想因子2的数量一定是大于5的，随便想都是这，所以10的个数就由因子5的数量来决定<br>比如：37的阶层<br>5 10 15 20 25(2) 30 35<br>上面一系列数都含有因子5，而25含有俩个因子5，所以总数是8个  </p>
<p>另外随着n的增大阶层中0的个数也不断增多，那这就是<code>有序</code>的，一看到有序，马上想起二分试错，二分n，如果n的阶层中0的数量不够，就去右边找，够了，要找最小，往左边找，思想就出来了，不过二分最难的不是思想，而是边界问题，整数上的二分最后一定是会到这样一种情况的left+1==right，因为每次都是right-1或者left+1，所以只要考虑好这种情况该怎么处理就行了  </p>
<p>再来看我们怎么算1~n中含有因子5的数量(n的阶层中0的数量)<br>一个数N,从1~N中包含因子M的数量为N/M<br>但是怎么去求1~N中因子M的数量呢？<br>这句话和上面的不一样<br>例如 N=36 M=5<br>那么1~N中包含因子5的数有：<br>5 10 15 20 25 30 35 （7）个<br>但是1~N中每一个数的因子M的数量和：<br>5(1) 10(1) 15(1) 20(1) 25(2) 30(1) 35(1)<br>这里面的25可以拆成5*5，是有两个因子5的<br>那如何求问题2呢？<br>可以这样去想，N/M表示包含因子M的数量<br>那N/=m之后就表示把从1~N里面的数包含因子M的数都除以了M<br>那么上面的数列就变成1~(N/5)：<br>1(0) 2(0) 3(0) 4(0) 5(1) 6(0) 7(5)<br>其实把N/M可以当作是把1~N中含有因子M的数都筛掉一遍<br>那么求1~N中含有因子M的数的的因子M的数量就是：  </p>
<p>代码：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while(n)&#123;  </span><br><span class="line">	ans+=(n/5);  </span><br><span class="line">	n/=5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="CODE-6"><a href="#CODE-6" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI acos(-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> mid)</span>&#123;</span><br><span class="line">	<span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(mid)&#123;</span><br><span class="line">		num+=mid/<span class="number">5</span>;</span><br><span class="line">		mid/=<span class="number">5</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t,kase=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		<span class="type">int</span> q;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;q;</span><br><span class="line">		<span class="type">int</span> l,r,mid,ans=<span class="number">0</span>;</span><br><span class="line">		l=<span class="number">5</span>; r=<span class="number">5e8</span>+<span class="number">10</span>;</span><br><span class="line">		<span class="keyword">while</span>(r&gt;=l)&#123;</span><br><span class="line">			mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(check(mid)&gt;=q)&#123;</span><br><span class="line">				r=mid<span class="number">-1</span>;</span><br><span class="line">				ans=mid;</span><br><span class="line">			&#125; </span><br><span class="line">			<span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Case &quot;</span>&lt;&lt;++kase&lt;&lt;<span class="string">&quot;: &quot;</span>;</span><br><span class="line">		<span class="keyword">if</span>(check(ans)==q) <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;impossible&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="Pie"><a href="#Pie" class="headerlink" title="Pie"></a>Pie</h2><p><strong>题意</strong><br>N种蛋糕，每个半径给出，要分给F+1个人，要求每个人分的体积一样（形状可以不一样），而且每人只能分得一种蛋糕（即一个人得到的蛋糕只能来自一块），求每人最大可以分到的体积。<br><strong>解</strong><br>一道实数上的二分题，有点像进击的奶牛那一道，都是猜一个答案去试错<br>double二分搜索</p>
<p>最小值是： 0 （大家都不吃）<br>最大值是：派的总体积 ÷ 总人数<br>每次取中间值 记作：mid，计算如果每个派切出 mid体积 能切多少块<br>如果能切够 F+1块，则将最小值更新为中间值<br>如果切不出 F+1块，则将最大值更新为中间值<br>直到两次中间值的差值 小于 10^(-4) 时就是结果了（精度）  </p>
<p>需要注意实数上的二分缩小区间时是r=mid或者l=mid</p>
<h3 id="CODE-7"><a href="#CODE-7" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#define pi acos(-1)</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN=1e4+100;</span><br><span class="line">double a[MAXN];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int t; cin&gt;&gt;t;</span><br><span class="line">	while(t--)&#123;</span><br><span class="line">		memset(a,0,sizeof a);</span><br><span class="line">		int n,f; cin&gt;&gt;n&gt;&gt;f;</span><br><span class="line">		double sum=0;</span><br><span class="line">		for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">			int tt; cin&gt;&gt;tt;</span><br><span class="line">			a[i]=pi*tt*tt;</span><br><span class="line">			sum+=a[i];</span><br><span class="line">		&#125;</span><br><span class="line">		double l,r,mid;</span><br><span class="line">		l=0; r=sum/(f+1);</span><br><span class="line">		while(1e-5&lt;r-l)&#123;</span><br><span class="line">			int sum2=0;</span><br><span class="line">			mid=(l+r)/2;</span><br><span class="line">			for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">				sum2+=(int)(a[i]/mid);</span><br><span class="line">			&#125;</span><br><span class="line">			if(sum2&gt;=(f+1))&#123;</span><br><span class="line">				l=mid;</span><br><span class="line">			&#125;else&#123;</span><br><span class="line">				r=mid;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%.4lf\n&quot;,mid);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Can-you-solve-this-equation"><a href="#Can-you-solve-this-equation" class="headerlink" title="Can you solve this equation?"></a>Can you solve this equation?</h2><p><strong>题意</strong><br>给出一个等式，和y的值，x为0~100之间的值，求出x(精确到4位小数)<br><strong>解</strong><br>经典二分题从0到一百二分答案试错就行了,注意精度要合适，大了会超时，小了误差大，具体看代码  </p>
<h3 id="CODE-8"><a href="#CODE-8" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;math.h&gt; </span><br><span class="line">using namespace std;</span><br><span class="line">double Y;</span><br><span class="line">double f(double x)&#123;</span><br><span class="line">	return 8*pow(x,4)+7*pow(x,3)+2*pow(x,2)+3*x+6-Y;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int t;</span><br><span class="line">	cin&gt;&gt;t;</span><br><span class="line">	while(t--)&#123;</span><br><span class="line">		cin&gt;&gt;Y;</span><br><span class="line">		if(f(0)*f(100)&gt;0) puts(&quot;No solution!&quot;);</span><br><span class="line">		else&#123;</span><br><span class="line">			double l=0,r=100,mid;</span><br><span class="line">			while(r-l&gt;1e-8)&#123;</span><br><span class="line">				mid=(l+r)/2;</span><br><span class="line">				if(f(mid)&lt;0) l=mid;</span><br><span class="line">				else r=mid;</span><br><span class="line">			&#125;</span><br><span class="line">			printf(&quot;%.4lf\n&quot;,mid);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Subsequence"><a href="#Subsequence" class="headerlink" title="Subsequence"></a>Subsequence</h2><p><strong>题意</strong><br>找到和大于等于给定数的最短子序列的长度<br><strong>解</strong><br>这道题不知道咋回事脑子抽了，<del>我直接排序了</del>，但是没注意到是子序列，但是wrong了还奇怪呢。。我真想抽自己一巴掌<br>我用的是尺取，毕竟时尺取的经典例题<br>二分的话预处理前缀和，然后二分后面的区间，大了往左看看能不能找到更小的，小了说明不够往右找 </p>
<h3 id="CODE-二分"><a href="#CODE-二分" class="headerlink" title="CODE(二分)"></a>CODE(二分)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxn=1e5+100;</span><br><span class="line">int a[maxn];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int t;</span><br><span class="line">	cin&gt;&gt;t;</span><br><span class="line">	while(t--)&#123;</span><br><span class="line">		memset(a,0,sizeof a); </span><br><span class="line">		int n,s,len=1e9;</span><br><span class="line">		cin&gt;&gt;n&gt;&gt;s;</span><br><span class="line">		for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">			cin&gt;&gt;a[i];</span><br><span class="line">			a[i]+=a[i-1];</span><br><span class="line">		&#125;</span><br><span class="line">		if(a[n]&lt;s)&#123;</span><br><span class="line">			cout&lt;&lt;&quot;0&quot;&lt;&lt;&#x27;\n&#x27;;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">			int temp=a[i];</span><br><span class="line">			int l=i+1,r=n,mid,len2=1e9;</span><br><span class="line">			while(l&lt;=r)&#123;</span><br><span class="line">				mid=(l+r)&gt;&gt;1;</span><br><span class="line">				if(a[mid]-temp&lt;s) l=mid+1;</span><br><span class="line">				else&#123;</span><br><span class="line">					len2=mid-i;</span><br><span class="line">					r=mid-1;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			len=min(len,len2);</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;len&lt;&lt;&#x27;\n&#x27;;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CODE-尺取"><a href="#CODE-尺取" class="headerlink" title="CODE(尺取)"></a>CODE(尺取)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int MAXN=1e5+100;</span><br><span class="line">int a[MAXN];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int t,n,s;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">	while(t--)&#123;</span><br><span class="line">		scanf(&quot;%d%d&quot;,&amp;n,&amp;s);</span><br><span class="line">		for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">		int l=1,r=0,ans=1e9,sum=0;</span><br><span class="line">		while(l&lt;=n)&#123;</span><br><span class="line">			while(r+1&lt;=n&amp;&amp;sum&lt;s) sum+=a[++r];</span><br><span class="line">			if(sum&gt;=s)&#123;</span><br><span class="line">				ans=min(ans,r-l+1);</span><br><span class="line">			&#125;</span><br><span class="line">			sum-=a[l];</span><br><span class="line">			l++;</span><br><span class="line">		&#125;</span><br><span class="line">		if(ans==1e9) printf(&quot;0\n&quot;);</span><br><span class="line">		else printf(&quot;%d\n&quot;,ans);</span><br><span class="line">	&#125;	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<font color="pink" size=4>
总结：题目还是很友好的，毕竟是基础 233~
</font>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>基础算法练习</tag>
      </tags>
  </entry>
  <entry>
    <title>积分赛2</title>
    <url>/posts/d2fd6931.html</url>
    <content><![CDATA[<blockquote>
<p>前两天打了第二场积分赛，难度明显比上次高，感觉更考验思维了，收集了一些我认为有价值的题目，因为太懒了，不想自己写思路题解了，搬来了别人的代码和题解，以后争取养成保存代码的习惯🐷</p>
</blockquote>
<h2 id="A-徐半仙的数学难题"><a href="#A-徐半仙的数学难题" class="headerlink" title="A 徐半仙的数学难题"></a>A 徐半仙的数学难题</h2><blockquote>
<blockquote>
<p>描述</p>
</blockquote>
<p>徐半仙经常修炼。但是每次修炼所能提升的功力确是不确定的（可能是功力还不够深厚</p>
<p>吧）。</p>
<p>每次修炼结束之后，徐半仙的脑海中就会浮现出两个数字，<em>n</em>和<em>m</em>，他的师父跟他说他每</p>
<p>次修炼增加的功力就是由这两个数决定的。每次增加的功力为(<em>n</em>!!!)%<em>m</em>，即<em>n</em>的阶乘的阶乘的</p>
<p>阶乘对<em>m</em>取模之后的值。</p>
<p>徐半仙想让你帮他写一个程序，通过<em>n</em>和<em>m</em>得到他每次修炼之后提升了多少功力。如果这</p>
<p>次修炼后提升的功力为0，输出<em>baigei</em></p>
<blockquote>
<p>输入数据</p>
</blockquote>
<p>多组输入，第一行一个正整数<em>t</em>(1 <em>≤</em> <em>t</em> <em>≤</em> 105)表示数据组数</p>
<p>每组数据包含两个整数<em>n, m</em>(0 <em>≤</em> <em>n</em> <em>≤</em> 109<em>,</em> 1 <em>≤</em> <em>m</em> <em>≤</em> 109)</p>
<blockquote>
<p>输出数据</p>
</blockquote>
<p>对于每组数据，如果答案为0，输出<em>baigei</em>，否则输出答案（每次修炼后提升的功力）</p>
<blockquote>
<p>样例输入</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line"></span><br><span class="line">2 6553</span><br><span class="line"></span><br><span class="line">2 2</span><br></pre></td></tr></table></figure>
<blockquote>
<p>样例输出</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line"></span><br><span class="line">baigei</span><br></pre></td></tr></table></figure>
<blockquote>
<p>提示</p>
</blockquote>
<p>在样例中,(2!!!) = 2,对6553取模为2，直接输出，对2取模为0，输出<em>baigei</em></p>
</blockquote>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>我们知道模最大是109，并且很容易知道从4开始，这个数的阶乘的阶乘已经是大于109的，</p>
<p>并且因为我们求的是阶乘，阶乘最后取模和每次取模后相乘的结果相同，因为现在计算的数一</p>
<p>定大于模，所以一定会出现一项为0，因此最后的结果也为0。所以如果<em>n</em>小于4，我们直接暴力</p>
<p>计算就可以了，反之直接输出<em>baigei</em>即可</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc ++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> +<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> +<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0</span> x3f3f3f3f ;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> t; <span class="built_in">cin</span> &gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        ll n,m,ans;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt;n&gt;&gt;m;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        	ans =<span class="number">1</span>%m;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">2</span>)&#123;</span><br><span class="line">        	ans =<span class="number">2</span>%m;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">3</span>)&#123;</span><br><span class="line">        	ans=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(ll i=<span class="number">1</span>;i &lt;=<span class="number">720</span>;i++)&#123;</span><br><span class="line">            ans *=i;</span><br><span class="line">            ans %=m;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        	ans =<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans ==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;baigei\n&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        	<span class="built_in">cout</span> &lt;&lt;ans &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="B-徐半仙的八字谜盘"><a href="#B-徐半仙的八字谜盘" class="headerlink" title="B 徐半仙的八字谜盘"></a>B 徐半仙的八字谜盘</h2><blockquote>
<ul>
<li>题目描述</li>
</ul>
<p>有一天徐半仙正在街道上给人算八字，他摆弄一个棋盘，和<em>K</em>个棋子，棋盘是<em>N</em> <em>×</em> <em>N</em>的矩阵方</p>
<p>格图，共有<em>N</em> <em>×</em> <em>N</em>个格子。</p>
<p>突然一位神秘ACM大佬来了，对徐半仙说：大仙，是不是您什么难题都算得出来啊？</p>
<p>徐半仙：Of course!</p>
<p>ACM大佬：那你算算这<em>N</em> <em>×</em> <em>N</em>的棋盘，每个方格只能放一个棋子，要把K个棋子都放进去，并且</p>
<p>第一行，最后一行，第一列，最后一列，主对角线，副对角线都至少有一颗棋子的方案数是多</p>
<p>少？</p>
<p>顿时，徐半仙冷汗直流，不知如何应对这位不速之客，只好说：ok….ok…..</p>
<p>为了不显尴尬，徐半仙偷偷用他的迷你手机给你发了一通电报，告诉你N和K，请求你尽快把答</p>
<p>案发送给他。</p>
<ul>
<li>输入数据</li>
</ul>
<p>第一行为数据的组数<em>T</em> (<em>T</em> ⩽ 1000)</p>
<p>接下来T行，每行为两个整数<em>N</em>和<em>K</em> (2 ⩽ <em>N</em> ⩽ 100<em>,</em> 0 ⩽ <em>K</em> ⩽ 100)</p>
<ul>
<li>输出数据</li>
</ul>
<p>输出T行，第i行为第i组询问的答案。由于答案可能过大，请将答案模1e9+7之后再输出。</p>
<ul>
<li>样例输入</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;1</span><br><span class="line"></span><br><span class="line">&gt;3 3</span><br></pre></td></tr></table></figure>
<ul>
<li>样例输出</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;10</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>这题主要考察了组合数+容斥原理，其中组合数不是难点，直接套模板就行。</p>
<p>这里如果直接求就必须得考虑很多的情况，所以可以反着来，先求个无规则的任意的摆放数，</p>
<p>再从这个总数里面减去不符合规则的。</p>
<p>但是我们发现，如果减去了第一行没有棋子的摆放数A，再减去了最后一行没有棋子的摆放数B，</p>
<p>其实就多减去了第一行和最后一行没有棋子的情况，所以这一部分减多的，还要加回来。这里</p>
<p>就可以看到容斥原理了，然后就可以写一个二进制枚举，一共就6条线上的格子，2的6次方种</p>
<p>情况，对应0～31(1代表该条线上没有棋子，0代表可有可无)，如果是奇数个1就减去对应的摆</p>
<p>放数，如果是偶数个1，就加上对应的摆放数。代码稍微多点，但思路上并不难。</p>
<h3 id="CODE-1"><a href="#CODE-1" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll MAXN=<span class="number">10010</span>;</span><br><span class="line"><span class="type">const</span> ll MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">ll c[MAXN][<span class="number">110</span>];</span><br><span class="line"><span class="type">void</span> __initC(ll N = <span class="number">10005</span>)&#123;</span><br><span class="line">	c[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;=N;i++) c[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(ll j =<span class="number">1</span>;j&lt;=<span class="number">105</span>;j++)&#123;</span><br><span class="line">			c[i][j]=(ll)(c[i<span class="number">-1</span>][j]+c[i<span class="number">-1</span>][j<span class="number">-1</span>])% MOD;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">ll N,K;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	__initC();</span><br><span class="line">	ll t;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;t);</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;N,&amp;K);</span><br><span class="line">		ll ans=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;<span class="number">6</span>);i++)&#123;</span><br><span class="line">			ll cnt=<span class="number">0</span>,n=N,m=N,L=<span class="number">0</span>,R=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(ll j=<span class="number">0</span>;j&lt;<span class="number">6</span>;j++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(i&gt;&gt;j &amp;<span class="number">1</span>)&#123;</span><br><span class="line">					cnt++;</span><br><span class="line">					<span class="keyword">if</span>(j==<span class="number">0</span>||j==<span class="number">1</span>) n--;</span><br><span class="line">					<span class="keyword">if</span>(j==<span class="number">2</span>||j==<span class="number">3</span>) m--;</span><br><span class="line">					<span class="keyword">if</span>(j==<span class="number">4</span>)&#123;</span><br><span class="line">						L=N;</span><br><span class="line">						<span class="keyword">if</span>((i&gt;&gt;<span class="number">0</span>&amp;<span class="number">1</span>)||(i&gt;&gt;<span class="number">2</span>&amp;<span class="number">1</span>)) L--;</span><br><span class="line">						<span class="keyword">if</span>((i&gt;&gt;<span class="number">1</span>&amp;<span class="number">1</span>)||(i&gt;&gt;<span class="number">3</span>&amp;<span class="number">1</span>)) L--;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span>(j==<span class="number">5</span>)&#123;</span><br><span class="line">						R=N;</span><br><span class="line">						<span class="keyword">if</span>((i&gt;&gt;<span class="number">0</span>&amp;<span class="number">1</span>)||(i&gt;&gt;<span class="number">3</span>&amp;<span class="number">1</span>)) R--;</span><br><span class="line">						<span class="keyword">if</span>((i&gt;&gt;<span class="number">2</span>&amp;<span class="number">1</span>)||(i&gt;&gt;<span class="number">1</span>&amp;<span class="number">1</span>)) R--;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			ll num=n*m;</span><br><span class="line">			<span class="keyword">if</span>(L &amp;&amp; R &amp;&amp; N&amp;<span class="number">1</span>) num-=L+R<span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">else</span> num-=L+R;</span><br><span class="line">			<span class="keyword">if</span>(cnt&amp;<span class="number">1</span>) ans=(ans-c[num][K]+MOD)%MOD;</span><br><span class="line">			<span class="keyword">else</span> ans=(ans+c[num][K])%MOD;</span><br><span class="line">	 	&#125;</span><br><span class="line">	 	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="D-徐半仙的修仙之路"><a href="#D-徐半仙的修仙之路" class="headerlink" title="D 徐半仙的修仙之路"></a>D 徐半仙的修仙之路</h2><blockquote>
<ul>
<li>描述</li>
</ul>
<p>徐半仙每天闲来无事就在家中打坐，他相信这样能够悟道，得道升仙的方法；</p>
<p>有一天他接到了一个电话，电话中告诉他，蜀山的掌门给了他一次让他去蜀山学习的机会，约</p>
<p>他去城郊见面。于是他特别开心的答应了下来，但是他到了以后发现对方竟然是传销团伙，徐</p>
<p>半仙这时十分的后悔，他想偷偷的逃走但是这里守卫森严他一点办法都没有，这时他十分无助</p>
<p>的哭泣着并且十分后悔自己迷恋修仙。忽然旁边的憨憨龙告诉他，只要你能够计算出这个房子</p>
<p>有几间房间，并且最大的一间房间有多大就可以帮助他逃走了。</p>
<p>这个房子是只有一层，被分成了<em>n</em>行<em>m</em>列，每一间房间的面积都是1，但是因为传销团伙</p>
<p>为了节约空间，这些房间的四面墙有些被堵着了。并且如果两个房间连在一起就是一个面积</p>
<p>为2的房间。</p>
<p>这时徐半仙突然看到了机会，于是经过徐半仙的一波神奇的操作后他和憨憨龙一起逃出了</p>
<p>这个传销团伙，并且还配合警方抓捕了这个传销团伙。从这以后徐半仙再也不想着修仙了，他</p>
<p>一心专注于程序设计，并成为了一名优秀的acmer。</p>
<p>聪明的你一定想知道徐半仙如何计算的吗？那么你也来尝试一下吧，看看你和徐半仙谁更</p>
<p>厉害一点！</p>
<ul>
<li>输入数据</li>
</ul>
<p>每个测试有<em>T</em>组数据每组第一行输入两个数 <em>n, m</em> (1 ⩽ <em>n, m</em> ⩽ 50。接下来<em>n</em>行数据，每</p>
<p>行<em>m</em>个整数这个整数<em>p</em>表示表示这个房间所拥有的墙的编号和 (1表示左墙，2表示上墙，4表示</p>
<p>右墙，8表示下墙)</p>
<ul>
<li>输出数据</li>
</ul>
<p>输出两个整数分别代表房间的数量，和最大的房间面积。</p>
<ul>
<li>样例输入</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;1</span><br><span class="line"></span><br><span class="line">&gt;4 7</span><br><span class="line"></span><br><span class="line">&gt;11 6 11 6 3 10 6</span><br><span class="line"></span><br><span class="line">&gt;7 9 6 13 5 15 5</span><br><span class="line"></span><br><span class="line">&gt;1 10 12 7 13 7 5</span><br><span class="line"></span><br><span class="line">&gt;13 11 10 8 10 12 13</span><br></pre></td></tr></table></figure>
<ul>
<li>样例输出</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;5 9</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>这题主要考察你的dfs和你的建模能力。其实如果就是我们的一个模板题Oil Deposits</p>
<p>只是在这道题上加了一个走下一步的限制条件。</p>
<p>如果 <em>p</em>&amp;8 == 0 我们可以向下走</p>
<p>如果 <em>p</em>&amp;4 == 0 我们可以向右走</p>
<p>如果 <em>p</em>&amp;2 == 0 我们可以向上走</p>
<p>如果 <em>p</em>&amp;1 == 0 我们可以向左走</p>
<p>这样的话就和上面的模板题一样了</p>
<h3 id="CODE-2"><a href="#CODE-2" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> maze[<span class="number">60</span>][<span class="number">60</span>],M,N;</span><br><span class="line"><span class="type">int</span> book[<span class="number">60</span>][<span class="number">60</span>];</span><br><span class="line"><span class="type">int</span> roomnum =<span class="number">0</span>, maxroom =<span class="number">0</span>, room;<span class="comment">// 记录 房 间数 、 最大房间 、 目 前 房 间 大 小 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123; </span><br><span class="line">	<span class="keyword">if</span>(book[x][y]) <span class="keyword">return</span>;</span><br><span class="line">	room++;</span><br><span class="line">	book[x][y]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(( maze[x][y] &amp; <span class="number">1</span>)==<span class="number">0</span>) dfs(x,y<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">if</span>(( maze[x][y] &amp; <span class="number">2</span>)==<span class="number">0</span>) dfs(x<span class="number">-1</span>,y);</span><br><span class="line">	<span class="keyword">if</span>(( maze[x][y] &amp; <span class="number">4</span>)==<span class="number">0</span>) dfs(x,y+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(( maze[x][y] &amp; <span class="number">8</span>)==<span class="number">0</span>) dfs(x+<span class="number">1</span>,y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> t;<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;M&gt;&gt;N;</span><br><span class="line">		<span class="built_in">memset</span>(book ,<span class="number">0</span>,<span class="keyword">sizeof</span>(book ));</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;N;j++)&#123;</span><br><span class="line">				<span class="built_in">cin</span>&gt;&gt;maze[i][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;N;j++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(!book[i][j])&#123;</span><br><span class="line">					room=<span class="number">0</span>;</span><br><span class="line">					roomnum++;</span><br><span class="line">					dfs(i,j);</span><br><span class="line">					maxroom=max(maxroom,room );</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;roomnum&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;maxroom&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="G-徐半仙的数学问题"><a href="#G-徐半仙的数学问题" class="headerlink" title="G 徐半仙的数学问题"></a>G 徐半仙的数学问题</h2><blockquote>
<ul>
<li>描述</li>
</ul>
<p>已知有a,b,c,d四个正整数求满足下列两个等式的x的个数。</p>
<p><em>gcd</em> (<em>x, a</em>) = <em>b</em></p>
<p><em>lcm</em> (<em>x, c</em>) = <em>d</em></p>
<ul>
<li>输入数据</li>
</ul>
<p>第一行输入一个整数T，表示测试的组数</p>
<p>第2行到T+1行，每行4个整数,分别表示a,b,c,d.数据保证a能够被b整除，d能够被c整除</p>
<p>1 <em>&lt;</em>= <em>T &lt;</em>= 2000</p>
<p>1 <em>&lt;</em>= <em>a, b, c, d &lt;</em>= 2<em>e</em>9</p>
<ul>
<li>输出数据</li>
</ul>
<p>共T行，每行一个整数，如果不存在这样的x,输出0,否则,输出满足条件的x的个数</p>
<ul>
<li>样例输入</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;4</span><br><span class="line"></span><br><span class="line">&gt;41 1 96 288</span><br><span class="line"></span><br><span class="line">&gt;95 1 37 1776</span><br><span class="line"></span><br><span class="line">&gt;8481 1 999976991 1999953982</span><br><span class="line"></span><br><span class="line">&gt;32560 2 999992632 1999985264</span><br></pre></td></tr></table></figure>
<ul>
<li>样例输出</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;6</span><br><span class="line"></span><br><span class="line">&gt;2</span><br><span class="line"></span><br><span class="line">&gt;4</span><br><span class="line"></span><br><span class="line">&gt;0</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>考察了唯一分解定理求lcm和gcd，打一个素数表，枚举素数，打出质因子表。详细看<a href="https://www.bilibili.com/video/BV1Uc411h7Yq">bilibili</a></p>
<h3 id="CODE-3"><a href="#CODE-3" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#define ios ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0)</span><br><span class="line">#define debug  freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin),freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);</span><br><span class="line">#define PI acos(-1)</span><br><span class="line">#define fs first</span><br><span class="line">#define sc second</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">typedef pair&lt;int,int&gt; pii;</span><br><span class="line">const ll maxn = 1e6+10;</span><br><span class="line">double eps = 1e-8;</span><br><span class="line"> </span><br><span class="line">int T;</span><br><span class="line">int a0,a1,b0,b1;</span><br><span class="line">bool vis[maxn];</span><br><span class="line">int P[maxn],tail;</span><br><span class="line">struct node&#123;</span><br><span class="line">    int a,b,c,d;</span><br><span class="line">&#125;;</span><br><span class="line">map&lt;int,node&gt; mp;</span><br><span class="line">void initP(int N)&#123;</span><br><span class="line">    for(int i = 2;i&lt;=N;i++)&#123;</span><br><span class="line">        if(!vis[i]) P[tail++] = i;</span><br><span class="line">        for(int j = 0;P[j]&lt;=N/i;j++)&#123;</span><br><span class="line">            vis[P[j]*i] = true;</span><br><span class="line">            if(i%P[j] == 0) break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void divP()&#123;</span><br><span class="line">    int idx = 0;</span><br><span class="line">    for(int t:&#123;a0,a1,b0,b1&#125;)&#123;</span><br><span class="line">        ++idx;</span><br><span class="line">        for(int j = 0;j&lt;tail &amp;&amp; P[j]*P[j] &lt;=t;j++)&#123;</span><br><span class="line">            if(t%P[j] == 0)&#123;</span><br><span class="line">                int cnt = 0;</span><br><span class="line">                while(t%P[j] == 0)&#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                    t/=P[j];</span><br><span class="line">                &#125;</span><br><span class="line">                if(idx == 1) mp[P[j]].a = cnt;</span><br><span class="line">                if(idx == 2) mp[P[j]].b = cnt;</span><br><span class="line">                if(idx == 3) mp[P[j]].c = cnt;</span><br><span class="line">                if(idx == 4) mp[P[j]].d = cnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(t&gt;1)&#123;</span><br><span class="line">            if(idx == 1) mp[t].a = 1;</span><br><span class="line">            if(idx == 2) mp[t].b = 1;</span><br><span class="line">            if(idx == 3) mp[t].c = 1;</span><br><span class="line">            if(idx == 4) mp[t].d = 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ll fun()&#123;</span><br><span class="line">    ll res = 1;</span><br><span class="line">    for(auto p:mp)&#123;</span><br><span class="line">        node cur = p.second;</span><br><span class="line">        int a = cur.a,b = cur.b,c = cur.c,d = cur.d;</span><br><span class="line">        int cnt = 0;</span><br><span class="line">        for(int i = 0;i&lt;=31;i++)&#123;</span><br><span class="line">            if(min(i,a) == b &amp;&amp; max(i,c) == d) cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        res *= cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    ios;</span><br><span class="line">    initP(1&lt;&lt;16);</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        cin&gt;&gt;a0&gt;&gt;a1&gt;&gt;b0&gt;&gt;b1;</span><br><span class="line">        mp.clear();</span><br><span class="line">        divP();</span><br><span class="line">        cout&lt;&lt;fun()&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>集训</tag>
      </tags>
  </entry>
  <entry>
    <title>积分赛3</title>
    <url>/posts/a5fa59a7.html</url>
    <content><![CDATA[<blockquote>
<p>学习了最短路后，感觉自己理解真的很一般，只会一些模板题目，稍微变一下就死了，而且发现我的思维很死，只会写套路题，做那些稍微灵活一点的题目感觉就很吃力，希望以后能有好转</p>
</blockquote>
<h2 id="B-张仙女的愧疚"><a href="#B-张仙女的愧疚" class="headerlink" title="B 张仙女的愧疚"></a>B 张仙女的愧疚</h2><blockquote>
<p>张仙女最近痴迷于游戏，可是他每周都得为学弟们准备一场积分赛。但，不是谁都能成为</p>
<p>时间管理大师。在游戏的诱惑下，他不小心出了几道难题，导致学弟们的心态可能爆炸，终于</p>
<p>他感到了深深的愧疚。决定这次一定友好一点。</p>
<p>他想到了一个有趣且简单的问题，准备交给学弟们解决。</p>
<p>给你一个数组<em>N</em>，数组的下标从1开始，数组中的每个数的值为<em>A**i</em>，你需要在这个数组中</p>
<p>找到两个数，使他们的数值和与他们的下标的差的绝对值相等，两个数为一组，张仙女想考考</p>
<p>你，在这个数组中你最多能找到可以满足题意的几组数。</p>
<p><strong>输入</strong></p>
<p>单组输入</p>
<p>第一行为数组的大小<em>N</em>(2 ⩽ <em>N</em> ⩽ 200000)</p>
<p>接下来一行<em>N</em>个以空格区分开的数表示数组中的值<em>A**i</em>1 <em>≤</em> <em>A**i</em> <em>≤</em> 109</p>
<p>(1 <em>≤</em> <em>i</em> <em>≤</em> <em>N</em>)</p>
<p><strong>输出数据</strong></p>
<p>一个数字，表示答案</p>
<p><strong>样例输入</strong></p>
<p>6</p>
<p>2 3 3 1 3 1</p>
<p><strong>样例输出</strong></p>
<p>3</p>
</blockquote>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>题意很简单求数组里面有多少对数满足数值和等于下标差，列出等式a[i]+a[j]==j-i，这道题就是一个简单的思维题，说简单，我还是没想出来，真的菜死了，这个式子可以变一下形把含i的弄到一边，这样a[i]+i==j-a[j]，这样一来我们只要遍历一遍看看数值等于a[i]+i的有多少个数，用map存下来，再遍历一遍，看看map下标等于j-a[j]的有多少个就行了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N= <span class="number">200010</span>;</span><br><span class="line"><span class="type">int</span> arr[N];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;arr[i];</span><br><span class="line">		mp[i+arr[i]]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(mp[i-arr[i]]) cnt+=mp[i-arr[i]];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;cnt&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>
<h2 id="C-何仙女的回文串"><a href="#C-何仙女的回文串" class="headerlink" title="C 何仙女的回文串"></a>C 何仙女的回文串</h2><blockquote>
<p>在一个遥远的国度里，有一个女儿国，里面住着很多很多的小仙女。某一天，一位英俊的</p>
<p>剑士前来寻求对象。国王告诉他，只要能回答出来一个问题，他就能娶走其中的何仙女；</p>
<p>现在有一个字符串S，S为所有仙女名字的首字母集合，国王命令他找出最长的字符串<strong>T</strong>， </p>
<p>T满足以下条件: </p>
<p>• T的长度不超过S的长度</p>
<p>• T是回文串</p>
<p>• 存在两个字符串A,B（可能为空），使得 T=A+B (‘+’表示连接两个字符串)，其中A是S的</p>
<p>前缀字符串，B是S的后缀字符串</p>
<p>剑士听后心头一颤，不知所措，暗地里告诉了你字符串S，希望没有对象的你能尽快告诉</p>
<p>他满足条件的字符串T是多少；</p>
<p><strong>输入数据</strong></p>
<p>第一行是一个整数<em>T</em>(1 ⩽ <em>t</em> ⩽ 1000)，表示样例的个数。</p>
<p>以后每个样例一行，是一个字符串S。 </p>
<p>(数据确保所有字符串长度不超过5000)</p>
<p><strong>输出数据</strong></p>
<p>对于每个测试用例，输出满足上述条件的最长字符串T。如果存在多个可能的解决方案，输</p>
<p>出其中任何一个。</p>
<p><strong>样例输入</strong></p>
<p>5</p>
<p>a</p>
<p>abcdfdcecba</p>
<p>abbaxyzyx</p>
<p>codeedoc</p>
<p>acbba</p>
<p><strong>样例输出</strong></p>
<p>a</p>
<p>abcdfdcba</p>
<p>xyzyx</p>
<p>codeedoc</p>
<p>abba</p>
</blockquote>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>其实这道题也不是很难的，我没做这道题很大的原因其实就是这道题没多少人AC，心理就有些抵触。。我把大量精力都放到了F，其实F是一道很难的题目，但是AC的人多我就去做了。。这道题既然要找最长回文串，还要求前后是源字符串的前缀和后缀，我们就可以从前后找，来一个双指针，找到第一个不同的字符然后找中间最长的回文串，把三段拼接在一起就行了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="built_in">string</span> s,ans;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span>&#123;  </span><br><span class="line">	<span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">		<span class="keyword">if</span>(s[l]!=s[r]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		l++,r--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> t; <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		ans.clear();</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">		<span class="type">int</span> l=<span class="number">0</span>,r=s.size()<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">while</span>(l&lt;r&amp;&amp;s[l]==s[r]) l++,r--;</span><br><span class="line">		<span class="type">int</span> i,j;</span><br><span class="line">		<span class="keyword">for</span>(i=l;i&lt;=r;i++) <span class="keyword">if</span>(check(i,r)) <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">for</span>(j=r;j&gt;=l;j--) <span class="keyword">if</span>(check(l,j)) <span class="keyword">break</span>;</span><br><span class="line">		<span class="type">int</span> ll,rr;</span><br><span class="line">		<span class="keyword">if</span>(r-i&gt;j-l) rr=r,ll=i;</span><br><span class="line">		<span class="keyword">else</span> rr=j,ll=l;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;l;i++) ans+=s[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=ll;i&lt;=rr;i++) ans+=s[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=r+<span class="number">1</span>;i&lt;s.size();i++) ans+=s[i];</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="E-拯救李仙女"><a href="#E-拯救李仙女" class="headerlink" title="E 拯救李仙女"></a>E 拯救李仙女</h2><blockquote>
<p>大魔王因为抓来的公主被勇士救走后很是不甘心，于是他将魔爪伸向了李仙女，这次为了</p>
<p>不再让强大的勇士阻止自己，他选择化身美男子让小仙女爱上自己，年轻的小仙女果不其然上</p>
<p>当了，她将不顾危险的来到大魔王的城堡中。</p>
<p>象征着爱与和平的尹法师想要阻止大魔王的阴谋，显然直接打败大魔王是不能拯救小仙女</p>
<p>的，于是大法师派遣<em>n</em>个人在沿途中劝阻小仙女，每个人都守在一个路口上，初始时小仙女对</p>
<p>大魔王的爱慕值为<em>w</em>，当她遇到第<em>i</em>个人，第<em>i</em>个人的影响力是<em>a**i</em>，将会使小仙女的爱慕值减少<em>a**i</em>，</p>
<p>小仙女很聪明，知道大法师不会让自己轻易见到心爱的人，并且获得了大法师派遣的人的位置</p>
<p>以及他们的影响力，她将选择受到最少阻拦的那条路，（即减少的爱慕值最少，如果有多条，那</p>
<p>么这几条路都有被选择的可能）。</p>
<p>如果小仙女在到达大魔王的城堡门口时，依旧爱着大魔王，大法师将出现在城堡门口。当</p>
<p>然大法师是没有丝毫作用的，不过如果此时的小仙女对大魔王的爱慕值是12的倍数，那么大法</p>
<p>师将获得神奇的力量，接下来，他将使用魔法进行召唤术（可进行无数次召唤），每次都会将</p>
<p>一个小仙女沿途不可能见过的人召唤到这里阻拦她（大法师是不知道小仙女具体走的哪条路，</p>
<p>且召换来的人依旧有与原来一样的影响力)，如果最后可以拦住请输出大法师最少的召唤次数。</p>
<p>当然如果爱慕力不是12的倍数大法师也不会获得神奇的力量，小仙女就会陷入大魔王的魔爪</p>
<p>中。</p>
<p>不可能见过即指小仙女一定不会遇到的人。</p>
<p><strong>输入数据</strong></p>
<p>第一行有两个整数<em>n m w</em>(1 ⩽ <em>n</em> ⩽ 100000<em>,</em> 1 ⩽ <em>m</em> ⩽ 200000<em>,</em> 1 ⩽ <em>w</em> ⩽ 1<em>e</em>9)，分别代表路口</p>
<p>数和道路数以及小仙女的初始爱慕值。</p>
<p>第二行有<em>n</em>个整数<em>a</em>1 <em>· · ·</em> <em>a**n</em>(1 ⩽ <em>a**i</em> ⩽ <em>w</em>)，<em>a**i</em>是第<em>i</em>个人的影响力。接下来的<em>m</em>行每行有两个</p>
<p>整数<em>i, j</em>(1 ⩽ <em>i, j</em> ⩽ <em>n</em>)，代表着第<em>i</em>号路口与第<em>j</em>号路口有一条路。（所给图不保证连通，当然不</p>
<p>连通大法师也就不必那么麻烦了）</p>
<p>初始时小仙女在1号路口处，大魔王的城堡在n号路口处，只要经过这个路口路口上的人就</p>
<p>会影响到小仙女，小仙女的爱慕力小于等于0的时候，小仙女就会放弃大魔王。</p>
<p><strong>输出数据</strong></p>
<p>如果最终可以阻止小仙女见到大魔王输出大法师使用的最少召唤次数，如果不可以输</p>
<p>出<em>ࠪ</em>1。</p>
<p><strong>样例输入1</strong></p>
<p>4 4 10</p>
<p>1 3 5 7</p>
<p>1 2</p>
<p>1 3</p>
<p>2 4</p>
<p>3 4</p>
<p><strong>样例输出1</strong></p>
<p>0</p>
<p><strong>样例输入2</strong></p>
<p>5 5 34</p>
<p>1 9 7 16 5</p>
<p>1 2</p>
<p>2 3</p>
<p>3 5</p>
<p>1 4</p>
<p>4 5</p>
<p><strong>样例输出2</strong></p>
<p>-1</p>
</blockquote>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>题意是公主爱上了大魔王，魔法师要劝她，安排了n个人在n个路口劝阻公主，公主有一个爱慕值，她会挑一个最短路去找大魔王，最短路指的是减少爱慕值最少的一条路，如果公主走到了大魔王前，大法师就会出现，如果此时爱慕值是十二的倍数，那么大法师就会召集所有非最短路径的人一起来劝阻公主，最短路径可能有多条</p>
<p>所以这道题就是首先从起点跑一遍迪杰斯特拉算法，找到最短路，判断是否爱慕值是十二的倍数，是的话就再标记所有最短路，难的就是标记最短路，具体看代码注释吧</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const ll N=100100;</span><br><span class="line">const ll M=200100;</span><br><span class="line">ll n,m,w;</span><br><span class="line">ll arr[M];</span><br><span class="line">ll val[N];</span><br><span class="line">bool vis2[N];</span><br><span class="line">struct node&#123; //链式前向星</span><br><span class="line">	ll pos; //这条边到达的结点</span><br><span class="line">	ll cost; //这条边的权值</span><br><span class="line">	ll next; //这条边的相邻边</span><br><span class="line">	bool operator &lt; (const node &amp;o) const&#123; //重载运算符</span><br><span class="line">		return cost&gt;o.cost;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;edge[M]; //链式前向星的边数组</span><br><span class="line">ll head[M]; //链式前向星的head数组，表示的是以u结点开始的最后一条边的编号</span><br><span class="line">ll size; //边的编号</span><br><span class="line">void add(ll u,ll v,ll w)&#123;</span><br><span class="line">	edge[size].cost=w; //这条边的权值</span><br><span class="line">	edge[size].pos=v; //这条边到达的结点</span><br><span class="line">	edge[size].next=head[u]; //这条边的邻边就是上次以这个节点开始的最后一条边的编号</span><br><span class="line">	head[u]=size++;//更新以这条边开始的最后一条边的编号，同时编号++</span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;node&gt; pq; //跑堆优化的迪杰斯特拉用的优先队列</span><br><span class="line">ll dis[N]; //存的是每一个点到起点的最短距离</span><br><span class="line">bool vis[N]; //记录是否确定了某一个点到起点的最短距离</span><br><span class="line">void init(ll n)&#123; //初始化函数</span><br><span class="line">	size=0; //边的序号更新为0</span><br><span class="line">	memset(head,-1,sizeof head); //head初始化为-1，也可以初始化为0，那样的话size就要从1开始</span><br><span class="line">	while(!pq.empty()) pq.pop(); //队列清空</span><br><span class="line">	memset(vis,0,sizeof vis); //vis重置</span><br><span class="line">	memset(dis,0x3f,sizeof dis); //memset以字节赋值longlong也可以使用这种方法</span><br><span class="line">&#125;</span><br><span class="line">void dij(ll s)&#123; //mlog(n)的复杂度</span><br><span class="line">	dis[s]=arr[s]; //起点的距离应该初始化为1结点的劝阻值</span><br><span class="line">	pq.push(&#123;s,arr[s]&#125;); //放进去起点</span><br><span class="line">	while(!pq.empty())&#123;</span><br><span class="line">		node x=pq.top(); pq.pop();</span><br><span class="line">		ll u=x.pos; //当前所有点离起点最近的</span><br><span class="line">		if(vis[u]) continue;</span><br><span class="line">		vis[u]=1; //这个点的最短路径就确定了，标记</span><br><span class="line">		for(ll e=head[u];e!=-1;e=edge[e].next)&#123; //找到以这个结点开始的最后一条边的编号，从这条边开始遍历邻边</span><br><span class="line">			ll v=edge[e].pos; //找到u结点所有邻接点</span><br><span class="line">			if(vis[v]) continue; //如果这个点的最短路径确定了continue</span><br><span class="line">			if(dis[v]&gt;dis[u]+edge[e].cost)&#123; //否则更新其到起点的最短距离</span><br><span class="line">				dis[v]=dis[u]+edge[e].cost;</span><br><span class="line">				pq.push(&#123;v,dis[v]&#125;); //放进队列，因为每次都是用所有结点离起点最近的点去更新每一个点的最短距离的</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void dfs(ll pos,ll d)&#123;</span><br><span class="line">	if(pos==1) return ; //到了起点退出</span><br><span class="line">	if(vis2[pos]) return ; //如果往回搜了退出</span><br><span class="line">	vis2[pos]=1; //标记父亲结点，防止往后走</span><br><span class="line">	for(ll e=head[pos];e!=-1;e=edge[e].next)&#123; //遍历当前点的邻接点</span><br><span class="line">		ll v=edge[e].pos; //邻接点</span><br><span class="line">		if(d==dis[v])&#123; //如果(当前点)减去(邻接点到当前点的那条边的权值)后等于(邻接点到起点的最短距离)，则说明当前点是由这个邻接点过来的，则这个邻接点一定是从起点到终点的最短路径中的一条</span><br><span class="line">			vis[v]=1; //标记该点</span><br><span class="line">			dfs(v,dis[v]-arr[v]); //从该点开始找</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	vis2[pos]=0; //其实这句在这里没有用，是恢复现场的，一条路撞到南墙了回来后每一个点都恢复原来的状态，加上这一句后其实不用再手动初始化vis2了</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;m,&amp;w); //n个结点，m条边，爱慕值</span><br><span class="line">	init(n); //初始化</span><br><span class="line">	for(ll i=1;i&lt;=n;i++)&#123; //输入每一个结点的人劝阻值</span><br><span class="line">		scanf(&quot;%lld&quot;,&amp;arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	while(m--)&#123;</span><br><span class="line">		ll u,v;</span><br><span class="line">		scanf(&quot;%lld%d&quot;,&amp;u,&amp;v);</span><br><span class="line">		add(u,v,arr[v]); //这里用一条边的终点的劝阻值作为这条边的权值</span><br><span class="line">		add(v,u,arr[u]); //无向边，但是权值不一样，但是不会有其他影响</span><br><span class="line">	&#125;</span><br><span class="line">	dij(1); //1起点，n终点</span><br><span class="line">	ll cost=dis[n]; //记录到n点的最少花费</span><br><span class="line">	</span><br><span class="line">	if(cost&gt;=w) printf(&quot;0\n&quot;); //如果公主到不了n点直接不用召唤了，输出0</span><br><span class="line">	else&#123;</span><br><span class="line">		if((w-cost)%12!=0) printf(&quot;-1\n&quot;);// 如果这时的爱慕值不是十二的倍数，则公主与大魔王相遇</span><br><span class="line">		else&#123;</span><br><span class="line">			memset(vis2,0,sizeof vis2); //dfs时不走回头路，这里其实不用初始化，因为dfs回朔已经全部恢复成0了，这里是一组数据，多组数据时就不用memset了，小优化</span><br><span class="line">			memset(vis,0,sizeof vis); //vis标记最短路</span><br><span class="line">			memset(val,0,sizeof val); //存非最短路的劝阻值</span><br><span class="line">			int tail=0; //非最短路的结点数量</span><br><span class="line">			vis[n]=1; //必须手动标记起点(dfs的起点)，因为直接就从起点的邻接点开始了</span><br><span class="line">			dfs(n,cost-arr[n]);//这里应该倒着去找，从n开始往前遍历</span><br><span class="line">			for(int i=1;i&lt;=n;i++)&#123; //遍历每一个结点，找到不是最短路径的点</span><br><span class="line">				if(!vis[i]) val[++tail]=arr[i];</span><br><span class="line">			&#125;</span><br><span class="line">			sort(val+1,val+1+tail,greater&lt;ll&gt;()); //从大到小排序，因为要输出最少召唤次数</span><br><span class="line">			ll cnt=0;</span><br><span class="line">			for(int i=1;i&lt;=tail;i++)&#123; //每次召唤最大的，使得召唤次数最少</span><br><span class="line">				if(w&lt;=cost) break;</span><br><span class="line">				w-=val[i];</span><br><span class="line">				cnt++;</span><br><span class="line">			&#125;</span><br><span class="line">			if(cost&gt;=w) printf(&quot;%lld\n&quot;,cnt);</span><br><span class="line">			else printf(&quot;-1\n&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>
<h2 id="F-黄仙女的生日"><a href="#F-黄仙女的生日" class="headerlink" title="F 黄仙女的生日"></a>F 黄仙女的生日</h2><blockquote>
<p>今天是黄仙女的生日，她妈妈给她买了一块很大很大的蛋糕，在吃蛋糕的时候需要把蛋糕</p>
<p>切开，黄仙女会法术，她每用一次法术就可以在蛋糕内任意选一点，发出两道激光（可以看作</p>
<p>同一点发出两道射线）把蛋糕切开。这两条激光不能重合，不在一条直线上。她想知道如果</p>
<p>用n次法术的话，最多可以把蛋糕分成多少块。（规定只能在蛋糕内选一点）    </p>
<p><strong>输入数据</strong></p>
<p>第一行是一个整数<em>T</em>(<em>T</em> ⩽ 1000)，表示测试实例的个数,然后是T行，每行有一个数字<em>n</em>(0 ⩽ </p>
<p><em>n</em> ⩽ 104)表示用n次法术</p>
<p><strong>输出数据</strong></p>
<p>T行数字，最多可以分多少块</p>
<p><strong>样例输入</strong></p>
<p>3</p>
<p>0</p>
<p>1</p>
<p>2</p>
<p><strong>样例输出</strong></p>
<p>1</p>
<p>2</p>
<p>7 </p>
</blockquote>
<h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>这道题明明这么难，竟然做出来的人这么多！！！可能是我真的太菜了，我现在这道题都没理解为什么这么画块最多，这道题不讲了</p>
<h3 id="CODE-1"><a href="#CODE-1" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">10001</span>;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">10001</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;<span class="number">10001</span>;i++)&#123;</span><br><span class="line">		dp[i]=dp[i<span class="number">-1</span>]+i*<span class="number">4</span><span class="number">-3</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		<span class="type">int</span> n;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;dp[n]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>
<h2 id="G-小仙女的树"><a href="#G-小仙女的树" class="headerlink" title="G 小仙女的树"></a>G 小仙女的树</h2><blockquote>
<p>小仙女在天上飞的时候，突然听到地面上有两个人争吵，Ayush和Ashish他们邀请小仙女</p>
<p>给他们做裁判，他们有一个无根树，每个人每一次都可以取一个叶子节点，树上有一个特殊节</p>
<p>点，问最后谁能取走特殊的节点。</p>
<p><strong>输入数据</strong></p>
<p>第一行输入表示有<em>T</em>(<em>T</em> ⩽ 10)组数据，第二行输入<em>n, x</em>(1 ⩽ <em>n, k</em> ⩽ 103),<em>n</em>表示有<em>n</em>个节点，</p>
<p><em>x</em>为特殊的节点,<em>x</em>小于等于<em>n</em>。下面的<em>nn</em> 1行每一行表表示两个节点无向互相连通，第一次</p>
<p>是Ayush开始走。</p>
<p><strong>输出数据</strong></p>
<p>输出两人谁能取到特殊节点</p>
<p><strong>样例输入</strong></p>
<p>1</p>
<p>3 1</p>
<p>2 1</p>
<p>3 1</p>
<p><strong>样例输出</strong></p>
<p>Ashish</p>
</blockquote>
<h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>少有的签到题目，可我还是很粗心，画图我想当然得看到x结点裸漏在外面就认为能取走了，其实它的度数是大于1的！！！</p>
<h3 id="CODE-2"><a href="#CODE-2" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const ll MOD= 998244353;</span><br><span class="line">ll degree[1100];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int t;</span><br><span class="line">	cin&gt;&gt;t;</span><br><span class="line">	while(t--)&#123;</span><br><span class="line">		int n,x;</span><br><span class="line">		cin&gt;&gt;n&gt;&gt;x;</span><br><span class="line">		n--;</span><br><span class="line">		while(n--)&#123;</span><br><span class="line">			int a,b;</span><br><span class="line">			cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">			degree[a]++;</span><br><span class="line">			degree[b]++;</span><br><span class="line">		&#125;</span><br><span class="line">		if(degree[x]==1||degree[x]==0)&#123;</span><br><span class="line">			cout&lt;&lt;&quot;Ayush&quot;&lt;&lt;&#x27;\n&#x27;;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			if(n==3) cout&lt;&lt;&quot;Ashish&quot;&lt;&lt;&#x27;\n&#x27;;</span><br><span class="line">			else if((n-3)&amp;1) cout&lt;&lt;&quot;Ayush&quot;&lt;&lt;&#x27;\n&#x27;;</span><br><span class="line">			else cout&lt;&lt;&quot;Ashish&quot;&lt;&lt;&#x27;\n&#x27;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>
<h2 id="H-仙女们的高数又双叒叕挂了"><a href="#H-仙女们的高数又双叒叕挂了" class="headerlink" title="H 仙女们的高数又双叒叕挂了"></a>H 仙女们的高数又双叒叕挂了</h2><blockquote>
<p>话说有棵树，挂了很多人，其中也不乏众多仙女。其中有道题目是这样的</p>
<p>从-1到1对(1-x^2^)^n^积分</p>
<p>给定n，求得上式的值</p>
<p><strong>输入数据</strong></p>
<p>输入包含多组测试，以文件结尾结束。每组测试包含一个整数n </p>
<p>1 <em>&lt;</em>= <em>n &lt;</em>= 1<em>e</em>6</p>
<p>样例总数不超过1<em>e</em>5</p>
<p><strong>输出数据</strong></p>
<p>结果若是整数，则直接输出</p>
<p>否则输出分数的最简形式，结果mod 998244353</p>
<p><strong>样例输入</strong></p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>455</p>
<p><strong>样例输出</strong></p>
<p>4/3</p>
<p>16/15</p>
<p>32/35</p>
<p>622707799/502563857</p>
</blockquote>
<h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><p>这道题我真的不信有人第一次就能手推出数学公式！！！不去网上查我是真的不信的！！！当然大神除外，不讲了，纯数学推导</p>
<h3 id="CODE-3"><a href="#CODE-3" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll MOD= <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> ll maxn=<span class="number">1e6</span>+<span class="number">7</span>;</span><br><span class="line">ll fac[maxn*<span class="number">2</span>+<span class="number">100</span>];</span><br><span class="line">ll <span class="title function_">ksm</span><span class="params">(ll a,ll b)</span>&#123;</span><br><span class="line">	ll ans=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(b)&#123;</span><br><span class="line">		<span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans=ans*a%MOD;</span><br><span class="line">		a=a*a%MOD;</span><br><span class="line">		b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">ll <span class="title function_">solve</span><span class="params">(ll n)</span>&#123;</span><br><span class="line">	ll ans=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		ans=ans*i%MOD;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">	fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=maxn*<span class="number">2</span>;i++) fac[i]=fac[i<span class="number">-1</span>]*i%MOD;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	init();</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123;</span><br><span class="line">		ll x=ksm(fac[n],<span class="number">2</span>)*ksm(<span class="number">2</span>,<span class="number">2</span>*n+<span class="number">1</span>)%MOD;</span><br><span class="line">		ll y=fac[<span class="number">2</span>*n+<span class="number">1</span>]%MOD;</span><br><span class="line">		ll tmp=__gcd(x,y);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;x/tmp&lt;&lt;<span class="string">&#x27;/&#x27;</span>&lt;&lt;y/tmp&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>
<h2 id="I-小仙女的善心"><a href="#I-小仙女的善心" class="headerlink" title="I  小仙女的善心"></a>I  小仙女的善心</h2><p>求两个矩形的覆盖面积</p>
<h3 id="CODE-4"><a href="#CODE-4" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll MOD= <span class="number">998244353</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ll a,b,c,d,e,f,g,h;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d&gt;&gt;e&gt;&gt;f&gt;&gt;g&gt;&gt;h;</span><br><span class="line">	ll s1=(c-a)*(d-b);</span><br><span class="line">	ll s2=(g-e)*(h-f);</span><br><span class="line">	<span class="keyword">if</span>(g&lt;=a||e&gt;=c||h&lt;=b||f&gt;=d)&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;s1+s2&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ll x1,y1,x2,y2;</span><br><span class="line">	x1=max(a,e);</span><br><span class="line">	y1=max(b,f);</span><br><span class="line">	x2=min(c,g);</span><br><span class="line">	y2=min(d,h);</span><br><span class="line">	ll mid=(x2-x1)*(y2-y1);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;s2+s1-mid&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>
<h2 id="J-林仙女的选美大赛"><a href="#J-林仙女的选美大赛" class="headerlink" title="J 林仙女的选美大赛"></a>J 林仙女的选美大赛</h2><blockquote>
<p>在马卡拉卡山脉的最深处，住着一群小仙女。最近，林仙女举办了一场选美大赛。有n名</p>
<p>小仙女参加了比赛。比赛现场有m名裁判仙女，每个裁判仙女会表达一个自己的观点。比如裁</p>
<p>判A说：“1=2”表示裁判A认为1号仙女和2号仙女一样美。选美比赛结束了，但是裁判仙女们</p>
<p>却犯了愁。因为他们不知道如何整理这些观点，无法给小仙女们排名。屏幕前的你能帮助林仙</p>
<p>女解决这个难题吗？如果根据所给信息可以给小仙女们排名请输出“OK”（可以存在并列排名）</p>
<p>,如果所给信息有冲突（裁判A认为1&gt;2, 裁判B认为1&lt;2）,请输出“CONFLICT”，如果所给信息</p>
<p>不全，无法确定排名请输出“UNCERTAIN”，如果信息中同时包含冲突且信息不完全，就输出</p>
<p>“CONFLICT”。</p>
<p><strong>输入数据</strong></p>
<p>本题目包含多组测试，请处理到文件结束。每组测试第一行包含两个整数N,M(0&lt;=N&lt;=10000,0&lt;=M&lt;=20000),</p>
<p>分别表示要参加选美比赛的小仙女数以及裁判仙女数。接下来有M行，分别是每个裁判的观</p>
<p>点(1&lt;=每个小仙女的编号&lt;=n)</p>
<p><strong>输出数据</strong></p>
<p>对于每组测试，在一行里按题目要求输出</p>
<p><strong>样例输入</strong></p>
<p>3 2</p>
<p>1 &gt; 2</p>
<p>2 = 3</p>
<p>3 3</p>
<p>1 &gt; 2</p>
<p>2 = 3</p>
<p>3 &gt; 1</p>
<p>3 1</p>
<p>1 &gt; 2</p>
<p><strong>样例输出</strong></p>
<p>OK</p>
<p>CONFLICT</p>
<p>UNCERTAIN</p>
</blockquote>
<h3 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h3><p>这是一道原题，虽然那道题当时删了，但还好我做了，这道题是用并查集去缩点，把所有=关系的点缩成一个，让它们的祖先代表他们，然后拓扑排序，看看是否有环</p>
<h3 id="CODE-5"><a href="#CODE-5" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">10100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">20100</span>;</span><br><span class="line"><span class="type">const</span> ll MOD= <span class="number">998244353</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> to;</span><br><span class="line">	ll cost;</span><br><span class="line">	<span class="type">int</span> next;</span><br><span class="line">&#125;edge[M];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">b</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> u,v;</span><br><span class="line">	<span class="type">char</span> c;</span><br><span class="line">&#125;arr[M];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line">ll dis[N];</span><br><span class="line"><span class="type">int</span> head[M],fa[N],in[N];</span><br><span class="line"><span class="type">int</span> size=<span class="number">0</span>,n,m,flag1,flag2,cnt;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span>&#123;</span><br><span class="line">	edge[size].to=v;</span><br><span class="line">	edge[size].cost=w;</span><br><span class="line">	edge[size].next=head[u];</span><br><span class="line">	head[u]=size++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">	size=<span class="number">0</span>; flag1=<span class="number">0</span>; flag2=<span class="number">0</span>; cnt=n;</span><br><span class="line">	<span class="keyword">while</span>(!q.empty()) q.pop();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++) head[i]=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++) fa[i]=i;</span><br><span class="line">	<span class="built_in">memset</span>(in,<span class="number">0</span>,<span class="keyword">sizeof</span> in);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==fa[x]) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">return</span> fa[x]=find(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">	<span class="type">int</span> x=find(a);</span><br><span class="line">	<span class="type">int</span> y=find(b);</span><br><span class="line">	<span class="keyword">if</span>(x!=y) fa[y]=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">tuo</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(fa[i]==i&amp;&amp;!in[i])&#123; <span class="comment">//祖先是自己并且入度为零</span></span><br><span class="line">			q.push(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		<span class="type">int</span> u=q.front(); q.pop();</span><br><span class="line">		<span class="keyword">if</span>(q.size()) flag2=<span class="number">1</span>; <span class="comment">//如果当前入度为0的点不止一个，则说明有两个点无法比较，Uncertain，这里还有一个很骚的操作，可以直接反向建图，直接在开始时候判断是否入度为0的点大于1个</span></span><br><span class="line">		cnt--; <span class="comment">//计数看看能拓扑排序的点有多少个</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> e=head[u];e!=<span class="number">-1</span>;e=edge[e].next)&#123;</span><br><span class="line">			<span class="type">int</span> v=edge[e].to;</span><br><span class="line">			in[v]--;</span><br><span class="line">			<span class="keyword">if</span>(!in[v]) q.push(v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m)&#123;</span><br><span class="line">		init(n);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;arr[i].u&gt;&gt;arr[i].c&gt;&gt;arr[i].v;</span><br><span class="line">			<span class="keyword">if</span>(arr[i].c==<span class="string">&#x27;=&#x27;</span>)&#123; <span class="comment">//把等于关系的两个点并到一个集合，即缩点</span></span><br><span class="line">				merge(arr[i].u,arr[i].v);</span><br><span class="line">				cnt--; <span class="comment">//cnt记录缩点后有几个点</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">			<span class="type">char</span> ch=arr[i].c;</span><br><span class="line">			<span class="type">int</span> u=find(arr[i].u), v=find(arr[i].v);<span class="comment">//没缩点的点祖先就是自己</span></span><br><span class="line">			<span class="keyword">if</span>(ch==<span class="string">&#x27;=&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(u==v) flag1=<span class="number">1</span>; <span class="comment">//矛盾</span></span><br><span class="line">			<span class="keyword">if</span>(ch==<span class="string">&#x27;&gt;&#x27;</span>)&#123;</span><br><span class="line">				add(u,v,<span class="number">0</span>);</span><br><span class="line">				in[v]++; </span><br><span class="line">			&#125; </span><br><span class="line">			<span class="keyword">if</span>(ch==<span class="string">&#x27;&lt;&#x27;</span>)&#123;</span><br><span class="line">				add(v,u,<span class="number">0</span>);</span><br><span class="line">				in[u]++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(flag1)&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;CONFLICT&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		tuo(); <span class="comment">//拓扑排序</span></span><br><span class="line">		<span class="keyword">if</span>(cnt&gt;<span class="number">0</span>||flag1) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;CONFLICT&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(flag2) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;UNCERTAIN&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;OK&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>集训</tag>
      </tags>
  </entry>
  <entry>
    <title>积分赛4</title>
    <url>/posts/3b9ecc04.html</url>
    <content><![CDATA[<p><a href="https://pan.baidu.com/s/1aWuvSuQW7LylPAX3pNOn4Q">题目面板</a> 提取码：k2fu</p>
<h2 id="A-胡图图的数学难题"><a href="#A-胡图图的数学难题" class="headerlink" title="A. 胡图图的数学难题"></a><strong>A.</strong> 胡图图的数学难题</h2><p>这道题很有意思让你求斐波那契数列的平方和，<a href="https://blog.csdn.net/lanchunhui/article/details/51840616?utm_source=blogxgwz5">一篇易懂的题解</a> 得到公式以后直接一个矩阵快速幂就解决了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	ll mat[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">memset</span>(mat,<span class="number">0</span>,<span class="keyword">sizeof</span> mat);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++) mat[i][i]=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	node <span class="keyword">operator</span> * (<span class="type">const</span> node &amp;o)&#123;</span><br><span class="line">		node ans;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>;j++)&#123;</span><br><span class="line">				ll sum=<span class="number">0</span>;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">2</span>;k++)&#123;</span><br><span class="line">					sum=(sum+mat[i][k]*o.mat[k][j]%MOD)%MOD;</span><br><span class="line">				&#125;</span><br><span class="line">				ans.mat[i][j]=sum;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">node p=&#123;</span><br><span class="line">	<span class="number">1</span>,<span class="number">1</span>,</span><br><span class="line">	<span class="number">1</span>,<span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">node <span class="title">ksm</span><span class="params">(node x,ll n)</span></span>&#123;</span><br><span class="line">	node ans;</span><br><span class="line">	ans.<span class="built_in">set</span>();</span><br><span class="line">	<span class="keyword">while</span>(n)&#123;</span><br><span class="line">		<span class="keyword">if</span>(n&amp;<span class="number">1</span>) ans=ans*x;</span><br><span class="line">		x=x*x;</span><br><span class="line">		n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios;</span><br><span class="line">	ll n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	node unit=<span class="built_in">ksm</span>(p,n<span class="number">-2</span>);</span><br><span class="line">	ll a=(unit.mat[<span class="number">0</span>][<span class="number">0</span>]+unit.mat[<span class="number">0</span>][<span class="number">1</span>])%MOD;</span><br><span class="line">	ll b=(unit.mat[<span class="number">1</span>][<span class="number">0</span>]+unit.mat[<span class="number">1</span>][<span class="number">1</span>])%MOD;</span><br><span class="line">	ll c=(a+b)%MOD;</span><br><span class="line">	cout&lt;&lt;(a*c)%MOD&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="C-胡图图公司大整改"><a href="#C-胡图图公司大整改" class="headerlink" title="C. 胡图图公司大整改"></a><strong>C.</strong> 胡图图公司大整改</h2><p>这道题是线段树的升级版，朴素版线段树是对一个连续的线段实现单点修改区间查询，而这道题则是在树上实现单点修改，区间查询，1结点是根节点，所以这道题就添加了一个操作把这n个点建成树的样子，然后对它们进行编号，编号方式是优先遍历子树，遍历到谁编号加一，这里用low数组来实现这个功能，到这里单点修改已经可以实现了，已经把一个线段上的每一个点都映射到了树上，但是区间查询还没有办法实现，为什么实现不了？这里要查询的是一个点的子树，这里的子树就相当于区间，我们上面优先遍历子树因此遍历完后，子树上的每一个点的序号是连续的，所以可以用high数组来记录子树区间的右端点，当遍历完一个点的所有子节点时就记录一下当前的序号，那么[lowi,highi]就表示了子树里面的点</p>
<p>总之这道题知识点就是用了一个dfs实现了将线段上的点映射到树上并且给之编号，实现了查询一个点的子树功能</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0), cin.tie(0), cout.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout );</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll,ll&gt; pii;</span><br><span class="line"><span class="type">const</span> ll maxn=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll inf=<span class="number">0x3f3f3f3f</span> ;</span><br><span class="line"></span><br><span class="line">ll N,Q;</span><br><span class="line">ll w[maxn]; <span class="comment">//每一个部门的薪资</span></span><br><span class="line">vector&lt;ll&gt; ve[maxn]; <span class="comment">//建边</span></span><br><span class="line">ll high[maxn],low[maxn],cnt; <span class="comment">//给树上的点编号</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    ll l,r;</span><br><span class="line">    ll minn,maxx;</span><br><span class="line">&#125;tr[maxn*<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(ll u)</span></span>&#123;</span><br><span class="line">    tr[u].minn=<span class="built_in">min</span>(tr[u&lt;&lt;<span class="number">1</span>].minn,tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].minn);</span><br><span class="line">    tr[u].maxx=<span class="built_in">max</span>(tr[u&lt;&lt;<span class="number">1</span>].maxx,tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].maxx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(ll u,ll l,ll r)</span></span>&#123; <span class="comment">//每一段的编号，范围</span></span><br><span class="line">    tr[u]=&#123;l,r&#125;;</span><br><span class="line">    <span class="keyword">if</span>(l!=r)&#123;</span><br><span class="line">        ll mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>,l,mid); <span class="comment">//建左端</span></span><br><span class="line">        <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r); <span class="comment">//建右端</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(ll u,ll x,ll c)</span></span>&#123; <span class="comment">//编号，要修改的位置，添加的值</span></span><br><span class="line">    <span class="keyword">if</span>(tr[u].l==x &amp;&amp; x==tr[u].r)&#123; <span class="comment">//找到位置</span></span><br><span class="line">        tr[u].minn+=c; <span class="comment">//此时只有一个点，因此最小值和最大值可以直接修改</span></span><br><span class="line">        tr[u].maxx+=c;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        ll mid=(tr[u].l+tr[u].r)&gt;&gt;<span class="number">1</span>; <span class="comment">//看看这个位置在左半边还是右半边</span></span><br><span class="line">        <span class="keyword">if</span>(x&lt;=mid) <span class="built_in">add</span>(u&lt;&lt;<span class="number">1</span>,x,c); <span class="comment">//左半边</span></span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">add</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,x,c); <span class="comment">//右半边</span></span><br><span class="line">        <span class="built_in">pushup</span>(u); <span class="comment">//每次修改节点的值后，都要上报给上级</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node <span class="title">query</span><span class="params">(ll u,ll l,ll r)</span></span>&#123; <span class="comment">//编号，范围</span></span><br><span class="line">    <span class="keyword">if</span>(l&lt;=tr[u].l &amp;&amp; tr[u].r&lt;=r) <span class="keyword">return</span> tr[u]; <span class="comment">//假若该段包含在给定范围内则直接返回</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        ll mid=(tr[u].l+tr[u].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(r&lt;=mid) <span class="keyword">return</span> <span class="built_in">query</span>(u&lt;&lt;<span class="number">1</span>,l,r); <span class="comment">//左端</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(l&gt;mid) <span class="keyword">return</span> <span class="built_in">query</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r); <span class="comment">//右端</span></span><br><span class="line">        <span class="keyword">else</span>&#123; <span class="comment">//左右两端中间</span></span><br><span class="line">            node ans,L,R;</span><br><span class="line">            L=<span class="built_in">query</span>(u&lt;&lt;<span class="number">1</span>,l,r); <span class="comment">//左半段</span></span><br><span class="line">            R=<span class="built_in">query</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r); <span class="comment">//右半段</span></span><br><span class="line">            ans.minn=<span class="built_in">min</span>(L.minn,R.minn);</span><br><span class="line">            ans.maxx=<span class="built_in">max</span>(L.maxx,R.maxx);</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//[low[x],high[x]]表示x结点下的结点编号范围</span></span><br><span class="line"><span class="comment">//high[x]-low[x]表示x结点下的子节点数量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(ll u,ll fa=<span class="number">-1</span>)</span></span>&#123; <span class="comment">//优先遍历每一个节点的子节点，给每一个结点编号</span></span><br><span class="line">    low[u]=++cnt; <span class="comment">//进入该节点时编个号</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v:ve[u])&#123; <span class="comment">//遍历每一个节点的子节点</span></span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>; <span class="comment">//注意不能返回原来的路</span></span><br><span class="line">        <span class="built_in">dfs</span>(v,u); <span class="comment">//优先遍历子节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    high[u]=cnt; <span class="comment">//遍历完该节点的子节点编个号，注意这里不能加</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    cin&gt;&gt;N&gt;&gt;Q; <span class="comment">//N个部门，Q组查询</span></span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=N;i++) cin&gt;&gt;w[i]; <span class="comment">//N个部门的薪资</span></span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=N<span class="number">-1</span>;i++)&#123; <span class="comment">//建树</span></span><br><span class="line">        ll u,v; cin&gt;&gt;u&gt;&gt;v; <span class="comment">//两个部门之间有从属关系即两者有边</span></span><br><span class="line">        ve[u].<span class="built_in">pb</span>(v);</span><br><span class="line">        ve[v].<span class="built_in">pb</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>); <span class="comment">//给树上的点进行编号，注意1是根节点</span></span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,N); <span class="comment">//建树，以上就是线段树的模板</span></span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=N;i++) <span class="built_in">add</span>(<span class="number">1</span>,low[i],w[i]); <span class="comment">//把原来的每一个点的权值映射到树上</span></span><br><span class="line">    <span class="keyword">while</span>(Q--)&#123;</span><br><span class="line">        ll op,x,y;</span><br><span class="line">        cin&gt;&gt;op;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">            cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">            <span class="built_in">add</span>(<span class="number">1</span>,low[x],y); <span class="comment">//x映射到书上就是low[x]的位置</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            node ans=<span class="built_in">query</span>(<span class="number">1</span>,low[x],high[x]); <span class="comment">//x的子树的范围就是[low[x],high[x]]</span></span><br><span class="line">            cout&lt;&lt; ans.maxx-ans.minn &lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="E-胡图图的难题"><a href="#E-胡图图的难题" class="headerlink" title="E. 胡图图的难题"></a><strong>E.</strong> 胡图图的难题</h2><p>1) 让最小的带最大的过去，最小的回来 fi = fii1 + ai + <em>a</em>1</p>
<p>2) 让最小的带第二小的过去，最小的回来，最大的两个过去，第二小的回来 <em>fi</em> = <em>fii</em> 2 + <em>ai</em> + a<em>1 + </em>a<em>1 + </em>a<em>2 </em>∗* 2</p>
<p>综上所述，fi = <em>min</em>(<em>fii</em> 1 + <em>ai</em> + <em>a</em>1<em>, fi</em>2 + <em>ai</em> + <em>a</em>1 + <em>a</em>2 <em>∗</em> 2)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc ++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mx =<span class="number">100000</span>+<span class="number">47</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> n,a[mx],f[mx];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">    sort(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line">    f[<span class="number">1</span>]=a[<span class="number">1</span>];</span><br><span class="line">    f[<span class="number">2</span>]=a[<span class="number">2</span>];</span><br><span class="line">    f[<span class="number">3</span>]=a[<span class="number">3</span>]+a[<span class="number">2</span>]+a[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">4</span>;i&lt;=n;i++)</span><br><span class="line">    f[i]= min(f[i <span class="number">-2</span>]+a[i]+a[<span class="number">1</span>]+(a[<span class="number">2</span>]&lt;&lt;<span class="number">1</span>),f[i <span class="number">-1</span>]+a[i]+a[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,f[n]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="F-胡图图找队友"><a href="#F-胡图图找队友" class="headerlink" title="F 胡图图找队友"></a>F 胡图图找队友</h2><h3 id="CODE1"><a href="#CODE1" class="headerlink" title="CODE1"></a>CODE1</h3><p>维护一个数组存储每一个点和根节点的关系，是否属于一个集合，因此每次只要通过根节点这个媒介联系两个结点的关系</p>
<p><a href="https://blog.csdn.net/freezhanacmore/article/details/8774033">详细题解</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e3</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> fa[MAXN],r[MAXN];</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		fa[i]=i;</span><br><span class="line">		r[i]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==fa[x]) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="type">int</span> tmp=fa[x]; <span class="comment">//备份父亲节点</span></span><br><span class="line">	fa[x]=find(fa[x]); <span class="comment">//递归特性先更新最里面的东西，因此在下面一行更新之前，父亲结点已经发生改变，同理递归深层也是如此，所以如今父亲节点记录的直接是和祖宗的关系</span></span><br><span class="line">	r[x]=(r[x]+r[tmp])%<span class="number">2</span>; <span class="comment">//因为压缩路径本质就是直接找到当前结点和根节点的关系，所以r数组记录的也要是和根节点的关系</span></span><br><span class="line">	<span class="keyword">return</span> fa[x]; <span class="comment">//fa[x]现在已经是根节点了，返回根节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Union</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span>&#123;</span><br><span class="line">	<span class="type">int</span> x=find(a), y=find(b);</span><br><span class="line">	<span class="keyword">if</span>(x!=y)&#123;</span><br><span class="line">		fa[y]=x; <span class="comment">//有一点要明白，并查集合并操作是对两个根节点的操作，儿子结点和根节点的联系是通过压缩路径去实现的</span></span><br><span class="line">		<span class="keyword">if</span>(c) r[y]=(r[a]+r[b]+<span class="number">1</span>)%<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">else</span> r[y]=(r[a]+r[b])%<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// ios;</span></span><br><span class="line">	<span class="comment">// debug;</span></span><br><span class="line">	<span class="type">int</span> t,n,m;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;t);</span><br><span class="line">	init(n);</span><br><span class="line">	<span class="type">char</span> c;</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c%d%d&quot;</span>,&amp;c,&amp;x,&amp;y);</span><br><span class="line">		<span class="keyword">if</span>(c==<span class="string">&#x27;B&#x27;</span>) Union(x,y,<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">else</span> Union(x,y,<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		<span class="type">int</span> a,b;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">		<span class="keyword">if</span>(find(a)==find(b))&#123;</span><br><span class="line">			<span class="keyword">if</span>(r[a]==r[b]) <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Not sure\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CODE2"><a href="#CODE2" class="headerlink" title="CODE2"></a>CODE2</h3><p>第二种思路，前n个作为第一个集合，后n个作为第二个集合，具体查看<a href="https://blog.csdn.net/u011008379/article/details/50999448?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param">题解</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e3</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> fa[MAXN*<span class="number">2</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++) fa[i]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==fa[x]) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">return</span> fa[x]=find(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Union</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">	<span class="type">int</span> x=find(a), y=find(b);</span><br><span class="line">	<span class="keyword">if</span>(x!=y) fa[y]=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> t,n,m;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;t);</span><br><span class="line">	init(<span class="number">2</span>*n);</span><br><span class="line">	<span class="type">char</span> c;</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot; %c%d%d&quot;</span>,&amp;c,&amp;x,&amp;y);</span><br><span class="line">		<span class="keyword">if</span>(c==<span class="string">&#x27;B&#x27;</span>)&#123;</span><br><span class="line">			Union(x,y);</span><br><span class="line">			Union(x+n,y+n);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			Union(x+n,y);</span><br><span class="line">			Union(x,y+n);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		<span class="type">int</span> a,b;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">		<span class="keyword">if</span>(find(a)==find(b)||find(a+n)==find(b+n)) <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(find(a+n)==find(b)||find(a)==find(b+n)) <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Not sure\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="H-胡图图的好兄弟"><a href="#H-胡图图的好兄弟" class="headerlink" title="H. 胡图图的好兄弟"></a>H. 胡图图的好兄弟</h2><p><strong>记忆化搜索</strong></p>
<p>首先不考虑<em>a</em>1为何值，先预处理出当<em>x &gt;</em> 1时的结果，首先定义一个数组dp[N] [2]，<em>dp</em>[<em>i</em>][<em>j</em>]是指<em>x</em> = <em>i</em>并且执行第<em>j</em>步操作时的最终结果。在过程中记录每一个<em>dp</em>[<em>i</em>][<em>j</em>]下一次再次来到<em>i</em>点便可以直接返回<em>dp</em>[<em>i</em>][<em>j</em>]。在这个过程中可能会遇到回到了<em>a</em>1，但是<em>a</em>1是不确定的。不过并没有影响，题目描述算法输出有两种情况，一个是<em>y</em>，一个是<em>ᱟ</em> 1，什么时候出现<em>⧠</em> 1，当出现循环的时候，比如说在一次程序运行中，已经计算了<em>dp</em>[<em>i</em>] [<em>j</em>]但是后来有来到了<em>dp</em>[<em>i</em>][<em>j</em>]，很明显此时陷入循环了，那么就会输出<em>ࠪ</em> 1，对于再次经过<em>a</em>1有两种情况，一种是<em>i</em> = 1<em>, j</em> = 0，即下一步<em>x</em> = <em>x</em> + <em>a</em>1，因为程序的第一步都是<em>i</em> = 1<em>, j</em> = 0，所以说，到这里陷入循环输出<em>ࠪ</em> 1。另外一种<em>i</em> = 1 <em>j</em> = 1是不会出现的。预处理完后，我们便可以逐个输dp<em>[i][1] + </em>ii<em> 1(</em>i &gt;<em> 1)，</em>ii<em> 1是指初始时经过</em>a<em>1也就是</em>dp*[1][0]的值。</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">100</span>;</span><br><span class="line">ll dp[N][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> arr[N];</span><br><span class="line"><span class="type">bool</span> vis[N][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123; <span class="comment">//表示当前在第几个点，当前经过了奇数还是偶数次操作</span></span><br><span class="line">    <span class="keyword">if</span>(vis[i][j]) <span class="keyword">return</span> ; <span class="comment">//如果当前点之前已经经过了则直接返回</span></span><br><span class="line">    <span class="type">int</span> nx; <span class="comment">//下一个点</span></span><br><span class="line">    vis[i][j]=<span class="number">1</span>; <span class="comment">//标记当前点已经访问过了</span></span><br><span class="line">    <span class="keyword">if</span>(j&amp;<span class="number">1</span>) nx=i-arr[i]; <span class="comment">//奇数次操作减</span></span><br><span class="line">    <span class="keyword">else</span> nx=i+arr[i]; <span class="comment">//偶数次操作加</span></span><br><span class="line">    <span class="keyword">if</span>(nx&lt;=<span class="number">0</span>||nx&gt;n)&#123; <span class="comment">//下一个点结束，则现在就可以直接记录答案，表示从第i个点开始经过奇偶次操作后结束答案为arr[i]</span></span><br><span class="line">        dp[i][j]=arr[i];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(nx,j^<span class="number">1</span>); <span class="comment">//下一个点没有结束则需要继续搜索，j变换奇偶</span></span><br><span class="line">    <span class="keyword">if</span>(dp[nx][j^<span class="number">1</span>]!=<span class="number">-1</span>)&#123; <span class="comment">//搜索完后如果从下一个点开始可以结束</span></span><br><span class="line">        dp[i][j]=arr[i]+dp[nx][j^<span class="number">1</span>]; <span class="comment">//加上下一步的答案</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ios;</span><br><span class="line">    vis[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>; <span class="comment">//表示从第一个点开始，经过了1次操作，也就是第一步后到达的第一个点</span></span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="keyword">sizeof</span> dp); <span class="comment">//初始化每一个点的答案都是-1，表示有循环</span></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;arr[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++) dfs(i,<span class="number">1</span>); <span class="comment">//预处理，得出每一个点的答案</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[i][<span class="number">1</span>]!=<span class="number">-1</span>) dp[i][<span class="number">1</span>]+=i<span class="number">-1</span>; <span class="comment">//因为是从第二步开始的，第一步i=1,j=0，因此需要加上a1，也就是i-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;dp[i][<span class="number">1</span>]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="I-胡图图吃桃子"><a href="#I-胡图图吃桃子" class="headerlink" title="I. 胡图图吃桃子"></a><strong>I.</strong> 胡图图吃桃子</h2><p>完全背包问题，算是比较模板，不过你得想到完全背包%%%</p>
<p>完全背包初始化我还不理解，不懂什么时候必须初始化一些东西，反正我现在的做法就是把能直接看出来答案的数都初始化一下</p>
<p><a href="https://www.luogu.com.cn/problem/solution/P1679">详细点击我</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> p[<span class="number">1000</span>],dp[<span class="number">120010</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> w;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;w;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">18</span>;i++) p[i]=<span class="built_in">pow</span>(i,<span class="number">4</span>); <span class="comment">//数据范围到1e5所以要算到18</span></span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dp); <span class="comment">//初始化为无穷大</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">18</span>;i++) dp[p[i]]=<span class="number">1</span>; <span class="comment">//因为是4次方所以最小值都是1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;p[i]&lt;=w;i++)&#123; <span class="comment">//注意条件</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=p[i];j&lt;=w;j++)&#123;</span><br><span class="line">            dp[j]=min(dp[j],dp[j-p[i]]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[w]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这道题我刚开始一直以为贪心做就可以了，但事实证明认为可行也只是我的个人感觉，我刚开始的做法就是每次对这个数开四次根号，再减去这个数的四次方，之前已知都没想到哪里错了，举了很多例子都找不出来错误，事实上例子确实不好找，跑了一下706到1里面错误的都很少，比如704=(4^4^)^2^+(2^4^)^12^,也就是14次，但是贪心每次都去最大四次方数就是二十次，错了</p>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>集训</tag>
      </tags>
  </entry>
  <entry>
    <title>积分赛5</title>
    <url>/posts/4c99fc92.html</url>
    <content><![CDATA[<blockquote>
<p><del>最友好的一次积分赛2333</del>应该也是最后一个个人积分赛了，不知道最后一次会不会是团队赛，再说吧，已经八月十五了，自从集训以来每天都有训练，虽然晚上一般都是有些时间去记录一些题解的，但是懒癌晚期的我真的不想去写，终于今天下定决心，趁着这两天我要补一下题解，把最近有意义的题目记录一下，也算是一个复习吧🎉</p>
</blockquote>
<h2 id="D-何不好的晨练"><a href="#D-何不好的晨练" class="headerlink" title="D 何不好的晨练"></a>D 何不好的晨练</h2><p><strong>描述</strong></p>
<p>何不好是一名晨练爱好者，每天他都要一大早出门进行晨跑锻炼，何不好生活的城市很大，</p>
<p>同时也比较繁荣，路边高楼耸立，道路上车辆往来，川流不息。</p>
<p>晨练的同时还可以欣赏路边的风景，于是，何不好打算每天选择 <em>M</em> 条路段，其中包括 <em>N</em></p>
<p>个路口。</p>
<p>但何不好想要从起点开始不重复的跑完所有路段，并且跑回起点，苦于是学渣的他不知道</p>
<p>能不能完成这个条件，于是他向你寻求帮助。</p>
<p><strong>输入数据</strong></p>
<p>第一行给定两个整数 <em>N</em> , <em>M</em> 。</p>
<p>接下来 <em>M</em> 行，每行有两个整数 <em>U</em>，<em>V</em> 代表路段相连的两个路口。</p>
<p>1 <em>≤</em> <em>N</em> <em>≤</em> 100,000. 0 <em>≤</em> <em>M</em> <em>≤</em> 100,000. 毎对儿 <em>U</em>, <em>V</em> 互不相同，且 <em>U</em>, <em>V</em> 不同。</p>
<p><strong>输出数据</strong></p>
<p>若能完成这个条件则输出Yes，否则输出No。</p>
<p><strong>样例输入</strong></p>
<p>4 4</p>
<p>1 2</p>
<p>2 3</p>
<p>3 4</p>
<p>4 1</p>
<p><strong>样例输出</strong></p>
<p>Yes</p>
<hr>
<p>不难的一道题，只要知道了一笔画问题就差不多能解决了，首先看两个概念</p>
<ol>
<li>欧拉通路：即可以不回到起点，但是必须经过每一条边，且只能一次。也叫”一笔画”问题。该路径成为欧拉路径。</li>
<li>图G的一个回路，如果恰通过图G的每一条边，则该回路称为欧拉回路，具有欧拉回路的图称为欧拉图。欧拉图就是从图上的一点出发，经过所有边且只能经过一次，最终回到起点的路径。</li>
</ol>
<p><strong>判定充要条件</strong></p>
<p>欧拉回路：    1:  图G是连通的，不能有孤立点存在。</p>
<p>　　　　　　2:  <code>对于无向图来说度数为奇数的点个数为0;  对于有向图来说每个点的入度必须等于出度</code>。</p>
<p>欧拉通路：    1:  图G是连通的，无孤立点存在。</p>
<p>　　　　　　2:  对于无向图来说，<code>度数为奇数的的点可以有2个或者0个，并且这两个奇点其中一个为起点另外一个为终点</code>。  对于有向图来说，可以<code>存在两个点，其入度不等于出度，其中一个出度比入度大1，为路径的起点；另外一个入度比出度大1，为路径的终点</code>。</p>
<p>知道了这个这个题目就只要判断<code>图是否联通+图上奇数度数点是否存在</code>，度数容易判断，图是否联通则可以用并查集来做，开一个son数组代表该结点作为根节点下方有多少点，合并时更新即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> fa[MAXN],son[MAXN];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;MAXN;i++)&#123; <span class="comment">//初始化</span></span><br><span class="line">    	fa[i]=i; son[i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(fa[x]==x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> fa[x]=find(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Union</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">    x=find(x);</span><br><span class="line">    y=find(y);</span><br><span class="line">    <span class="keyword">if</span>(x!=y)&#123;</span><br><span class="line">        fa[x]=y;</span><br><span class="line">        son[y]+=son[x]; <span class="comment">//右面结点的son数量加上左面结点的son数量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">    <span class="type">int</span> n,m,a,b;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        mp[a]++,mp[b]++;</span><br><span class="line">        Union(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> f1=<span class="number">0</span>,f2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> p:mp)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p.second&amp;<span class="number">1</span>) f1=<span class="number">1</span>; <span class="comment">//判奇数结点</span></span><br><span class="line">        <span class="keyword">if</span>(son[find(p.first)]!=n) f2=<span class="number">1</span>; <span class="comment">//若图联通则任意一个结点的祖先的son值一定等于所有节点的数量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f1||f2) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="E-何不好的博弈游戏"><a href="#E-何不好的博弈游戏" class="headerlink" title="E 何不好的博弈游戏"></a>E 何不好的博弈游戏</h2><p><strong>描述</strong></p>
<p>何不好要和他的好朋友Tom玩一个游戏，游戏规则是有n个硬币，正面向上围成一个圆圈，</p>
<p>并且排上序号1到n，确定一个数字k，每次只能翻序号连续的1到k个硬币（n和1连续），每个硬</p>
<p>币只能翻一次，如果最后谁没有硬币可以翻(所有的硬币都被翻过一次了)，谁就输掉了这个游</p>
<p>戏，每次都是何不好先手，如果两个人都很聪明，并且没有失误的话，问最后何不好能不能赢</p>
<p>得这次游戏。</p>
<p><strong>输入数据</strong></p>
<p>第一行是一个整数<em>T</em>(<em>T</em> ⩽ 10)</p>
<p>接下来有T行，每一行有两个整数<em>n</em>(1 ⩽ <em>n</em> ⩽ 103)，<em>k</em>(1 ⩽ <em>k</em> ⩽ 103)。</p>
<p><strong>输出数据</strong></p>
<p>如果何不好能赢这次游戏，输出“Yes”，如果不能，输出“No”。</p>
<p><strong>样例输入</strong></p>
<p>3</p>
<p>3 1</p>
<p>5 2</p>
<p>5 6</p>
<p><strong>样例输出</strong></p>
<p>Yes</p>
<p>No</p>
<p>Yes</p>
<hr>
<p><strong>思路</strong></p>
<p>博弈论个人理解就是智力题，这道题对不同情况分别讨论：</p>
<ol>
<li><p>如果 k&lt;n:</p>
<ol>
<li>当k=1时，如果n是奇数，先手一定能赢，n是偶数后手赢</li>
<li>当k&gt;1时，后手一定赢（先手第一次翻什么位置，后手就翻对称的位置，使剩下的硬币分为两个相同长度的序列），然后无论先手接下来怎么翻，后手就翻对称的位置，这样保证后手永远有硬币可以翻</li>
</ol>
</li>
<li><p>如果k&gt;=n:  后手赢，直接翻完就完事了</p>
</li>
</ol>
<p>把思路直接写成代码就行了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc ++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		<span class="type">int</span> n,k;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">		<span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(k&lt;n)&#123;</span><br><span class="line">			<span class="keyword">if</span>(k==<span class="number">1</span>&amp;&amp;(n&amp;<span class="number">1</span>)) flag=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(k&gt;=n) flag=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(flag==<span class="number">1</span>) <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="I-何不好的字符串"><a href="#I-何不好的字符串" class="headerlink" title="I 何不好的字符串"></a>I 何不好的字符串</h2><p><strong>描述</strong></p>
<p>何不好非常不好，因为别人给他一个字符串，要让他解答问题，何不好懒得写就把他交给</p>
<p>你们了，何不好可以不回答，但你们必须回答，给你一个字符串<em>S</em>,先将字符串扩充一次，比</p>
<p>如<em>AB</em>变成<em>ABAB</em>,在把字符串中随意加入一个字母构成字符串<em>U</em>，让你重新构造出字符串<em>S</em>;</p>
<p><strong>输入数据</strong></p>
<p>第一行输入表示字符串<em>U</em>长度为<em>N</em>(<em>N</em> ⩽ 20000001)，第二行输入字符串<em>U</em>;</p>
<p><strong>输出数据</strong></p>
<p>输出字符串<em>S</em>, 如果符串无法按照上述方法构造出来，输出<em>NOT P OSSIBLE</em>; 如果字符串<em>S</em>不唯一，输出<em>NOT UNIQUE</em>;</p>
<p><strong>样例输入1</strong></p>
<p>7</p>
<p>ABXCABC</p>
<p><strong>样例输出1</strong></p>
<p>ABC</p>
<p><strong>样例输入2</strong> </p>
<p>6</p>
<p>ABCDEF</p>
<p><strong>样例输出3</strong></p>
<p>NOT POSSIBLE</p>
<hr>
<p><strong>思路</strong></p>
<p>哈希预处理，使得字符串比较复杂度降低为O(1)，因此枚举每一个位置删除该位置后看看前半部分和后半部分是否相同，时间复杂度为O(n)，不过这个数据真的吓人2e7的字符串长度，计算机1s能算5e8的数据，能过的</p>
<p>现在给你两个字符串的哈希值，让你求两个字符串拼接后的哈希值，只需要让左面的乘以p^右面字符串长度^加上右面字符串哈希值就行了，这里卡了好久</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="type">const</span> ull base=<span class="number">2333</span>;</span><br><span class="line"><span class="type">const</span> ull N=<span class="number">20000101</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;ull,ull&gt; mp;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> n,len,cnt;</span><br><span class="line">ull Hash[N],p[N];</span><br><span class="line">ull <span class="title function_">gethash</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> Hash[y]-Hash[x<span class="number">-1</span>]*p[y-x+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> pos)</span>&#123;</span><br><span class="line">    ull hash1,hash2;</span><br><span class="line">    <span class="keyword">if</span>(pos&lt;=n+<span class="number">1</span>)&#123;</span><br><span class="line">    	hash1=Hash[pos<span class="number">-1</span>]*p[n+<span class="number">1</span>-pos]+gethash(pos+<span class="number">1</span>,n+<span class="number">1</span>); <span class="comment">//算出删除点左面哈希值和右面哈希值，然后把左面乘以相应权值然后加上右面就是拼接好的哈希值</span></span><br><span class="line">    	hash2=gethash(n+<span class="number">2</span>,len); <span class="comment">//因为删除点在左半部分，因此右面直接算哈希</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">    	hash1=Hash[n]; <span class="comment">//删除点在右半部分，左面直接算</span></span><br><span class="line">    	hash2=gethash(n+<span class="number">1</span>,pos<span class="number">-1</span>)*p[len-pos]+gethash(pos+<span class="number">1</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(hash1==hash2)&#123;</span><br><span class="line">        mp[hash1]++; <span class="comment">//把新得到的字符串的哈希值存到map里</span></span><br><span class="line">        <span class="keyword">if</span>(mp[hash1]==<span class="number">1</span>) cnt++; <span class="comment">//若该字符串是第一次出现则计数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">    len=n;</span><br><span class="line">    <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>)&#123; <span class="comment">//原串字符数量是偶数时直接输出不可能</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;NOT POSSIBLE&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    n/=<span class="number">2</span>; <span class="comment">//找到中点</span></span><br><span class="line">    p[<span class="number">0</span>]=<span class="number">1</span>; <span class="comment">//打一个每一位权值的表</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;++i)&#123; <span class="comment">//打哈希表加权值表</span></span><br><span class="line">    	p[i]=p[i<span class="number">-1</span>]*base;</span><br><span class="line">    	Hash[i]=Hash[i<span class="number">-1</span>]*base+(s[i]-<span class="string">&#x27;A&#x27;</span>+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> pos;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;++i)&#123;</span><br><span class="line">    	<span class="keyword">if</span>(check(i)) pos=i; <span class="comment">//枚举每一个点，当删除该点后左右字符串哈希值一样则表示符合条件记录该位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!cnt) <span class="built_in">puts</span>(<span class="string">&quot;NOT POSSIBLE&quot;</span>); <span class="comment">//枚举每一个点左右两边的哈希值都不一样就不可能</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(cnt&gt;<span class="number">1</span>) <span class="built_in">puts</span>(<span class="string">&quot;NOT UNIQUE&quot;</span>); <span class="comment">//当出现了两个解输出不唯一</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos&lt;=n+<span class="number">1</span>) <span class="keyword">for</span>(<span class="type">int</span> i=n+<span class="number">2</span>;i&lt;=len;++i) <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,s[i]); <span class="comment">//删除的字符在左面就输出右面</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,s[i]); <span class="comment">//否则输出左面</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>集训</tag>
      </tags>
  </entry>
  <entry>
    <title>集训第一天</title>
    <url>/posts/1f97ad2b.html</url>
    <content><![CDATA[<blockquote>
<p>紧张刺激而又枯燥的集训开始了🐷</p>
</blockquote>
<h2 id="problem1"><a href="#problem1" class="headerlink" title="problem1"></a>problem1</h2><p><a href="https://vjudge.net/contest/382262#problem/D">题目链接</a></p>
<p>一道思维题，很容易想到从大往小减，这是一个误区，可以这样思考，任意两个数如果差为偶数一定是满足题目要求的，当这两个数高度相同时就可以看成一棵树了，再让这个数去和其他的数比较，当差又是偶数时便又满足题目要求，便可以得出规律，只要给定序列任意两个数相差为偶数便满足题意</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI acos(-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> h[MAXN];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">    	<span class="type">int</span> n;</span><br><span class="line">    	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;h[i];</span><br><span class="line">		<span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>((h[i]-h[i<span class="number">-1</span>])%<span class="number">2</span>)&#123;</span><br><span class="line">				flag=<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(flag) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;no&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;yes&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="Problem2"><a href="#Problem2" class="headerlink" title="Problem2"></a>Problem2</h2><p><a href="https://vjudge.net/contest/382262#problem/G">题目链接</a></p>
<p>英文不好真的读不懂题。。。这道题意思是机器人从原点出发，经过一系列走法之后到达一点，问能不能删除这一系列走法中的字串，使得终点不变而删除的字串长度最小</p>
<p>不难看出当走到以前经过的一点时，这中间的序列一定是可以删除的，那么我们可以每一点上一次走到这里花费的步数(注意不是最小步数因为我们要求的是删除的字串长度最小)，当再次走到该点时用此时的步数减去上一次走到该点的步数得到的就是可以删除的字串长度，若该长度最小那么更新答案便可以了，这里如何记录一个点是否走过呢？假设用数组来存就需要二维数组，里面大多数点都是没用的，就很浪费空间，这道题开不了这么大的空间，可以用map来存，map<pair<int,int>,int&gt;</p>
<h3 id="CODE-1"><a href="#CODE-1" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt;,<span class="type">int</span>&gt; mp;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		mp.clear();</span><br><span class="line">		<span class="type">int</span> n,maxn=<span class="number">1e9</span>;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;s;</span><br><span class="line">		s=<span class="string">&#x27; &#x27;</span>+s;</span><br><span class="line">		<span class="type">int</span> l,r,x=<span class="number">0</span>,y=<span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> len=s.size();</span><br><span class="line">		mp[<span class="built_in">make_pair</span>(x,y)]=<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(s[i]==<span class="string">&#x27;L&#x27;</span>) x--;</span><br><span class="line">			<span class="keyword">if</span>(s[i]==<span class="string">&#x27;R&#x27;</span>) x++;</span><br><span class="line">			<span class="keyword">if</span>(s[i]==<span class="string">&#x27;D&#x27;</span>) y--;</span><br><span class="line">			<span class="keyword">if</span>(s[i]==<span class="string">&#x27;U&#x27;</span>) y++;</span><br><span class="line">			<span class="type">int</span> m=mp[<span class="built_in">make_pair</span>(x,y)];</span><br><span class="line">			<span class="keyword">if</span>(m!=<span class="number">0</span>)&#123;</span><br><span class="line">				<span class="keyword">if</span>(m==<span class="number">-1</span>) m=<span class="number">0</span>;</span><br><span class="line">				<span class="keyword">if</span>(i-m&lt;maxn)&#123;</span><br><span class="line">					maxn=i-m;</span><br><span class="line">					l=m+<span class="number">1</span>; r=i;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			mp[<span class="built_in">make_pair</span>(x,y)]=i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(maxn==<span class="number">1e9</span>) <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;l&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;r&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="problem3"><a href="#problem3" class="headerlink" title="problem3"></a>problem3</h2><p><a href="https://vjudge.net/contest/382262#problem/K">题目链接</a></p>
<p>这道题我想错方向了，我在想把两个字符串连接后转化成新数，然后这个问题就转换成了从1到a，从1到b挑出两个数满足题意，这样我最多就能想出二分优化成NlogN，但是数据量1e9，指定过不了，就在这可了很久很久，原来这道题两个数连接不是让用字符串连接的，是让你用a10^(b的位数)+b来连接的，这样一来原来的a+b+ab==a10^(b的位数)+b，两边消去b，然后等式都除以a，就把a消去了，然后就能算出来b的公式，b=10^(b的位数)-1，啊！这道题其实不难，就是方向错了，难受😫</p>
<h3 id="CODE-2"><a href="#CODE-2" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> <span class="title function_">check</span><span class="params">(ll t)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(t&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">int</span> x=t%<span class="number">10</span>;</span><br><span class="line">        t/=<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span>(x!=<span class="number">9</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        ll a,b;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        ll cnt=<span class="number">0</span>;</span><br><span class="line">        ll temp=b;</span><br><span class="line">        <span class="keyword">while</span>(temp&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            temp/=<span class="number">10</span>;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(check(b)) <span class="built_in">cout</span>&lt;&lt;a*cnt&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;a*(cnt<span class="number">-1</span>)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Problem4"><a href="#Problem4" class="headerlink" title="Problem4"></a>Problem4</h2><p><a href="https://vjudge.net/contest/382262#problem/J">题目链接</a></p>
<p>这道题也算是一道思维题吧，要想让数最大，一定是数的位数优先，两位数肯定比一位数大对吧，想通了这再举几个例子就能看出来这是一个递归的过程，递归出口就是2和3</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI acos(-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> h[MAXN];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">    	<span class="type">int</span> n;</span><br><span class="line">    	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;h[i];</span><br><span class="line">		<span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>((h[i]-h[i<span class="number">-1</span>])%<span class="number">2</span>)&#123;</span><br><span class="line">				flag=<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(flag) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;no&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;yes&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>集训</tag>
      </tags>
  </entry>
  <entry>
    <title>STL集训典型题目</title>
    <url>/posts/c024eb61.html</url>
    <content><![CDATA[<blockquote>
<p>自己找题，做课件，还得学习新的东西，不得不说确实挺费时间的，光找找题目就花了2个小时左右，还是因为自己的题量少的原因，只能去搜一些题目自己再做做，不过粘贴题目AC的感觉真的美妙🐷</p>
</blockquote>
<h2 id="Running-Medians"><a href="#Running-Medians" class="headerlink" title="Running Medians"></a>Running Medians</h2><p>For this problem, you will write a program that reads in a sequence of 32-bit signed integers. After each <em>odd-indexed</em> value is read, output the median (middle value) of the elements received so far.</p>
<blockquote>
<p><strong>Input</strong></p>
<p>The first line of input contains a single integer P, (1 ≤ P ≤ 1000), which is the number of data sets that follow. The first line of each data set contains the data set number, followed by a space, followed by an odd decimal integer M, (1 ≤ M ≤ 9999), giving the total number of signed integers to be processed.<br>The remaining line(s) in the dataset consists of the values, 10 per line, separated by a single space.<br>The last line in the dataset may contain less than 10 values.</p>
<p><strong>Output</strong></p>
<p>For each data set the first line of output contains the data set number, a single space and the number of medians output (which should be one-half the number of input values plus one). The output medians will be on the following lines, 10 per line separated by a single space. The last line may have less than 10 elements, but at least 1 element. There should be no blank lines in the output.</p>
<p><strong>Sample Input</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">9</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br><span class="line"><span class="number">2</span> <span class="number">9</span></span><br><span class="line"><span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">23</span></span><br><span class="line"><span class="number">23</span> <span class="number">41</span> <span class="number">13</span> <span class="number">22</span> <span class="number">-3</span> <span class="number">24</span> <span class="number">-31</span> <span class="number">-11</span> <span class="number">-8</span> <span class="number">-7</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">103</span> <span class="number">211</span> <span class="number">-311</span> <span class="number">-45</span> <span class="number">-67</span> <span class="number">-73</span> <span class="number">-81</span> <span class="number">-99</span></span><br><span class="line"><span class="number">-33</span> <span class="number">24</span> <span class="number">56</span></span><br></pre></td></tr></table></figure>
<p>Sample Output</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;<span class="number">1</span> <span class="number">5</span></span><br><span class="line">&gt;<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line">&gt;<span class="number">2</span> <span class="number">5</span></span><br><span class="line">&gt;<span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span></span><br><span class="line">&gt;<span class="number">3</span> <span class="number">12</span></span><br><span class="line">&gt;<span class="number">23</span> <span class="number">23</span> <span class="number">22</span> <span class="number">22</span> <span class="number">13</span> <span class="number">3</span> <span class="number">5</span> <span class="number">5</span> <span class="number">3</span> <span class="number">-3</span></span><br><span class="line">&gt;<span class="number">-7</span> <span class="number">-3</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>一道对顶堆的典型例题，对顶堆是优先队列的一种典型使用方式，主要就是开辟两个优先队列，一个大根一个小根，动态维护它们的元素数量以及两个队列的队头大小关系，永远保证大根堆头比小根堆头小，从而使整个序列元素有序，因此每次进来一个新元素只要判断其是该放到哪一个堆就行了</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> T,n,m,a[<span class="number">50005</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">priority_queue</span>&lt;<span class="type">int</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt; &gt; q;</span><br><span class="line"></span><br><span class="line"><span class="built_in">priority_queue</span>&lt;<span class="type">int</span>&gt; p;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())q.pop();</span><br><span class="line">        <span class="keyword">while</span>(!p.empty())p.pop();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;m,&amp;n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,m,(n+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        q.push(a[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a[<span class="number">1</span>]);</span><br><span class="line">        <span class="type">int</span> cnt=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;q.top()) q.push(a[i]);</span><br><span class="line">            <span class="keyword">else</span> p.push(a[i]);</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(p.size()&gt;(i/<span class="number">2</span>))&#123;</span><br><span class="line">                    q.push(p.top());</span><br><span class="line">                    p.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>(q.size()&gt;(i-(i/<span class="number">2</span>)))&#123;</span><br><span class="line">                    p.push(q.top());</span><br><span class="line">                    q.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                cnt++;</span><br><span class="line">                <span class="keyword">if</span>(cnt%<span class="number">10</span>==<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;\n%d&quot;</span>,q.top());</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>,q.top());</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Constructing-the-Array"><a href="#Constructing-the-Array" class="headerlink" title="Constructing the Array"></a>Constructing the Array</h2><p><a href="https://vjudge.net/contest/382426#problem/I">题目链接</a></p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>这道题拿到手应该第一反应就是找规律，找规律是能做出来的，情况也就是那么多种，但是这道题更官方的做法是用优先队列来做，什么你问我怎么做？我们只要每一段连续0的字符串当作一个优先队列，定义一个结构体，装这对序列的最左面元素的下标和这段序列的长度，优先按长度从大到小排列，然后再按下标从小到大排列，每次将指定元素放到到指定位置时，以这个元素作为分割线从中间分开，之后就会出现两个队列，依次入队，每次重复这样的操作，直到放完所有的元素</p>
<h3 id="CODE-1"><a href="#CODE-1" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> len,l,r;</span><br><span class="line">	<span class="type">bool</span> operator &lt; (<span class="type">const</span> node &amp;a) <span class="type">const</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(a.len==len) <span class="keyword">return</span> l&gt;a.l;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> len&lt;a.len;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">priority_queue</span>&lt;node&gt; pq;</span><br><span class="line"><span class="type">int</span> ans[N];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		<span class="type">int</span> n;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">		<span class="built_in">memset</span>(ans,<span class="number">0</span>,<span class="keyword">sizeof</span> ans);</span><br><span class="line">		<span class="keyword">while</span>(!pq.empty()) pq.pop();</span><br><span class="line">		pq.push((node)&#123;n,<span class="number">1</span>,n&#125;);</span><br><span class="line">		<span class="type">int</span> cnt=<span class="number">0</span>,mid;</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">			node now=pq.top(); pq.pop();</span><br><span class="line">			<span class="keyword">if</span>((now.r-now.l+<span class="number">1</span>)&amp;<span class="number">1</span>)&#123;</span><br><span class="line">				ans[(now.l+now.r)&gt;&gt;<span class="number">1</span>]=++cnt;</span><br><span class="line">				mid=(now.l+now.r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				ans[(now.l+now.r<span class="number">-1</span>)&gt;&gt;<span class="number">1</span>]=++cnt;</span><br><span class="line">				mid=(now.l+now.r<span class="number">-1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(cnt==n) <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">if</span>(mid<span class="number">-1</span>&gt;=now.l) pq.push((node)&#123;mid-now.l,now.l,mid<span class="number">-1</span>&#125;);</span><br><span class="line">			<span class="keyword">if</span>(now.r&gt;=mid+<span class="number">1</span>) pq.push((node)&#123;now.r-mid,mid+<span class="number">1</span>,now.r&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cout</span>&lt;&lt;ans[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>进制转换模板</title>
    <url>/posts/6bf2ab0f.html</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请你编一程序实现两种不同进制之间的数据转换。</p>
<p>输入格式</p>
<p>共三行，第一行是一个正整数，表示需要转换的数的进制n(2≤n≤16)n(2≤n≤16)n(2≤n≤16)，第二行是一个n进制数，若n&gt;10n&gt;10n&gt;10则用大写字母A−FA-FA−F表示数码10−1510-1510−15，并且该nnn进制数对应的十进制的值不超过100000000010000000001000000000，第三行也是一个正整数，表示转换之后的数的进制m(2≤m≤16)m(2≤m≤16)m(2≤m≤16)。</p>
<p>输出格式</p>
<p>一个正整数，表示转换之后的mmm进制数。</p>
<p>输入输出样例</p>
<p>输入 #1</p>
<pre><code>16

FF

2
</code></pre><p>输出 #1</p>
<pre><code>11111111
</code></pre><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;math.h&gt;
#include&lt;vector&gt;
using namespace std;
int change(char ch)&#123;
  if(ch==&#39;A&#39;) return 10;
  if(ch==&#39;B&#39;) return 11;
  if(ch==&#39;C&#39;) return 12;
  if(ch==&#39;D&#39;) return 13;
  if(ch==&#39;E&#39;) return 14;
  if(ch==&#39;F&#39;) return 15;
&#125;
char judge(int a)&#123;
  if(a&gt;=0&amp;&amp;a&lt;=9) return char(a+&#39;0&#39;);
  if(a==10) return &#39;A&#39;;
  if(a==11) return &#39;B&#39;;
  if(a==12) return &#39;C&#39;;
  if(a==13) return &#39;D&#39;;
  if(a==14) return &#39;E&#39;;
  if(a==15) return &#39;F&#39;;
&#125;
int main()
&#123;
  int n,m,i=0,cnt=0;
  long long sum=0;
  vector&lt;int&gt; arr;
  string num;
  cin&gt;&gt;m&gt;&gt;num&gt;&gt;n;
  for(int i=num.size()-1;i&gt;=0;i--,cnt++)&#123;
    if(num[i]&gt;=&#39;A&#39;&amp;&amp;num[i]&lt;=&#39;F&#39;)&#123;
      int t=change(num[i]);
      sum+=t*pow(m,cnt);
    &#125;
    else sum+=(num[i]-&#39;0&#39;)*pow(m,cnt);    
  &#125;
//    cout&lt;&lt;sum&lt;&lt;endl;
  if(n==10) cout&lt;&lt;sum&lt;&lt;endl;
  else if(n&gt;=2&amp;&amp;n&lt;10||n&gt;10&amp;&amp;n&lt;=16)&#123;
    string s=&quot;&quot;;
    while(sum!=0)&#123;
      s=judge(sum%n)+s;
      sum/=n;
    &#125;
    cout&lt;&lt;s&lt;&lt;endl;
  &#125;
&#125; 
</code></pre>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>集训前缀和与差分</title>
    <url>/posts/a36c6b85.html</url>
    <content><![CDATA[<h2 id="程序设计：蒜头君的数轴"><a href="#程序设计：蒜头君的数轴" class="headerlink" title="程序设计：蒜头君的数轴"></a>程序设计：蒜头君的数轴</h2><p>题目来源 ：<a href="https://nanti.jisuanke.com/t/A1633">点击我</a></p>
<p>今天蒜头君拿到了一个数轴，上边有 n 个点，但是蒜头君嫌这根数轴不够优美，想要通过加一些点让它变优美，所谓优美是指考虑相邻两个点的距离，最多只有一对点的距离与其它的不同。</p>
<p>蒜头君想知道，他最少需要加多少个点使这个数轴变优美。</p>
<blockquote>
<p><strong>输入格式</strong></p>
<p>输入第一行为一个整数 n(1 &lt;=n ,q&lt;= 10^5)(1≤<em>n</em>≤105)，表示数轴上的点数。</p>
<p>第二行为 n个不重复的整数</p>
<p><em>x</em>1,<em>x</em>2,…, xn (−109≤xi≤109)，表示这些点的坐标，点坐标乱序排列。</p>
<p><strong>输出格式</strong></p>
<p>输出一行，为一个整数，表示蒜头君最少需要加多少个点使这个数轴变优美。</p>
<p><strong>样例输入</strong></p>
<p>4<br>1 3 7 15</p>
<p><strong>样例输出</strong></p>
<p>1</p>
</blockquote>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>题目很简单，意思就是在一个数轴给你n个点，让在数轴上添加最少的点使得任意两点之间距离都相等(允许一组点间距和其他不等)。</p>
<p>这道题目用到了gcd，如果不考虑允许一组间距和其他的不相等的情况的话，那么就应该把所有区间都变成长度为gcd(所有点间距)(下面用gcd代替)，现在允许一组不等，那么可以枚举这n-1个区间，删除一个区间看看此时需要添加的最小点数量是多少，取其中最小值，如何求点数量呢？任意一段区间想把它变成gcd就要添加x/gcd-1，x表示这一段区间长度，这是显而易见的，两个连续点是这样的情况，那n个点呢？就应该是这n个点每一组区间的点数加起来，而gcd是一样的，也就是说分母一样，分子是这一段区间长度，而后面减去了多少个一呢？原本有n-1段区间，现在删去了一个，剩下了n-2个，所以计算了n-2次，就是说最后公式就变成了len/gcd-n+2，len表示减去区间后的长度，OK到这里思路就很清晰了，不过还有一点，删去一个区间后你怎么算剩下的区间的gcd呢？每次删去难道都要枚举一下吗？那也太费时了，这里就用到了前缀的思想(注意没有“和”字哦)，开一个gcd1的数组，gcd1[i]表示前i个区间的gcd，再开一个gcd2数组，gcd2[i]表示i之后所有区间的gcd(包括i)，每次删去一个区间，就可以更新gcd为__gcd(gcd1[i-1]gcd2[i+1])，OK分析完毕，接下来就可以<del>开心</del>的写代码了</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF= <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> val[N],gcd1[N],gcd2[N],dis[N];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n,sum=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;val[i];</span><br><span class="line">	sort(val+<span class="number">1</span>,val+<span class="number">1</span>+n); <span class="comment">//因为输入是乱序，所以要排一下序</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">		dis[i]=val[i+<span class="number">1</span>]-val[i];</span><br><span class="line">		sum+=dis[i];</span><br><span class="line">	&#125;</span><br><span class="line">	gcd1[<span class="number">0</span>]=<span class="number">0</span>;<span class="comment">//注意初始化</span></span><br><span class="line">	gcd2[n]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++) gcd1[i]=__gcd(gcd1[i<span class="number">-1</span>],dis[i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--) gcd2[i]=__gcd(gcd2[i+<span class="number">1</span>],dis[i]);</span><br><span class="line">	<span class="type">int</span> ans=INF;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">		<span class="type">int</span> len=sum-dis[i];</span><br><span class="line">		<span class="type">int</span> temp;</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">1</span>) temp=(len/gcd2[i+<span class="number">1</span>])-n+<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(i==n<span class="number">-1</span>) temp=(len/gcd1[n<span class="number">-2</span>])-n+<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">else</span> temp=(len/__gcd(gcd1[i<span class="number">-1</span>],gcd2[i+<span class="number">1</span>]))-n+<span class="number">2</span>;</span><br><span class="line">		ans=min(ans,temp);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>
<h2 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h2><p>Xiaoteng has a large area of land for growing crops, and the land can be seen as a rectangle of $n \times m$.</p>
<p>But recently Xiaoteng found that his crops were often stolen by a group of people, so he decided to install some monitors to find all the people and then negotiate with them.</p>
<p>However, Xiao Teng bought bad monitors, each monitor can only monitor the crops inside a rectangle. There are $p$ monitors installed by Xiaoteng, and the rectangle monitored by each monitor is known.</p>
<p>Xiao Teng guess that the thieves would also steal $q$ times of crops. he also guessed the range they were going to steal, which was also a rectangle. Xiao Teng wants to know if his monitors can see all the thieves at a time.</p>
<blockquote>
<p><strong>Input</strong></p>
<p>There are mutiple test cases.</p>
<p>Each case starts with a line containing two integers $n,m (1 &lt;= n,1 &lt;= m , n \times m &lt;= 10^7)$ which represent the area of the land.</p>
<p>And the secend line contain a integer $p(1 &lt;=p &lt;= 10^6)$ which represent the number of the monitor Xiaoteng has installed. This is followed by p lines each describing a rectangle. Each of these lines contains four intergers $x_1,y_1,x_2~and~y_2(1&lt;=x_1 &lt;=x_2 &lt;= n,1&lt;= y_1 &lt;= y_2 &lt;= m)$ ,meaning the lower left corner and upper right corner of the rectangle.</p>
<p>Next line contain a integer $q(1 &lt;= q&lt;= 10^6)$ which represent the number of times that thieves will steal the crops. This is followed by q lines each describing a rectangle. Each of these lines contains four intergers $x_1,y_1,x_2~and~y_2(1&lt;= x_1 &lt;= x_2 &lt;= n,1&lt;= y_1 &lt;= y_2 &lt;= m)$,meaning the lower left corner and upper right corner of the rectangle.</p>
<p><strong>Output</strong></p>
<p>For each case you should print $q$ lines.</p>
<p>Each line containing <strong>YES</strong> or <strong>NO</strong> mean the all thieves whether can be seen.</p>
<p><strong>Sample Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6 6</span><br><span class="line">3</span><br><span class="line">2 2 4 4</span><br><span class="line">3 3 5 6</span><br><span class="line">5 1 6 2</span><br><span class="line">2</span><br><span class="line">3 2 5 4</span><br><span class="line">1 5 6 5</span><br></pre></td></tr></table></figure>
</blockquote>
<p>&gt;<br>&gt;</p>
<blockquote>
<p><strong>Sample Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;YES</span><br><span class="line">&gt;NO</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>题意比较好理解，给你几个矩形区域，这些区域是可以被监控到的，之后再给一些矩形区域，问你这些区域是不是包含在监控区域内部，</p>
<p>很明显我们可以用差分和前缀和把所有监控区域标记为1，然后看偷庄稼的区域面积是不是等于该区域对应值的和，是则包含，否则不包含，这道题难就难在数据量，只说了n*m&lt;=1e7，却没有说n和m的范围，这很为难人啊，你开小一点，万一坐标给你来一个（1，1e7），那不就炸了，你必须开到[ 1e7 ] [1e7]的量才能过，但是会爆内存，这时有一种非常巧妙的方法，把二维映射到一维，具体怎么做呢？比如(2 , 3)，映射规则就是 (x-1)m+y，那这一点就映射到了m+3这一点上，这样可以把这种映射规则写成一个函数，参数就是二维坐标，函数返回映射到一维数组的位置。特别需要注意的一点就是如果你传入参数坐标有0或者大于n或者m了一定要返回0，因为二维前缀和的边界都是0，然后就可以写代码了</p>
<h3 id="CODE-1"><a href="#CODE-1" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI acos(-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e7</span>+<span class="number">100</span>;</span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> n,m,v[N];</span><br><span class="line"><span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==<span class="number">0</span>||y==<span class="number">0</span>||x&gt;n||y&gt;m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> (x<span class="number">-1</span>)*m+y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m))&#123;</span><br><span class="line">		<span class="built_in">memset</span>(v,<span class="number">0</span>,<span class="keyword">sizeof</span> v);</span><br><span class="line">		<span class="type">int</span> t; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">		<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">			<span class="type">int</span> x1,x2,y1,y2;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);</span><br><span class="line">			v[get(x1,y1)]++; </span><br><span class="line">			v[get(x2+<span class="number">1</span>,y2+<span class="number">1</span>)]++;</span><br><span class="line">			v[get(x1,y2+<span class="number">1</span>)]--;</span><br><span class="line">			v[get(x2+<span class="number">1</span>,y1)]--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">				v[get(i,j)]+=v[get(i<span class="number">-1</span>,j)]+v[get(i,j<span class="number">-1</span>)]-v[get(i<span class="number">-1</span>,j<span class="number">-1</span>)];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(v[get(i,j)]&gt;<span class="number">0</span>) v[get(i,j)]=<span class="number">1</span>;</span><br><span class="line">				v[get(i,j)]+=v[get(i<span class="number">-1</span>,j)]+v[get(i,j<span class="number">-1</span>)]-v[get(i<span class="number">-1</span>,j<span class="number">-1</span>)];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> q; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q);</span><br><span class="line">		<span class="keyword">while</span>(q--)&#123;</span><br><span class="line">			<span class="type">int</span> x1,x2,y1,y2;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);</span><br><span class="line">			<span class="type">int</span> ans=v[get(x2,y2)]+v[get(x1<span class="number">-1</span>,y1<span class="number">-1</span>)]-v[get(x2,y1<span class="number">-1</span>)]-v[get(x1<span class="number">-1</span>,y2)];</span><br><span class="line">			<span class="keyword">if</span>(ans==(x2-x1+<span class="number">1</span>)*(y2-y1+<span class="number">1</span>))<span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>
<h3 id="做法二"><a href="#做法二" class="headerlink" title="做法二"></a>做法二</h3><p>这道题内存问题还可以用vector来解，因为vector是动态的嘛，定义方式vector<vector< int >&gt; ve(n+10, vector&lt; int &gt;(m+10,0))</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,m,p,q;</span><br><span class="line">int main()&#123; </span><br><span class="line">	while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m))&#123; </span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt; ve(n+10,vector&lt;int&gt;(m+10,0));</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;p); </span><br><span class="line">        int x1,y1,x2,y2;</span><br><span class="line">        while(p--)&#123;</span><br><span class="line">            scanf(&quot;%d%d%d%d&quot;,&amp;x1,&amp;y1,&amp;x2,&amp;y2);</span><br><span class="line">            // cout&lt;&lt;x1&lt;&lt;y1&lt;&lt;x2&lt;&lt;y2&lt;&lt;endl;</span><br><span class="line">            ve[x1][y1]++;</span><br><span class="line">            ve[x2+1][y1]--;</span><br><span class="line">            ve[x1][y2+1]--;</span><br><span class="line">            ve[x2+1][y2+1]++;</span><br><span class="line">        &#125;</span><br><span class="line">        //二维差分求前缀和</span><br><span class="line">		for(int i=1;i&lt;=n;i++)</span><br><span class="line">		for(int j=1;j&lt;=m;j++)&#123;</span><br><span class="line">			ve[i][j]+=ve[i-1][j]+ve[i][j-1]-ve[i-1][j-1];</span><br><span class="line">		&#125;</span><br><span class="line">		//把每个格子都置为1</span><br><span class="line">        for(int i=1;i&lt;=n;i++)</span><br><span class="line">            for(int j=1;j&lt;=m;j++)&#123;</span><br><span class="line">                ve[i][j]=min(1,ve[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        for(int i=1;i&lt;=n;i++)</span><br><span class="line">            for(int j=1;j&lt;=m;j++)&#123;</span><br><span class="line">                ve[i][j]+=ve[i-1][j]+ve[i][j-1]-ve[i-1][j-1];</span><br><span class="line">            &#125;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;q);</span><br><span class="line">        while(q--)&#123;</span><br><span class="line">            scanf(&quot;%d%d%d%d&quot;,&amp;x1,&amp;y1,&amp;x2,&amp;y2);</span><br><span class="line">            int t=ve[x2][y2]-ve[x2][y1-1]-ve[x1-1][y2]+ve[x1-1][y1-1];</span><br><span class="line">            if(t==(x2-x1+1)*(y2-y1+1)) cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;</span><br><span class="line">            else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>集训</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心与二分</title>
    <url>/posts/8fb3f0eb.html</url>
    <content><![CDATA[<blockquote>
<p>被虐惨了，各种调试与超时或者看不懂题🐷</p>
</blockquote>
<h2 id="Strange-fuction"><a href="#Strange-fuction" class="headerlink" title="Strange fuction"></a>Strange fuction</h2><blockquote>
<p>Now, here is a fuction:<br>F(x) = 6 <em> x^7+8</em>x^6+7<em>x^3+5</em>x^2-y*x (0 &lt;= x &lt;=100)<br>Can you find the minimum value when x is between 0 and 100.</p>
<p><strong>Input</strong></p>
<p>The first line of the input contains an integer T(1&lt;=T&lt;=100) which means the number of test cases. Then T lines follow, each line has only one real numbers Y.(0 &lt; Y &lt;1e10)</p>
<p><strong>Output</strong></p>
<p>Just the minimum value (accurate up to 4 decimal places),when x is between 0 and 100.</p>
<p><strong>Sample Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;2</span><br><span class="line">&gt;100</span><br><span class="line">&gt;200</span><br></pre></td></tr></table></figure>
<p><strong>Sample Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;-74.4291</span><br><span class="line">&gt;-178.8534</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>做了这道题我终于相信ACM和高中数学紧密相连，因为是打代码，我就没往导数的方向去想，一搜题解看到导数俩字我瞬间醍醐灌顶，行如流水代码出来🐶</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI acos(-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="type">double</span> y;</span><br><span class="line"><span class="type">double</span> <span class="title function_">dao</span><span class="params">(<span class="type">double</span> x)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">42</span>*<span class="built_in">pow</span>(x,<span class="number">6.0</span>)+<span class="number">48</span>*<span class="built_in">pow</span>(x,<span class="number">5.0</span>)+<span class="number">21</span>*<span class="built_in">pow</span>(x,<span class="number">2.0</span>)+<span class="number">10</span>*x-y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> <span class="title function_">f</span><span class="params">(<span class="type">double</span> x)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">6</span>*<span class="built_in">pow</span>(x,<span class="number">7</span>)+<span class="number">8</span>*<span class="built_in">pow</span>(x,<span class="number">6</span>)+<span class="number">7</span>*<span class="built_in">pow</span>(x,<span class="number">3</span>)+<span class="number">5</span>*<span class="built_in">pow</span>(x,<span class="number">2</span>)-x*y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;y);</span><br><span class="line">		<span class="type">double</span> l,r,mid;</span><br><span class="line">		l=<span class="number">0</span>; r=<span class="number">100</span>;</span><br><span class="line">		<span class="keyword">while</span>(r-l&gt;=eps)&#123;</span><br><span class="line">			mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span>(dao(mid)&gt;<span class="number">0</span>) r=mid;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(dao(mid)&lt;<span class="number">0</span>) l=mid;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%.4f\n&quot;</span>,f(mid));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Best-Cow-Line"><a href="#Best-Cow-Line" class="headerlink" title="Best Cow Line"></a>Best Cow Line</h2><p>读不懂题的一道题，其实很简单，但是我就是没读懂意思，它的顺序更换规则只能改变第一个和最后一个，其实是一道比较水的题目，我要吐槽的是刚开始我想锻炼一下数据结构，用双端队列来做了，还用了迭代器，最后交后直接给我来个编译错误，我<em>，喵的，我*</em>写了这么久你t喵的不能使用迭代器，k！最后还是换成了字符数组来做</p>
<h3 id="CODE-1"><a href="#CODE-1" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI acos(-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="type">int</span> n; <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="type">char</span> ch[n+<span class="number">10</span>];</span><br><span class="line">	<span class="built_in">string</span> ans;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;ch[i];</span><br><span class="line">	<span class="type">int</span> p1=<span class="number">1</span>,p2=n;</span><br><span class="line">	<span class="keyword">while</span>(p2&gt;=p1)&#123;</span><br><span class="line">		<span class="keyword">if</span>(ch[p1]&lt;ch[p2])&#123;</span><br><span class="line">			ans+=ch[p1];</span><br><span class="line">			p1++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(ch[p1]&gt;ch[p2])&#123;</span><br><span class="line">			ans+=ch[p2];</span><br><span class="line">			p2--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(ch[p1]==ch[p2])&#123;</span><br><span class="line">			<span class="type">int</span> it1=p1,it2=p2;</span><br><span class="line">			<span class="keyword">while</span>(ch[it1]==ch[it2]&amp;&amp;it2&gt;it1)&#123;</span><br><span class="line">				it1++; it2--;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(ch[it1]&gt;=ch[it2])&#123;</span><br><span class="line">				ans+=ch[p2];</span><br><span class="line">				p2--;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(ch[it1]&lt;ch[it2])&#123;</span><br><span class="line">				ans+=ch[p1];</span><br><span class="line">				p1++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> cnt=<span class="number">1</span>,len=ans.size();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(cnt%<span class="number">80</span>==<span class="number">0</span>) <span class="built_in">cout</span>&lt;&lt;ans[i]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;ans[i];</span><br><span class="line">		cnt++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="The-Frog’s-Games"><a href="#The-Frog’s-Games" class="headerlink" title="The Frog’s Games"></a>The Frog’s Games</h2><blockquote>
<p>The annual Games in frogs’ kingdom started again. The most famous game is the Ironfrog Triathlon. One test in the Ironfrog Triathlon is jumping. This project requires the frog athletes to jump over the river. The width of the river is L (1&lt;= L &lt;= 1000000000). There are n (0&lt;= n &lt;= 500000) stones lined up in a straight line from one side to the other side of the river. The frogs can only jump through the river, but they can land on the stones. If they fall into the river, they<br>are out. The frogs was asked to jump at most m (1&lt;= m &lt;= n+1) times. Now the frogs want to know if they want to jump across the river, at least what ability should they have. (That is the frog’s longest jump distance).</p>
<p><strong>Input</strong></p>
<p>The input contains several cases. The first line of each case contains three positive integer L, n, and m.<br>Then n lines follow. Each stands for the distance from the starting banks to the nth stone, two stone appear in one place is impossible.</p>
<p><strong>Output</strong></p>
<p>For each case, output a integer standing for the frog’s ability at least they should have.</p>
<p><strong>Sample Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;6 1 2</span><br><span class="line">&gt;2</span><br><span class="line">&gt;25 3 3</span><br><span class="line">&gt;11 </span><br><span class="line">&gt;2</span><br><span class="line">&gt;18</span><br></pre></td></tr></table></figure>
<p><strong>Sample Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;4</span><br><span class="line">&gt;11</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>青蛙过河，给你河宽，石头数以及每一个石头离河岸的距离，跳的步数，问青蛙每次最少跳几米才能不掉进河里且安全过岸，典型二分，大致估算复杂度NlogN，不会超时，这里难的其实是怎么判断当前检测的距离是否满足，说白了就是青蛙必须跳到最远能跳到的石头，这样才能保证可能能跳到对面，怎么解决跳到最远能跳到的石头呢？可以用一个pre记录上一次所在的石头位置，然后枚举石头距离，如果当前石头距离上一次位置距离小于等于你的最远弹跳距离的话，就把当前石头位置往后移一个，那么最后出来循环当前石头距离上次驻留位置距离一定是大于最远弹跳距离的，再把石头位置往前移动一个就达到了最远能跳到的距离，<code>二分检查经常碰到这种情况，一定要知道怎么解决</code>。</p>
<h3 id="CODE-2"><a href="#CODE-2" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI acos(-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> d[N];</span><br><span class="line"><span class="type">int</span> L,n,m;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> mid)</span>&#123;</span><br><span class="line">	<span class="type">int</span> pos=<span class="number">0</span>,pre=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="keyword">while</span>(pos&lt;=n+<span class="number">1</span>&amp;&amp;d[pos]-d[pre]&lt;=mid) pos++;</span><br><span class="line">		pos--;</span><br><span class="line">		pre=pos;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(pos&gt;=n+<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;L&gt;&gt;n&gt;&gt;m)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;d[i];</span><br><span class="line">		d[n+<span class="number">1</span>]=L;</span><br><span class="line">		sort(d+<span class="number">1</span>,d+<span class="number">1</span>+n);</span><br><span class="line">		<span class="type">int</span> l=<span class="number">0</span>,r=L,mid,ans;</span><br><span class="line">		<span class="keyword">while</span>(r&gt;=l)&#123;</span><br><span class="line">			mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(check(mid))&#123;</span><br><span class="line">				ans=mid;</span><br><span class="line">				r=mid<span class="number">-1</span>;</span><br><span class="line">			&#125; </span><br><span class="line">			<span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="湫湫系列故事——消灭兔子"><a href="#湫湫系列故事——消灭兔子" class="headerlink" title="湫湫系列故事——消灭兔子"></a>湫湫系列故事——消灭兔子</h2><blockquote>
<p>湫湫减肥<br>　　越减越肥！</p>
<p>最近，减肥失败的湫湫为发泄心中郁闷，在玩一个消灭免子的游戏。<br>　　游戏规则很简单，用箭杀死免子即可。<br>　　箭是一种消耗品，已知有M种不同类型的箭可以选择，并且每种箭都会对兔子造成伤害，对应的伤害值分别为Di（1 &lt;= i &lt;= M），每种箭需要一定的QQ币购买。<br>　　假设每种箭只能使用一次，每只免子也只能被射一次，请计算要消灭地图上的所有兔子最少需要的QQ币。</p>
<p><strong>Input</strong></p>
<p>输入数据有多组，每组数据有四行；<br>第一行有两个整数N，M（1 &lt;= N, M &lt;= 100000），分别表示兔子的个数和箭的种类；<br>第二行有N个正整数，分别表示兔子的血量Bi（1 &lt;= i &lt;= N）；<br>第三行有M个正整数，表示每把箭所能造成的伤害值Di（1 &lt;= i &lt;= M）；<br>第四行有M个正整数，表示每把箭需要花费的QQ币Pi（1 &lt;= i &lt;= M）。</p>
<p>特别说明：<br>1、当箭的伤害值大于等于兔子的血量时，就能将兔子杀死；<br>2、血量Bi，箭的伤害值Di，箭的价格Pi，均小于等于100000。</p>
<p><strong>Output</strong></p>
<p>如果不能杀死所有兔子，请输出”No”，否则，请输出最少的QQ币数，每组输出一行。</p>
<p><strong>Sample Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;3 3</span><br><span class="line">&gt;1 2 3</span><br><span class="line">&gt;2 3 4</span><br><span class="line">&gt;1 2 3</span><br><span class="line">&gt;3 4</span><br><span class="line">&gt;1 2 3</span><br><span class="line">&gt;1 2 3 4</span><br><span class="line">&gt;1 2 3 1</span><br></pre></td></tr></table></figure>
<p><strong>Sample Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;6</span><br><span class="line">&gt;4</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>做这道题就只需要知道一点，杀一只兔子，我们应该选择伤害足够的箭里面消耗最小的，我们把兔子按照血量从大到小排序，箭按伤害从大到小排序，然后枚举兔子血量，去箭里面找到能够杀死这只兔子的所有箭，去里面找到耗费最小的，然后累加耗费就行了，做着做着就发现这用到了优先队列<del>不用优先队列还超时</del>，优先队列用来装每次枚举兔子时可以杀死这只兔子的所有箭，然后给优先队列进行一次比较运算符重载就行了</p>
<h3 id="CODE-3"><a href="#CODE-3" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI acos(-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> d[N];</span><br><span class="line"><span class="type">int</span> L,n,m;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> mid)</span>&#123;</span><br><span class="line">	<span class="type">int</span> pos=<span class="number">0</span>,pre=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="keyword">while</span>(pos&lt;=n+<span class="number">1</span>&amp;&amp;d[pos]-d[pre]&lt;=mid) pos++;</span><br><span class="line">		pos--;</span><br><span class="line">		pre=pos;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(pos&gt;=n+<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;L&gt;&gt;n&gt;&gt;m)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;d[i];</span><br><span class="line">		d[n+<span class="number">1</span>]=L;</span><br><span class="line">		sort(d+<span class="number">1</span>,d+<span class="number">1</span>+n);</span><br><span class="line">		<span class="type">int</span> l=<span class="number">0</span>,r=L,mid,ans;</span><br><span class="line">		<span class="keyword">while</span>(r&gt;=l)&#123;</span><br><span class="line">			mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(check(mid))&#123;</span><br><span class="line">				ans=mid;</span><br><span class="line">				r=mid<span class="number">-1</span>;</span><br><span class="line">			&#125; </span><br><span class="line">			<span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Can-you-find-it"><a href="#Can-you-find-it" class="headerlink" title="Can you find it?"></a>Can you find it?</h2><blockquote>
<p>Give you three sequences of numbers A, B, C, then we give you a number X. Now you need to calculate if you can find the three numbers Ai, Bj, Ck, which satisfy the formula Ai+Bj+Ck = X.</p>
<p><strong>Input</strong></p>
<p>There are many cases. Every data case is described as followed: In the first line there are three integers L, N, M, in the second line there are L integers represent the sequence A, in the third line there are N integers represent the sequences B, in the forth line there are M integers represent the sequence C. In the fifth line there is an integer S represents there are S integers X to be calculated. 1&lt;=L, N, M&lt;=500, 1&lt;=S&lt;=1000. all the integers are 32-integers.</p>
<p><strong>Output</strong></p>
<p>For each case, firstly you have to print the case number as the form “Case d:”, then for the S queries, you calculate if the formula can be satisfied or not. If satisfied, you print “YES”, otherwise print “NO”.</p>
<p><strong>Sample Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;3 3 3</span><br><span class="line">&gt;1 2 3</span><br><span class="line">&gt;1 2 3</span><br><span class="line">&gt;1 2 3</span><br><span class="line">&gt;3</span><br><span class="line">&gt;1</span><br><span class="line">&gt;4</span><br><span class="line">&gt;10</span><br></pre></td></tr></table></figure>
<p><strong>Sample Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;Case 1:</span><br><span class="line">&gt;NO</span><br><span class="line">&gt;YES</span><br><span class="line">&gt;NO</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h2><p>题意比较好理解，给你三组序列数从这三组序列里随便挑三个数求满足式子所有做法数量，很好想到的是加俩序列，然后在第三组序列里二分找K-a[i]-b[i]，高高兴兴写好代码，交上去超时了。。。后来想了很久感觉没办法再优化了，没想到正解是二分K-c[i]，用一个新数组存ab数组的组合，再在新数组里面二分找K-c[i]，这样好处就是二分的数组变长了，复杂度虽然还是nlogn，但是n却变小了（logn虽然变大了，但是因为是log级别几乎没影响）。真是巧妙</p>
<h3 id="CODE-4"><a href="#CODE-4" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e3</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> a[MAXN],b[MAXN],c[MAXN],d[MAXN],x[<span class="number">250010</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> 	<span class="type">int</span> L,N,M,kase=<span class="number">0</span>;</span><br><span class="line"> 	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;L&gt;&gt;N&gt;&gt;M)&#123;</span><br><span class="line"> 		<span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">	 	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=L;i++) <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++) <span class="built_in">cin</span>&gt;&gt;b[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=M;i++) <span class="built_in">cin</span>&gt;&gt;c[i];</span><br><span class="line">		<span class="type">int</span> S; <span class="built_in">cin</span>&gt;&gt;S;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=S;i++) <span class="built_in">cin</span>&gt;&gt;d[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=L;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=N;j++)&#123;</span><br><span class="line">				x[++cnt]=a[i]+b[j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		sort(x+<span class="number">1</span>,x+<span class="number">1</span>+cnt);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Case &quot;</span>&lt;&lt;++kase&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=S;k++)&#123;</span><br><span class="line">			<span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=M;i++)&#123;</span><br><span class="line">				<span class="type">int</span> temp=d[k]-c[i];</span><br><span class="line"><span class="comment">//				cout&lt;&lt;temp&lt;&lt;endl;</span></span><br><span class="line">				<span class="type">int</span> id=lower_bound(x+<span class="number">1</span>,x+<span class="number">1</span>+cnt,temp)-x;</span><br><span class="line">				<span class="keyword">if</span>(id!=cnt+<span class="number">1</span>&amp;&amp;x[id]==temp)&#123;</span><br><span class="line">					flag=<span class="number">1</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(flag) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="Aggressive-cows"><a href="#Aggressive-cows" class="headerlink" title="Aggressive cows"></a>Aggressive cows</h2><blockquote>
<p>Farmer John has built a new long barn, with N (2 &lt;= N &lt;= 100,000) stalls. The stalls are located along a straight line at positions x1,…,xN (0 &lt;= xi &lt;= 1,000,000,000).</p>
<p>His C (2 &lt;= C &lt;= N) cows don’t like this barn layout and become aggressive towards each other once put into a stall. To prevent the cows from hurting each other, FJ want to assign the cows to the stalls, such that the minimum distance between any two of them is as large as possible. What is the largest minimum distance?</p>
<p><strong>Input</strong></p>
<p>* Line 1: Two space-separated integers: N and C</p>
<p>* Lines 2..N+1: Line i+1 contains an integer stall location, xi</p>
<p><strong>Output</strong></p>
<p>* Line 1: One integer: the largest minimum distance</p>
<p><strong>Sample Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;5 3</span><br><span class="line">&gt;1</span><br><span class="line">&gt;2</span><br><span class="line">&gt;8</span><br><span class="line">&gt;4</span><br><span class="line">&gt;9</span><br></pre></td></tr></table></figure>
<p><strong>Sample Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;3</span><br></pre></td></tr></table></figure>
<p><strong>Hint</strong></p>
<p>OUTPUT DETAILS:</p>
<p>FJ can put his 3 cows in the stalls at positions 1, 4 and 8, resulting in a minimum distance of 3.</p>
<p>Huge input data,scanf is recommended.</p>
</blockquote>
<h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>最简单的一道二分题，却放在了最后一题。。。</p>
<h3 id="CODE-5"><a href="#CODE-5" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI acos(-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> N,C;</span><br><span class="line"><span class="type">int</span> v[MAXN];</span><br><span class="line"><span class="type">int</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> mid)</span>&#123;</span><br><span class="line">	<span class="type">int</span> pre=<span class="number">1</span>,cnt=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=N;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(v[i]-v[pre]&gt;=mid)&#123;</span><br><span class="line">			pre=i;</span><br><span class="line">			cnt++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(cnt==C) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;N&gt;&gt;C;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++) <span class="built_in">cin</span>&gt;&gt;v[i];</span><br><span class="line">	sort(v+<span class="number">1</span>,v+<span class="number">1</span>+N);</span><br><span class="line">	<span class="type">int</span> l=<span class="number">0</span>,r=v[N],mid,ans;</span><br><span class="line">	<span class="keyword">while</span>(r&gt;=l)&#123;</span><br><span class="line">		mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(check(mid))&#123;</span><br><span class="line">			ans=mid;</span><br><span class="line">			l=mid+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Radar-Installation"><a href="#Radar-Installation" class="headerlink" title="Radar Installation"></a>Radar Installation</h2><blockquote>
<p>Assume the coasting is an infinite straight line. Land is in one side of coasting, sea in the other. Each small island is a point locating in the sea side. And any radar installation, locating on the coasting, can only cover d distance, so an island in the sea can be covered by a radius installation, if the distance between them is at most d.</p>
<p>We use Cartesian coordinate system, defining the coasting is the x-axis. The sea side is above x-axis, and the land side below. Given the position of each island in the sea, and given the distance of the coverage of the radar installation, your task is to write a program to find the minimal number of radar installations to cover all the islands. Note that the position of an island is represented by its x-y coordinates.</p>
</blockquote>
<p><img src="https://vj.z180.cn/f6ffe515205096387436c13c7449b0ed?v=1594806647" alt=""></p>
<blockquote>
<p><strong>Input</strong></p>
<p>The input consists of several test cases. The first line of each case contains two integers n (1&lt;=n&lt;=1000) and d, where n is the number of islands in the sea and d is the distance of coverage of the radar installation. This is followed by n lines each containing two integers representing the coordinate of the position of each island. Then a blank line follows to separate the cases.</p>
<p>The input is terminated by a line containing pair of zeros</p>
<p><strong>Output</strong></p>
<p>For each test case output one line consisting of the test case number followed by the minimal number of radar installations needed. “-1” installation means no solution for that case.</p>
<p><strong>Sample Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 2</span><br><span class="line">1 2</span><br><span class="line">-3 1</span><br><span class="line">2 1</span><br><span class="line"></span><br><span class="line">1 2</span><br><span class="line">0 2</span><br><span class="line"></span><br><span class="line">0 0</span><br></pre></td></tr></table></figure>
<p><strong>Sample Output</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Case <span class="number">1</span>: <span class="number">2</span></span><br><span class="line">Case <span class="number">2</span>: <span class="number">1</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>膜拜岑大佬</p>
<h3 id="CODE-6"><a href="#CODE-6" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> n,d,maxy,cnt,sum;</span><br><span class="line"><span class="type">double</span> lastx,newx;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span> </span><br><span class="line">	<span class="type">int</span> x,y; </span><br><span class="line">&#125;nod[maxn]; </span><br><span class="line"><span class="type">bool</span> <span class="title function_">cmp</span><span class="params">(node a,node b)</span>&#123; <span class="comment">//因为习惯是从左往右看，因此把横坐标小的放到前面（当然你想从右往左 看也可以，但是后面就需要改动一下，把能让点在边界上的左圆心作为推断的圆心就可以）  </span></span><br><span class="line">	<span class="keyword">if</span>(a.x!=b.x) <span class="keyword">return</span> a.x&lt;b.x;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> a.y&gt;b.y;<span class="comment">//这个让纵坐标小的在前面也可以，不写也可以。不写的话就需要把上 一条的if条件去掉，不然会RE。让不让纵坐标排序都是习惯问题，在此题中不是关键。 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123; </span><br><span class="line">	cnt=<span class="number">1</span>; </span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;d)&#123; <span class="comment">//有n个岛屿，雷达的半径为d </span></span><br><span class="line">		<span class="keyword">if</span>(n==<span class="number">0</span> &amp;&amp; d==<span class="number">0</span>) <span class="keyword">break</span>; </span><br><span class="line">		maxy=<span class="number">-1</span>; sum=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123; </span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;nod[i].x&gt;&gt;nod[i].y; </span><br><span class="line">			<span class="keyword">if</span>(nod[i].y&gt;maxy) maxy=nod[i].y;</span><br><span class="line">		&#125;</span><br><span class="line">		sort(nod,nod+n,cmp);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Case &quot;</span>&lt;&lt;cnt&lt;&lt;<span class="string">&quot;: &quot;</span>;</span><br><span class="line">		cnt++;</span><br><span class="line">		<span class="keyword">if</span>(maxy&gt;d) <span class="comment">//如果有岛屿到x轴的距离比d大，那么一定不能让所有岛屿都在雷达范围中</span></span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			lastx=nod[<span class="number">0</span>].x+<span class="built_in">sqrt</span>(d*d-nod[<span class="number">0</span>].y*nod[<span class="number">0</span>].y); <span class="comment">//老圆心的横坐标 </span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">				newx=nod[i].x+<span class="built_in">sqrt</span>(d*d-nod[i].y*nod[i].y); <span class="comment">//新圆心的横坐标 </span></span><br><span class="line">				<span class="keyword">if</span>(newx&lt;lastx) <span class="comment">//新圆心横坐标在老圆心横坐标左边 </span></span><br><span class="line">					lastx=newx; <span class="comment">//优化上一个圆的圆心坐标 </span></span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">sqrt</span>((nod[i].x-lastx)*(nod[i].x- lastx)+nod[i].y*nod[i].y)&gt;d)&#123;<span class="comment">//如果新圆心在老圆心右边，而且该岛屿到老圆心的距离比d还大，说 明需要增加一个雷达 </span></span><br><span class="line">					lastx=newx; <span class="comment">//更新老圆心的坐标 </span></span><br><span class="line">					sum++; <span class="comment">//雷达个数增加 </span></span><br><span class="line">				&#125; </span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>集训</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈矩阵快速幂</title>
    <url>/posts/a28e20bb.html</url>
    <content><![CDATA[<blockquote>
<p>集训开始了对矩阵快速幂的讲解，但是讲解的非常不好，基本没讲，这导致我这个之前就不知道矩阵快速幂的蒟蒻不得不自己乖乖的去网上查资料学习，找到了两个比较不错的视频讲解，具体可以看<strong>清单</strong>里面的<strong>转载</strong>，我来记录一下矩阵快速幂的基本用法🐷</p>
</blockquote>
<h2 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h2><p>学习过线性代数或者离散数学的应该都知道矩阵之间的乘法怎么做，知道的可以跳过，矩阵相乘有一个前提条件，就是前一个矩阵的列数必须等于后一个矩阵的行数两个矩阵才能做乘法运算，这是因为矩阵是不满足交换律的，他们相乘得到的矩阵的元素等于这个元素所在的行对应第一个矩阵的行元素依次乘以这个得到的矩阵元素列数对应第二个矩阵的列元素，很绕口，举个例子，假如两个矩阵相乘后得到了新的矩阵，这个矩阵的第一个元素是在第一行第一列对吧，那么这个元素就是第一个矩阵的第一行和第二个矩阵的第二列元素依次相乘再累加的结果，这样你就知道为什么第一个矩阵的列数必须和第二个矩阵行数相同了吧。</p>
<p>那在纸上你肯定会算了，怎么把它转化成代码呢？</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mat</span>&#123;</span></span><br><span class="line">	ll m[<span class="number">20</span>][<span class="number">20</span>]; <span class="comment">//定义了一个20*20的矩阵</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> n;<span class="comment">//n为相乘的矩阵的维数，一般长和宽是相同的</span></span><br><span class="line">mat operator * (mat a,mat b)&#123; <span class="comment">//重载了*运算符，使得两个结构体可以做乘法</span></span><br><span class="line">	mat ans;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">			ll x=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line">				x+=a.m[i][k]*b.m[k][j]%MOD;</span><br><span class="line">			&#125;</span><br><span class="line">			ans.m[i][j]=x;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans; <span class="comment">//ans储存结果</span></span><br><span class="line">&#125;</span><br><span class="line">mat <span class="title function_">mul</span><span class="params">(mat a,mat b)</span>&#123; <span class="comment">//也可以写一个相乘的函数和重载效果一样</span></span><br><span class="line">    mat ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">			ll x=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>; k&lt;n; k++)&#123;</span><br><span class="line">            	x=(x+a.m[i][k]*b.m[k][j]%MOD)%MOD;</span><br><span class="line">			&#125;</span><br><span class="line">			ans.m[i][j]=x;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h2><p>OK，知道了矩阵乘法，我们就可以开始矩阵快速幂的学习了，加入给你了一个矩阵让你算这个矩阵的N次幂，你怎么算呢？一个一个乘吗？那时间复杂度就是O(n)了，有没有办法降一下呢？学了快速幂的你一定会说可以的，快速幂不仅仅限制于实数上的乘法，它是广义的！来看看广义快速幂：</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/Sucai/9.png" alt=""></p>
<p>很明显矩阵的乘法也是满足广义快速幂的要求的，而矩阵快速幂的幺元其实就是单位矩阵也就是左对角线为1其他全为0的矩阵，这样的单位矩阵乘以任何矩阵都不会改变这个矩阵结果，其意义就相当于实数运算中的“1”。明白了这个就可以直接上代码了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mat <span class="title function_">mul</span><span class="params">(mat a,mat b)</span>&#123; <span class="comment">//自定义矩阵相乘函数</span></span><br><span class="line">    mat ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">			ll x=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>; k&lt;n; k++)&#123;</span><br><span class="line">            	x=(x+a.m[i][k]*b.m[k][j]%MOD)%MOD;</span><br><span class="line">			&#125;</span><br><span class="line">			ans.m[i][j]=x;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">mat <span class="title function_">ksm</span><span class="params">(mat a,ll b)</span>&#123; <span class="comment">//矩阵快速幂</span></span><br><span class="line">    mat ans;</span><br><span class="line">    <span class="built_in">memset</span>(ans.m,<span class="number">0</span>,<span class="keyword">sizeof</span> ans.m); <span class="comment">//定义矩阵快速幂的幺元</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) ans.m[i][i]=<span class="number">1</span>; <span class="comment">//左对角线都为1</span></span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">    	<span class="keyword">if</span>(n&amp;<span class="number">1</span>) ans=mul(a,ans);</span><br><span class="line">    	a=mul(a,a);</span><br><span class="line">    	b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> ans; <span class="comment">//ans即为这个a矩阵的n次幂</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上操作其实不难理解，仔细想一想很简单的，接下来重点来了！！！</p>
<font color="red" size=4>我学了这个有什么用呢？</font>

<p>难道只是为了解一下矩阵的乘法？当然不是的！！！它可以大大加快递推的速度</p>
<h2 id="加快递推"><a href="#加快递推" class="headerlink" title="加快递推"></a>加快递推</h2><p>什么叫递推？比如十分经典的斐波那契数列，我现在要求你算出第n项是多少，那你肯定要从前往后一步一步算，不可能跳步的，因为后面的结果必须由前面的元素决定！如果你不知道矩阵快速幂，那时间复杂度是O(N)的，假如我就很难为你，把数据量开到1e9，绝对不能单纯的递推了对吧，这时我们的矩阵快速幂就派上用场了，我们可以定义这样的一个矩阵：</p>
<p>|   f(n)  |</p>
<p>|  f(n-1)|                     为什么要这样定义呢？因为这一个矩阵包含了推出f(n+1)的所有元素，也就是包含了推出下一个矩阵的所有元素！而这个矩阵也等于：</p>
<p>| f(n-1)+f(n-2) |</p>
<p>|       f(n-1)      |                就是把上面的式子的第一项变成了f(n-1)+f(n-2)结果不变的对吧，而这个式子就等于</p>
<p>| 1 1 |             | f(n-1) |</p>
<p>| 1 0 |  乘上    | f(n-2) |  ，由此我们发现了矩阵前后的关系</p>
<p>|   f(n)  |          | 1 1 |          | f(n-1) |</p>
<p>|  f(n-1)|   =    | 1 0 |    <em>    | f(n-2) |  ，这像不像一个等比数列，an=x </em> an-1，那么我们就可以直接转换成</p>
<p>|   f(n)  |          | 1 1 |(n-2)   |  f(2)    |</p>
<p>|  f(n-1)| =      | 1  0|   *      |  f(1)    | ，式子的第二个矩阵就是需要套用快速幂的矩阵，其n-2次方乘以式子第三个矩阵就是式子第一个矩阵，OK，到这里我们就成功把递推式子转换成为了快速幂的式子，套一下快速幂的模板就解出来了</p>
<p>可以是试着做这道题目： <a href="https://vjudge.net/contest/383066#problem/A">题目链接</a> 密码：hpucam</p>
<h3 id="AC-CODE"><a href="#AC-CODE" class="headerlink" title="AC-CODE"></a>AC-CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD=<span class="number">10000</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mat</span>&#123;</span></span><br><span class="line">	ll m[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">mat operator * (mat a,mat b)&#123;</span><br><span class="line">	mat ans;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">2</span>;j++)&#123;</span><br><span class="line">			ll x=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">2</span>;k++)&#123;</span><br><span class="line">				x+=a.m[i][k]*b.m[k][j]%MOD;</span><br><span class="line">			&#125;</span><br><span class="line">			ans.m[i][j]=x;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">mat <span class="title function_">ksm</span><span class="params">(mat a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">	mat ans;</span><br><span class="line">	<span class="built_in">memset</span>(ans.m,<span class="number">0</span>,<span class="keyword">sizeof</span> ans.m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>;i++) ans.m[i][i]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(b)&#123;</span><br><span class="line">		<span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans=ans*a;</span><br><span class="line">		a=a*a;</span><br><span class="line">		b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n),n!=<span class="number">-1</span>)&#123;</span><br><span class="line">		mat a,ans;</span><br><span class="line">		a.m[<span class="number">1</span>][<span class="number">1</span>]=a.m[<span class="number">1</span>][<span class="number">2</span>]=a.m[<span class="number">2</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">		a.m[<span class="number">2</span>][<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line">		ans=ksm(a,n);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;ans.m[<span class="number">2</span>][<span class="number">1</span>]%MOD&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<font color="red" size=5>终于完了，帮助到您的话留下一句鼓励的话吧👍</font>

<font color="green" size=5>Ending</font>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title>快读快写</title>
    <url>/posts/e38e89eb.html</url>
    <content><![CDATA[<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>一些题目需要读取的数据量十分庞大，很可能读取数据次数高达几十万次，而这时用cin或者scanf时间上就有了一些差距（scanf比cin要快），当输入数据更加庞大，scanf时间上也有些乏力，毕竟有些题目就是考你会不会快读快写，C语言输入输出字符时是要比数字输出的快的，我们可以利用这一点来把数字转化成字符来输出</p>
<p>下面的inline是内联函数的意思，小伙伴可以看 <a href="https://blog.csdn.net/hyqsong/article/details/51857833">https://blog.csdn.net/hyqsong/article/details/51857833</a> 了解一下</p>
<h2 id="快读代码"><a href="#快读代码" class="headerlink" title="快读代码"></a>快读代码</h2><pre><code>inline int read()&#123;
    int x=1,y=0;
    char ch=getchar();
    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;)&#123;
        if(ch==&#39;-&#39;) x=-1; ch=getchar(); //这里的循环是为了避免输入数字之前的空格造成影响
    &#125;
    while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)&#123;
        y=y*10+ch-&#39;0&#39;;
        ch=getchar();
    &#125;
    return x*y;
&#125;
</code></pre><p>需要注意的是每次循环最后都要加一句getchar()</p>
<h2 id="快写代码"><a href="#快写代码" class="headerlink" title="快写代码"></a>快写代码</h2><pre><code>inline void write(int n)&#123;
    if(n&lt;0) putchar(&#39;-&#39;),n*=-1;
    if(n&gt;9) write(n/10);
    putchar(n%10+&#39;0&#39;);
&#125;
</code></pre><p>代码比较好理解，注意puchar()里面的n%10</p>
<blockquote>
<p>制作不易，您的赞助是我最大动力，点击下面的赏，快来赞助我吧</p>
</blockquote>
<p><img src="https://dss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=868635476,2104676212&amp;fm=111&amp;gp=0.jpg" alt=""></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title>快速幂详解</title>
    <url>/posts/3fe565b1.html</url>
    <content><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>先举个例子，比如说算3^6^,你要怎么算，用6个6相乘对不对，那要是3^1000^呢？1000个3相乘，复杂度为O(N)，现在我们这样算，6的二进制是110，所以6=1(2^2^)+1(2^1^)+0(2^0^)，那么3^6^就变成了3^( 1(2^2^)+1(2^1^)+0(2^0^) )=3^(1<em>(2^2^)) </em> 3^(1<em>(2^1^))^ </em> 3^(0*(2^0^))^，这其实就是快速幂的原理，看起来麻烦了对吗？OK，先不看复杂度，先看用代码如何实现，我们可以用一个数来充当3^(1*(2^2^))^、3^(1*(2^1^))^、3^(0*(2^0^))^，在下面的代码中y就是这个变量，不是每一次都要算的，比如3^(0*(2^0^))^=1，乘不乘都一样，那怎么判断呢？我们每次取二进制数的最后一位，要么是0要么是1，如果是0，就不用不用乘，否则就乘，先看代码：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int p(int a,int b)&#123;</span><br><span class="line">  int t,y;  //定义两个变量，t起到类乘的作用，而y则就是每一次要乘的数</span><br><span class="line">  t=1; y=a;  //注意一定要初始化</span><br><span class="line">  while (b!=0)&#123;  //只要二进制位数还没有遍历完就还要循环</span><br><span class="line">    if (b&amp;1==1) t=t*y; //y就是幂的形式a^(2^0),a^(2^1),a^(2^2),a^(2^3)</span><br><span class="line">    y=y*y;  //</span><br><span class="line">    b=b&gt;&gt;1;  //每次要舍去二进制数的最后一位</span><br><span class="line">  &#125;</span><br><span class="line">  return t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这就是原理是不是很简单呢（qwq）</p>
<h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>也许你会疑惑明明步骤变多了怎么会快了呢？这只是你的直观感觉，代码是变长了，但次数确确实实变少了，我们来看上面的代码，复杂度主要就在于循环上，循环的条件是b!=0，而每次不都要除以2，设循环次数为x，那么2^x=b，x=log(2,b)，循环里面运算次数最多为3次，那么复杂度最大就是3log(2,N)，3是常数，当数值很大时，可以省略，复杂度为log(2,N)，那么假如算2^10000，常规需要10000次运算，而快速幂只需要14*3次运算，是不是很神奇呢？</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>学习了这个算法有什么用呢？实际上快速幂是一个非常常用的算法，它经常与其他算法一起混用，一般来说快速幂适用于求一个指数非常高的数对某个数的余数，例如：题目：<br>现在星期日，问：再过2^10000^天后星期几？学习了快速幂这种题就是送分题了，每次对7取余就行了</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>附上链接，有兴趣的小伙伴可以前往相关网站做一下</p>
<pre><code>Fermat&#39;s theorem states that for any prime number p and for any integer a &gt; 1, ap = a (mod p). That is, if we raise a to the pth power and divide by p, the remainder is a. Some (but not very many) non-prime values of p, known as base-a pseudoprimes, have this property for some a. (And some, known as Carmichael Numbers, are base-a pseudoprimes for all a.)

Given 2 &lt; p ≤ 1000000000 and 1 &lt; a &lt; p, determine whether or not p is a base-a pseudoprime.
</code></pre><p>Input</p>
<pre><code>Input contains several test cases followed by a line containing &quot;0 0&quot;. Each test case consists of a line containing p and a.
</code></pre><p>Output</p>
<pre><code>For each test case, output &quot;yes&quot; if p is a base-a pseudoprime; otherwise output &quot;no&quot;.
</code></pre><p>Sample Input</p>
<pre><code>3 2
10 3
341 2
341 3
1105 2
1105 3
0 0
</code></pre><p>Sample Output</p>
<pre><code>no
no
yes
no
yes
yes
</code></pre><p>AC代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
long long p(long long a,long long b)&#123;
    long long t,y,n=b;
    t=1; y=a;
    while (b!=0)&#123;
        if (b&amp;1==1) t=t*y%n;
        y=y*y%n;
        b=b&gt;&gt;1;
    &#125;    
    return t;
&#125;
int main()
&#123;
    long long m,n;
    while(scanf(&quot;%lld %lld&quot;,&amp;m,&amp;n)!=EOF)&#123;
        if(m==0&amp;&amp;n==0) break;
        int flag=0;
        for(int i=2;i*i&lt;=m;i++)&#123;
            if(m%i==0)&#123;
                flag=1;
                break;
            &#125;
        &#125;
        if(flag==0) cout&lt;&lt;&quot;no&quot;&lt;&lt;endl;
        else&#123;
            if(p(n,m)==n) cout&lt;&lt;&quot;yes&quot;&lt;&lt;endl;
            else cout&lt;&lt;&quot;no&quot;&lt;&lt;endl;
        &#125;
    &#125;
&#125;
</code></pre><p>地址：<a href="http://poj.org/problem?id=3641">http://poj.org/problem?id=3641</a></p>
<p>Rightmost Digit </p>
<p>Given a positive integer N, you should output the most right digit of N^N.</p>
<p>Input</p>
<pre><code>The input contains several test cases. The first line of the input is a single integer T which is the number of test cases. T test cases follow.
Each test case contains a single positive integer N(1&lt;=N&lt;=1,000,000,000).
</code></pre><p>Output<br>    For each test case, you should output the rightmost digit of N^N.<br>Sample Input</p>
<pre><code>2
3
4
</code></pre><p>Sample Output</p>
<pre><code>7
6
</code></pre><p>​<br>​      </p>
<p>Hint</p>
<pre><code>In the first case, 3 * 3 * 3 = 27, so the rightmost digit is 7.
In the second case, 4 * 4 * 4 * 4 = 256, so the rightmost digit is 6.
</code></pre><p>AC代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
long long p(long long a)&#123;
    long long t,y;
    t=1; y=a;
    while(a!=0)&#123;
        if (a&amp;1==1) t=t*y%10;
        y=y*y%10; 
        a=a&gt;&gt;1;
    &#125;
    return t;
&#125;
int main()
&#123;
    int t;
    cin&gt;&gt;t;
    while(t--)&#123;
        long long n;
        scanf(&quot;%lld&quot;,&amp;n);
        cout&lt;&lt;p(n)&lt;&lt;endl;
    &#125;
&#125;
</code></pre><p>地址：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1061">http://acm.hdu.edu.cn/showproblem.php?pid=1061</a></p>
<p>小蒜想知道：假设今天是星期日，那么过 aba^bab 天之后是星期几？</p>
<p>输入格式</p>
<p>两个正整数 aaa，bbb，中间用单个空格隔开。0&lt;a≤100,0&lt;b≤100000 &lt; a \le 100, 0 &lt; b \le 100000&lt;a≤100,0&lt;b≤10000。</p>
<p>输出格式</p>
<p>一个字符串，代表过 aba^bab ​天之后是星期几。</p>
<p>其中，Monday 是星期一，Tuesday 是星期二，Wednesday 是星期三，Thursday 是星期四，Friday 是星期五，Saturday 是星期六，Sunday 是星期日。</p>
<p>输出时每行末尾的多余空格，不影响答案正确性</p>
<p>样例输入</p>
<pre><code>3 2000
</code></pre><p>样例输出</p>
<pre><code>Tuesday
</code></pre><p>AC代码</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;math.h&gt;
#include&lt;string.h&gt;
using namespace std;
typedef long long ll;
ll p(ll a,ll b)&#123;
    int t,y;
    t=1; y=a;
    while (b!=0)&#123;
        if (b&amp;1==1) t=t*y%7;
        y=y*y%7; 
        b=b&gt;&gt;1;
    &#125;
    return t;
&#125;
int main()
&#123;
    int a,b;
    cin&gt;&gt;a&gt;&gt;b;
    switch(p(a,b))&#123;
        case 1: printf(&quot;Monday\n&quot;);break;
        case 2: printf(&quot;Tuesday\n&quot;);break;
        case 3: printf(&quot;Wednesday\n&quot;);break;
        case 4: printf(&quot;Thursday\n&quot;);break;
        case 5: printf(&quot;Friday\n&quot;);break;
        case 6: printf(&quot;Saturday \n&quot;);break;
        case 0: printf(&quot;Sunday\n&quot;);break;
    &#125;
&#125;
</code></pre><p>地址：<a href="https://nanti.jisuanke.com/t/T1234">https://nanti.jisuanke.com/t/T1234</a></p>
<blockquote>
<p>制作不易，您的赞助是我最大的动力，留下您的评论，有条件的小伙伴可以打赏2毛钱，谢谢各位老板（owo）</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>基础数学</tag>
      </tags>
  </entry>
  <entry>
    <title>离散化加差分求解</title>
    <url>/posts/aa71e9f5.html</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>Covered Points Count </p>
<p>You are given n</p>
<p>segments on a coordinate line; each endpoint of every segment has integer coordinates. Some segments can degenerate to points. Segments can intersect with each other, be nested in each other or even coincide.</p>
<p>Your task is the following: for every k∈[1..n]<br>, calculate the number of points with integer coordinates such that the number of segments that cover these points equals k. A segment with endpoints li and ri covers point x if and only if li≤x≤ri.</p>
<p>Input</p>
<p>The first line of the input contains one integer n (1≤n≤2⋅105</p>
<p>) — the number of segments.</p>
<p>The next n<br>lines contain segments. The i-th line contains a pair of integers li,ri (0≤li≤ri≤1018) — the endpoints of the i-th segment.</p>
<p>Output</p>
<p>Print n space separated integers cnt1,cnt2,…,cntn, where cnti is equal to the number of points such that the number of segments that cover these points equals to i.</p>
<p>Examples</p>
<p>Input</p>
<p>3</p>
<p>0 3</p>
<p>1 3</p>
<p>3 8</p>
<p>Output</p>
<p>6 2 1 </p>
<p>Input</p>
<p>3</p>
<p>1 3</p>
<p>2 4</p>
<p>5 7</p>
<p>Output</p>
<p>5 2 0 </p>
<p>note</p>
<p>The picture describing the first example:</p>
<p><img src="https://vj.z180.cn/9e2db93c851be80e4482c4512ded4d6b?v=1586670318" alt=""></p>
<p>Points with coordinates [0,4,5,6,7,8] are covered by one segment, points [1,2] are covered by two segments and point [3]</p>
<p>is covered by three segments.</p>
<p>The picture describing the second example:</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly92ai56MTgwLmNuLzllMmRiOTNjODUxYmU4MGU0NDgyYzQ1MTJkZWQ0ZDZi?x-oss-process=image/format,png" alt=""></p>
<p>Points [1,4,5,6,7] are covered by one segment, points [2,3] are covered by two segments and there are no points covered by three segments.</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>题目大意是给一个数n，接下来有n组输入，每次都给一个区间，区间上的每一个值都被覆盖一次，要你输出最后覆盖了1 2 3……次的数的数量</p>
<p>很典型的一道差分题，只不过这道题数据量很大(0≤li≤ri≤1018) ，开不了这么大的数组，但是数据量很小 (1≤n≤2⋅105)，可以使用离散化，用一个数组储存每一次输入的左段点和右端点，然后把该数组进行排序去重，再定义一个新的差分数组进行差分操作，最后对差分数组求前缀和</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxn=2e5+100;</span><br><span class="line">struct node&#123;</span><br><span class="line">	ll x,y;</span><br><span class="line">&#125;p[maxn];用一个数组储存端点值</span><br><span class="line">ll a[maxn&lt;&lt;1],b[maxn],c[maxn];//一个数组储存离散化后的值，一个数组储存差分的值,c数组用来存储最后结果 </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	ios::sync_with_stdio(false);</span><br><span class="line">	int n,tail=0; cin&gt;&gt;n;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;p[i].x&gt;&gt;p[i].y;  //输入左端点和右端点</span><br><span class="line">		a[++tail]=p[i].x;   //存入a数组用来离散化</span><br><span class="line">		a[++tail]=p[i].y+1; </span><br><span class="line">	&#125;</span><br><span class="line">	sort(a+1,a+1+tail);  //排序</span><br><span class="line">	int len=unique(a+1,a+1+tail)-a-1;  //去重</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		int x=lower_bound(a+1,a+1+len,p[i].x)-a;  //在a数组中找到每一组的左端点位置</span><br><span class="line">		int y=lower_bound(a+1,a+1+len,p[i].y+1)-a;  //找右端点的下一个位置</span><br><span class="line">		b[x]++;b[y]--;  //差分数组，左端点++，右端点的下一个位置--</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=1;i&lt;=len;i++)&#123;</span><br><span class="line">		b[i]+=b[i-1];  //求前缀和</span><br><span class="line">		c[b[i]]+=a[i+1]-a[i]; //c数组注意用long long，这里代表着从a[i]开始到a[i+1]都是被染色了b[i]次。</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=1;i&lt;=n;i++) printf(&quot;%lld%c&quot;,c[i],i==n?&#x27;\n&#x27;:&#x27; &#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ok，结束，刚接触真的感觉好抽象</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>离散化差分</tag>
      </tags>
  </entry>
  <entry>
    <title>解决Leancloud流控问题</title>
    <url>/posts/260e182.html</url>
    <content><![CDATA[<blockquote>
文章背景
<p>因为明天要考科目一了，本来是打算明天下午写这篇文章的，可是Acm训练要开始了，所以决定提前写了吧，明天考完直接投入复习算法的学习中🐷哎，魔鬼月要开始了！</p>
</blockquote>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前写过一篇给Leancloud添加自定义邮件回复的文章<a href="https://www.fezhu.top/2020/05/15/Valineyoujian/">Click me</a>，令我自责的是教程有一些问题，因为我也是看别人教程去做的，没想到她的那个教程错了，导致我也跟着错了。。<code>ADMIN_URL</code>这个值不是填博客地址，这个跟邮件回复没有半点关系，不加这个参数也行，这个参数是用来实行自唤醒任务用的，具体看文章吧，在这里跟我教错的网友说一声抱歉</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>Leancloud最近实行了流控: 自唤醒任务是无法唤醒已经休眠的机器的，所以要想任何时候都能收到邮件就需要早上手动唤醒一次机器，接下来交给自唤醒任务就行了，不过每天都手动唤醒也是挺烦的，所以就有大佬站出来了，<a href="https://www.antmoe.com/tags/LeanCloud%E6%B5%81%E6%8E%A7/">原作者</a>，这位大佬直接解决了这个问题，在短时间内众多网友纷纷效仿，Leancloud流控问题彻底解决</p>
<p>首先你要确保你的Leancloud是正常的，如果你的Leancloud是国内版本的，我劝你换成国际版本的，因为国内版本绑定Web域名是需要备案的，而备案有需要服务器，你总不可能一直续费服务器吧，而国际版本是不需要备案直接就能绑定的，而且Leancloud的数据是可以导入导出的，把久的数据导入到国际版本中，花不了多少时间，非常香🤗</p>
<h3 id="绑定Web域名"><a href="#绑定Web域名" class="headerlink" title="绑定Web域名"></a>绑定Web域名</h3><p><a href="https://www.93bok.com/Valine%E8%AF%84%E8%AE%BA%E7%9A%84Web%E7%AE%A1%E7%90%86%E7%95%8C%E9%9D%A2/">参考原文</a></p>
<p>点击<code>云引擎</code>-&gt;<code>设置</code>，找到Web主机域名，这里没有限制，你可以随便填写，一般都是自己博客的字母，比如我的就是fezhu，<code>注意不用加后缀和前面的www</code>！！！</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/20200702205200250.png" alt=""></p>
<blockquote>
改域名作用
<p>当机器休眠时，访问此地址能够唤醒机器</p>
</blockquote>

<p>然后点击上面的添加新变量，前面填ADMIN_URL，后面填Web主机域名，这个Web主机域名有什么用呢？你可以访问这个域名，这个网址就是你的评论后台地址</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/20200702205849784.png" alt=""></p>
<p>打开页面就是这个样子，接下来添加账户名和密码：</p>
<p><img src="https://s1.ax1x.com/2018/11/22/FP0mlQ.png" alt=""> </p>
<p><img src="https://s1.ax1x.com/2018/11/22/FP0uOs.png" alt=""></p>
<p>OK,现在我们使用<code>email</code>字段的邮箱去登陆即可</p>
<p><img src="https://s1.ax1x.com/2018/11/22/FP0lT0.png" alt=""></p>
<p>在这个后台你还能查看删除评论</p>
<h3 id="设置定时任务"><a href="#设置定时任务" class="headerlink" title="设置定时任务"></a>设置定时任务</h3><p>定时任务使用cron表达式设定的<br><br><a href="https://www.cnblogs.com/yanghj010/p/10875151.html">参考文章</a><br><br>首先应该明白UTC时间和北京时间区别：</p>
<blockquote>
<p>协调世界时,又称世界统一时间,世界标准时间,国际协调时间,简称UTC。<br>UTC时间比北京慢8个小时，UTC时间=北京时间-8小时，国际版本用的是UTC时间，所以定时任务要减去8小时，我是设定了三个定时任务，分别填写cron表达式如下：</p>
</blockquote>
<p><code>0 25/0 0-15 * * ?</code>&amp;&amp;<code>0 45/0 0-15 * * ?</code>&amp;&amp;<code>0 5/0 0-15 * * ?</code></p>
<p>这表示从北京时间早上八点开始一直到晚上11点，每小时的5分，25分，45分都执行一次自唤醒，之所以不设成整点是因为，从外部唤醒会有一定延迟</p>
<h3 id="从外部访问后台"><a href="#从外部访问后台" class="headerlink" title="从外部访问后台"></a>从外部访问后台</h3><font color="red" size=4>接下来就是重点内容了</font>

<ol>
<li>鼠标放在右上角，选择 setting</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/blogimg/picbed@latest/2020/05/14/a81f88e80fd7105d7cc3e1844970e8bd.png" alt=""></p>
<ol>
<li>点击 Developer settings。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/blogimg/picbed@latest/2020/05/14/66df62fbc0d51403fcdc8223c4b6ce52.png" alt=""></p>
<ol>
<li>选择<code>Personal access tokens</code>，添加一个新的<code>TOKEN</code>。<br>这个 <code>TOKEN</code> 主要使用来启动 <code>actions</code> 和上传结果用的。<br><br>设置名字为<code>GITHUB_TOKEN</code> , 然后勾选 <code>repo , admin:repo_hook , workflow</code> 等选项，最后点击 <code>Generate token</code> 即可。<br><b>名字请务必使用GITHUB_TOKEN。</b></li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/blogimg/picbed@latest/2020/05/15/23ee2808dce8dab17e06107d1ddaf5d6.png" alt=""></p>
<ol>
<li><p>接下来 FORK 项目。<a href="https://github.com/blogimg/WakeLeanCloud">点击我</a><br>如果觉得好用可以点个赞哦！</p>
</li>
<li><p>成功 FORK 后，进入项目的设置。添加你的 leancloud 的后台地址（也就是评论管理的后台地址）<br><img src="https://cdn.jsdelivr.net/gh/blogimg/picbed@latest/2020/05/14/d15b1fffb681f0dd3b9264ea878bf055.png" alt=""><br>选择 Secrets，添加你的评论后台地址，一定是 Leancloud 的后台地址（环境变量 ADMIN_URL），而不是你的博客地址。</p>
<p><img src="https://cdn.jsdelivr.net/gh/blogimg/picbed@latest/2020/05/14/6c2cd1845116e3d4e4147157d334be19.png" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/blogimg/picbed@latest/2020/05/14/caed66e8408e5a0c91fe446951180f8d.png" alt=""></p>
<div class="note danger">
注意
<p>SITE 的网址应填你的评论管理后台地址，而不是博客地址。</p>
</div>

<p>其中 Name 的名字必须为 SITE，Value 可以是多个后台地址（注意请求头也要写），用英文逗号分隔。不要中中文逗号，不要用中文逗号，不要用中文逗号</p>
</li>
<li><p>接下来对自己的项目点个 star 就能启动了，启动后请切换到 actions，看看是否运行成功。<br>成功那么你就可以关掉了，默认是每天 8:00-24:00 时每 20 分钟运行一次。(GitHub 时间稍有延迟，大概时 2-5 分钟。)</p>
<p><img src="https://cdn.jsdelivr.net/gh/blogimg/HexoStaticFile2@latest/2020/05/25/4736d5905066440617f4a63ecfc70cc1.png" alt=""></p>
</li>
</ol>
<ul>
<li><ul>
<li><p>失败<br>如果你的 GitHub 从来没有用过 actions，那么需要先 “了解”。方法很简单，点击绿色的按钮即可。</p>
<p><img src="https://cdn.jsdelivr.net/gh/blogimg/HexoStaticFile2@latest/2020/05/25/91a79177e21e2a49d28be09cc676ad7a.png" alt=""></p>
<blockquote>
<p>自己点自己的项目是手动执行一次 actions。是为了测试才设计这个功能的哦！<br>并不是不点星这个 actions 就不会运行。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<font color="red" size=4>以上是原作者文章原话，非常详细</font><br>

这里我推荐大家把cron表达式改成`0 0 * * *`，这表示每天八点从外部访问一次你的后台地址，之后就可以交给你的定时任务了，如果过按照默认的设置，每小时都会提交好几次，一天下来都几百个了，不建议用默认设置

>>修改cron方法：修改workflows文件夹中的autoWakeup.yml文件，找到里面的cron表达式改成上述即可

一小时过去了......
<font color="red" size=5>帮助到您就点个赞吧，富豪也可以赞赏我哦🙃</font>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>流控</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown语法</title>
    <url>/posts/f134a8e5.html</url>
    <content><![CDATA[<p><a href="https://www.jianshu.com/p/191d1e21f7ed/">文章链接</a></p>
<h1 id="总结如下"><a href="#总结如下" class="headerlink" title="总结如下"></a>总结如下</h1><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>在想要设置为标题的文字前面加#来表示<br>一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。</p>
<p>注：标准语法一般在#后跟个空格再写文字</p>
<h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><ul>
<li>加粗</li>
</ul>
<p>要加粗的文字左右分别用两个*号包起来</p>
<ul>
<li>斜体</li>
</ul>
<p>要倾斜的文字左右分别用一个*号包起来</p>
<ul>
<li>斜体加粗</li>
</ul>
<p>要倾斜和加粗的文字左右分别用三个*号包起来</p>
<ul>
<li>删除线</li>
</ul>
<p>要加删除线的文字左右分别用两个~~号包起来</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;<br>n个…<br>貌似可以一直加下去，但没神马卵用</p>
<p>效果如下：</p>
<blockquote>
<p>这是引用的内容</p>
<blockquote>
<p>这是引用的内容</p>
<blockquote>
<p>这是引用的内容</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>三个或者三个以上的 - 或者 * 都可以。</p>
<p>实例：</p>
<pre><code>---
----
***
*****
</code></pre><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>语法：</p>
<pre><code>![图片alt](图片地址 &#39;&#39;图片title&#39;&#39;)

图片alt就是显示在图片下面的文字，相当于对图片内容的解释。
图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加
</code></pre><p>上传本地图片直接点击导航栏的图片标志，选择图片即可<br>markdown格式追求的是简单、多平台统一。那么图片的存储就是一个问题，需要用图床，提供统一的外链，这样就不用在不同的平台去处理图片的问题了。才能做到书写一次，各处使用。<br>关于图床的选择我写了一篇文章，对网上存在的各种方法做了总结，需要的朋友可以看看。<br><a href="https://www.jianshu.com/p/ea1eb11db63f">mark图床</a></p>
<h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p>语法：</p>
<pre><code>[超链接名](超链接地址 &quot;超链接title&quot;)
title可加可不加
</code></pre><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>语法：<br>无序列表用 - + * 任何一种都可以</p>
<pre><code>- 列表内容
+ 列表内容
* 列表内容

注意：- + * 跟内容之间都要有一个空格
</code></pre><h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><p>语法：</p>
<p>数字加点</p>
<pre><code>1. 列表内容
2. 列表内容
3. 列表内容

注意：序号跟内容之间要有空格
</code></pre><h2 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h2><p>上一级和下一级之间敲三个空格即可</p>
<p>实例：</p>
<ul>
<li><p>第一级</p>
<ul>
<li><p>第二级</p>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>语法：</p>
<p>表头|表头|表头<br>—-|:—:|—-:<br>内容|内容|内容<br>内容|内容|内容</p>
<p>第二行分割表头和内容。</p>
</li>
<li>有一个就行，为了对齐，多加了几个<br>文字默认居左<br>-两边加：表示文字居中<br>-右边加：表示文字居右<br>注：原生的语法两边都要用 | 包起来。此处省略</li>
</ul>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>姓名</th>
<th style="text-align:center">技能</th>
<th style="text-align:right">排行</th>
</tr>
</thead>
<tbody>
<tr>
<td>刘备</td>
<td style="text-align:center">哭</td>
<td style="text-align:right">大哥</td>
</tr>
<tr>
<td>关羽</td>
<td style="text-align:center">打</td>
<td style="text-align:right">二哥</td>
</tr>
<tr>
<td>张飞</td>
<td style="text-align:center">骂</td>
<td style="text-align:right">三弟</td>
</tr>
</tbody>
</table>
</div>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>语法：</p>
<p>单行代码：代码之间分别用一个反引号包起来</p>
<pre><code>   `代码内容`
</code></pre><p>代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行</p>
<pre><code>(```)
代码...
代码...
代码...
(```)
</code></pre><blockquote>
<p>注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。</p>
<h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2></blockquote>
<pre><code>```flow
st=&gt;start: 开始
op=&gt;operation: My Operation
cond=&gt;condition: Yes or No?
e=&gt;end
st-&gt;op-&gt;cond
cond(yes)-&gt;e
cond(no)-&gt;op
&amp;```
</code></pre><p>实例：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/6860761-9d9524ba31047696.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/751" alt=""></p>
]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>我的第一篇博客</title>
    <url>/posts/d95d7e09.html</url>
    <content><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=38592976&auto=0&height=66"></iframe>

<h1 id="我的第一篇博客"><a href="#我的第一篇博客" class="headerlink" title="我的第一篇博客"></a>我的第一篇博客</h1><!--- more --->
<h2 id="我对博客的态度"><a href="#我对博客的态度" class="headerlink" title="我对博客的态度"></a>我对博客的态度</h2><ul>
<li>每次做题不会的时候上网查总是能看到一群大佬们发布的各种博客文章，布局十分漂亮，我</li>
</ul>
<p>就在想什么时候我也能有一个这样的博客，现在我的愿望实现了，在我看来博客不只是推送</p>
<p>一篇文章这么简单，它也是对生活的一种记录，我不想在我以后工作了或者给别人将述我的</p>
<p>成长经历时，没有实实在在的东西，因为我本人写字不太好看，所以我希望博客能代替日记</p>
<p>陪伴我走下去，希望我能在博客的陪伴下努力生长，虽然现在的我是一只蒟蒻，但几年后的</p>
<p>今天我相信我一定可以成为我想成为的人！  </p>
<h2 id="我对分享的看法"><a href="#我对分享的看法" class="headerlink" title="我对分享的看法"></a>我对分享的看法</h2><ul>
<li>我本人是希望与别人分享一些东西的，无论是知识或是一些平常琐事，虽然我只是一只蒟</li>
</ul>
<p>蒻，我会把一些自己认为有必要记录的东西都写下来，也是对知识的一种巩固吧。</p>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul>
<li>成为像马云那样的有钱人，呸呸！成为一个能养的起自己，照顾好家庭，服务好社会的好公</li>
</ul>
<p>民，顺便成为一个计算机大佬，哈哈！</p>
<h2 id="——"><a href="#——" class="headerlink" title="——"></a>——</h2><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p>【奋斗】(<a href="http://img.08087.cc/uploads/20190819/20/1566217745-WgQljednVf.jpg">http://img.08087.cc/uploads/20190819/20/1566217745-WgQljednVf.jpg</a>)</p>
<p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1585500060586&amp;di=d6ded2e6b4baee6259a036ead70d5111&amp;imgtype=0&amp;src=http%3A%2F%2Fimg.mp.itc.cn%2Fupload%2F20170515%2Fb519a0f765bb45c0b35a98c3f1df8bf1_th.jpg" alt=""></p>
<hr>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>数状数组求逆序对&amp;&amp;二维树状数组</title>
    <url>/posts/142f8d42.html</url>
    <content><![CDATA[<p>参考原文：<a href="https://blog.csdn.net/GodJing007/article/details/81158288"></a></p>
<h1 id="二维树状数组"><a href="#二维树状数组" class="headerlink" title="二维树状数组"></a>二维树状数组</h1><p>我们先来讲讲怎么去表示。<br>数组A[][]的树状数组定义为：</p>
<p>C[x][y] = ∑ a[i][j], 其中，<br>x-lowbit(x) + 1 &lt;= i &lt;= x,<br>y-lowbit(y) + 1 &lt;= j &lt;= y.</p>
<p>例：举个例子来看看C[][]的组成。<br>设原始二维数组为：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A[][]=&#123;&#123;a11,a12,a13,a14,a15,a16,a17,a18,a19&#125;,   </span><br><span class="line">&#123;a21,a22,a23,a24,a25,a26,a27,a28,a29&#125;,   </span><br><span class="line">&#123;a31,a32,a33,a34,a35,a36,a37,a38,a39&#125;，   </span><br><span class="line">&#123;a41,a42,a43,a44,a45,a46,a47,a48,a49&#125;&#125;;</span><br></pre></td></tr></table></figure><br>那么它对应的二维树状数组C[][]呢？</p>
<p>记:<br>B[1]={a11,a11+a12,a13,a11+a12+a13+a14,a15,a15+a16,…} 这是第一行的一维树状数组<br>B[2]={a21,a21+a22,a23,a21+a22+a23+a24,a25,a25+a26,…} 这是第二行的一维树状数组<br>B[3]={a31,a31+a32,a33,a31+a32+a33+a34,a35,a35+a36,…} 这是第三行的一维树状数组<br>B[4]={a41,a41+a42,a43,a41+a42+a43+a44,a45,a45+a46,…} 这是第四行的一维树状数组<br>那么：<br>C[1][1]=a11,C[1][2]=a11+a12,C[1][3]=a13,C[1][4]=a11+a12+a13+a14,c[1][5]=a15,C[1][6]=a15+a16,…<br>这是A[][]第一行的一维树状数组</p>
<p>C[2][1]=a11+a21,C[2][2]=a11+a12+a21+a22,C[2][3]=a13+a23,C[2][4]=a11+a12+a13+a14+a21+a22+a23+a24,<br>C[2][5]=a15+a25,C[2][6]=a15+a16+a25+a26,…<br>这是A[][]数组第一行与第二行相加后的树状数组   </p>
<p>C[3][1]=a31,C[3][2]=a31+a32,C[3][3]=a33,C[3][4]=a31+a32+a33+a34,C[3][5]=a35,C[3][6]=a35+a36,…<br>这是A[][]第三行的一维树状数组   </p>
<p>C[4][1]=a11+a21+a31+a41,C[4][2]=a11+a12+a21+a22+a31+a32+a41+a42,C[4][3]=a13+a23+a33+a43,…<br>这是A[][]数组第一行+第二行+第三行+第四行后的树状数组</p>
<blockquote>
<p>就是每一行都是一个树状数组，以行为元素，整个列也是一个树状数组。<br>（这句话请记住，这个思想会贯穿始终）<br>既然如此，我相信代码也很快就出来了，接下来我就来给出代码，并进行简单的解释。</p>
<h2 id="单点修改"><a href="#单点修改" class="headerlink" title="单点修改"></a>单点修改</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void add(int x,int y,int p)&#123;  </span><br><span class="line">    while(x&lt;=n)&#123;</span><br><span class="line">        for(int i=y;i&lt;=m;i+=lowbit(i))&#123;</span><br><span class="line">            C[x][i]+=p;</span><br><span class="line">        &#125; </span><br><span class="line">        x+=lowbit(x);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>这个根据我刚刚说的两个树状数组（那句贯穿始终的话），就很容易理解了。<br>我们外围循环枚举每一行，内循环在行内进行一维树状数组的单点修改，从而实现二维树状数组的单点修改。</p>
<h2 id="以原点为一个端点的子矩阵和"><a href="#以原点为一个端点的子矩阵和" class="headerlink" title="以原点为一个端点的子矩阵和"></a>以原点为一个端点的子矩阵和</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int sum(int x,int y)&#123;  </span><br><span class="line">    int result = 0;  </span><br><span class="line">    while(x&gt;0)&#123;</span><br><span class="line">        for(int i=y;i&gt;0;i-=lowbit(i))&#123;</span><br><span class="line">            result+=C[x][i];</span><br><span class="line">        &#125;</span><br><span class="line">        x-=lowbit(x);</span><br><span class="line">    &#125;  </span><br><span class="line">    return result;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h2 id="以任意两点为左上和右下两个端点的子矩阵和"><a href="#以任意两点为左上和右下两个端点的子矩阵和" class="headerlink" title="以任意两点为左上和右下两个端点的子矩阵和"></a>以任意两点为左上和右下两个端点的子矩阵和</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int ask(int x1,int y1,int x2,int y2)&#123;</span><br><span class="line">    return sum(x2,y2)+sum(x1-1,y1-1)-sum(x2-1,y1)-sum(x1,y2-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="逆序对"><a href="#逆序对" class="headerlink" title="逆序对"></a>逆序对</h1><p>这个借助例题来讲解<br><a href="https://vjudge.net/contest/368993#problem/B">题目</a><br>求冒泡排序交换了多少次，分析一下，不难看出就是求逆序对的个数，首先明白逆序对的概念给定i,j满足i &lt; j &amp;&amp; a[ i ]&gt;a[ j ]则a[ i ]和a[ j ]就是一对逆序对。<br>求逆序对的做法，举个例子：<br>给定序列<br>9 6 4 8 7<br>遍历这个数组，每次遇到一个数，就把该数所在的树状数组的位置处的数加一：<br>1 2 3 4 5 6 7 8 9<br>0 0 0 0 0 0 0 0 0<br>初始数组值为0，代表插入0个数，sum(n)代表小于等于该数的个数，那么大于该数的个数就是i-sum(n) </p>
<ol>
<li>1 2 3 4 5 6 7 8 9<br>0 0 0 0 0 0 0 0 1<br> 此时插入了一个数，sum(9)=1,1-1=0</li>
<li>1 2 3 4 5 6 7 8 9<br>0 0 0 0 0 1 0 0 1<br>sum(6)=1 2-1=1</li>
<li>1 2 3 4 5 6 7 8 9<br>0 0 0 1 0 1 0 0 1<br>sum(4)=1 3-1=2</li>
<li>1 2 3 4 5 6 7 8 9<br>0 0 0 1 0 1 0 1 1<br>sum(8)=3 4-3=1   </li>
<li>1 2 3 4 5 6 7 8 9<br>0 0 0 1 0 1 1 1 1<br>sum(7)=3 5-3=2 </li>
</ol>
</blockquote>
<p>上面所有的得数相加就得到了最后结果：<br>0+1+2+1+2=6<br>这就是思路，思路清楚了就可以做题了，可是这道题数据很大，明显开不了这么大得树状数组，一个简单得离散化就行了，先对树状数组按照值的大小进行排序，新开一个从序号1开始的连续的数组，一一映射到树状数组，最后对序号求逆序对就行了。</p>
<p>建立一个结构体包含val和id， val就是输入的数，id表示输入的顺序。然后按照val从小到大排序，如果val相等，那么就按照id排序。</p>
<p>如果没有逆序的话，肯定id是跟i（表示拍好后的顺序）一直一样的，如果有逆序数，那么有的i和id是不一样的。所以，利用树状数组的特性，我们可以简单的算出逆序数的个数。</p>
<p>如果还是不明白的话举个例子。（输入4个数）</p>
<p>输入：9 -1 18 5</p>
<p>输出 3.</p>
<p>输入之后对应的结构体就会变成这样<br>val：9 -1 18 5<br>id：  1  2  3  4<br>排好序之后就变成了<br>val ：  -1 5 9 18<br>id：      2 4  1  3<br>2 4 1 3 的逆序数 也是3<br>之后再利用树状数组的特性就可以解决问题了<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;algorithm&gt; </span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=500001;</span><br><span class="line">int c[maxn];</span><br><span class="line">struct Node</span><br><span class="line">&#123;</span><br><span class="line">	int v,index;</span><br><span class="line">	bool operator &lt; (const Node &amp;b) const</span><br><span class="line">	&#123;</span><br><span class="line">		return v&lt;b.v; //从小到大排序 </span><br><span class="line">	&#125;</span><br><span class="line">&#125;node[maxn];</span><br><span class="line">int n;</span><br><span class="line">void add(int i)</span><br><span class="line">&#123;</span><br><span class="line">	while(i&lt;=n)</span><br><span class="line">	&#123;</span><br><span class="line">		c[i]++;</span><br><span class="line">		i+=i&amp;(-i);	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">long long getsum(int i)</span><br><span class="line">&#123;</span><br><span class="line">	long long res=0;</span><br><span class="line">	while(i&gt;0)</span><br><span class="line">	&#123;</span><br><span class="line">		res+=c[i];</span><br><span class="line">		i-=i&amp;(-i);</span><br><span class="line">	&#125;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		cin&gt;&gt;n;</span><br><span class="line">		if(n==0) break;</span><br><span class="line">		int a;</span><br><span class="line">		memset(node,0,sizeof node);</span><br><span class="line">		memset(c,0,sizeof c);</span><br><span class="line">		for(int i=1;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			scanf(&quot;%d&quot;,&amp;a);</span><br><span class="line">			node[i].index=i;</span><br><span class="line">			node[i].v=a;</span><br><span class="line">		&#125;</span><br><span class="line">		sort(node+1,node+1+n);</span><br><span class="line">		long long ans=0;</span><br><span class="line">		for(int i=1;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			add(node[i].index);  //离散化结果—— 下标等效于数值</span><br><span class="line">			ans+=i-getsum(node[i].index); //得到之前有多少个比你大的数（逆序对）</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>python_arrange</title>
    <url>/posts/cd2bd376.html</url>
    <content><![CDATA[<blockquote>
<p>写这个代码花了一个小时，因为刚学了一点点OS模块，还不是很熟悉，写完后功能也都有，但是！！！导出为exe文件时不小心误删了py文件，气死我了！又重新写了一遍。</p>
<p>新加了GUI界面的整理页面小程序，效果如下图所示</p>
<p>GitHub项目地址 <a href="https://github.com/uncleacc/Organize-documents">Here</a></p>
</blockquote>
<p><strong>效果图：</strong></p>
<p><img src="http://ww1.sinaimg.cn/large/007Y60soly1gilvhm4w0ij30oa0gn0to.jpg" alt="">{height=”400”,width=”400”}</p>
<p><img src="http://ww1.sinaimg.cn/large/007Y60soly1gijcql8z7pj30ln0bhgmc.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/007Y60soly1gijdfc5nb5j30sv084ab9.jpg" alt=""></p>
<h2 id="CODE1（不含有重命名）"><a href="#CODE1（不含有重命名）" class="headerlink" title="CODE1（不含有重命名）"></a>CODE1（不含有重命名）</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> shutil <span class="keyword">import</span> copyfile</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;------创建文件夹------&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> var_list:</span><br><span class="line">        Path_now = os.path.join(Path, i).replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">not</span> os.path.exists(Path_now)):</span><br><span class="line">            os.mkdir(Path_now)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;------创建完成------&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">move</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;------移动文件------&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> os.listdir(Path):</span><br><span class="line">        Path_src = os.path.join(Path, file).replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span>(os.path.isfile(Path_src)):</span><br><span class="line">            pos = file.find(<span class="string">&#x27;.&#x27;</span>) + <span class="number">1</span></span><br><span class="line">            postfix = file[pos:]</span><br><span class="line">            <span class="keyword">if</span>(postfix <span class="keyword">in</span> var_list):</span><br><span class="line">                Path_tar = os.path.join(Path, postfix, file).replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">                copyfile(Path_src, Path_tar)</span><br><span class="line">                os.remove(Path_src)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;------移动完成------&#x27;</span>)</span><br><span class="line"></span><br><span class="line">var_list = [<span class="string">&#x27;jpg&#x27;</span>, <span class="string">&#x27;jpeg&#x27;</span>, <span class="string">&#x27;png&#x27;</span>, <span class="string">&#x27;txt&#x27;</span>, <span class="string">&#x27;webp&#x27;</span>, <span class="string">&#x27;gif&#x27;</span>, <span class="string">&#x27;avi&#x27;</span>] <span class="comment">#改这里面的内容可以添加整理文件方式(只需要改这里)</span></span><br><span class="line">Path = <span class="built_in">input</span>(<span class="string">&#x27;请输入您要整理的文件夹目录位置： &#x27;</span>)</span><br><span class="line">name = <span class="built_in">input</span>(<span class="string">&#x27;请输入您要整理的文件夹名称： &#x27;</span>)</span><br><span class="line">Path = os.path.join(Path, name).replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(Path)</span><br><span class="line">sure = <span class="built_in">input</span>(<span class="string">&#x27;确认您要整理此文件夹吗？ y/n?&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span>(sure == <span class="string">&#x27;y&#x27;</span>):</span><br><span class="line">    flag = <span class="number">0</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        flag = os.path.isdir(Path)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;无法打开此文件夹！请确认你具有权限访问此文件夹！！！&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span>(flag):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;------开始整理------&#x27;</span>)</span><br><span class="line">        create()</span><br><span class="line">        move()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;请确认地址指向文件夹&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;------exit successfully------&#x27;</span>)</span><br><span class="line"></span><br><span class="line">os.system(<span class="string">&quot;pause&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="CODE2-（重命名）"><a href="#CODE2-（重命名）" class="headerlink" title="CODE2 （重命名）"></a>CODE2 （重命名）</h2><p>实现了移动文件的过程中从0开始往上迭代重命名的过程</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> shutil <span class="keyword">import</span> copyfile</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Any</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 全局变量</span></span><br><span class="line">cnt_jpg = cnt_gif = cnt_png = cnt_txt = cnt_avi = cnt_webp = cnt_pdf = cnt_doc = <span class="number">0</span></span><br><span class="line">fileFormat = [<span class="string">&#x27;jpg&#x27;</span>, <span class="string">&#x27;jpeg&#x27;</span>, <span class="string">&#x27;png&#x27;</span>, <span class="string">&#x27;txt&#x27;</span>, <span class="string">&#x27;webp&#x27;</span>, <span class="string">&#x27;gif&#x27;</span>, <span class="string">&#x27;avi&#x27;</span>] <span class="comment"># 分类的文件格式</span></span><br><span class="line">Path = <span class="string">&quot;&quot;</span></span><br><span class="line">name = <span class="string">&quot;&quot;</span></span><br><span class="line">prefix = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用户输入</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__input</span>():</span><br><span class="line">    <span class="keyword">global</span> Path, name, prefix</span><br><span class="line">    Path = <span class="built_in">input</span>(<span class="string">&#x27;请输入您要整理的文件夹目录位置： &#x27;</span>)</span><br><span class="line">    name = <span class="built_in">input</span>(<span class="string">&#x27;请输入您要整理的文件夹名称： &#x27;</span>)</span><br><span class="line">    prefix = <span class="built_in">input</span>(<span class="string">&#x27;请输入重命名后的文件前缀： &#x27;</span>)</span><br><span class="line">    Path = os.path.join(Path, name).replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建文件夹，如果文件夹中有文件则将这些文件夹移出来</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__create</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;------创建文件夹------&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> fileFormat:</span><br><span class="line">        Path_now = os.path.join(Path, i).replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">not</span> os.path.exists(Path_now)):</span><br><span class="line">            os.mkdir(Path_now)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> file <span class="keyword">in</span> os.listdir(Path_now):</span><br><span class="line">                Path_cur = os.path.join(Path_now, file).replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">                Path_tar = os.path.join(Path, file).replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">                copyfile(Path_cur, Path_tar)</span><br><span class="line">                os.remove(Path_cur)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;------创建完成------&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重命名</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__change</span>(<span class="params">name, var, pos</span>):</span><br><span class="line">    <span class="keyword">global</span> cnt_jpg, cnt_gif, cnt_png, cnt_txt, cnt_avi, cnt_webp, cnt_doc, cnt_pdf</span><br><span class="line">    <span class="keyword">if</span>(var == <span class="string">&#x27;jpg&#x27;</span>):</span><br><span class="line">        cnt_jpg += <span class="number">1</span></span><br><span class="line">        name = name.replace(name[<span class="number">0</span>:pos-<span class="number">1</span>], <span class="built_in">str</span>(cnt_jpg))</span><br><span class="line">    <span class="keyword">if</span>(var == <span class="string">&#x27;avi&#x27;</span>):</span><br><span class="line">        cnt_avi += <span class="number">1</span></span><br><span class="line">        name = name.replace(name[<span class="number">0</span>:pos - <span class="number">1</span>], <span class="built_in">str</span>(cnt_avi))</span><br><span class="line">    <span class="keyword">if</span>(var == <span class="string">&#x27;doc&#x27;</span>):</span><br><span class="line">        cnt_doc += <span class="number">1</span></span><br><span class="line">        name = name.replace(name[<span class="number">0</span>:pos - <span class="number">1</span>], <span class="built_in">str</span>(cnt_doc))</span><br><span class="line">    <span class="keyword">if</span>(var == <span class="string">&#x27;pdf&#x27;</span>):</span><br><span class="line">        cnt_pdf += <span class="number">1</span></span><br><span class="line">        name = name.replace(name[<span class="number">0</span>:pos - <span class="number">1</span>], <span class="built_in">str</span>(cnt_pdf))</span><br><span class="line">    <span class="keyword">if</span>(var == <span class="string">&#x27;webp&#x27;</span>):</span><br><span class="line">        cnt_webp += <span class="number">1</span></span><br><span class="line">        name = name.replace(name[<span class="number">0</span>:pos - <span class="number">1</span>], <span class="built_in">str</span>(cnt_webp))</span><br><span class="line">    <span class="keyword">if</span>(var == <span class="string">&#x27;png&#x27;</span>):</span><br><span class="line">        cnt_png += <span class="number">1</span></span><br><span class="line">        name = name.replace(name[<span class="number">0</span>:pos-<span class="number">1</span>], <span class="built_in">str</span>(cnt_png))</span><br><span class="line">    <span class="keyword">if</span>(var == <span class="string">&#x27;gif&#x27;</span>):</span><br><span class="line">        cnt_gif += <span class="number">1</span></span><br><span class="line">        name = name.replace(name[<span class="number">0</span>:pos - <span class="number">1</span>], <span class="built_in">str</span>(cnt_gif))</span><br><span class="line">    <span class="keyword">if</span>(var == <span class="string">&#x27;txt&#x27;</span>):</span><br><span class="line">        cnt_txt += <span class="number">1</span></span><br><span class="line">        name = name.replace(name[<span class="number">0</span>:pos - <span class="number">1</span>], <span class="built_in">str</span>(cnt_txt))</span><br><span class="line">    <span class="keyword">return</span> prefix + name</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__move</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;------移动文件------&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> os.listdir(Path):</span><br><span class="line">        Path_src = os.path.join(Path, file).replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span>(os.path.isfile(Path_src)):</span><br><span class="line">            pos = file.rfind(<span class="string">&#x27;.&#x27;</span>) + <span class="number">1</span></span><br><span class="line">            postfix = file[pos:]</span><br><span class="line">            <span class="keyword">if</span>(postfix <span class="keyword">in</span> fileFormat):</span><br><span class="line">                file = __change(file, postfix, pos)</span><br><span class="line">                Path_tar = os.path.join(Path, postfix, file).replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">                copyfile(Path_src, Path_tar)</span><br><span class="line">                os.remove(Path_src)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;------移动完成------&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    __<span class="built_in">input</span>()</span><br><span class="line">    <span class="built_in">print</span>(Path)</span><br><span class="line">    sure = <span class="built_in">input</span>(<span class="string">&#x27;确认您要整理此文件夹吗？ y/n?&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span>(sure == <span class="string">&#x27;y&#x27;</span>):</span><br><span class="line">        <span class="keyword">if</span>(os.path.isdir(Path)):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;------开始整理------&#x27;</span>)</span><br><span class="line">            __create()</span><br><span class="line">            __move()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;请确认地址指向文件夹，如果确实是文件夹则检查权限问题&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;------exit successfully------&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">os.system(<span class="string">&quot;pause&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="CODE3-（GUI界面）"><a href="#CODE3-（GUI界面）" class="headerlink" title="CODE3 （GUI界面）"></a>CODE3 （GUI界面）</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> tkinter <span class="keyword">as</span> tk</span><br><span class="line"><span class="keyword">import</span> tkinter.messagebox</span><br><span class="line"><span class="keyword">from</span> shutil <span class="keyword">import</span> copyfile</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Any</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#创建tk窗口</span></span><br><span class="line">window = tk.Tk()</span><br><span class="line">window.title(<span class="string">&#x27;文档整理器&#x27;</span>)</span><br><span class="line">window.geometry(<span class="string">&#x27;700x450&#x27;</span>)</span><br><span class="line"><span class="comment">#建立表单</span></span><br><span class="line">var_info = tk.StringVar()</span><br><span class="line">var_info.<span class="built_in">set</span>(<span class="string">&#x27;当前您还没有进行整理&#x27;</span>)</span><br><span class="line">tk.Label(window, font=(<span class="string">&#x27;Arial, 15&#x27;</span>), bg=<span class="string">&#x27;yellow&#x27;</span>, textvariable=var_info).place(x=<span class="number">250</span>, y=<span class="number">20</span>)</span><br><span class="line">tk.Label(window, font=(<span class="string">&#x27;Arial&#x27;</span>, <span class="number">15</span>), text=<span class="string">&#x27;请输入您要整理的文件夹的路径: &#x27;</span>).place(x=<span class="number">10</span>, y=<span class="number">100</span>)</span><br><span class="line">tk.Label(window, font=(<span class="string">&#x27;Arial&#x27;</span>, <span class="number">15</span>), text=<span class="string">&#x27;请输入该文件夹的名字: &#x27;</span>).place(x=<span class="number">10</span>, y=<span class="number">150</span>)</span><br><span class="line">tk.Label(window, font=(<span class="string">&#x27;Arial&#x27;</span>, <span class="number">15</span>), text=<span class="string">&#x27;请输入重命名后的文件前缀： &#x27;</span>).place(x=<span class="number">10</span>, y=<span class="number">200</span>)</span><br><span class="line"><span class="comment"># 创建输入框</span></span><br><span class="line"><span class="comment"># 文件夹路径</span></span><br><span class="line">var_Path = tk.StringVar()</span><br><span class="line">entry_Path = tk.Entry(window, font=(<span class="string">&#x27;Arial&#x27;</span>,<span class="number">15</span>), textvariable=var_Path, width=<span class="number">30</span>)</span><br><span class="line">entry_Path.place(x=<span class="number">300</span>, y=<span class="number">100</span>)</span><br><span class="line"><span class="comment"># 文件夹名称</span></span><br><span class="line">var_name = tk.StringVar()</span><br><span class="line">entry_Name = tk.Entry(window, font=(<span class="string">&#x27;Arial&#x27;</span>,<span class="number">15</span>), textvariable=var_name, width=<span class="number">30</span>)</span><br><span class="line">entry_Name.place(x=<span class="number">300</span>, y=<span class="number">150</span>)</span><br><span class="line"><span class="comment"># 重命名前缀</span></span><br><span class="line">var_prefix = tk.StringVar()</span><br><span class="line">entry_Prefix = tk.Entry(window, font=(<span class="string">&#x27;Arial&#x27;</span>,<span class="number">15</span>), textvariable=var_prefix, width=<span class="number">30</span>)</span><br><span class="line">entry_Prefix.place(x=<span class="number">300</span>, y=<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 全局变量</span></span><br><span class="line">cnt_jpg = cnt_gif = cnt_png = cnt_txt = cnt_avi = cnt_webp = cnt_pdf = cnt_doc = <span class="number">0</span></span><br><span class="line">fileFormat = [<span class="string">&#x27;jpg&#x27;</span>, <span class="string">&#x27;jpeg&#x27;</span>, <span class="string">&#x27;png&#x27;</span>, <span class="string">&#x27;txt&#x27;</span>, <span class="string">&#x27;webp&#x27;</span>, <span class="string">&#x27;gif&#x27;</span>, <span class="string">&#x27;avi&#x27;</span>] <span class="comment"># 分类的文件格式</span></span><br><span class="line">Path = <span class="string">&#x27;&#x27;</span></span><br><span class="line">name = <span class="string">&#x27;&#x27;</span></span><br><span class="line">prefix = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 创建文件夹，如果文件夹中有文件则将这些文件夹移出来</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__create</span>():</span><br><span class="line">    <span class="keyword">global</span> var_info</span><br><span class="line">    var_info.<span class="built_in">set</span>(<span class="string">&#x27;------创建文件夹------&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> fileFormat:</span><br><span class="line">        Path_now = os.path.join(Path, i).replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">not</span> os.path.exists(Path_now)):</span><br><span class="line">            os.mkdir(Path_now)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> file <span class="keyword">in</span> os.listdir(Path_now):</span><br><span class="line">                Path_cur = os.path.join(Path_now, file).replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">                Path_tar = os.path.join(Path, file).replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">                copyfile(Path_cur, Path_tar)</span><br><span class="line">                os.remove(Path_cur)</span><br><span class="line">    var_info.<span class="built_in">set</span>(<span class="string">&#x27;------创建完成------&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重命名</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__change</span>(<span class="params">name, var, pos</span>):</span><br><span class="line">    <span class="keyword">global</span> cnt_jpg, cnt_gif, cnt_png, cnt_txt, cnt_avi, cnt_webp, cnt_doc, cnt_pdf</span><br><span class="line">    <span class="keyword">if</span>(var == <span class="string">&#x27;jpg&#x27;</span>):</span><br><span class="line">        cnt_jpg += <span class="number">1</span></span><br><span class="line">        name = name.replace(name[<span class="number">0</span>:pos-<span class="number">1</span>], <span class="built_in">str</span>(cnt_jpg))</span><br><span class="line">    <span class="keyword">if</span>(var == <span class="string">&#x27;avi&#x27;</span>):</span><br><span class="line">        cnt_avi += <span class="number">1</span></span><br><span class="line">        name = name.replace(name[<span class="number">0</span>:pos - <span class="number">1</span>], <span class="built_in">str</span>(cnt_avi))</span><br><span class="line">    <span class="keyword">if</span>(var == <span class="string">&#x27;doc&#x27;</span>):</span><br><span class="line">        cnt_doc += <span class="number">1</span></span><br><span class="line">        name = name.replace(name[<span class="number">0</span>:pos - <span class="number">1</span>], <span class="built_in">str</span>(cnt_doc))</span><br><span class="line">    <span class="keyword">if</span>(var == <span class="string">&#x27;pdf&#x27;</span>):</span><br><span class="line">        cnt_pdf += <span class="number">1</span></span><br><span class="line">        name = name.replace(name[<span class="number">0</span>:pos - <span class="number">1</span>], <span class="built_in">str</span>(cnt_pdf))</span><br><span class="line">    <span class="keyword">if</span>(var == <span class="string">&#x27;webp&#x27;</span>):</span><br><span class="line">        cnt_webp += <span class="number">1</span></span><br><span class="line">        name = name.replace(name[<span class="number">0</span>:pos - <span class="number">1</span>], <span class="built_in">str</span>(cnt_webp))</span><br><span class="line">    <span class="keyword">if</span>(var == <span class="string">&#x27;png&#x27;</span>):</span><br><span class="line">        cnt_png += <span class="number">1</span></span><br><span class="line">        name = name.replace(name[<span class="number">0</span>:pos-<span class="number">1</span>], <span class="built_in">str</span>(cnt_png))</span><br><span class="line">    <span class="keyword">if</span>(var == <span class="string">&#x27;gif&#x27;</span>):</span><br><span class="line">        cnt_gif += <span class="number">1</span></span><br><span class="line">        name = name.replace(name[<span class="number">0</span>:pos - <span class="number">1</span>], <span class="built_in">str</span>(cnt_gif))</span><br><span class="line">    <span class="keyword">if</span>(var == <span class="string">&#x27;txt&#x27;</span>):</span><br><span class="line">        cnt_txt += <span class="number">1</span></span><br><span class="line">        name = name.replace(name[<span class="number">0</span>:pos - <span class="number">1</span>], <span class="built_in">str</span>(cnt_txt))</span><br><span class="line">    <span class="keyword">return</span> prefix + name</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__move</span>():</span><br><span class="line">    var_info.<span class="built_in">set</span>(<span class="string">&#x27;------移动文件------&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> os.listdir(Path):</span><br><span class="line">        Path_src = os.path.join(Path, file).replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span>(os.path.isfile(Path_src)):</span><br><span class="line">            pos = file.rfind(<span class="string">&#x27;.&#x27;</span>) + <span class="number">1</span></span><br><span class="line">            postfix = file[pos:]</span><br><span class="line">            <span class="keyword">if</span>(postfix <span class="keyword">in</span> fileFormat):</span><br><span class="line">                file = __change(file, postfix, pos)</span><br><span class="line">                Path_tar = os.path.join(Path, postfix, file).replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">                copyfile(Path_src, Path_tar)</span><br><span class="line">                os.remove(Path_src)</span><br><span class="line">    var_info.<span class="built_in">set</span>(<span class="string">&#x27;------移动完成------&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check</span>():</span><br><span class="line">    <span class="keyword">if</span>(var_Path.get() <span class="keyword">and</span> var_name.get()):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">if</span>(check()):</span><br><span class="line">        <span class="keyword">global</span> Path, prefix</span><br><span class="line">        Path = os.path.join(var_Path.get(), var_name.get()).replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">        prefix = var_prefix.get()</span><br><span class="line">        sure = tk.messagebox.askyesno(title=<span class="string">&#x27;Are you sure?&#x27;</span>, message=<span class="string">&#x27;请确定您要整理的文件夹路径是&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(Path))</span><br><span class="line">        <span class="keyword">if</span>(sure == <span class="literal">True</span>):</span><br><span class="line">            <span class="keyword">if</span>(os.path.isdir(Path)):</span><br><span class="line">                var_info.<span class="built_in">set</span>(<span class="string">&#x27;------开始整理------&#x27;</span>)</span><br><span class="line">                __create()</span><br><span class="line">                __move()</span><br><span class="line">                tk.messagebox.showinfo(title=<span class="string">&#x27;Success&#x27;</span>, message=<span class="string">&#x27;文件整理完毕&#x27;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tk.messagebox.showerror(title=<span class="string">&#x27;ERROR&#x27;</span>, message=<span class="string">&#x27;请确认该路径指向文件夹，如果确实是文件夹则检查权限问题&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        tk.messagebox.showwarning(title=<span class="string">&#x27;Warning&#x27;</span>, message=<span class="string">&#x27;请确保您的文件夹目录和名字进行了输入(前缀为空则默认全部数字)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">bt1 = tk.Button(window,font=(<span class="string">&#x27;Arial&#x27;</span>,<span class="number">15</span>), activebackground=<span class="string">&#x27;black&#x27;</span>, text=<span class="string">&#x27;开始整理&#x27;</span>, height=<span class="number">2</span>, width=<span class="number">30</span>, command=main)</span><br><span class="line">bt1.place(x=<span class="number">210</span>, y=<span class="number">260</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">window.mainloop()</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈哈希</title>
    <url>/posts/819591f7.html</url>
    <content><![CDATA[<blockquote>
<p><strong>前言</strong></p>
<p>趁着还没忘记录一下吧🐷</p>
</blockquote>
<h2 id="哈希能干些啥？"><a href="#哈希能干些啥？" class="headerlink" title="哈希能干些啥？"></a>哈希能干些啥？</h2><p>学一个新算法首先一定要知道学这个能干些啥对吧，我们是为了用某个东西而去学这个东西而不是盲目目的的学，现在假如给你两段字符串让你去比较他们是否相同，如果暴力做法就是从头到尾扫一遍，都相同则相同，复杂度为O(N)，假如数据量非常大，而且字符串长度很大，现在题目就变成了给你n个字符串，现在又给你t个字符串问你每一个字符串是否在这n个字符串中，平常做法时间复杂度O(t<em>t个字符串每一个字符串长度\</em>n)，若用哈希预处理时间复杂度降到O(t*字符串长度+n)，也就是把那n个字符串预先处理一下，使得接下来比较每一个字符串时时间复杂度变成O(1)，让我们来看一下具体怎么操作吧</p>
<h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>其实哈希和二进制思想是类似的，如果让你比较两个二进制串是否相同，你肯定会想到把二进制转成十进制比较起来会更方便，因为复杂度降低到了O(1)，不用你去逐位比较了，那字符串也是可以像二进制那样转换成为一个数字的，例如：abcd这个字符串可以转换成为a<em>p^3^+b\</em>p^2^+c*p^1^+d*p^0^，这里的p值是多少先不说，每一个字符都是有acall值的，我们可以直接利用这一点把每一个字符串转换成这样的数字，其中如果涉及到字符串子串问题，例如找一个字符串中是否含有某一段子串，我们就可用前缀的思想讲一个字符及之前的所有字符转换成数字存到数组里面，例如abcd我们就开一个Hash[5]，Hash[1]存a的哈希值，Hash[2]存ab的哈希值，Hash[3]存abc的哈希值，以此类推，这样假如我们要找其中一段子串的哈希值就可以前缀减一下也在O(1)的时间得出来，但是注意的是这里每一位权值不同不能简单做一下减法，具体实现继续看</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>这段代码就实现了哈希</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Hash[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) Hash[i]=(Hash[i<span class="number">-1</span>]*p+s[i])%mod;<span class="comment">//前i 个字符的 hash值</span></span><br></pre></td></tr></table></figure>
<p>是不是很简单呢？注意的是字符串转换的哈希值是特别特别大的，你想一想64位二进制都到了longlon的程度这里的p还比2大也就是说字符串不到64位都存不下了，因此但总归每一个字符串映射过来的数字基本都是不同的，因此我们可以取一下模，取模后数字依旧是不同的，需要注意的是虽然数字相同概率非常小，但是假如p和mod取得数字不对依旧是有很大几率两段不同字符串映射到相同数字的，因此这里的p和mod都应该是一个质数，以降低重复概率，，<code>p 一般取 131、13331 或者 2333，mod 一般取 1e9+7，1e9+9 或者 2^64^</code>。需要说明的是C语言的unsigned long long 无符号整数当存储数字超过范围后会自动取模，不会爆，所以hash数组可以用ull定义，只不过有的题目可能会卡内存，因此还是建议自己实现取模操作</p>
<p>到这里就实现了把字符串转换成为数字，接下来如何取子串的哈希值呢？</p>
<p>Hash[r]=s[1]*p^r-1^+s[2]*p^r-2^…s[r]*p^0^</p>
<p>Hash[l-1]=s[1]*p^l^+s[2]*p^l-1^…s[r]*p^0^</p>
<p>Hash[l~r]=s[l]<em>p^r-l^+s[l+1]\</em>p^r-l+1^…s[r]*p^0^</p>
<p>发现3式等于1式减去2式*p^r-l+1^，因此取字串哈希值代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">get_hash</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ((hash[r]-hash[l<span class="number">-1</span>]*<span class="built_in">pow</span>(p,r-l+<span class="number">1</span>))%mod+mod)%mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的pow函数当有多组数据时可以用po数组预先处理一下，存储p的i次方，这里的复杂度就降低为O(1)了，本来pow函数复杂度为O(N)的</p>
<p>po数组代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">po[i<span class="number">-1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) po[i]=po[i<span class="number">-1</span>]*p%MOD;</span><br></pre></td></tr></table></figure>
<p>这样整个就结束了</p>
<p><a href="https://vjudge.net/contest/388681#problem/A">来看一道例题吧</a></p>
<p>甚至可以直接看代码，知道实现的大致思路</p>
<h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 500005</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">400100</span>;</span><br><span class="line">ull ha[MAXN],po[MAXN];</span><br><span class="line"><span class="type">int</span> ans[MAXN];</span><br><span class="line"><span class="type">char</span> ch[MAXN];</span><br><span class="line"><span class="type">int</span> p=<span class="number">131</span>;</span><br><span class="line">ull <span class="title function_">get_ha</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ha[r]-ha[l<span class="number">-1</span>]*po[r-l+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;ch+<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="type">int</span> len=<span class="built_in">strlen</span>(ch+<span class="number">1</span>);</span><br><span class="line">		ha[<span class="number">0</span>]=<span class="number">0</span>; po[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++)&#123;</span><br><span class="line">			ha[i]=ha[i<span class="number">-1</span>]*p+ch[i]-<span class="string">&#x27;a&#x27;</span>+<span class="number">1</span>;</span><br><span class="line">			po[i]=po[i<span class="number">-1</span>]*p;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> tail =<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(get_ha(<span class="number">1</span>,i)==get_ha(len-i+<span class="number">1</span>,len)) ans[++tail]=i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tail;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(i!=tail) <span class="built_in">cout</span>&lt;&lt;ans[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;ans[i]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>哈希还可以后缀，利用后缀和前缀比较可以快速判断回文串</p>
<p><a href="https://vjudge.net/contest/388813#problem/D">例题</a></p>
<h2 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 500005</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">100100</span>;</span><br><span class="line">ull ha1[MAXN],ha2[MAXN],po[MAXN];</span><br><span class="line"><span class="type">char</span> ch[MAXN];</span><br><span class="line"><span class="type">int</span> p=<span class="number">131</span>;</span><br><span class="line">ull <span class="title function_">get_h1</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ha1[r]-ha1[l<span class="number">-1</span>]*po[r-l+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">ull <span class="title function_">get_h2</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ha2[l]-ha2[r+<span class="number">1</span>]*po[r-l+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	ios;</span><br><span class="line">	po[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;MAXN;i++) po[i]=p*po[i<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;ch+<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="type">int</span> len=<span class="built_in">strlen</span>(ch+<span class="number">1</span>);</span><br><span class="line">		ha1[<span class="number">0</span>]=ha2[len+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++)</span><br><span class="line">			ha1[i]=ha1[i<span class="number">-1</span>]*p+ch[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=len;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">			ha2[i]=ha2[i+<span class="number">1</span>]*p+ch[i];</span><br><span class="line">		<span class="type">int</span> pos;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(get_h1(i,len)==get_h2(i,len))&#123;</span><br><span class="line">				pos=i<span class="number">-1</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;ch+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=pos;i&gt;=<span class="number">1</span>;i--) <span class="built_in">cout</span>&lt;&lt;ch[i];</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="双哈希乃至多哈希"><a href="#双哈希乃至多哈希" class="headerlink" title="双哈希乃至多哈希"></a>双哈希乃至多哈希</h2><p>需要明白的一点是虽然错误率是极低的，但是依旧有错误率的，为了进一步降低错误率，我们可以用双哈希乃至多哈希降低错误率，也就是对一个字符串定义两个hash数组，分别对不同的p和mod操作，当两个字符串比较时，除非两个hash数组都一样才说两个字符串相同，<a href="https://vjudge.net/contest/388813#problem/F">例题</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> base 33</span></span><br><span class="line">LL p[<span class="number">1000100</span>];</span><br><span class="line">LL h1[<span class="number">1000100</span>],h2[<span class="number">1000100</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> LL <span class="title function_">gethash1</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span> &#123;</span><br><span class="line">    LL tp = l?h1[l<span class="number">-1</span>]:<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> h1[r] - tp*p[r-l+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> LL <span class="title function_">gethash2</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span> &#123;</span><br><span class="line">    LL tp = l?h2[l<span class="number">-1</span>]:<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> h2[r] - tp*p[r-l+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Is_palindrome</span><span class="params">(<span class="built_in">string</span> s)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.size()/<span class="number">2</span>; i++)</span><br><span class="line">        <span class="keyword">if</span> (s[i] != s[s.size()<span class="number">-1</span>-i]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> <span class="title function_">find</span><span class="params">(<span class="built_in">string</span> s)</span> &#123;</span><br><span class="line">    <span class="built_in">string</span> ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">int</span> len = s.size();</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">       <span class="keyword">if</span> (i == <span class="number">0</span>) h1[i] = s[i];</span><br><span class="line">       <span class="keyword">else</span> h1[i] = h1[i<span class="number">-1</span>]*base+s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) h2[i] = s[len-i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">else</span> h2[i] = h2[i<span class="number">-1</span>]*base+s[len-i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = len<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (gethash1(<span class="number">0</span>,i) == gethash2(len<span class="number">-1</span>-i,len<span class="number">-1</span>) &amp;&amp; Is_palindrome(s.substr(<span class="number">0</span>,i+<span class="number">1</span>))) <span class="keyword">return</span> s.substr(<span class="number">0</span>,i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">work</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    <span class="built_in">string</span> comm = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; s.size()/<span class="number">2</span>; i++)</span><br><span class="line">      <span class="keyword">if</span> (s[i] == s[s.size()<span class="number">-1</span>-i]) comm += s[i];</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    s = s.substr(i,s.size()-i-i);</span><br><span class="line">    <span class="built_in">string</span> ss = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = s.size()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) ss += s[i];</span><br><span class="line">    <span class="built_in">string</span> s1 = find(s),s2 = find(ss);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; comm  &lt;&lt; (s1.size()&gt;s2.size()?s1:s2);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = comm.size()<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; comm[i];</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1000000</span>; i++)</span><br><span class="line">       p[i] = p[i<span class="number">-1</span>]*base;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        work();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>集训</tag>
      </tags>
  </entry>
  <entry>
    <title>全排列问题</title>
    <url>/posts/543746.html</url>
    <content><![CDATA[<h1 id="STL-next-permutation函数实现"><a href="#STL-next-permutation函数实现" class="headerlink" title="STL next_permutation函数实现"></a>STL next_permutation函数实现</h1><p><a href="https://www.cnblogs.com/luruiyuan/p/5914909.html">原文链接</a><br>掌握了next_permutation函数的原理:smile:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void inline swap(char *s1,char *s2)&#123;</span><br><span class="line">    char t=*s1;</span><br><span class="line">    *s1=*s2;</span><br><span class="line">    *s2=t;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">*反转字符串函数,s,e分别执行字符串的开始和结尾，不能反转中文 </span><br><span class="line">**/</span><br><span class="line">void reverse(char *s,char* e)&#123;</span><br><span class="line">    for(e--;s&lt;e;s++,e--)swap(s,e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool next_permutation(char *start,char *end)&#123;</span><br><span class="line">    char *cur = end-1, *pre=cur-1;</span><br><span class="line">    while(cur&gt;start &amp;&amp; *pre&gt;=*cur)cur--,pre--;</span><br><span class="line">    if(cur&lt;=start)return false;</span><br><span class="line">    </span><br><span class="line">    for(cur=end-1;*cur&lt;=*pre;cur--);//找到逆序中大于*pre的元素的最小元素 </span><br><span class="line">    swap(cur,pre);</span><br><span class="line">    reverse(pre+1,end);//将尾部的逆序变成正序 </span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>prev_permutation只要将上面的cur和pre作比较的地方换一下位置就行了</code><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool prev_permutation(char *start,char *end)&#123;</span><br><span class="line">    char *cur = end-1, *pre=cur-1;</span><br><span class="line">    while(cur&gt;start &amp;&amp; *pre&lt;=*cur)cur--,pre--;//这里符号有变化 </span><br><span class="line">    if(cur&lt;=start)return false;</span><br><span class="line">    </span><br><span class="line">    for(cur=end-1;*cur&gt;=*pre;cur--);//这里符号有变化 </span><br><span class="line">    swap(*cur,*pre);</span><br><span class="line">    reverse(pre+1,end);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>给出一个字符串S（可能有重复的字符），按照字典序从小到大，输出S包括的字符组成的所有排列。例如：S = “1312”，</p>
<p>输出为：</p>
<p>1123<br>1132<br>1213<br>1231<br>1312<br>1321<br>2113<br>2131<br>2311<br>3112<br>3121<br>3211<br>Sample Input<br>1312<br>Sample Output<br>1123<br>1132<br>1213<br>1231<br>1312<br>1321<br>2113<br>2131<br>2311<br>3112<br>3121<br>3211   </p>
<h1 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">bool next_permutation(char *start,char *end)&#123;</span><br><span class="line">    char *cur = end-1, *pre=cur-1;</span><br><span class="line">    while(cur&gt;start &amp;&amp; *pre&gt;=*cur)cur--,pre--;</span><br><span class="line">    if(cur&lt;=start)return false;</span><br><span class="line">    </span><br><span class="line">    for(cur=end-1;*cur&lt;=*pre;cur--);//找到逆序中大于*pre的元素的最小元素 </span><br><span class="line">    swap(*cur,*pre);</span><br><span class="line">    reverse(pre+1,end);//将尾部的逆序变成正序 </span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    char s2[100];</span><br><span class="line">    scanf(&quot;%s&quot;,s2);</span><br><span class="line">    int n=strlen(s2);</span><br><span class="line">    sort(s2,s2+n);</span><br><span class="line">    do&#123;</span><br><span class="line">        puts(s2);</span><br><span class="line">//        cnt++;</span><br><span class="line">    &#125;while(next_permutation(s2,s2+n));</span><br><span class="line">//    printf(&quot;%d&quot;,cnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DFS</span><br><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">const int N = 10+5;</span><br><span class="line"> </span><br><span class="line">char ch[N];</span><br><span class="line">char ans[N];</span><br><span class="line">bool vis[N];</span><br><span class="line">int n;</span><br><span class="line"> </span><br><span class="line">void dfs(int x)&#123;</span><br><span class="line">	int i;</span><br><span class="line">	if(x == n)&#123; </span><br><span class="line">		printf(&quot;%s\n&quot;,ans);</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		for(int i = 0; i &lt; n;i++)&#123;</span><br><span class="line">			if(vis[i] == false)&#123;</span><br><span class="line">				vis[i] = true;</span><br><span class="line">				ans[x] = ch[i];</span><br><span class="line">				dfs(x+1);</span><br><span class="line">				vis[i]=false;</span><br><span class="line">				//筛除重复数据 </span><br><span class="line">				while(i &lt; n-1 &amp;&amp; ch[i+1]==ch[i]) i++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	scanf(&quot;%s&quot;,&amp;ch);</span><br><span class="line">	n = strlen(ch);</span><br><span class="line">	sort(ch,ch+n);</span><br><span class="line">	dfs(0);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>全排列</tag>
      </tags>
  </entry>
  <entry>
    <title>容斥原理</title>
    <url>/posts/bb1025ee.html</url>
    <content><![CDATA[<p>今天学习了容斥原理，感觉智商又一次遭到了蹂躏（eoe），百度了CSDN上面的讲解，感觉讲的都不是很详细（或许真的是我笨吧，哎~），还是结合题目来讲吧，上题：</p>
<p>I - Co-prime </p>
<p>Given a number N, you are asked to count the number of integers between A and B inclusive which are relatively prime to N.<br>Two integers are said to be co-prime or relatively prime if they have no common positive divisors other than 1 or, equivalently, if their greatest common divisor is 1. The number 1 is relatively prime to every integer. </p>
<p>Input</p>
<pre><code>The first line on input contains T (0 &lt; T &lt;= 100) the number of test cases, each of the next T lines contains three integers A, B, N where (1 &lt;= A &lt;= B &lt;= 10^15) and (1 &lt;=N &lt;= 10^9).
</code></pre><p>Output</p>
<pre><code>For each test case, print the number of integers between A and B inclusive which are relatively prime to N. Follow the output format below.
</code></pre><p>Sample Input</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">10</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">15</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>Sample Output</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Case #<span class="number">1</span>: <span class="number">5</span></span><br><span class="line">Case #<span class="number">2</span>: <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>Hint</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">In the first test <span class="keyword">case</span>, the five integers in range [<span class="number">1</span>,<span class="number">10</span>] which are relatively prime to <span class="number">2</span> are &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>&#125;. </span><br></pre></td></tr></table></figure>
<p>题目的意思给定一个区间的左端点和右端点，再给你一个数，求在这个区间里面和这个数互质的数的个数，只要您不是初学者就应该知道这么10^15如此大区间不可能去遍历它，这时候就要用到容斥原理了，接下来是重点（。。敲黑板。。），注意看！！</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>举个例子，如何把一个区间中2，3，5的的倍数全部筛掉，假如区间是1-20，我们先筛2的倍数，那么筛掉的数量就是20/2=10，同理筛3的倍数筛掉的数量就是20/3（注意向下取整），5同理，ok，筛完了，但是实际上答案是不对的，细心的你一定发现了，2和3的乘积6被多次筛选了，同理2和5，3和5也被多次筛选了，因此我们还要把6，10，15的倍数再减一遍，然后我们再去找2，3，5的乘积筛了几遍，上面我们单独筛2，3，5的时候我们是把2，3，5的乘积筛了3遍，之后又筛选两两乘积的时候又筛了三遍，因为单独筛选时用的是加法，而两两乘积的筛选用的是减法，这就导致了2，3，5的乘积实际上一次没有筛，所以我们最后还要加上2，3，5的乘积的筛选个数，什么？看不懂，行，给你画图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/20200703230236206.png" alt=""></p>
<p>其实就是求图形的面积，我们第一次加上了2，3，5的3个大圆面积，之后又减去了6，10，15的3个椭圆的面积，而最中间的小圆相当于一次没加，最后加上就行了，然后我们会发现，出现奇数个数，就用加法，偶数个数用减法。</p>
<p>最后的式子是这样的：k / 2 + k / 3 + k / 5 - k / (2 <em> 3) - k / (3 </em> 5) - k / (2 <em> 5) + k / (2 </em> 3 * 5)是不是很简单呢（qwq）</p>
<h2 id="分析题解"><a href="#分析题解" class="headerlink" title="分析题解"></a>分析题解</h2><p>ok，讲完了容斥的原理，接下来就能做题了，题目要求区间段内与k互质的个数，就是求区间段内与k不互质的个数，然后再用区间长度减去这个数就行了，求[l,r]中与k不互质的个数，就是求[1,r]-[1,l-1]（一定注意是l-1，因为包括l），理清了思路，就可以敲代码了</p>
<h2 id="分解质因子的代码"><a href="#分解质因子的代码" class="headerlink" title="分解质因子的代码"></a>分解质因子的代码</h2><p>上面忘了说要筛掉一个区间中与k不互质的个数，首先要把k分解成质因子，首先应该知道任何一个数要不是质数，要不是可以由多个质数相乘得到，例如：10=2 <em> 5, 30=2 </em> 3 <em> 5 , 50=2 </em> 5 * 5，利用这个性质，就可以分解了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i*i&lt;=k;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(k%i==<span class="number">0</span>)&#123;</span><br><span class="line">        p[++tail]=i;  <span class="comment">//p就是储存质因子的数组</span></span><br><span class="line">        <span class="keyword">while</span>(k%i==<span class="number">0</span>) k/=i;  <span class="comment">//把k中所有i的质因子全部除去</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(k&gt;<span class="number">1</span>) p[++tail]=k;  <span class="comment">//最后如果大于一，则最后一个数一定是质因子，这一步可能有一点难理解，可以多想想</span></span><br></pre></td></tr></table></figure>
<h2 id="实现容斥定理的代码"><a href="#实现容斥定理的代码" class="headerlink" title="实现容斥定理的代码"></a>实现容斥定理的代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">fun</span><span class="params">(<span class="type">long</span> <span class="type">long</span> x)</span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> res=<span class="number">0</span>;  <span class="comment">//res储存的是1-x中与K不互质的数量 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;(<span class="number">1</span>&lt;&lt;tail);i++)&#123;  <span class="comment">//这里的1&lt;&lt;tail是指2的tail次方，表示tail个质因子有多少种组合情况 </span></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> cur=<span class="number">1</span>,cnt=<span class="number">0</span>;  <span class="comment">//cur表示在当前选中的质因子中的乘积，cnt表示当前选中的数量是奇数还是偶数 </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;tail;j++)&#123;  <span class="comment">//这个循环是枚举tail的二进制形式 </span></span><br><span class="line">            <span class="keyword">if</span>((i&gt;&gt;j)&amp;<span class="number">1</span>)&#123;  <span class="comment">//这个是判断i的第j位是不是1，如果是则表示选中第j个数 </span></span><br><span class="line">                cnt++;  <span class="comment">//表示选中了几个数，每选中一个就加一 </span></span><br><span class="line">                cur*=p[j+<span class="number">1</span>];  <span class="comment">//选中第j个数就用cur乘以第j个质因子数，注意质因子数组是从1开始的，所以要加一 </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt&amp;<span class="number">1</span>) res+=x/cur;  <span class="comment">//如果cnt是偶数就相加 </span></span><br><span class="line">        <span class="keyword">else</span> res-=x/cur;  <span class="comment">//奇数就相减 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x-res;  <span class="comment">//res储存的是1-x中与K不互质的数量，所以要用x-res得到互质的数量 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一段代码我觉得好难理解，尤其是我在网上查资料感觉讲的不是很详细，想了一下午，才茅塞顿开，因此我希望广大网友在这里能够少花时间，代码里的（1&lt;&lt;tail）<br>实际上就是2^tail，表示n个质因子的组合情况数，需要说明这里面包括空集，所以循环从条件是小于而不是小于等于，然后每一个i的二进制形式每一位要不是1要不是0，而1&lt;&lt;tail<br>的二进制形式位数正好等于质因子数，我们就把每一位数字用1表示选中，0表示没有选中，那么我们遍历二进制的每一位数，如果是1，设这是第n位数（从左到右数），就类乘第n个质因子数，最后判断选中了多少位，如果是偶数就加，否则减，然后就完成了，二进制这一段代码确实比较难以理解，不过只要仔细想一想还是能想通的（加油）</p>
<p>然后就结束了，贴一下AC代码吧</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> p[<span class="number">1000000</span>];</span><br><span class="line"><span class="type">int</span> tail;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">fun</span><span class="params">(<span class="type">long</span> <span class="type">long</span> x)</span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;(<span class="number">1</span>&lt;&lt;tail);i++)&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> cur=<span class="number">1</span>,cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;tail;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((i&gt;&gt;j)&amp;<span class="number">1</span>)&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                cur*=p[j+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt&amp;<span class="number">1</span>) res+=x/cur;</span><br><span class="line">        <span class="keyword">else</span> res-=x/cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x-res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> t,times=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        tail=<span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> l,r,k;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r&gt;&gt;k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i*i&lt;=k;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(k%i==<span class="number">0</span>)&#123;</span><br><span class="line">                p[++tail]=i;</span><br><span class="line">                <span class="keyword">while</span>(k%i==<span class="number">0</span>) k/=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k&gt;<span class="number">1</span>) p[++tail]=k;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans=fun(r)-fun(l<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: %lld\n&quot;</span>,++times,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果有不懂的，留下评论，我会按时解答的哦</p>
<blockquote>
<p>告诉你一个小秘密，点击下方的赏字，就能够赞助我了哦（乖乖的说）</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>筛选素数的n种方法</title>
    <url>/posts/fe6d75ae.html</url>
    <content><![CDATA[<blockquote>
<h1 id="暴力筛选"><a href="#暴力筛选" class="headerlink" title="暴力筛选"></a>暴力筛选</h1><p>这种方法我就不多说了，一个数是素数则其只能被1和它本身整除，抓住这个特性，从2开始遍历到这个数减1，如果该数能整除其中任意一个数，则其都不是素数，如果想筛选某个范围内的，则遍历这个区间，从左端点遍历到右端点，该数是素数则将其标记为0，遍历完以后，数组中是0的就是合数，非0是素数，时间复杂度On^2</p>
</blockquote>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 判断一个数是不是质数</span><br><span class="line">    for(int i=2;i&lt;n;i++)&#123;</span><br><span class="line">        if(n%i==0)&#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">筛选一个区间的质数</span><br><span class="line">    memset(arr,1,sizeof arr);</span><br><span class="line">    for(int j=x;j&lt;=y;j++)&#123;</span><br><span class="line">        for(int i=2;i&lt;n;i++)&#123;</span><br><span class="line">            if(n%i==0)&#123;</span><br><span class="line">                arr[j]=0;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">arr[i]=1则是质数否则是合数</span><br></pre></td></tr></table></figure>
<ul>
<li><h2 id="稍加优化"><a href="#稍加优化" class="headerlink" title="稍加优化"></a>稍加优化</h2>对于一个数其因子一定是成对出现的，例如8的一对因子就是2和4，因此如果这个数能被2整除则不用判断能否被4整除了，对于一个合数来说这个性质没什么用，因为判断到能整除2就直接break了，但若该数是一个质数呢？那就会把该数从头到尾都遍历一遍，假若数据很大时，这是非常消耗时间的，我们就可以利用因子成对的性质，遍历到根号n，为什么是根号n，举个例子，25，一对因子对是5 5，5相当于一个分界线，其他的因子一定一个大一个小，这样就优化了这个算法，时间复杂度是On^3/2</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for(int i=2;i*i&lt;=n;i++)&#123; //注意这里判断条件是&lt;=</span><br><span class="line">    if(n%i==0)&#123;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h1 id="素筛"><a href="#素筛" class="headerlink" title="素筛"></a>素筛</h1><p>注意：素筛必须从1开始筛，实质上是一个打表</p>
</blockquote>
<ul>
<li><h2 id="埃式筛"><a href="#埃式筛" class="headerlink" title="埃式筛"></a>埃式筛</h2>学习素筛之前我们要知道一个任意一个合数都可以转换成为一个质数和某个数的乘积，例如25可以转换成5<em>5，偶数可以转换成2</em>a，这样我们其实可以利用这个性质将一个区间内的所有质数的倍数都标记一下，被标记的数就是合数，剩下的就是质数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int p[1000]; //p数组用来存储质数</span><br><span class="line">void prime()</span><br><span class="line">&#123;</span><br><span class="line">    vis[1]=1; //1不是质数</span><br><span class="line">    for(int i=2;i&lt;=n;i++)&#123; //n是筛选的范围</span><br><span class="line">        if(!vis[i])&#123;</span><br><span class="line">            p[++cnt]=i; //存储质数</span><br><span class="line">            for(int j=2*i;j&lt;=n;j+=i)&#123;  //这里可以有一个优化，j=2*i</span><br><span class="line">                vis[j]=1; //标记质数的倍数</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><h2 id="欧拉筛"><a href="#欧拉筛" class="headerlink" title="欧拉筛"></a>欧拉筛</h2>上面讲的埃式筛有一个非常大的缺陷，就是会重复标记，例如12，我们首先用2的6倍标记了它，之后又用了3的4倍再次标记，这样就造成了时间的浪费，而素筛本身就是因为时间上的优化才出现的，因此这点必须优化，因此出现了欧拉筛，欧拉筛就是为了解决重复标记的问题</li>
</ul>
<p>对于vis[i*p[j]] = 1 的解释： 这里不是用i的倍数来消去合数，而是把 p里面纪录的素数，升序来当做要消去合数的最小素因子。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int vis[maxn],p[maxn/10]; //质数密度不大，除以10可以减少空间浪费</span><br><span class="line">int cnt=0;</span><br><span class="line">void prime()</span><br><span class="line">&#123;</span><br><span class="line">    vis[1]=1;</span><br><span class="line">    for(int i=2;i&lt;=maxn;i++)&#123;</span><br><span class="line">        if(!vis[i]) p[++cnt]=i;</span><br><span class="line">        for(int j=1;j&lt;=cnt&amp;&amp;i&lt;=maxn/p[j];j++)&#123;</span><br><span class="line">            vis[i*p[j]]=1;</span><br><span class="line">            if(i%p[j]==0) break; //核心代码，如果i能整除这个质数则跳出循环</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">对于 i%p[j] == 0 就break的解释 ：当 i是[j]的倍数时，i = kp[j]，如果继续运算 j+1，i * p[j+1] = p[j] * k p[j+1]，这里p[j]是最小的素因子，当i = k * p[j+1]时会重复，所以才跳出循环。</span><br><span class="line">举个例子 ：i = 8 ，j = 1，p[j] = 2，如果不跳出循环，p[j+1] = 3，8 * 3 = 2 * 4 * 3 = 2 * 12，在i = 12时会计算。因为欧拉筛法的原理便是通过最小素因子来消除。</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>简单三维DFS搜索</title>
    <url>/posts/bfeaea3b.html</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2102">problem link</a><br>可怜的公主在一次次被魔王掳走一次次被骑士们救回来之后，而今，不幸的她再一次面临生命的考验。魔王已经发出消息说将在T时刻吃掉公主，因为他听信谣言说吃公主的肉也能长生不老。年迈的国王正是心急如焚，告招天下勇士来拯救公主。不过公主早已习以为常，她深信智勇的骑士LJ肯定能将她救出。<br>现据密探所报，公主被关在一个两层的迷宫里，迷宫的入口是S（0，0，0），公主的位置用P表示，时空传输机用#表示，墙用<em>表示，平地用.表示。骑士们一进入时空传输机就会被转到另一层的相对位置，但如果被转到的位置是墙的话，那骑士们就会被撞死。骑士们在一层中只能前后左右移动，每移动一格花1时刻。层间的移动只能通过时空传输机，且不需要任何时间。<br><code>Input</code><br>输入的第一行C表示共有C个测试数据，每个测试数据的前一行有三个整数N，M，T。 N，M迷宫的大小NM（1 &lt;= N,M &lt;=10)。T如上所意。接下去的前NM表示迷宫的第一层的布置情况，后NM表示迷宫第二层的布置情况。<br><code>Output</code><br>如果骑士们能够在T时刻能找到公主就输出“YES”，否则输出“NO”。<br><code>Sample Input</code><br>1<br>5 5 14<br>S#</em>.<br>.#…<br>…<br><em>**</em>.<br>…#.   </p>
<p>….P   </p>
<h1 id="…"><a href="#…" class="headerlink" title=".…"></a>.…</h1><p><em>*…<br>….   
</em>.#…<br><code>Sample Output</code><br>YES</p>
<p>解题思路：类似于三维空间，但完全可以用二维数组做，标记一下在哪一层就可以了。注意两层同一位置都是传输机的情况，可能会造成无限循环。</p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int ex,ey,ez;</span><br><span class="line">int n,m,t,flag,T;</span><br><span class="line">int d[4][2]=&#123;1,0,-1,0,0,-1,0,1&#125;;</span><br><span class="line">int vis[15][15][15];</span><br><span class="line">char a[15][15][15];</span><br><span class="line">void dfs(int x,int y,int z,int step)&#123;</span><br><span class="line">	if(flag) return ;</span><br><span class="line">	if(x==ex&amp;&amp;y==ey&amp;&amp;z==ez)&#123;</span><br><span class="line">		if(step&lt;=T)&#123;</span><br><span class="line">			flag=1;</span><br><span class="line">		&#125;</span><br><span class="line">		return ;</span><br><span class="line">	&#125;</span><br><span class="line">	if(step&gt;=T) return ;</span><br><span class="line">	for(int i=0;i&lt;4;i++)&#123;</span><br><span class="line">		int dx=x+d[i][0];</span><br><span class="line">		int dy=y+d[i][1];</span><br><span class="line">		int dz=z;</span><br><span class="line">		if(dx&gt;=0&amp;&amp;dx&lt;n&amp;&amp;dy&gt;=0&amp;&amp;dy&lt;m&amp;&amp;!vis[dz][dx][dy]&amp;&amp;a[dz][dx][dy]!=&#x27;*&#x27;)&#123;</span><br><span class="line">			vis[dz][dx][dy]=1;</span><br><span class="line">			if(a[dz][dx][dy]==&#x27;#&#x27;)&#123;</span><br><span class="line">				vis[abs(dz-1)][dx][dy]=1;</span><br><span class="line">				dfs(dx,dy,abs(dz-1),step+1);</span><br><span class="line">				vis[abs(dz-1)][dx][dy]=0;</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				dfs(dx,dy,dz,step+1);</span><br><span class="line">			&#125;</span><br><span class="line">			vis[dz][dx][dy]=0;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int t;</span><br><span class="line">	cin&gt;&gt;t;</span><br><span class="line">	while(t--)&#123;</span><br><span class="line">		memset(vis,0,sizeof(vis));</span><br><span class="line">		flag=0;</span><br><span class="line">		cin&gt;&gt;n&gt;&gt;m&gt;&gt;T;</span><br><span class="line">		for(int i=0;i&lt;2;i++)&#123;</span><br><span class="line">			for(int j=0;j&lt;n;j++)&#123;</span><br><span class="line">				for(int k=0;k&lt;m;k++)&#123;</span><br><span class="line">					cin&gt;&gt;a[i][j][k];</span><br><span class="line">					if(a[i][j][k]==&#x27;P&#x27;)&#123;</span><br><span class="line">						ex=j,ey=k,ez=i;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">			for(int j=0;j&lt;m;j++)&#123;</span><br><span class="line">				if(a[0][i][j]==&#x27;#&#x27;&amp;&amp;a[1][i][j]==&#x27;#&#x27;)&#123;//两边都是#的情况 ，会造成无限循环 </span><br><span class="line">					vis[0][i][j]=vis[1][i][j]=1;</span><br><span class="line">				&#125;</span><br><span class="line">				if(a[0][i][j]==&#x27;*&#x27;&amp;&amp;a[1][i][j]==&#x27;#&#x27;)&#123;</span><br><span class="line">					vis[0][i][j]=vis[1][i][j]=1;</span><br><span class="line">				&#125;</span><br><span class="line">				if(a[0][i][j]==&#x27;#&#x27;&amp;&amp;a[1][i][j]==&#x27;*&#x27;)&#123;</span><br><span class="line">					vis[0][i][j]=vis[1][i][j]=1;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		dfs(0,0,0,0);</span><br><span class="line">		if(flag) cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;</span><br><span class="line">		else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>十字链表存储稀疏矩阵</title>
    <url>/posts/f0a66312.html</url>
    <content><![CDATA[<blockquote>
<p>课程设计</p>
<p><strong>问题描述:</strong>    用十字链表存储稀疏矩阵，实现两个可进行矩阵之间的乘法运算。 </p>
<p><strong>基本要求:</strong> （1）要对两个矩阵能否进行乘法进行判断。（2）对能够进行乘法运算的稀疏矩阵进行乘法运算并输出正确的结果。</p>
</blockquote>
<p><a href="https://blog.csdn.net/zhuyi2654715/article/details/6729783"><strong>参考博客</strong></a></p>
<h2 id="大致思路"><a href="#大致思路" class="headerlink" title="大致思路"></a>大致思路</h2><p>一般矩阵中会有很多值为0的元素，十字链表把这些值给忽略掉了，只存有值不为0的元素，每一行都是一个链表，每一列也是一个链表，用一个行指针、一个列指针指向它们，形成矩阵形式</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">OLNode</span>&#123;</span>  <span class="comment">//元素类型</span></span><br><span class="line">	<span class="type">int</span> row,col;  <span class="comment">//行列</span></span><br><span class="line">	ElemType val;  <span class="comment">//数值</span></span><br><span class="line">	OLNode *right,*down;  <span class="comment">//行指针、列指针</span></span><br><span class="line">&#125;*OLink; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CrossList</span>&#123;</span>  <span class="comment">//矩阵结构</span></span><br><span class="line">	<span class="type">int</span> n,m,num;</span><br><span class="line">	OLink *Rhead,*Chead;  <span class="comment">//指向行链表、列链表的指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="初始化指针"><a href="#初始化指针" class="headerlink" title="初始化指针"></a>初始化指针</h2><p>每次都要先把矩阵指针置为空</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitCrossList</span><span class="params">(CrossList &amp;CL)</span>&#123;</span><br><span class="line">	CL.n=CL.m=CL.num=<span class="number">0</span>;</span><br><span class="line">	CL.Rhead=CL.Chead=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="销毁链表"><a href="#销毁链表" class="headerlink" title="销毁链表"></a>销毁链表</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DestroyCrossList</span><span class="params">(CrossList CL)</span>&#123;</span><br><span class="line">	<span class="type">int</span> n=CL.n,m=CL.m;</span><br><span class="line">	OLink temp;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		OLink p=CL.Rhead[i];</span><br><span class="line">		<span class="keyword">while</span>(p)&#123;</span><br><span class="line">			temp=p;</span><br><span class="line">			delete temp;</span><br><span class="line">			p=p-&gt;right;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	delete CL.Rhead;</span><br><span class="line">	delete CL.Chead;</span><br><span class="line">	CL.Rhead=<span class="literal">NULL</span>;</span><br><span class="line">	CL.Chead=<span class="literal">NULL</span>;</span><br><span class="line">	CL.n=CL.m=CL.num=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建链表"><a href="#创建链表" class="headerlink" title="创建链表"></a>创建链表</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CreateCrossList</span><span class="params">(CrossList &amp;CL)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(CL.Rhead) DestroyCrossList(CL);  <span class="comment">//矩阵不为空先销毁</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入十字链表的行数、列数、非零元个数(空格隔开):\n&quot;</span>;</span><br><span class="line">	<span class="type">int</span> n,m,num;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;num)&#123;  </span><br><span class="line">		<span class="keyword">if</span>(n&gt;=<span class="number">1</span> &amp;&amp; m&gt;=<span class="number">1</span> &amp;&amp; num&gt;=<span class="number">1</span> &amp;&amp; num&lt;=n*m) <span class="keyword">break</span>;  <span class="comment">//行数列数不能小于1，非零元个数不能大于矩阵最大容纳量</span></span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;输入有误，请重新输入:\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	CL.n=n; CL.m=m; CL.num=num;  <span class="comment">//矩阵行数，列数，非零元个数</span></span><br><span class="line">	CL.Rhead=new OLink[m+<span class="number">1</span>];  <span class="comment">//给每一行分配链表</span></span><br><span class="line">	<span class="keyword">if</span>(!CL.Rhead)&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;内存不足\n&quot;</span>;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	CL.Chead=new OLink[n+<span class="number">1</span>];  <span class="comment">//给每一列分配链表</span></span><br><span class="line">	<span class="keyword">if</span>(!CL.Chead) &#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;内存不足\n&quot;</span>;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) CL.Rhead[i]=<span class="literal">NULL</span>;  <span class="comment">//初始化为空</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) CL.Chead[i]=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">		<span class="type">int</span> row,col,val;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入第&quot;</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot;个非零元的横坐标、纵坐标、不为0的值(空格隔开):\n&quot;</span>;</span><br><span class="line">		<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;row&gt;&gt;col&gt;&gt;val)&#123;</span><br><span class="line">			<span class="keyword">if</span>(row&gt;=<span class="number">1</span> &amp;&amp; row&lt;=n &amp;&amp; col&gt;=<span class="number">1</span> &amp;&amp; col&lt;=m &amp;&amp; val) <span class="keyword">break</span>;  <span class="comment">//坐标不能超出矩阵，值不能为0</span></span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;输入有误，请重新输入:\n&quot;</span>;</span><br><span class="line">		&#125; </span><br><span class="line">		OLink p=new OLNode;</span><br><span class="line">		<span class="keyword">if</span>(!p)&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;内存不足\n&quot;</span>;</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		p-&gt;row=row; p-&gt;col=col; p-&gt;val=val;</span><br><span class="line">		<span class="keyword">if</span>(CL.Rhead[row]==<span class="literal">NULL</span> || CL.Rhead[row]-&gt;col&gt;col)&#123;</span><br><span class="line">			p-&gt;right=CL.Rhead[row];</span><br><span class="line">			CL.Rhead[row]=p;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			OLink j;</span><br><span class="line">			<span class="keyword">for</span>(j=CL.Rhead[row];j-&gt;right &amp;&amp; j-&gt;right-&gt;col&lt;=col;j=j-&gt;right);  <span class="comment">//找到插入位置</span></span><br><span class="line">			<span class="keyword">if</span>(j-&gt;col==col)&#123;  <span class="comment">//当当前坐标有值时覆盖它</span></span><br><span class="line">				j-&gt;val=val;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			p-&gt;right=j-&gt;right;</span><br><span class="line">			j-&gt;right=p;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(CL.Chead[col]==<span class="literal">NULL</span> || CL.Chead[col]-&gt;row&gt;row)&#123;</span><br><span class="line">			p-&gt;down=CL.Chead[col];</span><br><span class="line">			CL.Chead[col]=p;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			OLink j;</span><br><span class="line">			<span class="keyword">for</span>(j=CL.Chead[col];j-&gt;down &amp;&amp; j-&gt;down-&gt;row&lt;row;j=j-&gt;down);  <span class="comment">//找到插入位置</span></span><br><span class="line">			p-&gt;down=j-&gt;down;</span><br><span class="line">			j-&gt;down=p;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="打印链表"><a href="#打印链表" class="headerlink" title="打印链表"></a>打印链表</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PrintCrossList</span><span class="params">(CrossList CL)</span>&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;------------------------\n&quot;</span>;</span><br><span class="line">	<span class="type">int</span> n=CL.n,m=CL.m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;第&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;行元素:  &quot;</span>;</span><br><span class="line">		OLink p=CL.Rhead[i];</span><br><span class="line">		<span class="keyword">if</span>(p)&#123;</span><br><span class="line">			<span class="keyword">while</span>(p)&#123;</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;p-&gt;val&lt;&lt;<span class="string">&quot;(&quot;</span>&lt;&lt;p-&gt;row&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;p-&gt;col&lt;&lt;<span class="string">&quot;)&quot;</span>&lt;&lt;<span class="string">&quot;  &quot;</span>;</span><br><span class="line">				p=p-&gt;right;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;空&quot;</span>;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;第&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;列元素:  &quot;</span>;</span><br><span class="line">		OLink p=CL.Chead[i];</span><br><span class="line">		<span class="keyword">if</span>(p)&#123;</span><br><span class="line">			<span class="keyword">while</span>(p)&#123;</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;p-&gt;val&lt;&lt;<span class="string">&quot;(&quot;</span>&lt;&lt;p-&gt;row&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;p-&gt;col&lt;&lt;<span class="string">&quot;)&quot;</span>&lt;&lt;<span class="string">&quot;  &quot;</span>;</span><br><span class="line">				p=p-&gt;down;</span><br><span class="line">			&#125;	</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;空&quot;</span>;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;------------------------\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="矩阵相乘"><a href="#矩阵相乘" class="headerlink" title="矩阵相乘"></a>矩阵相乘</h2><p>这里用一个二维数组去存了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">multiCrossList</span><span class="params">(CrossList CL1,CrossList CL2)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(CL1.m!=CL2.n)&#123;</span><br><span class="line">    	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;矩阵无法相乘\n&quot;</span>;</span><br><span class="line">    	<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=CL1.n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=CL2.m;j++)&#123;</span><br><span class="line">			<span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">			OLink p=CL1.Rhead[i];</span><br><span class="line">			<span class="keyword">while</span>(p)&#123;</span><br><span class="line">				OLink q=CL2.Chead[j];</span><br><span class="line">				<span class="keyword">while</span>(q &amp;&amp; q-&gt;row&lt;p-&gt;col)&#123;</span><br><span class="line">					q=q-&gt;down;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span>(q &amp;&amp; q-&gt;row==p-&gt;col)&#123;</span><br><span class="line">					<span class="built_in">cout</span>&lt;&lt;p-&gt;val&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;q-&gt;val&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">					num+=p-&gt;val*q-&gt;val;</span><br><span class="line">				&#125;</span><br><span class="line">				p=p-&gt;right;</span><br><span class="line">			&#125; </span><br><span class="line">			mat[i][j]=num;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	CrossList CL1,CL2;</span><br><span class="line">	InitCrossList(CL1);</span><br><span class="line">	InitCrossList(CL2);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;创建矩阵1:\n&quot;</span>;</span><br><span class="line">	CreateCrossList(CL1); </span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;创建矩阵2:\n&quot;</span>;</span><br><span class="line">	CreateCrossList(CL2);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\n创建矩阵1如下:\n&quot;</span>;</span><br><span class="line">	PrintCrossList(CL1);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\n创建矩阵2如下:\n&quot;</span>;</span><br><span class="line">	PrintCrossList(CL2);</span><br><span class="line">	multiCrossList(CL1,CL2);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\n相乘后矩阵:\n&quot;</span>;</span><br><span class="line">	PrintResult();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试数据"><a href="#测试数据" class="headerlink" title="测试数据"></a>测试数据</h2><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">2 2 2</span><br><span class="line">1 1 1</span><br><span class="line">2 2 2</span><br><span class="line">2 3 5</span><br><span class="line">1 1 1</span><br><span class="line">1 2 2</span><br><span class="line">1 3 1</span><br><span class="line">2 1 3</span><br><span class="line">2 3 -1</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">2</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">1</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">0</td>
<td style="text-align:center">-1</td>
</tr>
</tbody>
</table>
</div>
<p>结果</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">1</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数独</title>
    <url>/posts/def1d7a0.html</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>题目描述</p>
<p>数独是根据9×9盘面上的已知数字，推理出所有剩余空格的数字，并满足每一行、每一列、每一个粗线宫内的数字均含1-9，不重复。每一道合格的数独谜题都有且仅有唯一答案，推理方法也以此为基础，任何无解或多解的题目都是不合格的。</p>
<p>芬兰一位数学家号称设计出全球最难的“数独游戏”，并刊登在报纸上，让大家去挑战。</p>
<p>这位数学家说，他相信只有“智慧最顶尖”的人才有可能破解这个“数独之谜”。</p>
<p>据介绍，目前数独游戏的难度的等级有一道五级，一是入门等级，五则比较难。不过这位数学家说，他所设计的数独游戏难度等级是十一，可以说是所以数独游戏中，难度最高的等级他还表示，他目前还没遇到解不出来的数独游戏，因此他认为“最具挑战性”的数独游戏并没有出现。<br>输入格式</p>
<p>一个未填的数独</p>
<p>输出格式</p>
<p>填好的数独</p>
<p>输入输出样例</p>
<p>输入 #1</p>
<p>8 0 0 0 0 0 0 0 0 </p>
<p>0 0 3 6 0 0 0 0 0 </p>
<p>0 7 0 0 9 0 2 0 0 </p>
<p>0 5 0 0 0 7 0 0 0 </p>
<p>0 0 0 0 4 5 7 0 0 </p>
<p>0 0 0 1 0 0 0 3 0 </p>
<p>0 0 1 0 0 0 0 6 8 </p>
<p>0 0 8 5 0 0 0 1 0 </p>
<p>0 9 0 0 0 0 4 0 0</p>
<p>输出 #1</p>
<p>8 1 2 7 5 3 6 4 9 </p>
<p>9 4 3 6 8 2 1 7 5 </p>
<p>6 7 5 4 9 1 2 8 3 </p>
<p>1 5 4 2 3 7 8 9 6 </p>
<p>3 6 9 8 4 5 7 2 1 </p>
<p>2 8 7 1 6 9 5 3 4 </p>
<p>5 2 1 9 7 4 3 6 8 </p>
<p>4 3 8 5 2 6 9 1 7 </p>
<p>7 9 6 3 1 8 4 5 2</p>
<h2 id="Code："><a href="#Code：" class="headerlink" title="Code："></a>Code：</h2><pre><code>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cstdlib&gt;
#include&lt;iostream&gt;
using namespace std;
int map[10][10];
bool row[10][10],col[10][10],g[10][10];//行，列，第几个格子
void print()
&#123;
    for(int i=1;i&lt;=9;i++)
    &#123;
        for(int j=1;j&lt;=9;j++)
            printf(&quot;%d &quot;,map[i][j]);
        printf(&quot;\n&quot;);
    &#125;
    exit(0);
&#125;
void dfs(int x,int y)//深搜 
&#123;
  if(map[x][y]!=0)//9*9中不为零的数直接跳过 
  &#123;
      if(x==9&amp;&amp;y==9) 
          print();//搜索结束后输出 
      if(y==9) //行到顶端后搜索列 
          dfs(x+1,1); 
      else //搜索行 
          dfs(x,y+1);
  &#125;
  if(map[x][y]==0)//等于零时 
  &#123;
      for(int i=1;i&lt;=9;i++)
      &#123; 
          if(!row[x][i]&amp;&amp;!col[y][i]&amp;&amp;!g[(x-1)/3*3+(y-1)/3+1][i])
          &#123;
              map[x][y]=i;
              row[x][i]=1;
              col[y][i]=1;
              g[(x-1)/3*3+(y-1)/3+1][i]=1;
              if(x==9&amp;&amp;y==9)                 
                  print();
              if(y==9) dfs(x+1,1); else dfs(x,y+1);
              map[x][y]=0;
              row[x][i]=0;
              col[y][i]=0;
              g[(x-1)/3*3+(y-1)/3+1][i]=0;
          &#125;
      &#125; 
  &#125;
&#125;
int main()
&#123;
    for(int i=1;i&lt;=9;i++)
    &#123;
        for(int j=1;j&lt;=9;j++)
        &#123;
            scanf(&quot;%d&quot;,&amp;map[i][j]);
            if(map[i][j]&gt;0)
            &#123;
                row[i][map[i][j]]=1;
                col[j][map[i][j]]=1; 
                g[(i-1)/3*3+(j-1)/3+1][map[i][j]]=1;
            &#125;
        &#125;
    &#125; 
    dfs(1,1);
    return 0;
&#125;
</code></pre><h2 id="教训"><a href="#教训" class="headerlink" title="教训"></a>教训</h2><p>一定明白一个概念递归不是之后的代码就不执行了，在dfs函数中调用dfs之后后面的代码还是会执行的！dfs输出一定要写在出口那里，不能写在main函数中，注意3*3的格子中也要符合1到9唯一性</p>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>数论的一些基本定理</title>
    <url>/posts/5f67ec8b.html</url>
    <content><![CDATA[<h2 id="欧几里得定理"><a href="#欧几里得定理" class="headerlink" title="欧几里得定理"></a>欧几里得定理</h2><p>其实就是求gcd的辗转相除法，gcd(a,b)==gcd(a-b,b)，由此可以把a中的b全部拿掉，gcd(a,b)==gcd(a%b,b)， ~a是大于b的~<br>gcd(a,b)==gcd(b,a%b)</p>
<h2 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h2><p><a href="https://blog.csdn.net/qq_37493070/article/details/81988725">具体证明点击我</a><br>X(N)==N <em> (1/p1) </em> (1/p2) <em> (1/p3) </em>… *(1/pn)(pi为N的质因子)   </p>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ol>
<li><p><strong>对于任意一个质数 p ,φ(n)=n−1</strong></p>
<font color="red">因为n为质数,与他互质的个数就是 n-1</font>
</li>
<li><p><strong>当 gcd(n,m)=1时,φ(nm)=φ(n)φ(m)</strong></p>
<font color="red">因为φ(n)是积性函数。 积性函数指对于所有互质的整数a和b有性质f(ab)=f(a)f(b)的数论函数。</font>
</li>
<li><p><strong>若 n=p^k^ 其中p为质数,则φ(n)=p^k^−p^k−1^=(p−1)p^k−1^</strong></p>
<font color="red">1→n中除了p的倍数，都与p^k^互质,1→n中p倍数的个数为 p^k^÷p=p^k−1^</font>
</li>
<li><p><strong>所有小于n与n互质个数的和sum=n × φ(n)/2</strong></p>
<p><a href="https://www.cnblogs.com/justPassBy/p/4489351.html">推导点击我</a></p>
</li>
<li><p><strong>如果 i mod p=0,其中p为质数,则 φ(i ∗ p)=p ∗ φ(i),否则φ(i ∗ p)=(p−1)φ(i)</strong></p>
</li>
<li><p><strong>n=∑d|nφ(d) (d|n)指n是d的倍数</strong></p>
</li>
<li><p><strong>当 N &gt; 2 时，φ( N )是偶数</strong></p>
<h2 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h2></li>
</ol>
<p><strong>对于互质的整数a,m,有 a^φ(m)^≡1 (mod m)。</strong></p>
<h2 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h2><p><strong>费马小定理(Fermat’s little theorem)是数论中的一个重要定理，在1636年提出。如果p是一个质数，而整数a不是p的倍数，则有a^（p-1）≡1（mod p）</strong></p>
<p>主要应用于求高阶次幂对某个数求余数，<a href="https://baike.baidu.com/item/%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86/4776158?fr=aladdin">点击我</a></p>
<h2 id="逆元"><a href="#逆元" class="headerlink" title="逆元"></a>逆元</h2><p><strong>a^(m-1)^=1(mod m), a * a^(m-2)^=1(mod m)，所以a的逆元是：a^(m-2)^ ,当m与a互质时。</strong></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>水果</title>
    <url>/posts/481c5c0c.html</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><font color="red" size=4>

F - 水果

夏天来了~好开心啊,呵呵,好多好多水果~
Joe经营着一个不大的水果店.他认为生存之道就是经营最受顾客欢迎的水果.现在他想要一份水果销售情况的明细表,这样Joe就可以很容易掌握所有水果的销售情况了.

Input

第一行正整数N(0<N<=10)表示有N组测试数据.
每组测试数据的第一行是一个整数M(0<M<=100),表示工有M次成功的交易.其后有M行数据,每行表示一次交易,由水果名称(小写字母组成,长度不超过80),水果产地(小写字母组成,长度不超过80)和交易的水果数目(正整数,不超过100)组成.

Output

对于每一组测试数据,请你输出一份排版格式正确(请分析样本输出)的水果销售情况明细表.  这份明细表包括所有水果的产地,名称和销售数目的信息.水果先按产地分类,产地按字母顺序排列;同一产地的水果按照名称排序,名称按字母顺序排序.   
两组测试数据之间有一个空行.最后一组测试数据之后没有空行.

Sample Input

1  
5  
apple shandong 3  
pineapple guangdong 1  
sugarcane guangdong 1  
pineapple guangdong 3  
pineapple guangdong 1  

Sample Output

guangdong  
   |----pineapple(5)  
   |----sugarcane(1)  
shandong  
   |----apple(3)  
</font>

<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>map&lt;（1）,（2）&gt;，1，2不只可以是基础数据类型，还是可以自定义类型，经常用自己定义的结构体，在结构体里面还可以再定义一个map，类似循环嵌套一样，map里面是有序排列的，这样的话就是最外面的map排列优先级最高，里面也是这样，这样就可以实现排列的优先级问题，而且map有一个特点就是它的键值是唯一的，天然去重，这道题正好可能会出现同名的水果，用一般数组写的话里面的数据关系很复杂，而用map比较清晰<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxn=2e5+100;</span><br><span class="line">struct node&#123;</span><br><span class="line">	map&lt;string,int&gt; mp;  //名字（优先级低），数量</span><br><span class="line">&#125;f[110];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	map&lt;string,node&gt; mm; //地点（优先级高），第二个是一个自定义结构体，实际上是一个小map</span><br><span class="line">	map&lt;string,int&gt;::iterator mpit;</span><br><span class="line">	map&lt;string,node&gt;::iterator mmit;</span><br><span class="line">	int t; cin&gt;&gt;t;</span><br><span class="line">	while(t--)&#123;</span><br><span class="line">		mm.clear();</span><br><span class="line">		int n; cin&gt;&gt;n;</span><br><span class="line">		for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">			string name,place;</span><br><span class="line">			int cnt;</span><br><span class="line">			cin&gt;&gt;name&gt;&gt;place&gt;&gt;cnt;</span><br><span class="line">			mm[place].mp[name]+=cnt;  //这里map实现了去重操作省去了很多麻烦，直接累加就行了</span><br><span class="line">		&#125;</span><br><span class="line">		for(mmit=mm.begin();mmit!=mm.end();mmit++)&#123;</span><br><span class="line">			cout&lt;&lt;mmit-&gt;first&lt;&lt;endl;</span><br><span class="line">			for(mpit=mmit-&gt;second.mp.begin();mpit!=mmit-&gt;second.mp.end();mpit++)&#123;</span><br><span class="line">				cout&lt;&lt;&quot;   |----&quot;&lt;&lt;mpit-&gt;first&lt;&lt;&quot;(&quot;&lt;&lt;mpit-&gt;second&lt;&lt;&quot;)&quot;&lt;&lt;endl;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if(t!=0) cout&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>数论题目集(协会)</title>
    <url>/posts/816bcb91.html</url>
    <content><![CDATA[<blockquote>
<p>以下题目涉及知识有 欧拉函数、素数筛、算数基本定理（唯一分解定理）</p>
<p>因为数论之前没咋学，欧拉函数还是这两天补的，又要考试，时间不够，所以大多数都是直接搜题解做的，本来信誓旦旦好好写一些题解巩固一下的，发现越写越累，索性直接搬来别人的优质题解算了🤔</p>
</blockquote>
<font color="red">一定记得素数筛时isp数组要用bool，bool只占用一个字节，int4个会爆内存，卡死我了，我说咋一直爆内存</font>

<h2 id="Bi-shoe-and-Phi-shoe"><a href="#Bi-shoe-and-Phi-shoe" class="headerlink" title="Bi-shoe and Phi-shoe"></a>Bi-shoe and Phi-shoe</h2><p><strong>题意</strong>：<br>给定N个数，让你求欧拉函数值大于等于这N个数的的那个数的最小数值之和（这里1的欧拉函数值很特殊，设置为0，因为小于1且与1互质的数量为0）<br>例如：<br>N==2<br>1 2<br>则答案为4 == 1+3<br><strong>思路</strong><br>要求的是欧拉函数值大于等于给定数的最小数，那么我们就要让这个数对应的欧拉函数值尽可能大一点，什么情况下一个数的欧拉函数值最大呢？很明显是素数时！一个素数的欧拉函数值就等于这个数减一，从这里我们就能推出来最小的那个对应欧拉函数值~大于等于~给定数的那个数最小就是这个给定数后面的那个素数，例如： 10对应的就是11 ，12对应13 ，14对应17，11，13，17就是所要求的最小的三个数，由此思路就明确了<br><strong>思路2</strong><br>还可以用筛法求1~N的欧拉函数，然后打表每个欧拉函数值的最优解，再取和最小</p>
<h3 id="CODE-1"><a href="#CODE-1" class="headerlink" title="CODE-1"></a>CODE-1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span><br><span class="line">#define debug freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin); freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout)</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int MAXN = 1e7+10;</span><br><span class="line">const int MOD = 1e9;</span><br><span class="line">int pr[MAXN/10], tail = 0; </span><br><span class="line">bool isp[MAXN];</span><br><span class="line">void prime() &#123;  //一个素数筛</span><br><span class="line">    isp[1] = 1;</span><br><span class="line">    for (int i = 2; i &lt; MAXN; i++) &#123;</span><br><span class="line">        if (!isp[i]) pr[++tail] = i;</span><br><span class="line">        for (int j = 1; i &lt;= MAXN/pr[j]; j++) &#123;</span><br><span class="line">            isp[i * pr[j]] = 1;</span><br><span class="line">            if (i % pr[j] == 0) break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	prime();</span><br><span class="line">  int t,kase=0; cin&gt;&gt;t;</span><br><span class="line">  while(t--)&#123;</span><br><span class="line">    int n; cin&gt;&gt;n;</span><br><span class="line">    ll sum=0;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">      int x; cin&gt;&gt;x;</span><br><span class="line">      for(int j=x+1; ;j++)&#123; //找到给定数字后面的那个素数累加到sum里面</span><br><span class="line">        if(!isp[j])&#123;</span><br><span class="line">          sum+=j;</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;&quot;Case &quot;&lt;&lt;++kase&lt;&lt;&quot;: &quot;&lt;&lt;sum&lt;&lt;&quot; Xukha&quot;&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CODE-2"><a href="#CODE-2" class="headerlink" title="CODE-2"></a>CODE-2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int MAXN = 1e6+100;</span><br><span class="line">const int MOD = 1e9;</span><br><span class="line">int pr[MAXN/10],tail;</span><br><span class="line">int phi[MAXN],ans[MAXN];</span><br><span class="line">bool isp[MAXN]; </span><br><span class="line">void euler()</span><br><span class="line">&#123;</span><br><span class="line">	phi[1]=0;</span><br><span class="line">	for(int i=2;i&lt;MAXN;i++)&#123;</span><br><span class="line">		if(!isp[i])&#123;</span><br><span class="line">			pr[++tail]=i;</span><br><span class="line">			phi[i]=i-1;</span><br><span class="line">		&#125;</span><br><span class="line">		for(int j=1;j&lt;=tail&amp;&amp;i*pr[j]&lt;MAXN;j++)&#123;</span><br><span class="line">			isp[i*pr[j]]=1;</span><br><span class="line">			if(i%pr[j]==0)&#123;</span><br><span class="line">				phi[i*pr[j]]=phi[i]*pr[j];</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			else phi[i*pr[j]]=phi[i]*phi[pr[j]];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	int cur=0;</span><br><span class="line">	for(int i=2;i&lt;MAXN;i++)&#123;  //核心代码，这里一定要保证ans是递增的，因为要往后走找更大的欧拉函数值</span><br><span class="line">		if(phi[i]&gt;cur&amp;&amp;ans[phi[i]]==0)&#123; //ans下标代表欧拉函数值，储存的是该欧拉函数值对应的数字，ans[]==0起到防止相同欧拉函数值的两个数后面那个数把前面的覆盖了</span><br><span class="line">			ans[phi[i]]=i;</span><br><span class="line">			cur=phi[i]; //记得更新cur 因为要求最小的那个数字</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	ios; ll n;</span><br><span class="line">	euler();</span><br><span class="line">	int t,kase=0;</span><br><span class="line">	cin&gt;&gt;t;</span><br><span class="line">	while(t--)&#123;</span><br><span class="line">		ll sum=0;</span><br><span class="line">		int n; cin&gt;&gt;n;</span><br><span class="line">		for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">			int x; cin&gt;&gt;x;</span><br><span class="line">			for(int j=x; ;j++)&#123;</span><br><span class="line">				if(ans[j]&gt;0)&#123;</span><br><span class="line">					sum+=ans[j];</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;	</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;&quot;Case &quot;&lt;&lt;++kase&lt;&lt;&quot;: &quot;&lt;&lt;sum&lt;&lt;&quot; Xukha&quot;&lt;&lt;&#x27;\n&#x27;;</span><br><span class="line">	&#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Aladdin-and-the-Flying-Carpet"><a href="#Aladdin-and-the-Flying-Carpet" class="headerlink" title="Aladdin and the Flying Carpet"></a>Aladdin and the Flying Carpet</h2><p><strong>题意</strong><br>给出矩形面积S，和组成该矩形的边的最小值，问这种面积为S的矩形有几种<br>比如样例12 2，矩形面积为12，组成这样矩形的最小边为2，共有2种这样的矩形（2， 6），（3， 4）(这些边都大于或等于2，其中（2,6）和（6,2）是同一种)<br><strong>思路</strong><br>这道题用到了唯一分解定理：N = p1^a1^  p2^a2^ <em> p3^a3^ </em> … <em>pn^an^(其中p1、p2、… pn为N的因子，a1、a2、… 、an分别为因子的指数)<br>N的因子个数公式：     M = (1 + a1)</em> (1 + a2)<em> (1 + a3)</em> …<em>(1 + an);<br>用唯一分解定理求出ab的因子个数，但题要求的是满足条件的因子对数，所以最终所求的因子个数需要除以2，然后再将不满足的减去<br>该题要用到筛选素数来缩短时间（减少循环次数）来防止TLE<br><em>*疑问</em></em><br>两个因子可以一样啊，25 ==5 ，5，那num不是应该=(num+1)/2吗？这道题自动排除了1和数本身的情况？</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int MAXN = 1e6+5;</span><br><span class="line">bool isp[MAXN];</span><br><span class="line">int pr[MAXN/10],tail;</span><br><span class="line">int prime()&#123;</span><br><span class="line">	isp[1]=1;</span><br><span class="line">	for(int i=2;i&lt;MAXN;i++)&#123;</span><br><span class="line">		if(!isp[i]) pr[++tail]=i;</span><br><span class="line">		for(int j=1;j&lt;=tail&amp;&amp;i*pr[j]&lt;MAXN;j++)&#123;</span><br><span class="line">			isp[i*pr[j]]=1;</span><br><span class="line">			if(i%pr[j]==0) break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">ll fun(ll n)&#123; //找出n的因子数量</span><br><span class="line">	ll ans=1;</span><br><span class="line">	for(ll i=1;i&lt;=tail&amp;&amp;pr[i]*pr[i]&lt;=n;i++)&#123;</span><br><span class="line">		if(n%pr[i]==0)&#123;</span><br><span class="line">			ll e=0;</span><br><span class="line">			while(n%pr[i]==0)&#123;</span><br><span class="line">				e++;</span><br><span class="line">				n/=pr[i];</span><br><span class="line">			&#125;</span><br><span class="line">			ans*=(1+e);//算数基本定理的经典问题：求一个数的因子数量</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if(n&gt;1) ans*=2;</span><br><span class="line">	return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	prime();</span><br><span class="line">  int t,kase=0;</span><br><span class="line">  scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">  while(t--)&#123;</span><br><span class="line">    kase++;</span><br><span class="line">    ll s,a;</span><br><span class="line">    scanf(&quot;%lld%lld&quot;,&amp;s,&amp;a);</span><br><span class="line">    if(a*a&gt;s)&#123;</span><br><span class="line">        printf(&quot;Case %d: 0\n&quot;, kase);</span><br><span class="line">        continue;</span><br><span class="line">    &#125;</span><br><span class="line">    ll num=fun(s);</span><br><span class="line">    num/=2; //两个因子为一对，除2</span><br><span class="line">    for(ll i=1;i&lt;a;i++)&#123;</span><br><span class="line">      if(s%i==0) num--;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;Case %d: %lld\n&quot;, kase, num);</span><br><span class="line">	&#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Goldbach-s-Conjecture"><a href="#Goldbach-s-Conjecture" class="headerlink" title="Goldbach`s Conjecture"></a>Goldbach`s Conjecture</h2><p><strong>题意</strong><br>给出几组测试数据，每组给出一个n，问n能被分成几对素数的和。<br><strong>思路</strong><br>少有的水题，素数筛一下，遍历素数，然后每次查看sum-该素数是不是素数是的话答案加一，遍历过半就可以退出了</p>
<h3 id="CODE-1"><a href="#CODE-1" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int MAXN=1e7+20;</span><br><span class="line">bool isp[MAXN];</span><br><span class="line">int pr[700000];</span><br><span class="line">int t,k=0;</span><br><span class="line">void prime()</span><br><span class="line">&#123;</span><br><span class="line">    isp[1]=1;</span><br><span class="line">    for(int i=2;i&lt;=MAXN;i++)&#123;</span><br><span class="line">        if(!isp[i])&#123;</span><br><span class="line">            pr[++k]=i;</span><br><span class="line">            for(int j=i+i;j&lt;=MAXN;j+=i)&#123;</span><br><span class="line">                isp[j]=1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	prime();</span><br><span class="line">    int t,kase=0;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">    	int n,cnt=0;</span><br><span class="line">    	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    	for(int i=1;i&lt;=n/2;i++)&#123;</span><br><span class="line">    		if(pr[i]&gt;=n/2+1) break;</span><br><span class="line">    		if(!isp[n-pr[i]]) cnt++;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;Case %d: &quot;,++kase);</span><br><span class="line">		cout&lt;&lt;cnt&lt;&lt;&#x27;\n&#x27;;</span><br><span class="line">	&#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Pairs-Forming-LCM"><a href="#Pairs-Forming-LCM" class="headerlink" title="Pairs Forming LCM"></a>Pairs Forming LCM</h2><p><strong>题意</strong><br>在1~n中有多少对数满足lcm(a,b)==n<br><strong>思路</strong><br>gcd(a,b)=p1 ^min(a1,b1)^ <em> p2^min(a2,b2)^ </em> ………. <em>pn^min(an,bn)^<br>lcm(a,b)=p1 ^max(a1,b1)^ </em> p2^max(a2,b2)^ <em> ………. </em>pn^max(an,bn)^<br>先对n素因子分解，n = p1^e1^ <em> p2^e2^ </em> ………. <em>pk^ek^，<br>lcm(a,b)=p1 ^max(a1,b1)^ </em> p2^max(a2,b2^ <em> ………. </em>pk^max(ak,bk)^  </p>
<p>所以，当lcm(a,b)==n时，max(a1,b1)==e1,max(a2,b2)==e2,…max(ak,bk)==ek<br>当ai == ei时，bi可取 [0, ei] 中的所有数  有 ei+1 种情况，bi==ei时同理。<br>那么就有2(ei+1)种取法,但是当ai = bi = ei 时有重复，所以取法数为2(ei+1)-1=2<em>ei+1。<br>除了 (n, n) 所有的情况都出现了两次  那么满足a&lt;=b的有 (2</em>ei + 1)) / 2 + 1 个   </p>
<h3 id="CODE-2"><a href="#CODE-2" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span><br><span class="line">#define debug freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin); freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout)</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int MAXN = 1e7+10;</span><br><span class="line">const int MOD = 1e9;</span><br><span class="line">int pr[MAXN/10], tail = 0;</span><br><span class="line">bool isp[MAXN];</span><br><span class="line">void prime() &#123;</span><br><span class="line">    isp[1] = 1;</span><br><span class="line">    for (int i = 2; i &lt;= MAXN; i++) &#123;</span><br><span class="line">        if (!isp[i]) pr[++tail] = i;</span><br><span class="line">        for (int j = 1; j&lt;=tail &amp;&amp;i * pr[j] &lt;= MAXN; j++) &#123;</span><br><span class="line">            isp[i * pr[j]] = 1;</span><br><span class="line">            if (i % pr[j] == 0) break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	prime();</span><br><span class="line">    int t,kase=1;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    for( ;kase&lt;=t;kase++)&#123;</span><br><span class="line">    	ll n; cin&gt;&gt;n;</span><br><span class="line">    	int ans=1;</span><br><span class="line">    	for(int i=1;i&lt;=tail&amp;&amp;pr[i]*pr[i]&lt;=n;i++)&#123;</span><br><span class="line">    		if(n%pr[i]==0)&#123;</span><br><span class="line">    			int e=0;</span><br><span class="line">    			while(n%pr[i]==0)&#123;</span><br><span class="line">    				e++;</span><br><span class="line">    				n/=pr[i];</span><br><span class="line">				&#125;</span><br><span class="line">				ans*=(2*e+1);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if(n&gt;1) ans*=(2*1+1);</span><br><span class="line">		printf(&quot;Case %d: %d\n&quot;,kase,(ans+1)/2);</span><br><span class="line">	&#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Mysterious-Bacteria"><a href="#Mysterious-Bacteria" class="headerlink" title="Mysterious Bacteria"></a>Mysterious Bacteria</h2><p><strong>题意</strong><br>给你一个数x = b^p^,求p的最大值<br><strong>思路</strong><br>p = gcd(x1, x2, x3, … , xs) xi是拆分后的指数<br>比如： 24 = 2^3^<em>3^1^，p应该是gcd(3, 1) = 1,即24 = 24^1^<br>      324 = 3^4^</em>2^2^,p应该是gcd(4, 2) = 2,即324 = 18^2^<br><del>注意：</del>本题有一个坑，就是x可能为负数，如果x为负数的话，x = b^q, q必须使奇数，所以将x转化为正数求得的解如果是偶数的话必须将其一直除2转化为奇数<br><strong>疑问</strong><br>为什么代码标记的地方的那个n不开ll会超时呢？ll转换成负数快？</p>
<h3 id="CODE-3"><a href="#CODE-3" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int MAXN = 1e5+10;</span><br><span class="line">const int MOD = 1e9;</span><br><span class="line">int pr[MAXN/10], tail = 0;</span><br><span class="line">bool isp[MAXN];</span><br><span class="line">void prime() &#123;</span><br><span class="line">    isp[1] = 1;</span><br><span class="line">    for (int i = 2; i &lt; MAXN; i++) &#123;</span><br><span class="line">        if (!isp[i]) pr[++tail] = i;</span><br><span class="line">        for (int j = 1; i &lt;= MAXN/pr[j]; j++) &#123;</span><br><span class="line">            isp[i * pr[j]] = 1;</span><br><span class="line">            if (i % pr[j] == 0) break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int gcd(int a,int b)&#123;</span><br><span class="line">	if(a%b==0) return b;</span><br><span class="line">	else return gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	prime();</span><br><span class="line">    int t,kase=0; cin&gt;&gt;t;</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">    	ll n; cin&gt;&gt;n;  //这里n必须开成ll否则会超时</span><br><span class="line">    	int flag=0,ans=0;</span><br><span class="line">    	if(n&lt;0)&#123;</span><br><span class="line">    		n=-n;  //n如果不开成ll的话这里会卡住</span><br><span class="line">    		flag=1;</span><br><span class="line">		&#125;</span><br><span class="line">    	for(int i=1;i&lt;=tail&amp;&amp;pr[i]*pr[i]&lt;=n;i++)&#123;</span><br><span class="line">    		if(n%pr[i]==0)&#123;</span><br><span class="line">				int e=0;</span><br><span class="line">    			while(n%pr[i]==0)&#123;</span><br><span class="line">    				e++;</span><br><span class="line">    				n/=pr[i];</span><br><span class="line">				&#125;</span><br><span class="line">				if(ans==0) ans=e;</span><br><span class="line">				else ans=gcd(ans,e);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">    	if(n&gt;1) ans=gcd(ans,1);</span><br><span class="line">    	if(flag==1)&#123;</span><br><span class="line">    		while(ans%2==0)&#123;</span><br><span class="line">    			ans/=2;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">    	cout&lt;&lt;&quot;Case &quot;&lt;&lt;++kase&lt;&lt;&quot;: &quot;&lt;&lt;ans&lt;&lt;&#x27;\n&#x27;;</span><br><span class="line">	&#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Large-Division"><a href="#Large-Division" class="headerlink" title="Large Division"></a>Large Division</h2><p><strong>题意</strong><br>给你两个数a，b，让你求出来a是否能够被b整除。<br><strong>思路</strong><br>需要注意的是数字a太大了，所以要用数组来存储，同时还要注意数字b可能超出了int范围，要用long long int，考的其实就是除法的模拟   </p>
<h3 id="CODE-4"><a href="#CODE-4" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int MAXN=1e6+10;</span><br><span class="line">char a[MAXN];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int t,kase=0;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">    	memset(a,0,sizeof a);</span><br><span class="line">    	ll b;</span><br><span class="line">    	scanf(&quot;%s&quot;,a);</span><br><span class="line">    	scanf(&quot;%lld&quot;,&amp;b);</span><br><span class="line">    	if(b&lt;0) b=-b;</span><br><span class="line">    	ll x=0,len=strlen(a);</span><br><span class="line">    	for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">    		if(a[i]==&#x27;-&#x27;) continue;</span><br><span class="line">    		x=(x*10+a[i]-&#x27;0&#x27;)%b;</span><br><span class="line">		&#125;</span><br><span class="line">		if(x==0) printf(&quot;Case %d: divisible\n&quot;,++kase);</span><br><span class="line">    	else printf(&quot;Case %d: not divisible\n&quot;,++kase);</span><br><span class="line">    	</span><br><span class="line">	&#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Help-Hanzo"><a href="#Help-Hanzo" class="headerlink" title="Help Hanzo"></a>Help Hanzo</h2><p><strong>题意</strong><br>求区间a,b内素数的数量<br><strong>思路</strong><br>由于b极大，所以打表会爆内存。但并不意味着放弃打表，我们可以先打一个小点的素数表出来，如果b在这个表内直接二分找一下a,b就可以了。否则利用到b-a&lt;=100000这个性质，可以开一个这么大的桶下标表示为j-a来筛选a-b内的素数，这样就用到我们之前的小素数表来筛选了。</p>
<h3 id="CODE-5"><a href="#CODE-5" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN=1e6+10;</span><br><span class="line">bool vis1[MAXN],vis2[MAXN];</span><br><span class="line">int pr[MAXN],cnt;</span><br><span class="line">int prime()&#123;</span><br><span class="line">	for(int i=2;i&lt;MAXN;i++)&#123;</span><br><span class="line">		if(vis1[i]==0)&#123;</span><br><span class="line">			pr[cnt++]=i;</span><br><span class="line">			vis1[i]=1;</span><br><span class="line">		&#125;</span><br><span class="line">		for(int j=0;j&lt;cnt&amp;&amp;pr[j]*i&lt;MAXN;j++)&#123;</span><br><span class="line">	  		vis1[i*pr[j]]=1;</span><br><span class="line">	  		if(i%pr[j]==0) break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	prime();</span><br><span class="line">  	int t,kase=1;</span><br><span class="line">  	cin&gt;&gt;t;</span><br><span class="line">  	while(t--)&#123;</span><br><span class="line">		ll a,b,ans=0;</span><br><span class="line">		cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">		if(b&lt;=MAXN)&#123;</span><br><span class="line">		    int loab=lower_bound(pr,pr+cnt,b)-pr; </span><br><span class="line">		    if(pr[loab]&gt;b) loab-=1;</span><br><span class="line">		    int loaa=lower_bound(pr,pr+cnt,a)-pr;</span><br><span class="line">		    ans=loab-loaa+1;</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">		    memset(vis2,0,sizeof(vis2));</span><br><span class="line">		    for(int i=0;i&lt;cnt;i++)&#123;</span><br><span class="line">		        ll k=(a%pr[i]==0)?a/pr[i]:a/pr[i]+1;  </span><br><span class="line">		        for(ll j=k*pr[i];j&lt;=b;j+=pr[i]) vis2[j-a]=1;</span><br><span class="line">		    &#125;</span><br><span class="line">		    for(ll i=a;i&lt;=b;i++)&#123;</span><br><span class="line">		        if(!vis2[i-a]) ans++;</span><br><span class="line">		    &#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;&quot;Case &quot;&lt;&lt;kase++&lt;&lt;&quot;: &quot;&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="GCD-Extreme-II"><a href="#GCD-Extreme-II" class="headerlink" title="GCD - Extreme (II)"></a>GCD - Extreme (II)</h2><p><strong>题意</strong><br>求在1-n之间所有任意两个数的的最大公因数的和。<br><strong>题解</strong><br>因为让求的1-n区间里任两个数的最大公因数之和，所以假设gcd(n,m)=z，在这里，因为n和m的范围都是超级大，所以，不能枚举n，m，但是可以枚举m，z，或者n，z。<br>具体思路是：假设gcd(x,y)=1,那么当执行到x，y的时候，最后的和都要加1，那么相应的，执行到2x，2y时，最后的和都要加2，以此类推，执行到kx，ky的时候最后的和都要加k，那么这些一切的根源都归咎于gcd(x,y)=1，所以才有了上面那一句话，枚举n，z（n，m选其一，无所谓的），这里的z就是上面的1，2，。。k。枚举z的问题解决了，那么轮到n了，枚举n，假设一个值为num，那么num代表与n的最大公因数是z（1，2，3，，，，k）的个数，这里的z有好多值，但是任何的z（大于1）都可以有最根本的gcd（x，y）推出，所以算出只需要算出z=1时num的值就可以了，这个时候，就会想到欧拉函数值（小于n的数里与n互质的个数）。然后，这道题算是结束了。</p>
<h3 id="CODE-6"><a href="#CODE-6" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int MAXN = 4e6+10;</span><br><span class="line">const int MOD = 1e9;</span><br><span class="line">int pr[MAXN/10],tail;</span><br><span class="line">ll a[MAXN],phi[MAXN];</span><br><span class="line">bool isp[MAXN]; </span><br><span class="line">void euler()</span><br><span class="line">&#123;</span><br><span class="line">	phi[1]=1;</span><br><span class="line">	for(int i=2;i&lt;MAXN;i++)&#123;</span><br><span class="line">		if(!isp[i])&#123;</span><br><span class="line">			pr[++tail]=i;</span><br><span class="line">			phi[i]=i-1;</span><br><span class="line">		&#125;</span><br><span class="line">		for(int j=1;j&lt;=tail&amp;&amp;i*pr[j]&lt;MAXN;j++)&#123;</span><br><span class="line">			isp[i*pr[j]]=1;</span><br><span class="line">			if(i%pr[j]==0)&#123;</span><br><span class="line">				phi[i*pr[j]]=phi[i]*pr[j];</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			else phi[i*pr[j]]=phi[i]*phi[pr[j]];</span><br><span class="line">		&#125;</span><br><span class="line">		for(int j=1;i*j&lt;MAXN;j++)&#123;</span><br><span class="line">			a[i*j]+=phi[i]*j;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int fun(int n)&#123;</span><br><span class="line">	int ans=n;</span><br><span class="line">	if(n==1) return 1;</span><br><span class="line">	for(int i=2;i*i&lt;=n;i++)&#123;</span><br><span class="line">		if(n%i==0)&#123;</span><br><span class="line">			ans=ans/i*(i-1);</span><br><span class="line">			while(n%i==0) n/=i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if(n&gt;1) ans=ans/n*(n-1);</span><br><span class="line">	return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	ios; ll n;</span><br><span class="line">	euler();</span><br><span class="line">	for(int i=1;i&lt;MAXN;i++)&#123;</span><br><span class="line">		a[i]+=a[i-1];</span><br><span class="line">	&#125;</span><br><span class="line">	while(~scanf(&quot;%lld&quot;,&amp;n)&amp;&amp;n)&#123;</span><br><span class="line">		printf(&quot;%lld\n&quot;,a[n]);</span><br><span class="line">	&#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Farey-Sequence"><a href="#Farey-Sequence" class="headerlink" title="Farey Sequence"></a>Farey Sequence</h2><p><strong>题意</strong><br>给出式子F F中分子分母互质，且分子小于分母<br>例：  </p>
<p>F2 = {1/2}<br>F3 = {1/3, 1/2, 2/3}<br>F4 = {1/4, 1/3, 1/2, 2/3, 3/4}<br>F5 = {1/5, 1/4, 1/3, 2/5, 1/2, 3/5, 2/3, 3/4, 4/5}<br>求解 fn的元素个数<br><strong>题解</strong><br>本题就是求解欧拉函数值的前n项和，模板题，筛一下就行了  </p>
<h3 id="CODE-7"><a href="#CODE-7" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int MAXN = 1e6+100;</span><br><span class="line">const int MOD = 1e9;</span><br><span class="line">int pr[MAXN/10],tail;</span><br><span class="line">ll phi[MAXN];</span><br><span class="line">bool isp[MAXN]; </span><br><span class="line">void euler()</span><br><span class="line">&#123;</span><br><span class="line">	phi[1]=0;</span><br><span class="line">	for(int i=2;i&lt;MAXN;i++)&#123;</span><br><span class="line">		if(!isp[i])&#123;</span><br><span class="line">			pr[++tail]=i;</span><br><span class="line">			phi[i]=i-1;</span><br><span class="line">		&#125;</span><br><span class="line">		for(int j=1;j&lt;=tail&amp;&amp;i*pr[j]&lt;MAXN;j++)&#123;</span><br><span class="line">			isp[i*pr[j]]=1;</span><br><span class="line">			if(i%pr[j]==0)&#123;</span><br><span class="line">				phi[i*pr[j]]=phi[i]*pr[j];</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			else phi[i*pr[j]]=phi[i]*phi[pr[j]];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	ios; ll n;</span><br><span class="line">	euler();</span><br><span class="line">	for(int i=1;i&lt;MAXN;i++)&#123;</span><br><span class="line">		phi[i]+=phi[i-1];</span><br><span class="line">	&#125;</span><br><span class="line">	while(cin&gt;&gt;n)&#123;</span><br><span class="line">		if(n==0) break;</span><br><span class="line">		cout&lt;&lt;phi[n]&lt;&lt;&#x27;\n&#x27;;</span><br><span class="line">	&#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Maximum-GCD"><a href="#Maximum-GCD" class="headerlink" title="Maximum GCD"></a>Maximum GCD</h2><p><strong>题意</strong><br>给定一串数，求两两gcd最大值<br><strong>思路</strong><br>这道题考的其实是读入，两个数之间空格可以有多个！！！  </p>
<h3 id="CODE-8"><a href="#CODE-8" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span><br><span class="line">#define debug freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin); freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout)</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int MAXN = 1e5;</span><br><span class="line">const int MOD = 1e9;</span><br><span class="line">int pr[MAXN], isp[MAXN], tail = 0;</span><br><span class="line">void prime() &#123;</span><br><span class="line">    isp[1] = 1;</span><br><span class="line">    for (int i = 2; i &lt;= 17000; i++) &#123;</span><br><span class="line">        if (!isp[i]) pr[++tail] = i;</span><br><span class="line">        for (int j = 1; i * pr[j] &lt;= 17000; j++) &#123;</span><br><span class="line">            isp[i * pr[j]] = 1;</span><br><span class="line">            if (i % pr[j] == 0) break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int a[110];</span><br><span class="line">char c[100000];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,tail=0;</span><br><span class="line">    scanf(&quot;%d\n&quot;,&amp;n);</span><br><span class="line">    while(n--)&#123;</span><br><span class="line">    	gets(c); tail=0;</span><br><span class="line">    	int len=strlen(c);</span><br><span class="line">        for(int i=0; i&lt;len; i++)&#123;</span><br><span class="line">            int sum=0;</span><br><span class="line">            while(i&lt;len&amp;&amp;c[i]!=&#x27; &#x27;)&#123;</span><br><span class="line">                sum=sum*10+c[i]-&#x27;0&#x27;;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            a[++tail]=sum;</span><br><span class="line">        &#125;</span><br><span class="line">        int maxx=-1e9;</span><br><span class="line">		for(int i=1;i&lt;tail;i++)&#123;</span><br><span class="line">			for(int j=i+1;j&lt;=tail;j++)&#123;</span><br><span class="line">				maxx=max(maxx,__gcd(a[i],a[j]));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;maxx&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Primes"><a href="#Primes" class="headerlink" title="Primes"></a>Primes</h2><p><strong>题意</strong><br>给定一个数判断是不是素数<br><strong>思路</strong><br>这个就太水了，坑我的就是题目最多有250组数据，我说咋一直超时。。</p>
<h3 id="CODE-9"><a href="#CODE-9" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span><br><span class="line">#define debug freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin); freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout)</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int MAXN = 1e5;</span><br><span class="line">const int MOD = 1e9;</span><br><span class="line">int pr[MAXN], isp[MAXN], tail = 0;</span><br><span class="line">void prime() &#123;</span><br><span class="line">    isp[1] = 1;</span><br><span class="line">    for (int i = 2; i &lt;= 17000; i++) &#123;</span><br><span class="line">        if (!isp[i]) pr[++tail] = i;</span><br><span class="line">        for (int j = 1; i * pr[j] &lt;= 17000; j++) &#123;</span><br><span class="line">            isp[i * pr[j]] = 1;</span><br><span class="line">            if (i % pr[j] == 0) break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	prime(); </span><br><span class="line">    int n, kase = 0;</span><br><span class="line">    for(int k=1;k&lt;=250;k++)&#123;</span><br><span class="line">    	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">        if (n &lt;= 0) break;</span><br><span class="line">        if (n &lt;= 2) &#123;</span><br><span class="line">            printf(&quot;%d: %s\n&quot;, ++kase, &quot;no&quot;);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d: &quot;,++kase);</span><br><span class="line">        if (isp[n]) printf(&quot;%s\n&quot;, &quot;no&quot;);</span><br><span class="line">        else printf(&quot;%s\n&quot;, &quot;yes&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>targan缩点</title>
    <url>/posts/3905b42d.html</url>
    <content><![CDATA[<p> &gt;</p>
<blockquote>
<p>用途：用来缩点（实际是用来缩强连通分量）</p>
<p>强连通分量：在有向图G中，如果两个顶点u，ｖ间有一条从ｕ到ｖ的有向路径，同时还有一条从ｖ到ｕ的有向路径，则称两个顶点强连通。如果有向图G的每两个顶点都强连通，称G是一个强连通图。有向非强连通图的极大强连通子图，称为强连通分量。</p>
</blockquote>
<h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><p>首先需要引入几个数组：</p>
<p>dfn[i]: 表示刚遍历到i号节点的时间戳</p>
<p>low[i]: 设以i为根的子树为Subtree(i)，low[i]定义为以下节点的dfn最小值：subtree(i)中的节点、从Subtree中连出一条不指向子树的边</p>
<p>idx[i]: 缩完强连通分量后i号节点后所在的缩点编号</p>
<p>siz[i]: 缩点的子树大小</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/image-20210909213353438.png" alt="image-20210909213353438"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/image-20210909213427976.png" alt="image-20210909213427976"></p>
<p>那么代码就可以写了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">targan</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">	dfn[x]=low[x]=++tim;</span><br><span class="line">	stk.push(x);</span><br><span class="line">	instk[x]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=h[x];~i;i=e[i].next)&#123;</span><br><span class="line">		<span class="type">int</span> v=e[i].to;</span><br><span class="line">		<span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line">			targan(v);</span><br><span class="line">			low[x]=min(low[v],low[x]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(instk[v]) low[x]=min(low[x],dfn[v]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(low[x]==dfn[x])&#123;</span><br><span class="line">		cnt++;</span><br><span class="line">		<span class="keyword">while</span>(stk.top()!=x)&#123;</span><br><span class="line">			siz[cnt]++;</span><br><span class="line">			idx[stk.top()]=cnt;</span><br><span class="line">			instk[stk.top()]=<span class="number">0</span>;</span><br><span class="line">			stk.pop();</span><br><span class="line">		&#125;</span><br><span class="line">		siz[cnt]++;</span><br><span class="line">		idx[stk.top()]=cnt;</span><br><span class="line">		instk[stk.top()]=<span class="number">0</span>;</span><br><span class="line">		stk.pop();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="受欢迎的牛"><a href="#受欢迎的牛" class="headerlink" title="受欢迎的牛"></a><a href="https://www.acwing.com/problem/content/1176/">受欢迎的牛</a></h2><p>本质就是求一个图上有多少个点可以被其他所有点到达</p>
<p>那么就可以先缩点，缩点后变成了一个有向无环图DAG，之后遍历所有边，如果这条边两端的点不属于一个强连通分量，那么这个边就是外部的边，则缩点出度加一，最后看一下如果出度为0的缩点数量&gt;=2，则不存在这样的牛，答案为0；如果只有一个出度为0的缩点，则这个缩点里面的点数就是答案。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0) </span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e4</span>+<span class="number">100</span>,M=<span class="number">5e4</span>+<span class="number">100</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> to,next;</span><br><span class="line">&#125;e[M];</span><br><span class="line"><span class="type">int</span> h[N],idx[N],dfn[N],out[N],low[N];</span><br><span class="line"><span class="type">int</span> siz[N];</span><br><span class="line"><span class="type">bool</span> instk[N];</span><br><span class="line"><span class="type">int</span> tot,n,m,cnt;</span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span>&#123;</span><br><span class="line">	e[tot]=&#123;v,h[u]&#125;;</span><br><span class="line">	h[u]=tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> tim;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line"><span class="type">void</span> <span class="title function_">targan</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">	dfn[x]=low[x]=++tim;</span><br><span class="line">	stk.push(x);</span><br><span class="line">	instk[x]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=h[x];~i;i=e[i].next)&#123;</span><br><span class="line">		<span class="type">int</span> v=e[i].to;</span><br><span class="line">		<span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line">			targan(v);</span><br><span class="line">			low[x]=min(low[v],low[x]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(instk[v]) low[x]=min(low[x],dfn[v]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(low[x]==dfn[x])&#123;</span><br><span class="line">		cnt++;</span><br><span class="line">		<span class="keyword">while</span>(stk.top()!=x)&#123;</span><br><span class="line">			siz[cnt]++;</span><br><span class="line">			idx[stk.top()]=cnt;</span><br><span class="line">			instk[stk.top()]=<span class="number">0</span>;</span><br><span class="line">			stk.pop();</span><br><span class="line">		&#125;</span><br><span class="line">		siz[cnt]++;</span><br><span class="line">		idx[stk.top()]=cnt;</span><br><span class="line">		instk[stk.top()]=<span class="number">0</span>;</span><br><span class="line">		stk.pop();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="type">int</span> u,v;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">		add(u,v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!dfn[i]) targan(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=h[i];~j;j=e[j].next)&#123;</span><br><span class="line">			<span class="keyword">if</span>(idx[i]!=idx[e[j].to]) out[idx[i]]++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>,js=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(out[i]==<span class="number">0</span>)&#123;</span><br><span class="line">			++js;</span><br><span class="line">			<span class="keyword">if</span>(js==<span class="number">2</span>)&#123;</span><br><span class="line">				ans=<span class="number">0</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			ans=siz[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>targan</tag>
      </tags>
  </entry>
  <entry>
    <title>如何给Hexo博客添加说说页面</title>
    <url>/posts/fa2b1812.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>本文已经过期，说说已经更名为artitalk具体百度</p>
</blockquote>
<p>最近看了许多大佬的博客，终于明白了我到底有多弱:weary:,不过虽然我菜，但是Chinese还是能看懂的:grin:,直接按照教程往下走，感谢把我教会的<a href="https://cungudafa.gitee.io/post/ec85.html">原文1</a>和<a href="https://cndrew.cn/2019/09/11/shuoshuo/">原文2</a></p>
<blockquote>
<p>看看效果吧:</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/20200703225932343.png" alt=""><br>这个和QQ空间里面的说说类似，用来记录自己的生活以及心情都挺好的，请忽略内容里面的表情符号:sleeping:我太菜了，这些原本是要被转成表情的，但说说页面好像不支持，/手动流汗/，如果哪位大佬看到了这篇文章，祈求您留言指教我</p>
<p>好了，废话少说，正文开始：</p>
<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><p>1.在<strong>themes\sakura\languages\zh-cn.yml</strong>中增添定义：</p>
<pre><code>shuoshuo: 说说
</code></pre><p>2.修改导航栏，位置：themes\sakura_config.yml增添：</p>
<pre><code>说说: &#123;path: /shuoshuo/, fa: fa-commenting-o fa-commenting &#125;
</code></pre><p>这里需要注意的是如果你的说说是添加在导航栏的子页面的，比如说在归档里面，那么需要在最后添加逗号( , )</p>
<p>3.在博客主目录下新建目录：</p>
<pre><code>hexo new page shuoshuo
</code></pre><p>路径<strong>Users/用户名/博客文件夹/source</strong>文件夹里就会出现刚刚新建的文件夹shuoshuo，打开文件shuoshuo，删除index文件夹，还有一个index.md文件,待会再来修改它。</p>
<p>4.Myblog\source\shuoshuo\ ，新建文件夹 <strong>shuoshuo.css</strong></p>
<p><strong>shuoshuo.css</strong>样式文件：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#shuoshuo_content &#123;</span><br><span class="line">    background-color: #fff;</span><br><span class="line">    padding: 10px;</span><br><span class="line">    min-height: 500px;</span><br><span class="line">&#125;</span><br><span class="line">/* shuo */</span><br><span class="line"> </span><br><span class="line">body.theme-dark .cbp_tmtimeline::before &#123;</span><br><span class="line">    background: RGBA(255, 255, 255, 0.06);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">ul.cbp_tmtimeline &#123;</span><br><span class="line">    padding: 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">div class.cdp_tmlabel &gt; li .cbp_tmlabel &#123;</span><br><span class="line">    margin-bottom: 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">.cbp_tmtimeline &#123;</span><br><span class="line">    margin: 30px 0 0 0;</span><br><span class="line">    padding: 0;</span><br><span class="line">    list-style: none;</span><br><span class="line">    position: relative;</span><br><span class="line">&#125;</span><br><span class="line">/* The line */</span><br><span class="line"> </span><br><span class="line">.cbp_tmtimeline:before &#123;</span><br><span class="line">    content: &#x27;&#x27;;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 0;</span><br><span class="line">    bottom: 0;</span><br><span class="line">    width: 4px;</span><br><span class="line">    background: RGBA(0, 0, 0, 0.02);</span><br><span class="line">    left: 80px;</span><br><span class="line">    margin-left: 10px;</span><br><span class="line">&#125;</span><br><span class="line">/* The date/time */</span><br><span class="line"> </span><br><span class="line">.cbp_tmtimeline &gt; li .cbp_tmtime &#123;</span><br><span class="line">    display: block;</span><br><span class="line">    /* width: 29%; */</span><br><span class="line">    /* padding-right: 110px; */</span><br><span class="line">    max-width: 70px;</span><br><span class="line">    position: absolute;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">.cbp_tmtimeline &gt; li .cbp_tmtime span &#123;</span><br><span class="line">    display: block;</span><br><span class="line">    text-align: right;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">.cbp_tmtimeline &gt; li .cbp_tmtime span:first-child &#123;</span><br><span class="line">    font-size: 0.9em;</span><br><span class="line">    color: #bdd0db;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">.cbp_tmtimeline &gt; li .cbp_tmtime span:last-child &#123;</span><br><span class="line">    font-size: 1.2em;</span><br><span class="line">    color: #9BCD9B;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">.cbp_tmtimeline &gt; li:nth-child(odd) .cbp_tmtime span:last-child &#123;</span><br><span class="line">    color: RGBA(255, 125, 73, 0.75);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">div.cbp_tmlabel &gt; p &#123;</span><br><span class="line">    margin-bottom: 0;</span><br><span class="line">&#125;</span><br><span class="line">/* Right content */</span><br><span class="line"> </span><br><span class="line">.cbp_tmtimeline &gt; li .cbp_tmlabel &#123;</span><br><span class="line">    margin: 0 0 45px 65px;</span><br><span class="line">    background: #9BCD9B;</span><br><span class="line">    color: #fff;</span><br><span class="line">    padding: .8em 1.2em .4em 1.2em;</span><br><span class="line">    /* font-size: 1.2em; */</span><br><span class="line">    font-weight: 300;</span><br><span class="line">    line-height: 1.4;</span><br><span class="line">    position: relative;</span><br><span class="line">    border-radius: 5px;</span><br><span class="line">    transition: all 0.3s ease 0s;</span><br><span class="line">    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.15);</span><br><span class="line">    cursor: pointer;</span><br><span class="line">    display: block;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">.cbp_tmlabel:hover &#123;</span><br><span class="line">    /* transform:scale(1.05); */</span><br><span class="line">    transform: translateY(-3px);</span><br><span class="line">    z-index: 1;</span><br><span class="line">    box-shadow: 0 15px 32px rgba(0, 0, 0, 0.15) !important</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">.cbp_tmtimeline &gt; li:nth-child(odd) .cbp_tmlabel &#123;</span><br><span class="line">    background: RGBA(255, 125, 73, 0.75);</span><br><span class="line">&#125;</span><br><span class="line">/* The triangle */</span><br><span class="line"> </span><br><span class="line">.cbp_tmtimeline &gt; li .cbp_tmlabel:after &#123;</span><br><span class="line">    right: 100%;</span><br><span class="line">    border: solid transparent;</span><br><span class="line">    content: &quot; &quot;;</span><br><span class="line">    height: 0;</span><br><span class="line">    width: 0;</span><br><span class="line">    position: absolute;</span><br><span class="line">    pointer-events: none;</span><br><span class="line">    border-right-color: #9BCD9B;</span><br><span class="line">    border-width: 10px;</span><br><span class="line">    top: 4px;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">.cbp_tmtimeline &gt; li:nth-child(odd) .cbp_tmlabel:after &#123;</span><br><span class="line">    border-right-color: RGBA(255, 125, 73, 0.75);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">p.shuoshuo_time &#123;</span><br><span class="line">    margin-top: 10px;</span><br><span class="line">    border-top: 1px dashed #fff;</span><br><span class="line">    padding-top: 5px;</span><br><span class="line">&#125;</span><br><span class="line">/* Media */</span><br><span class="line"> </span><br><span class="line">@media screen and (max-width: 65.375em) &#123;</span><br><span class="line">    .cbp_tmtimeline &gt; li .cbp_tmtime span:last-child &#123;</span><br><span class="line">        font-size: 1.2em;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">.shuoshuo_author_img img &#123;</span><br><span class="line">    border: 1px solid #ddd;</span><br><span class="line">    padding: 2px;</span><br><span class="line">    float: left;</span><br><span class="line">    border-radius: 64px;</span><br><span class="line">    transition: all 1.0s;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">.avatar &#123;</span><br><span class="line">    border-radius: 100% !important;</span><br><span class="line">    -moz-border-radius: 100% !important;</span><br><span class="line">    box-shadow: inset 0 -1px 0 3333sf;</span><br><span class="line">    -webkit-box-shadow: inset 0 -1px 0 3333sf;</span><br><span class="line">    -webkit-transition: 0.4s;</span><br><span class="line">    -webkit-transition: -webkit-transform 0.4s ease-out;</span><br><span class="line">    transition: transform 0.4s ease-out;</span><br><span class="line">    -moz-transition: -moz-transform 0.4s ease-out;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">.zhuan &#123;</span><br><span class="line">    transform: rotateZ(720deg);</span><br><span class="line">    -webkit-transform: rotateZ(720deg);</span><br><span class="line">    -moz-transform: rotateZ(720deg);</span><br><span class="line">&#125;</span><br><span class="line">/* end */</span><br></pre></td></tr></table></figure></p>
<p>主页面：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: shuoshuo</span><br><span class="line">type: shuoshuo</span><br><span class="line">noDate: &#x27;true&#x27;</span><br><span class="line">comments: &#x27;false&#x27;</span><br><span class="line">---</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;./shuoshuo.css&quot;&gt;</span><br><span class="line"> </span><br><span class="line">&lt;div id=&quot;primary&quot; class=&quot;content-area&quot; style=&quot;&quot;&gt;</span><br><span class="line">    &lt;main id=&quot;main&quot; class=&quot;site-main&quot; role=&quot;main&quot;&gt;</span><br><span class="line">        &lt;div id=&quot;shuoshuo_content&quot;&gt;</span><br><span class="line">            &lt;ul class=&quot;cbp_tmtimeline&quot;&gt;</span><br><span class="line">                &lt;li&gt; &lt;span class=&quot;shuoshuo_author_img&quot;&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/cungudafa/cdn/img/custom/cungudafa.jpg&quot; class=&quot;avatar avatar-48 zhuan&quot; width=&quot;48&quot; height=&quot;48&quot;&gt;&lt;/span&gt;</span><br><span class="line">                    &lt;a class=&quot;cbp_tmlabel&quot; href=&quot;&quot;&gt;</span><br><span class="line">                        &lt;p&gt;&lt;/p&gt;</span><br><span class="line">                        &lt;p&gt;想要开学，想吃火锅，想吃烧烤，想吃蟹肉煲，想吃鸡脚米线，想喝奶茶~&lt;/p&gt;</span><br><span class="line">                        &lt;iframe frameborder=&quot;no&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=86 src=&quot;//music.163.com/outchain/player?type=2&amp;id=1338809890&amp;auto=1&amp;height=66&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">                        &lt;p&gt;&lt;/p&gt;</span><br><span class="line">                        &lt;p class=&quot;shuoshuo_time&quot;&gt;&lt;i class=&quot;fa fa-clock-o&quot;&gt;&lt;/i&gt;</span><br><span class="line">                            2020年2月25日</span><br><span class="line">                        &lt;/p&gt;</span><br><span class="line">                    &lt;/a&gt;</span><br><span class="line">                &lt;/li&gt;</span><br><span class="line">                 &lt;li&gt; &lt;span class=&quot;shuoshuo_author_img&quot;&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/cungudafa/cdn/img/custom/cungudafa.jpg&quot; class=&quot;avatar avatar-48 zhuan&quot; width=&quot;48&quot; height=&quot;48&quot;&gt;&lt;/span&gt;</span><br><span class="line">                    &lt;a class=&quot;cbp_tmlabel&quot; href=&quot;&quot;&gt;</span><br><span class="line">                        &lt;p&gt;&lt;/p&gt;</span><br><span class="line">                        &lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1582636990314&amp;di=2421dcd34e1cc519b7f7f9559afbe7b1&amp;imgtype=0&amp;src=http%3A%2F%2Fpics1.baidu.com%2Ffeed%2Fb17eca8065380cd7531865282a19873258828151.jpeg%3Ftoken%3Dce6f76a2b9dc38c02c91acfc2a4bb8d8%26s%3D3C79EF14C510746516F547E003007036&quot; height=&quot;200&quot; width=&quot;100&quot; /&gt;</span><br><span class="line">                        &lt;p&gt;武汉加油！中国加油！&lt;/p&gt;</span><br><span class="line">                        &lt;p&gt;&lt;/p&gt;</span><br><span class="line">                        &lt;p class=&quot;shuoshuo_time&quot;&gt;&lt;i class=&quot;fa fa-clock-o&quot;&gt;&lt;/i&gt;</span><br><span class="line">                            2020年2月25日</span><br><span class="line">                        &lt;/p&gt;</span><br><span class="line">                    &lt;/a&gt;</span><br><span class="line">                &lt;/li&gt;</span><br><span class="line">                &lt;li&gt; &lt;span class=&quot;shuoshuo_author_img&quot;&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/cungudafa/cdn/img/custom/cungudafa.jpg&quot; class=&quot;avatar avatar-48 zhuan&quot; width=&quot;48&quot; height=&quot;48&quot;&gt;&lt;/span&gt;</span><br><span class="line">                    &lt;a class=&quot;cbp_tmlabel&quot; href=&quot;&quot;&gt;</span><br><span class="line">                        &lt;p&gt;&lt;/p&gt;</span><br><span class="line">                        &lt;p&gt;第一个说说&lt;/p&gt;</span><br><span class="line">                        &lt;p&gt;&lt;/p&gt;</span><br><span class="line">                        &lt;p class=&quot;shuoshuo_time&quot;&gt;&lt;i class=&quot;fa fa-clock-o&quot;&gt;&lt;/i&gt;</span><br><span class="line">                            2020年2月25日</span><br><span class="line">                        &lt;/p&gt;</span><br><span class="line">                    &lt;/a&gt;</span><br><span class="line">                &lt;/li&gt;</span><br><span class="line">            &lt;/ul&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    (function () &#123;</span><br><span class="line">        var oldClass = &quot;&quot;;</span><br><span class="line">        var Obj = &quot;&quot;;</span><br><span class="line">        $(&quot;.cbp_tmtimeline li&quot;).hover(function () &#123;</span><br><span class="line">            Obj = $(this).children(&quot;.shuoshuo_author_img&quot;);</span><br><span class="line">            Obj = Obj.children(&quot;img&quot;);</span><br><span class="line">            oldClass = Obj.attr(&quot;class&quot;);</span><br><span class="line">            var newClass = oldClass + &quot; zhuan&quot;;</span><br><span class="line">            Obj.attr(&quot;class&quot;, newClass);</span><br><span class="line">        &#125;, function () &#123;</span><br><span class="line">            Obj.attr(&quot;class&quot;, oldClass);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><br>只会报别人代码的我再次像大佬们深深鞠一躬(orz)</p>
]]></content>
  </entry>
  <entry>
    <title>数学问题模板</title>
    <url>/posts/d6ebbabc.html</url>
    <content><![CDATA[<h2 id="筛选质因子"><a href="#筛选质因子" class="headerlink" title="筛选质因子"></a>筛选质因子</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i*i&lt;=k;i++)&#123;</span><br><span class="line">     <span class="keyword">if</span>(k%i==<span class="number">0</span>)&#123;</span><br><span class="line">         p[++tail]=i;  <span class="comment">//p就是储存质因子的数组</span></span><br><span class="line">         <span class="keyword">while</span>(k%i==<span class="number">0</span>) k/=i;  <span class="comment">//把k中所有i的质因子全部除去</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">   <span class="keyword">if</span>(k&gt;<span class="number">1</span>) p[++tail]=k;</span><br></pre></td></tr></table></figure>
<h2 id="判断是否为质数"><a href="#判断是否为质数" class="headerlink" title="判断是否为质数"></a>判断是否为质数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isp</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">1</span>||n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">2</span>||n==<span class="number">3</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(n%<span class="number">6</span>!=<span class="number">1</span>&amp;&amp;n%<span class="number">6</span>!=<span class="number">5</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">5</span>;i*i&lt;=n;i+=<span class="number">6</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(n%i==<span class="number">0</span>||n%(i+<span class="number">2</span>)==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="容斥原理"><a href="#容斥原理" class="headerlink" title="容斥原理"></a>容斥原理</h2><p>前言：</p>
<ol>
<li>计算1-n中m的的倍数的数量时，直接n/m</li>
<li>容斥原理是在互质的数的基础上实现的<br>公式：</li>
</ol>
<p>(A+B+C+D+E……)-(A<em>B+A</em>C+A<em>D……+B</em>C+B<em>D)+(A</em>B<em>C+B</em>C<em>D……)-(A</em>B<em>C</em>D+B<em>C</em>D*E……)……</p>
<p>规律： 奇数相加，偶数相减</p>
<p>代码：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p数组储存的是筛选的质因子</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">fun</span><span class="params">(<span class="type">long</span> <span class="type">long</span> x)</span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> res=<span class="number">0</span>;  <span class="comment">//res储存的是1-x中与K不互质的数量 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;(<span class="number">1</span>&lt;&lt;tail);i++)&#123;  <span class="comment">//这里的1&lt;&lt;tail是指2的tail次方，表示tail个质因子有多少种组合情况 </span></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> cur=<span class="number">1</span>,cnt=<span class="number">0</span>;  <span class="comment">//cur表示在当前选中的质因子中的乘积，cnt表示当前选中的数量是奇数还是偶数 </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;tail;j++)&#123;  <span class="comment">//这个循环是枚举tail的二进制形式 </span></span><br><span class="line">            <span class="keyword">if</span>((i&gt;&gt;j)&amp;<span class="number">1</span>)&#123;  <span class="comment">//这个是判断i的第j位是不是1，如果是则表示选中第j个数 </span></span><br><span class="line">                cnt++;  <span class="comment">//表示选中了几个数，每选中一个就加一 </span></span><br><span class="line">                cur*=p[j+<span class="number">1</span>];  <span class="comment">//选中第j个数就用cur乘以第j个质因子数，注意质因子数组是从1开始的，所以要加一 </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt&amp;<span class="number">1</span>) res+=x/cur;  <span class="comment">//如果cnt是偶数就相加 </span></span><br><span class="line">        <span class="keyword">else</span> res-=x/cur;  <span class="comment">//奇数就相减 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x-res;  <span class="comment">//res储存的是1-x中与K不互质的数量，所以要用x-res得到互质的数量 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="欧拉筛"><a href="#欧拉筛" class="headerlink" title="欧拉筛"></a>欧拉筛</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> vis[maxn],p[maxn/<span class="number">10</span>]; <span class="comment">//质数密度不大，除以10可以减少空间浪费</span></span><br><span class="line"><span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">prime</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    vis[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=maxn;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i]) p[++cnt]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=cnt&amp;&amp;i&lt;=maxn/p[j];j++)&#123;</span><br><span class="line">            vis[i*p[j]]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%p[j]==<span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">//核心代码，如果i能整除这个质数则跳出循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="埃式筛"><a href="#埃式筛" class="headerlink" title="埃式筛"></a>埃式筛</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> p[<span class="number">1000</span>]; <span class="comment">//p数组用来存储质数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">prime</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    vis[<span class="number">1</span>]=<span class="number">1</span>; <span class="comment">//1不是质数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123; <span class="comment">//n是筛选的范围</span></span><br><span class="line">        <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">            p[++cnt]=i; <span class="comment">//存储质数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>*i;j&lt;=n;j+=i)&#123;  <span class="comment">//这里可以有一个优化，j=2*i</span></span><br><span class="line">                vis[j]=<span class="number">1</span>; <span class="comment">//标记质数的倍数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h2><ul>
<li>海伦公式<br>S=sqrt(p <em> (p-a) </em> (p-b) * (p-c))<h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><font color="red">
非递归版本
</font>

</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int p(int a,int b)&#123;</span><br><span class="line">  int t,y;</span><br><span class="line">  t=1; y=a;</span><br><span class="line">  while (b!=0)&#123;</span><br><span class="line">    if (b&amp;1==1) t=t*y%MOD;</span><br><span class="line">    y=y*y%MOD;</span><br><span class="line">    b=b&gt;&gt;1;</span><br><span class="line">  &#125;</span><br><span class="line">  return t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<font color="red">
递归版本
</font>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ll <span class="title function_">pow</span><span class="params">(ll a,ll i)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (i==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  ll temp=<span class="built_in">pow</span>(a,i&gt;&gt;<span class="number">1</span>)%MOD;</span><br><span class="line">  temp=temp*temp%MOD;</span><br><span class="line">  <span class="keyword">if</span> (i&amp;<span class="number">1</span>) temp=temp*a%MOD;</span><br><span class="line">  <span class="keyword">return</span> temp%MOD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="龟速乘-快速幂BUG"><a href="#龟速乘-快速幂BUG" class="headerlink" title="龟速乘(快速幂BUG)"></a>龟速乘(快速幂BUG)</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ll <span class="title function_">gsc</span><span class="params">(ll a,ll b)</span>&#123;</span><br><span class="line">	ll ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(b)&#123;</span><br><span class="line">		<span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans=(ans+a)%MOD;</span><br><span class="line">		a=a*<span class="number">2</span>%MOD;</span><br><span class="line">		b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="快速乘-有误差"><a href="#快速乘-有误差" class="headerlink" title="快速乘(有误差)"></a>快速乘(有误差)</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;mod;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;((a*b-(<span class="type">long</span> <span class="type">long</span>)((<span class="type">long</span> <span class="type">double</span>)a*b/mod)*mod+mod)%mod);</span><br></pre></td></tr></table></figure>
<h2 id="树状数组模板"><a href="#树状数组模板" class="headerlink" title="树状数组模板"></a>树状数组模板</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">lowbit</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n&amp;-n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x;i&lt;=n;i+=lowbit(i))</span><br><span class="line">        c[i] += y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getsum</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x;i;i-=lowbit(i))</span><br><span class="line">        ans += c[i];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查并集"><a href="#查并集" class="headerlink" title="查并集"></a>查并集</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        f[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getFriend</span><span class="params">(<span class="type">int</span> v)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span>(f[v] == v) &#123;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[v] = getFriend(f[v]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> t1 = getFriend(a);</span><br><span class="line">    <span class="type">int</span> t2 = getFriend(b);</span><br><span class="line">    <span class="keyword">if</span>(t1 != t2) &#123;  </span><br><span class="line">        f[t2] = t1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//左右都是闭区间 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">qsort</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> *v)</span>&#123;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> i=l,j=r;</span><br><span class="line">	<span class="type">int</span> temp=v[mid];<span class="comment">//基准值是会被交换的，必须备份 </span></span><br><span class="line">	<span class="keyword">while</span>(i&lt;=j)&#123;<span class="comment">//这里小于等于都行 </span></span><br><span class="line">		<span class="keyword">while</span>(v[j]&gt;temp) j--;<span class="comment">//找到第一个小于等于基准值的 </span></span><br><span class="line">		<span class="keyword">while</span>(v[i]&lt;temp) i++;</span><br><span class="line">		<span class="keyword">if</span>(i&lt;=j)&#123; <span class="comment">//这里必须是小于等于,因为当只有两个数时，两个指针一定会重合 </span></span><br><span class="line">			swap(v[i],v[j]);</span><br><span class="line">			i++; j--;<span class="comment">//这里必须，因为当交换的两个数有基准值时，若没有这一步，两个指针必然重合，然后会无限重复 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//i一定比j大，排序过后i左面都小于基准值，j右面都大于基准值就找到了基准值的位置  </span></span><br><span class="line">	<span class="keyword">if</span>(i&lt;r) qsort(i,r,v);<span class="comment">//再排基准值右面 </span></span><br><span class="line">	<span class="keyword">if</span>(j&gt;l) qsort(l,j,v);<span class="comment">//再排基准值左面 </span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="组合数打表-杨辉三角"><a href="#组合数打表-杨辉三角" class="headerlink" title="组合数打表(杨辉三角)"></a>组合数打表(杨辉三角)</h2><font color="red">
int类型最多到33层，34层开始爆int，ll最多50层左右，打表最多1e3的量
</font>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> c[<span class="number">50</span>][<span class="number">50</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">zuhe</span><span class="params">()</span>&#123;<span class="comment">//下标从0开始</span></span><br><span class="line">	c[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	c[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">1</span>;c[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">33</span>;i++)&#123;</span><br><span class="line">		c[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">			c[i][j]=c[i<span class="number">-1</span>][j<span class="number">-1</span>]+c[i<span class="number">-1</span>][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>持续更新中……</p>
</blockquote>
]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>数学问题记录</tag>
      </tags>
  </entry>
  <entry>
    <title>凸包讲解</title>
    <url>/posts/4d10af4f.html</url>
    <content><![CDATA[<blockquote>
<p>凸包（百度百科）:</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/Sucai/20210208174637.png" style="zoom: 67%;" /></p>
</blockquote>
<p>讲解凸包之前先讲解一下极角排序、叉积</p>
<h2 id="叉积"><a href="#叉积" class="headerlink" title="叉积"></a>叉积</h2><p>就是数学上的叉乘，两个向量叉乘，有正有负，相乘的两个向量前后顺序颠倒符号相反，乘出来的的结果也是一个向量，值等于以这两个向量作为平行四边形的两条边长的面积，方向指向与两个向量垂直的方向，右手定则，拇指指向x轴弯向y轴大拇指指向方向就是叉积的方向</p>
<p>数学上叉积非常重要，利用它可以计算出来不规则图形的面积，只需要知道不规则图形的顶点坐标。</p>
<p><code>利用叉积求多边形面积</code></p>
<blockquote>
<p>两个向量的叉积值等于以这两个向量作边的平行四边形的面积</p>
<p>求多边形面积，就可以把多边形分解成许多三角形，求各个三角形面积加起来即可，从原点到各个点做向量，逆时针或者顺时针依次作叉积/2求和即可，顺时针和逆时针求出来的叉积方向不同，正负不同逆时针为正，顺时针为负</p>
<p>例题：HDU2036</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">&gt;<span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line">&gt;<span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)</span></span><br><span class="line">&gt;using namespace <span class="built_in">std</span>;</span><br><span class="line">&gt;<span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">&gt;<span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line">&gt;<span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">100</span>;</span><br><span class="line">&gt;<span class="type">const</span> <span class="type">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">&gt;<span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">&gt;<span class="type">const</span> <span class="type">int</span> SUB=<span class="number">-0x3f3f3f3f</span>;</span><br><span class="line">&gt;<span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-4</span>;</span><br><span class="line">&gt;<span class="type">const</span> <span class="type">double</span> E=<span class="built_in">exp</span>(<span class="number">1</span>);</span><br><span class="line">&gt;<span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line">&gt;<span class="type">int</span> n;</span><br><span class="line">&gt;<span class="type">double</span> ans;</span><br><span class="line">&gt;<span class="type">double</span> x[MAXN],y[MAXN];</span><br><span class="line">&gt;<span class="type">double</span> <span class="title function_">calc</span><span class="params">(<span class="type">double</span> x1,<span class="type">double</span> y1,<span class="type">double</span> x2,<span class="type">double</span> y2)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> x1*y2-x2*y1;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">ios;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">	ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;x[i]&gt;&gt;y[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">		ans+=calc(x[i+<span class="number">1</span>],y[i+<span class="number">1</span>],x[i],y[i])/<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ans+=calc(x[<span class="number">1</span>],y[<span class="number">1</span>],x[n],y[n])/<span class="number">2</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;fixed&lt;&lt;setprecision(<span class="number">1</span>)&lt;&lt;-ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="极角排序"><a href="#极角排序" class="headerlink" title="极角排序"></a>极角排序</h2><p>将一系列的点相对于一个基准点顺时针或者逆时针排序</p>
<p>两种方法</p>
<ol>
<li><p>利用叉积排序，叉积有正有负，两个向量交换顺序符号就会相反</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cross</span><span class="params">(point a,point b,point c)</span>&#123;</span><br><span class="line">	<span class="type">int</span> x1=b.x-a.x;</span><br><span class="line">	<span class="type">int</span> y1=b.y-a.y;</span><br><span class="line">	<span class="type">int</span> x2=c.x-a.x;</span><br><span class="line">	<span class="type">int</span> y2=c.y-a.y;</span><br><span class="line">	<span class="keyword">return</span> x1*y2-x2*y1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getxx</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;<span class="number">0</span> &amp;&amp; y&gt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(x&gt;<span class="number">0</span> &amp;&amp; y&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(x&lt;<span class="number">0</span> &amp;&amp; y&gt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(x&lt;<span class="number">0</span> &amp;&amp; y&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">cmp1</span><span class="params">(point a,point b)</span>&#123;</span><br><span class="line">	point c=&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="type">int</span> x1=a.x-c.x, y1=a.y-c.y;</span><br><span class="line">	<span class="type">int</span> x2=b.x-c.x, y2=b.y-c.y;</span><br><span class="line">	<span class="keyword">if</span>(getxx(x1,y1)!=getxx(x2,y2)) <span class="keyword">return</span> getxx(x1,y1)&lt;getxx(x2,y2);</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(cross(c,a,b)==<span class="number">0</span>) <span class="keyword">return</span> a.x&lt;b.x;</span><br><span class="line">		<span class="keyword">return</span> cross(c,a,b)&gt;<span class="number">0</span>;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>atan2，接受一个坐标，返回一个角度值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getxx</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;<span class="number">0</span> &amp;&amp; y&gt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(x&gt;<span class="number">0</span> &amp;&amp; y&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(x&lt;<span class="number">0</span> &amp;&amp; y&gt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(x&lt;<span class="number">0</span> &amp;&amp; y&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">cmp2</span><span class="params">(point a,point b)</span>&#123;	<span class="comment">//atan2排序</span></span><br><span class="line">	point c=&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="type">int</span> x1=a.x-c.x, y1=a.y-c.y;</span><br><span class="line">	<span class="type">int</span> x2=b.x-c.x, y2=b.y-c.y;</span><br><span class="line">	<span class="keyword">if</span>(getxx(x1,y1)!=getxx(x2,y2)) <span class="keyword">return</span> getxx(x1,y1)&lt;getxx(x2,y2);</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(getxx(x1,y1)==<span class="number">3</span> || getxx(x1,y1)==<span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">atan2</span>(-x1,-y1)!=<span class="built_in">atan2</span>(-x2,-y2)) <span class="keyword">return</span> <span class="built_in">atan2</span>(-y1,-x1)&gt;<span class="built_in">atan2</span>(-y2,-x2);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> a.x&gt;b.x; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">atan2</span>(x1,y1)!=<span class="built_in">atan2</span>(x2,y2)) <span class="keyword">return</span> <span class="built_in">atan2</span>(y1,x1)&lt;<span class="built_in">atan2</span>(y2,x2);</span><br><span class="line">	        <span class="keyword">else</span> <span class="keyword">return</span> a.x&lt;b.x;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>atan()和atan2是两个不同的函数</p>
<blockquote>
<p>atan(): 接受的是一个正切值（直线的斜率）得到夹角，但是由于正切的规律性本可以有两个角度的但它却只返回一个，因此值域是从-90~90 也就是它只处理一四象限，所以一般不用它。</p>
<p>atan2(double y,double x) 其中y代表已知点的Y坐标，同理x ,返回值是此点与远点连线与x轴正方向的夹角，这样它就可以处理四个象限的任意情况了，<code>它的值域相应的也就是-180~180了</code></p>
</blockquote>
<p>叉积速度慢，但是没有精度问题，atan2速度快，精度可能出现问题</p>
<p>:::warn</p>
<p>这里求凸包，极角排序最好根据y值最小的点为基准点，不要以原点为基准点，因为atan2的值域是[-pi,pi]，当点出现在x轴下面时，返回角度就是负的了，所以最好把所有点的向量都算成x轴上方！而且y值最小的点一定在凸包上的</p>
<p>:::</p>
<h2 id="凸包"><a href="#凸包" class="headerlink" title="凸包"></a>凸包</h2><p>找出所有点中最靠下且最靠左的坐标点，以这个点作为基准点进行极角排序，之后把前两个点放进去栈中(注意这里的栈不能用stl中的栈实现，因为还要取出倒数第二个元素)，从第三个点开始往后遍历，每次取出栈中前两个点和这个点做叉积，为负数表明内凹，就弹出栈顶元素再做叉积，直到叉积大于0就把这个点入栈，最后栈中元素就是凸包，算出栈中相邻两点的距离就是凸包距离。</p>
<p>例题: POJ1113</p>
<h2 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SUP=<span class="number">0x800000</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-4</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">&#125;p[MAXN],d[MAXN];</span><br><span class="line"><span class="type">int</span> n,m,top;</span><br><span class="line">node mi;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">cmp</span><span class="params">(node a,node b)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">atan2</span>(a.y-mi.y,a.x-mi.x)==<span class="built_in">atan2</span>(b.y-mi.y,b.x-mi.x)) <span class="keyword">return</span> a.x&lt;b.x;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">atan2</span>(a.y-mi.y,a.x-mi.x)&lt;<span class="built_in">atan2</span>(b.y-mi.y,b.x-mi.x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> <span class="title function_">getdis</span><span class="params">(node a,node b)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sqrt</span>((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">cross</span><span class="params">(node a,node b,node c)</span>&#123;</span><br><span class="line">	<span class="type">int</span> x1=b.x-a.x,y1=b.y-a.y;</span><br><span class="line">	<span class="type">int</span> x2=c.x-b.x,y2=c.y-b.y;</span><br><span class="line">	<span class="keyword">return</span> x1*y2-x2*y1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;fixed&lt;&lt;setprecision(<span class="number">0</span>)&lt;&lt;<span class="number">2</span>*pi*m&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	mi=&#123;INF,INF&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;p[i].x&gt;&gt;p[i].y;</span><br><span class="line">		<span class="keyword">if</span>(p[i].y&lt;mi.y || (p[i].y==mi.y &amp;&amp; p[i].x&lt;mi.x)) mi=p[i];</span><br><span class="line">	&#125;</span><br><span class="line">	sort(p+<span class="number">1</span>,p+<span class="number">1</span>+n,cmp);</span><br><span class="line">	d[<span class="number">0</span>]=p[<span class="number">1</span>];</span><br><span class="line">	d[<span class="number">1</span>]=p[<span class="number">2</span>];</span><br><span class="line">	top=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">while</span>(top&gt;=<span class="number">1</span> &amp;&amp; cross(d[top<span class="number">-1</span>],d[top],p[i])&lt;=<span class="number">0</span>) top--;  <span class="comment">//注意这里&lt;=可以减少凸包上的点，比较好的优化</span></span><br><span class="line">		d[++top]=p[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(top&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(top==<span class="number">2</span>) ans+=getdis(st[<span class="number">1</span>],st[<span class="number">2</span>]);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;fixed&lt;&lt;setprecision(<span class="number">0</span>)&lt;&lt;ans*<span class="number">2</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">double</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=top;i++) ans+=getdis(d[i<span class="number">-1</span>],d[i]);</span><br><span class="line">	ans+=getdis(d[<span class="number">0</span>],d[top])+<span class="number">2</span>*pi*m;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;fixed&lt;&lt;setprecision(<span class="number">0</span>)&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="最小外接圆"><a href="#最小外接圆" class="headerlink" title="最小外接圆"></a>最小外接圆</h2><p><a href="">POJ-2215</a></p>
<p>给定n个点坐标，求最小外接圆</p>
<p>求一个凸包，枚举凸包上的3个点，3个点确定一个⚪，当三个点组成钝角三角形，半径就是最长边的一半，否则面积就是a*b*c/(4*S)，S通过叉积求即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SUB=<span class="number">-0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-4</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> E=<span class="built_in">exp</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="type">double</span> x,y;</span><br><span class="line">&#125;p[MAXN],st[MAXN];</span><br><span class="line">node bas;</span><br><span class="line"><span class="type">int</span> n,top; </span><br><span class="line"><span class="type">bool</span> <span class="title function_">cmp</span><span class="params">(node a,node b)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">atan2</span>(a.y-bas.y,a.x-bas.x)==<span class="built_in">atan2</span>(b.y-bas.y,b.x-bas.x)) <span class="keyword">return</span> a.x&lt;b.x;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">atan2</span>(a.y-bas.y,a.x-bas.x)&lt;<span class="built_in">atan2</span>(b.y-bas.y,b.x-bas.x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> <span class="title function_">cross</span><span class="params">(node a,node b,node c)</span>&#123;</span><br><span class="line">	<span class="type">double</span> x1=b.x-a.x,y1=b.y-a.y;</span><br><span class="line">	<span class="type">double</span> x2=c.x-b.x,y2=c.y-b.y;</span><br><span class="line">	<span class="keyword">return</span> x1*y2-x2*y1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> <span class="title function_">getdis</span><span class="params">(node a,node b)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sqrt</span>((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isdun</span><span class="params">(<span class="type">double</span> a,<span class="type">double</span> b,<span class="type">double</span> c)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(a*a+b*b&lt;c*c || a*a+c*c&lt;b*b || b*b+c*c&lt;a*a)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//是钝角三角形</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n &amp;&amp; n)&#123;</span><br><span class="line">		top=<span class="number">0</span>;</span><br><span class="line">		bas=&#123;INF,INF&#125;;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;p[i].x&gt;&gt;p[i].y;</span><br><span class="line">			<span class="keyword">if</span>(p[i].y&lt;bas.y || (p[i].y==bas.y &amp;&amp; p[i].x&lt;bas.x)) bas=p[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;0.50&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		sort(p+<span class="number">1</span>,p+<span class="number">1</span>+n,cmp);</span><br><span class="line">		st[++top]=p[<span class="number">1</span>];</span><br><span class="line">		st[++top]=p[<span class="number">2</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="keyword">while</span>(top&gt;<span class="number">1</span> &amp;&amp; cross(st[top<span class="number">-1</span>],st[top],p[i])&lt;=<span class="number">0</span>) --top;</span><br><span class="line">			st[++top]=p[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(top==<span class="number">2</span>)&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;fixed&lt;&lt;setprecision(<span class="number">2</span>)&lt;&lt;getdis(st[<span class="number">1</span>],st[<span class="number">2</span>])/<span class="number">2</span>+<span class="number">0.5</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">double</span> ans=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=top;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=top;j++)&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> k=j+<span class="number">1</span>;k&lt;=top;k++)&#123;</span><br><span class="line">					<span class="type">double</span> dis1=getdis(st[i],st[j]);</span><br><span class="line">					<span class="type">double</span> dis2=getdis(st[j],st[k]);</span><br><span class="line">					<span class="type">double</span> dis3=getdis(st[i],st[k]);</span><br><span class="line">					<span class="keyword">if</span>(isdun(dis1,dis2,dis3))&#123;</span><br><span class="line">						<span class="type">double</span> len=max(max(dis1,dis2),dis3);</span><br><span class="line">						ans=max(len/<span class="number">2</span>,ans);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span>&#123;</span><br><span class="line">						<span class="type">double</span> S=<span class="built_in">fabs</span>(cross(st[i],st[j],st[k]))/<span class="number">2</span>;</span><br><span class="line">						ans=max(ans,dis1*dis2*dis3/(<span class="number">4</span>*S));</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;fixed&lt;&lt;setprecision(<span class="number">2</span>)&lt;&lt;ans+<span class="number">0.5</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>凸包</tag>
      </tags>
  </entry>
  <entry>
    <title>主席树</title>
    <url>/posts/fbeda914.html</url>
    <content><![CDATA[<h1 id="主席树-可持续化权值线段树"><a href="#主席树-可持续化权值线段树" class="headerlink" title="主席树(可持续化权值线段树)"></a>主席树(可持续化权值线段树)</h1><blockquote>
<p>可持续化系列的一种数据结构，可以保存修改的版本，本质上是一种可持续化权值线段树</p>
</blockquote>
<h2 id="区间第k小"><a href="#区间第k小" class="headerlink" title="区间第k小"></a>区间第k小</h2><p>倘若不是区间，而是每次求所有值的第k小，一个权值线段树就搞定了，将所有数离散化一下，将数值作为插入位置建树，之后查询第k小时，如果左子树插入点数量大于k就在右子树上，否则就在左子树上，这样就能第k小的数在排好序的数组中排第几个了，每次修改花费logn时间，查询也花费logn时间</p>
<p>而如果现在变成了区间第k小，单纯的线段树就维护不了了，因为无法保存过去的信息，如果可以保存过去没有修改过的信息就好了，（<del>每次修改都建一颗新树，空间炸不炸呀</del>），其实容易想到修改一个点后，变动的点只是这个点的所有祖宗节点（包括父亲节点），只有logn个（n个点的树深度最多是logn），所以可以拉出来一条链来保存修改过的信息</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/20210410213132.png" alt="image-20210410213123576" style="zoom:50%;" /></p>
<p>如图，红色的链就是修改过的信息</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/20210410213507.png" alt="image-20210410213503619" style="zoom:50%;" /></p>
<p>主席树因为要保存版本信息，无法用2*id表示左孩子那种方式建树，要用朴素的lson和rson数组表示左右孩子</p>
<h2 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h2><p>主席树本质就是前缀权值线段树，权值线段树保存的是每一个区间的值的个数，而主席树就是对每一个前缀都建了一棵树，只不过是优化了空间，并没有真的建出一棵树，在一棵树上拉出了几条链，查询区间第k小时，就用r版本的树减去l-1版本的树，得到的就是这个区间的树</p>
<h2 id="洛谷P3834"><a href="#洛谷P3834" class="headerlink" title="洛谷P3834"></a><a href="https://www.luogu.com.cn/problem/P3834">洛谷P3834</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#pragma G++ optimize(2)</span></span><br><span class="line"><span class="comment">//#pragma G++ optimize(3,&quot;Ofast&quot;,&quot;inline&quot;)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SUB=<span class="number">-0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-4</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> E=<span class="built_in">exp</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> lson,rson,sum;</span><br><span class="line">&#125;hjt[MAXN*<span class="number">5</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">name</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> id,val,fak;</span><br><span class="line">&#125;arr[MAXN];</span><br><span class="line"><span class="type">int</span> bak[MAXN];</span><br><span class="line"><span class="type">int</span> root[MAXN*<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> n,m,k,cnt,mid;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">cmp1</span><span class="params">(name a,name b)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.val&lt;b.val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">cmp2</span><span class="params">(name a,name b)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.id&lt;b.id;</span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">	<span class="type">int</span> rt=++cnt;  <span class="comment">//分配空间 </span></span><br><span class="line">	<span class="keyword">if</span>(l==r) <span class="keyword">return</span> rt;  <span class="comment">//如果这个节点是叶子节点(不是管理员)就返回这个节点的编号 </span></span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	hjt[rt].lson=build(l,mid);  <span class="comment">//建立这个节点的左子树 </span></span><br><span class="line">	hjt[rt].rson=build(mid+<span class="number">1</span>,r);</span><br><span class="line">	<span class="keyword">return</span> rt;  <span class="comment">//返回根节点 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> pre,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> pos)</span>&#123;</span><br><span class="line">	<span class="type">int</span> rt=++cnt;  <span class="comment">//分配空间</span></span><br><span class="line">	hjt[rt]=hjt[pre];  <span class="comment">//在前一个版本的基础上建树</span></span><br><span class="line">	hjt[rt].sum++;  <span class="comment">//当前版本多了一个值 </span></span><br><span class="line">	<span class="keyword">if</span>(l==r)  <span class="keyword">return</span> rt;  <span class="comment">//叶子节点直接返回，表示已经建好当前版本了</span></span><br><span class="line">	mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(pos&lt;=mid) hjt[rt].lson=insert(hjt[pre].lson,l,mid,pos);</span><br><span class="line">	<span class="keyword">else</span> hjt[rt].rson=insert(hjt[pre].rson,mid+<span class="number">1</span>,r,pos); </span><br><span class="line">	<span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r) <span class="keyword">return</span> l;</span><br><span class="line">	<span class="type">int</span> cha=hjt[hjt[v].lson].sum-hjt[hjt[u].lson].sum;</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(cha&gt;=k) <span class="keyword">return</span> query(hjt[u].lson,hjt[v].lson,l,mid,k);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> query(hjt[u].rson,hjt[v].rson,mid+<span class="number">1</span>,r,k-cha);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;arr[i].val;</span><br><span class="line">		bak[i]=arr[i].val;</span><br><span class="line">		arr[i].id=i;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(bak+<span class="number">1</span>,bak+<span class="number">1</span>+n);</span><br><span class="line">	sort(arr+<span class="number">1</span>,arr+<span class="number">1</span>+n,cmp1);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) arr[i].fak=i;</span><br><span class="line">	sort(arr+<span class="number">1</span>,arr+<span class="number">1</span>+n,cmp2);</span><br><span class="line">	root[<span class="number">0</span>]=build(<span class="number">1</span>,n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) root[i]=insert(root[i<span class="number">-1</span>],<span class="number">1</span>,n,arr[i].fak);</span><br><span class="line"><span class="comment">//	for(int i=0;i&lt;=n;i++) cout&lt;&lt;hjt[root[i]].sum&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line"><span class="comment">//	cout&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="type">int</span> l,r;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r&gt;&gt;k;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;bak[query(root[l<span class="number">-1</span>],root[r],<span class="number">1</span>,n,k)]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title>三分</title>
    <url>/posts/d459644e.html</url>
    <content><![CDATA[<h2 id="POJ2420"><a href="#POJ2420" class="headerlink" title="POJ2420"></a>POJ2420</h2><p>三分和二分输出答案是l还是r就看中间的判断条件，不满足条件更新的那个值就是要输出的值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-5</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N],b[N];</span><br><span class="line"><span class="type">double</span> <span class="title function_">getdis</span><span class="params">(<span class="type">double</span> x,<span class="type">double</span> y)</span>&#123;</span><br><span class="line">	<span class="type">double</span> res=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) res+=<span class="built_in">sqrt</span>(<span class="built_in">pow</span>(x-a[i],<span class="number">2</span>)+<span class="built_in">pow</span>(y-b[i],<span class="number">2</span>));</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> <span class="title function_">work</span><span class="params">(<span class="type">double</span> x)</span>&#123;</span><br><span class="line">	<span class="type">double</span> l=<span class="number">0</span>,r=<span class="number">10000</span>,lmid,rmid;</span><br><span class="line">	<span class="keyword">while</span>(r-l&gt;eps)&#123;</span><br><span class="line">		lmid=l+(r-l)/<span class="number">3</span>;</span><br><span class="line">		rmid=r-(r-l)/<span class="number">3</span>;</span><br><span class="line">		<span class="keyword">if</span>(getdis(x,lmid)&gt;getdis(x,rmid)) l=lmid;</span><br><span class="line">		<span class="keyword">else</span> r=rmid;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> getdis(x,lmid);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;a[i]&gt;&gt;b[i];</span><br><span class="line">	<span class="type">double</span> l=<span class="number">0</span>,r=<span class="number">10000</span>,lmid,rmid;</span><br><span class="line">	<span class="keyword">while</span>(r-l&gt;eps)&#123;</span><br><span class="line">		lmid=l+(r-l)/<span class="number">3</span>;</span><br><span class="line">		rmid=r-(r-l)/<span class="number">3</span>;</span><br><span class="line">		<span class="keyword">if</span>(work(lmid)&gt;work(rmid)) l=lmid;</span><br><span class="line">		<span class="keyword">else</span> r=rmid;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;fixed&lt;&lt;setprecision(<span class="number">0</span>)&lt;&lt;work(l)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>三分</tag>
      </tags>
  </entry>
  <entry>
    <title>判断是否存在一条线经过所有线段</title>
    <url>/posts/bd16ef6a.html</url>
    <content><![CDATA[<h1 id="ACWING"><a href="#ACWING" class="headerlink" title="ACWING"></a><a href="https://www.acwing.com/problem/content/2987/">ACWING</a></h1><p><img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/ef4eb9ca60b54de5814e0442fae75655.png" alt="ef4eb9ca60b54de5814e0442fae75655"></p>
<p>如果一条直线经过了所有线段，那么把这条直线旋转之后，边界就是卡在两个线段的端点处</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/773f3b29fcdd40be885f42432645b139.png" alt="773f3b29fcdd40be885f42432645b139"></p>
<p>那么就可以遍历每两个端点，判断这两个端点组成的直线是否穿过了所有的线段，如果是，则存在，不是继续找，找不到就不存在</p>
<p>如何判断一条直线是否经过了所有点呢？挨个判断这条线是否穿过线段</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#pragma G++ optimize(2)</span></span><br><span class="line"><span class="comment">//#pragma G++ optimize(3,&quot;Ofast&quot;,&quot;inline&quot;)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SUB=<span class="number">-0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-8</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> E=<span class="built_in">exp</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">int</span> t,n,tail;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line">	<span class="type">double</span> x,y;</span><br><span class="line">&#125;pt[MAXN];	<span class="comment">//点</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">cross</span><span class="params">(point a,point b,point c)</span>&#123;	<span class="comment">//叉积</span></span><br><span class="line">	<span class="keyword">return</span> (b.x-a.x)*(c.y-a.y)-(c.x-a.x)*(b.y-a.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fcmp</span><span class="params">(<span class="type">double</span> x,<span class="type">double</span> y)</span>&#123;	<span class="comment">//误差比较</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">fabs</span>(x-y)&lt;eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(x&gt;y) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sign</span><span class="params">(<span class="type">double</span> x)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">fabs</span>(x)&lt;=eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(x&gt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">check</span><span class="params">(<span class="type">double</span> x1,<span class="type">double</span> y1,<span class="type">double</span> x2,<span class="type">double</span> y2)</span>&#123;</span><br><span class="line">	point q1=&#123;x1,y1&#125;,q2=&#123;x2,y2&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=tail;k+=<span class="number">2</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(sign(cross(q1,q2,pt[k]))*sign(cross(q1,q2,pt[k+<span class="number">1</span>]))&gt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; 	<span class="comment">//在直线的同一侧</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		tail=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="type">double</span> x1,y1,x2,y2;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;</span><br><span class="line">			pt[++tail]=&#123;x1,y1&#125;;</span><br><span class="line">			pt[++tail]=&#123;x2,y2&#125;;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;tail;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=tail;j++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(!fcmp(pt[i].x,pt[j].x) &amp;&amp; !fcmp(pt[i].y,pt[j].y)) <span class="keyword">continue</span>;</span><br><span class="line">				<span class="keyword">if</span>(check(pt[i].x,pt[i].y,pt[j].x,pt[j].y)) flag=<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span>(flag) <span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(flag) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(flag) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Yes!\n&quot;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;No!\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title>可持久化并查集</title>
    <url>/posts/1011873c.html</url>
    <content><![CDATA[<h1 id="可持久并查集"><a href="#可持久并查集" class="headerlink" title="可持久并查集"></a>可持久并查集</h1><blockquote>
<p>前置知识：主席树、可持久化数组</p>
<p>作用：保存历史的集合版本，查询过去版本</p>
<p>空间复杂度&gt;=(klog(n)+2^log(n)^-1) [一般开40倍原空间]</p>
</blockquote>
<p><a href="https://www.cnblogs.com/peng-ym/p/9357220.html">详细讲解</a></p>
<h2 id="大致过程"><a href="#大致过程" class="headerlink" title="大致过程"></a>大致过程</h2><p>将fa数组和dep数组可持久化，fa数组就有了各个版本不同的值，如果开结构体的话只需要将fa定义成结构体类型，因为两个数组可持久化后下标是相同的，需要注意的是不能路径压缩，一定要按秩合并！</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://www.luogu.com.cn/problem/P3402">洛谷模板</a></p>
<p><img src="C:\Users\60116\AppData\Roaming\Typora\typora-user-images\image-20210426204636666.png" alt="image-20210426204636666" style="zoom:50%;" /></p>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定n个集合，每一个集合初始只有自己一个数，接下来m次操作，每次操作有三种选择，合并a和b，回到k版本，询问a和b是否属于一个集合</p>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>将fa数组和dep数组可持久化，需要注意的是一定不能路径压缩，因为每次要保存版本，只是拉出来一条链，压缩路径的话就会影响其他版本的fa数组值，例如现在高版本压缩了一次路径，低版本的fa数组值被改变了，之后查询低版本时就会出错！如果没有了路径压缩那么时间就会慢很多，所以一定要按秩合并来优化一下，为什么按秩合并会快一点呢？</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/20210426213038.png" alt="image-20210426213034161" style="zoom:50%;" /></p>
<p>看这个图，倘若询问2和4是否在一个集合，第一个畸形图就需要多往上走两步，而第二个图就可以省下些时间。</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#pragma G++ optimize(2)</span></span><br><span class="line"><span class="comment">//#pragma G++ optimize(3,&quot;Ofast&quot;,&quot;inline&quot;)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SUB=<span class="number">-0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-4</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> E=<span class="built_in">exp</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> ls,rs,val;</span><br><span class="line">&#125;fa[MAXN*<span class="number">40</span>];  </span><br><span class="line"><span class="type">int</span> dep[MAXN*<span class="number">40</span>],rt[MAXN*<span class="number">40</span>];</span><br><span class="line"><span class="type">int</span> n,m,op,a,b,tot,k;</span><br><span class="line"><span class="type">int</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span>&#123;  </span><br><span class="line">	<span class="type">int</span> root=++tot;</span><br><span class="line">	<span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">		fa[root].val=l;  <span class="comment">//初始fa数组值为本身</span></span><br><span class="line">		<span class="keyword">return</span> root;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	fa[root].ls=build(l,mid);</span><br><span class="line">	fa[root].rs=build(mid+<span class="number">1</span>,r);</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> nod,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span>&#123;  <span class="comment">//查询x在这个版本的fa数组下标</span></span><br><span class="line">	<span class="keyword">if</span>(l==r) <span class="keyword">return</span> nod;</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=mid) <span class="keyword">return</span> query(fa[nod].ls,l,mid,x);  <span class="comment">//在左子树上</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> query(fa[nod].rs,mid+<span class="number">1</span>,r,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> nod,<span class="type">int</span> x)</span>&#123;</span><br><span class="line">	<span class="type">int</span> now=query(nod,<span class="number">1</span>,n,x);  <span class="comment">//查询x点在这个版本中fa数组的下标</span></span><br><span class="line">	<span class="keyword">if</span>(fa[now].val==x) <span class="keyword">return</span> now;  <span class="comment">//如果x的父亲值就是x说明x就是祖先</span></span><br><span class="line">	<span class="keyword">return</span> find(nod,fa[now].val);  <span class="comment">//否则就继续找</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">remerge</span><span class="params">(<span class="type">int</span> pre,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">	<span class="type">int</span> root=++tot;</span><br><span class="line">	fa[root]=fa[pre];  <span class="comment">//合并时需要创建一个新版本</span></span><br><span class="line">	<span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">		fa[root].val=y;  <span class="comment">//更新这个位置的父亲值</span></span><br><span class="line">		<span class="keyword">return</span> root;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=mid) fa[root].ls=remerge(fa[pre].ls,l,mid,x,y);</span><br><span class="line">	<span class="keyword">else</span> fa[root].rs=remerge(fa[pre].rs,mid+<span class="number">1</span>,r,x,y);</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	rt[<span class="number">0</span>]=build(<span class="number">1</span>,n);  <span class="comment">//初始化fa数组</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;op;</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">			rt[i]=rt[i<span class="number">-1</span>];  <span class="comment">//一定不能少了这一句，之前我就是想着remerge里面已经创建当前版本了，所以这一句没必要，但是如果两个点已经在一个集合里了，下面的if就不会执行，当前版本就没有保存</span></span><br><span class="line">			<span class="type">int</span> x=find(rt[i],a),y=find(rt[i],b);  <span class="comment">//查询a和b在当前版本的祖先</span></span><br><span class="line">			<span class="keyword">if</span>(fa[x].val!=fa[y].val)&#123;  </span><br><span class="line">				<span class="keyword">if</span>(dep[x]&gt;dep[y]) swap(x,y);  <span class="comment">//按秩合并</span></span><br><span class="line">				rt[i]=remerge(rt[i<span class="number">-1</span>],<span class="number">1</span>,n,fa[x].val,fa[y].val);  <span class="comment">//保存版本</span></span><br><span class="line">				<span class="keyword">if</span>(dep[x]==dep[y]) dep[y]++;  <span class="comment">//如果两个集合高度相同的话，合并后父集合高度要加一</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>)&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;k;</span><br><span class="line">			rt[i]=rt[k];  <span class="comment">//回到k版本</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">3</span>)&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">			rt[i]=rt[i<span class="number">-1</span>];  <span class="comment">//新建版本</span></span><br><span class="line">			<span class="type">int</span> fx=find(rt[i],a),fy=find(rt[i],b);  <span class="comment">//查询</span></span><br><span class="line">			<span class="keyword">if</span>(fx==fy) <span class="built_in">cout</span>&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>可持续化并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>半平面交</title>
    <url>/posts/d0f12e08.html</url>
    <content><![CDATA[<blockquote>
<p>半平面交用于求几个凸包围成的面积</p>
</blockquote>
<p>一条直线可以将平面分为两部分，我们取左半部分，右半部分舍弃，那么所有的直线围成的左半部分的面积的交集就是半平面交。</p>
<h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><p>首先把所有线首先按照角度从小到大排序，角度相同就按照线从左到右排序，排序后用一个双端队列来维护，每次新进来一条边，判断这条边是否在队列的队尾两条边的交点左边，如果是，就把队尾元素pop出去，如此往复，队头也是如此，所有边遍历完后还要用队头去维护队尾，用队尾去维护队头</p>
<h2 id="线点"><a href="#线点" class="headerlink" title="线点"></a>线点</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line">	<span class="type">double</span> x,y;</span><br><span class="line">&#125;pt[MAXN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">line</span>&#123;</span></span><br><span class="line">	point a,b;</span><br><span class="line">&#125;L[MAXN];</span><br></pre></td></tr></table></figure>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>思想很简单，但是实现很复杂，一点点错误满盘皆输，这8个函数非常有用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">point operator-(point a,point b)&#123;	<span class="comment">//重载运算符 </span></span><br><span class="line">	<span class="keyword">return</span> &#123;a.x-b.x,a.y-b.y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> <span class="title function_">cross</span><span class="params">(point a,point b)</span>&#123;		<span class="comment">//叉积 </span></span><br><span class="line">	<span class="keyword">return</span> a.x*b.y-a.y*b.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> <span class="title function_">area</span><span class="params">(point a,point b,point c)</span>&#123;	<span class="comment">//ab向量叉乘ac向量 </span></span><br><span class="line">	<span class="keyword">return</span> cross(b-a,c-a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> <span class="title function_">get_angle</span><span class="params">(line x)</span>&#123;	<span class="comment">//得到线的角度 </span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">atan2</span>(x.b.y-x.a.y,x.b.x-x.a.x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">cmp</span><span class="params">(line a,line b)</span>&#123;</span><br><span class="line">	<span class="type">double</span> ag1=get_angle(a),ag2=get_angle(b);	<span class="comment">//得到两条线的角度 </span></span><br><span class="line">	<span class="keyword">if</span>(ag1==ag2) <span class="keyword">return</span> (area(a.a,a.b,b.b)&lt;<span class="number">0</span>);	<span class="comment">//返回左边的，这是因为两条平行的直线左边的有用 </span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> ag1&lt;ag2;	<span class="comment">//角度小的在前 </span></span><br><span class="line">&#125;</span><br><span class="line">point <span class="title function_">get_J</span><span class="params">(point p,point u,point q,point v)</span>&#123;	<span class="comment">//得到交点 </span></span><br><span class="line">	point w=p-q;</span><br><span class="line">	<span class="type">double</span> t=cross(v,w)/cross(u,v);</span><br><span class="line">	<span class="keyword">return</span> &#123;p.x+u.x*t,p.y+u.y*t&#125;;</span><br><span class="line">&#125;</span><br><span class="line">point <span class="title function_">get_J</span><span class="params">(line a,line b)</span>&#123;		<span class="comment">//重载 </span></span><br><span class="line">	<span class="keyword">return</span> get_J(a.a,a.b-a.a,b.a,b.b-b.a); </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">onRight</span><span class="params">(line a,line b,line c)</span>&#123;		<span class="comment">//判断a是否在bc交点右面 </span></span><br><span class="line">	point x=get_J(b,c);</span><br><span class="line">	<span class="keyword">return</span> area(a.a,a.b,x)&lt;=<span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ACWING2803凸多边形"><a href="#ACWING2803凸多边形" class="headerlink" title="ACWING2803凸多边形"></a><a href="https://www.acwing.com/problem/content/2805/">ACWING2803凸多边形</a></h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SUP=<span class="number">0x800000</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-8</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line">	<span class="type">double</span> x,y;</span><br><span class="line">&#125;pt[MAXN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">line</span>&#123;</span></span><br><span class="line">	point a,b;</span><br><span class="line">&#125;L[MAXN];</span><br><span class="line"><span class="type">int</span> cnt,n,m;</span><br><span class="line"><span class="type">int</span> front,tail;</span><br><span class="line"><span class="type">int</span> dq[MAXN];</span><br><span class="line">point operator-(point a,point b)&#123;	<span class="comment">//重载运算符 </span></span><br><span class="line">	<span class="keyword">return</span> &#123;a.x-b.x,a.y-b.y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> <span class="title function_">cross</span><span class="params">(point a,point b)</span>&#123;		<span class="comment">//叉积 </span></span><br><span class="line">	<span class="keyword">return</span> a.x*b.y-a.y*b.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> <span class="title function_">area</span><span class="params">(point a,point b,point c)</span>&#123;	<span class="comment">//ab向量叉乘ac向量 </span></span><br><span class="line">	<span class="keyword">return</span> cross(b-a,c-a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> <span class="title function_">get_angle</span><span class="params">(line x)</span>&#123;	<span class="comment">//得到线的角度 </span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">atan2</span>(x.b.y-x.a.y,x.b.x-x.a.x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">cmp</span><span class="params">(line a,line b)</span>&#123;</span><br><span class="line">	<span class="type">double</span> ag1=get_angle(a),ag2=get_angle(b);	<span class="comment">//得到两条线的角度 </span></span><br><span class="line">	<span class="keyword">if</span>(ag1==ag2) <span class="keyword">return</span> (area(a.a,a.b,b.b)&lt;<span class="number">0</span>);	<span class="comment">//返回左边的，这是因为两条平行的直线左边的有用 </span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> ag1&lt;ag2;	<span class="comment">//角度小的在前 </span></span><br><span class="line">&#125;</span><br><span class="line">point <span class="title function_">get_J</span><span class="params">(point p,point u,point q,point v)</span>&#123;	<span class="comment">//得到交点 </span></span><br><span class="line">	point w=p-q;</span><br><span class="line">	<span class="type">double</span> t=cross(v,w)/cross(u,v);</span><br><span class="line">	<span class="keyword">return</span> &#123;p.x+u.x*t,p.y+u.y*t&#125;;</span><br><span class="line">&#125;</span><br><span class="line">point <span class="title function_">get_J</span><span class="params">(line a,line b)</span>&#123;		<span class="comment">//重载 </span></span><br><span class="line">	<span class="keyword">return</span> get_J(a.a,a.b-a.a,b.a,b.b-b.a); </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">onRight</span><span class="params">(line a,line b,line c)</span>&#123;		<span class="comment">//判断a是否在bc交点右面 </span></span><br><span class="line">	point x=get_J(b,c);</span><br><span class="line">	<span class="keyword">return</span> area(a.a,a.b,x)&lt;=<span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">half</span><span class="params">()</span>&#123;</span><br><span class="line">	sort(L+<span class="number">1</span>,L+<span class="number">1</span>+cnt,cmp);</span><br><span class="line">	front=<span class="number">1</span>;tail=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i&gt;=<span class="number">2</span> &amp;&amp; get_angle(L[i<span class="number">-1</span>])==get_angle(L[i])) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">while</span>(tail-front&gt;=<span class="number">1</span> &amp;&amp; onRight(L[i],L[dq[tail<span class="number">-1</span>]],L[dq[tail]])) tail--;</span><br><span class="line">		<span class="keyword">while</span>(tail-front&gt;=<span class="number">1</span> &amp;&amp; onRight(L[i],L[dq[front]],L[dq[front+<span class="number">1</span>]])) front++;</span><br><span class="line">		dq[++tail]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(tail-front&gt;=<span class="number">1</span> &amp;&amp; onRight(L[dq[front]],L[dq[tail<span class="number">-1</span>]],L[dq[tail]])) tail--;</span><br><span class="line">	<span class="keyword">while</span>(tail-front&gt;=<span class="number">1</span> &amp;&amp; onRight(L[dq[tail]],L[dq[front]],L[dq[front+<span class="number">1</span>]])) front++;</span><br><span class="line">	dq[++tail]=dq[front];</span><br><span class="line">	<span class="type">double</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> js=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=front;i&lt;tail;i++)&#123;</span><br><span class="line">		pt[++js]=get_J(L[dq[i]],L[dq[i+<span class="number">1</span>]]);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i+<span class="number">1</span>&lt;=js;i++)&#123;</span><br><span class="line">		ans+=area(pt[<span class="number">1</span>],pt[i],pt[i+<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;fixed&lt;&lt;setprecision(<span class="number">3</span>)&lt;&lt;ans/<span class="number">2</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;m;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;pt[j].x&gt;&gt;pt[j].y;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(j!=m) L[++cnt]=&#123;pt[j].x,pt[j].y,pt[j+<span class="number">1</span>].x,pt[j+<span class="number">1</span>].y&#125;;</span><br><span class="line">			<span class="keyword">else</span> L[++cnt]=&#123;pt[j].x,pt[j].y,pt[<span class="number">1</span>].x,pt[<span class="number">1</span>].y&#125;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	half();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title>可持久化数组</title>
    <url>/posts/9bca2feb.html</url>
    <content><![CDATA[<h1 id="可持久化数组-可持久化线段树"><a href="#可持久化数组-可持久化线段树" class="headerlink" title="可持久化数组(可持久化线段树)"></a>可持久化数组(可持久化线段树)</h1><blockquote>
<p>前置知识：主席树</p>
<p>作用：记录下历史版本，可以进入历史版本进行修改或者查询</p>
</blockquote>
<h2 id="洛谷P3919"><a href="#洛谷P3919" class="headerlink" title="洛谷P3919"></a>洛谷P3919</h2><p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/20210508213141.png" alt="image-20210425201653739" style="zoom:50%;" /></p>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定初始版本数组的n个数，之后m次操作，可以查询或者单点修改，每次查询或者修改都会产生一个新版本，查询产生一摸一样的版本，修改会产生一个只有一个位置不同的版本，版本数连续递增，输出每次查询某一个版本的某一个位置的数是几？</p>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>原本想用vector开n个表示数组的每一个位置的不同版本，想的是每次只把一个数塞进要修改的ve里，不过这样会有问题。正解是可持续化数组，本质上就是一个保存历史版本的线段树，利用主席树的思想单点修改时只拉出来一条链保存修改过的信息。</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#pragma G++ optimize(2)</span></span><br><span class="line"><span class="comment">//#pragma G++ optimize(3,&quot;Ofast&quot;,&quot;inline&quot;)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SUB=<span class="number">-0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-4</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> E=<span class="built_in">exp</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> ls,rs,val;</span><br><span class="line">&#125;hjt[MAXN*<span class="number">32</span>];</span><br><span class="line"><span class="type">int</span> arr[MAXN],rt[MAXN];</span><br><span class="line"><span class="type">int</span> n,m,tot,cnt;</span><br><span class="line"><span class="type">int</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span>&#123;  <span class="comment">//首先建一个初始的树</span></span><br><span class="line">	<span class="type">int</span> root=++tot;  <span class="comment">//分配空间</span></span><br><span class="line">	<span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">		hjt[root].val=arr[l];  <span class="comment">//到叶子节点就保存值</span></span><br><span class="line">		<span class="keyword">return</span> root;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	hjt[root].ls=build(l,mid);  <span class="comment">//建造左子树</span></span><br><span class="line">	hjt[root].rs=build(mid+<span class="number">1</span>,r);  <span class="comment">//建造右子树</span></span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> pre,<span class="type">int</span> pos,<span class="type">int</span> val,<span class="type">int</span> l,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">	<span class="type">int</span> root=++tot;</span><br><span class="line">	hjt[root]=hjt[pre];</span><br><span class="line">	<span class="keyword">if</span>(l==r)&#123;  <span class="comment">//单点修改</span></span><br><span class="line">		hjt[root].val=val;</span><br><span class="line">		<span class="keyword">return</span> root;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(pos&lt;=mid) hjt[root].ls=insert(hjt[pre].ls,pos,val,l,mid);</span><br><span class="line">	<span class="keyword">else</span> hjt[root].rs=insert(hjt[pre].rs,pos,val,mid+<span class="number">1</span>,r);</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> pos)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r) <span class="keyword">return</span> hjt[x].val;</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(pos&lt;=mid) <span class="keyword">return</span> query(l,mid,hjt[x].ls,pos);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> query(mid+<span class="number">1</span>,r,hjt[x].rs,pos);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;arr[i];</span><br><span class="line">	rt[cnt]=build(<span class="number">1</span>,n);</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="type">int</span> k,op,pos,val;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;k&gt;&gt;op;</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;pos&gt;&gt;val;</span><br><span class="line">			rt[++cnt]=insert(rt[k],pos,val,<span class="number">1</span>,n);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;pos;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;query(<span class="number">1</span>,n,rt[k],pos)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">			rt[++cnt]=rt[k];  <span class="comment">//直接复制过来之前的版本</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>可持久化数组</tag>
      </tags>
  </entry>
  <entry>
    <title>字典树</title>
    <url>/posts/eea60a6a.html</url>
    <content><![CDATA[<h1 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h1><blockquote>
<p>作用：快速实现查询某一个字符串是否出现过，类似字符串哈希</p>
<p>时复：O(L) [L:要查询的字符串长度]</p>
<p>空间复杂度：正比于需要插入的字符串总量，比普通数组存储要省空间</p>
</blockquote>
<h2 id="大致过程"><a href="#大致过程" class="headerlink" title="大致过程"></a>大致过程</h2><p>每一个节点代表一个字符，根节点为0，从根节点到叶子节点是一个完整的字符串，实际上就是一个前缀树，两个相同前缀的字符串在字典树上就有一个相同的前缀路径，给每一个节点编一个号，从1开始，用一个二维数组，第一维表示编号，第二维表示字符下标(s[i]-‘a’)，来表示这个编号的节点下有没有这个字符，这样一来省去了相同前缀的空间，而且查询可以每次以O(1)时间查询当前编号下是否有查询字符，需要查询L次，所以是O(L)</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><a href="https://www.luogu.com.cn/problem/P2580">洛谷模板P2580</a></p>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定n个字符串，m次询问，每次询问一个给定字符串是否出现过？</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>两种做法：</p>
<ol>
<li>map</li>
<li>trie字典树</li>
</ol>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#pragma G++ optimize(2)</span></span><br><span class="line"><span class="comment">//#pragma G++ optimize(3,&quot;Ofast&quot;,&quot;inline&quot;)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SUB=<span class="number">-0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-4</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> E=<span class="built_in">exp</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">int</span> nex[MAXN][<span class="number">27</span>];</span><br><span class="line"><span class="type">bool</span> exist[MAXN];</span><br><span class="line"><span class="type">int</span> tot;</span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(<span class="built_in">string</span> s)</span>&#123;</span><br><span class="line">	<span class="type">int</span> len=s.size(),p=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">		<span class="type">int</span> c=s[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">		<span class="keyword">if</span>(!nex[p][c]) nex[p][c]=++tot;</span><br><span class="line">		p=nex[p][c];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="built_in">string</span> s)</span>&#123;</span><br><span class="line">	<span class="type">int</span> len=s.size(),p=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">		<span class="type">int</span> c=s[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">		<span class="keyword">if</span>(!nex[p][c]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		p=nex[p][c];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!exist[p])&#123;</span><br><span class="line">		exist[p]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="type">int</span> n,m;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="built_in">string</span> now;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;now;</span><br><span class="line">		insert(now);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;m;</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="built_in">string</span> now;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;now;</span><br><span class="line">		<span class="type">int</span> k=find(now);</span><br><span class="line">		<span class="keyword">if</span>(k==<span class="number">0</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;WRONG\n&quot;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(k==<span class="number">1</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;OK\n&quot;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;REPEAT\n&quot;</span>; </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字典树</tag>
      </tags>
  </entry>
  <entry>
    <title>小Q与异或</title>
    <url>/posts/53b46afd.html</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="C:\Users\60116\AppData\Roaming\Typora\typora-user-images\image-20210427204752367.png" alt="image-20210427204752367" style="zoom:67%;" /></p>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>让你构造一个序列，满足m个位置的前缀异或等于m个值</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>先把p位置的值定成x，把每一个定好的位置标记一下，从前往后跑，没有标记过的点就给他定一个比1e9要大的数，之所以要比1e9要大，是因为要保证定好的位置和它的前一个位置异或不为0，而定好的位置的值x&lt;=1e9，输出时，就输出每一个数和前一个数的异或结果</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n , m;</span><br><span class="line"><span class="type">int</span> ned[<span class="number">1200000</span>] , is[<span class="number">1200000</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">work</span> <span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> i , p , x , pre;</span><br><span class="line">	<span class="built_in">scanf</span> ( <span class="string">&quot;%d%d&quot;</span> , &amp;n , &amp;m );</span><br><span class="line">	<span class="keyword">for</span> ( i = <span class="number">1</span> ; i &lt;= m ; i++ ) &#123;</span><br><span class="line">		<span class="built_in">scanf</span> ( <span class="string">&quot;%d%d&quot;</span> , &amp;p , &amp;x );</span><br><span class="line">		<span class="keyword">if</span> ( is[p] &amp;&amp; ned[p] != x ) &#123;</span><br><span class="line">			<span class="built_in">printf</span> ( <span class="string">&quot;-1\n&quot;</span> );</span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">		ned[p] = x;</span><br><span class="line">		is[p] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> ( i = <span class="number">1</span> ; i &lt;= n ; i++ ) &#123;</span><br><span class="line">		<span class="keyword">if</span> ( is[i] == <span class="number">0</span> ) &#123;</span><br><span class="line">			ned[i] = <span class="number">1000000000</span> + i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> ( ned[i] == ned[i<span class="number">-1</span>] ) &#123;</span><br><span class="line">			<span class="built_in">printf</span> ( <span class="string">&quot;-1\n&quot;</span> );</span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> ( i = <span class="number">1</span> ; i &lt;= n ; i++ ) &#123;</span><br><span class="line">		<span class="built_in">printf</span> ( <span class="string">&quot;%d%c&quot;</span> , ned[i<span class="number">-1</span>] ^ ned[i] , i==n?<span class="string">&#x27;\n&#x27;</span>:<span class="string">&#x27; &#x27;</span> );</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span> &#123;</span><br><span class="line">	work ();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>异或题</tag>
      </tags>
  </entry>
  <entry>
    <title>可持久化01字典树</title>
    <url>/posts/462ec91a.html</url>
    <content><![CDATA[<h1 id="可持久化01字典树"><a href="#可持久化01字典树" class="headerlink" title="可持久化01字典树"></a>可持久化01字典树</h1><blockquote>
<p>作用：实现区间查询异或最大</p>
<p>时复：插入和查询都是O(logn)</p>
</blockquote>
<h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><p>先开一个内存池，动态开点，每次插入一个数都建一个根节点，从根节点拉出一条链，链上的节点一边连向上一个版本的节点，一边连向新插入的点，再开一个num数组表示每一个节点经过了几次，查询时当高版本的num值大于低版本的num值时表示在这个区间内有对应的值，走到最后直接返回即可</p>
<h2 id="P4735-最大异或和"><a href="#P4735-最大异或和" class="headerlink" title="P4735 最大异或和"></a><a href="https://www.luogu.com.cn/problem/P4735">P4735 最大异或和</a></h2><p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/20210511170238.png" alt="image-20210511170230311"></p>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定有初始值的n个数，m此操作，每次可以选择插入一个数或者查询一个区间内和给定的数异或最大是多少？</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/20200304122526467.png" alt="https://m-sea-blog.com/archives/1450/"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">600000</span>*<span class="number">40</span>;</span><br><span class="line"><span class="type">int</span> ch[MAXN][<span class="number">2</span>],rt[MAXN];</span><br><span class="line"><span class="type">int</span> val[MAXN],num[MAXN];</span><br><span class="line"><span class="type">int</span> tot,n,m,pre,tmp;</span><br><span class="line"><span class="type">int</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> last,<span class="type">int</span> x)</span>&#123;</span><br><span class="line">	<span class="type">int</span> root=++tot,u=root;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">31</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">		<span class="type">int</span> id=(x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">		ch[u][id]=++tot;</span><br><span class="line">		ch[u][!id]=ch[last][!id];</span><br><span class="line">		num[ch[u][id]]=num[ch[last][id]]+<span class="number">1</span>;</span><br><span class="line">		u=ch[u][id];</span><br><span class="line">		last=ch[last][id];</span><br><span class="line">	&#125;</span><br><span class="line">	val[u]=x;</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r) <span class="keyword">return</span> <span class="number">0</span>^x;  <span class="comment">// 特判当区间为空</span></span><br><span class="line">	<span class="type">int</span> ret=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">31</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">		<span class="type">int</span> id=(x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(num[ch[r][!id]]&gt;num[ch[l][!id]])&#123;</span><br><span class="line">			<span class="keyword">if</span>(!id==<span class="number">1</span>) ret+=(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">			l=ch[l][!id];</span><br><span class="line">			r=ch[r][!id];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(id==<span class="number">1</span>) ret+=(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">			l=ch[l][id];</span><br><span class="line">			r=ch[r][id];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret^x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;tmp;</span><br><span class="line">		pre^=tmp;  <span class="comment">//前缀异或</span></span><br><span class="line">		rt[i]=insert(rt[i<span class="number">-1</span>],pre);  <span class="comment">//插入</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="type">char</span> op;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;op;</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;tmp;</span><br><span class="line">			n++;</span><br><span class="line">			pre^=tmp;</span><br><span class="line">			rt[n]=insert(rt[n<span class="number">-1</span>],pre);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="type">int</span> l,r,x;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r&gt;&gt;x;</span><br><span class="line">			<span class="keyword">if</span>(l<span class="number">-1</span>==<span class="number">0</span>) <span class="built_in">cout</span>&lt;&lt;query(<span class="number">0</span>,rt[r<span class="number">-1</span>],pre^x)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;  <span class="comment">//注意这里如果l-1已经等于0了，则直接查询0到r-1范围即可</span></span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;query(rt[l<span class="number">-2</span>],rt[r<span class="number">-1</span>],pre^x)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5 1</span></span><br><span class="line"><span class="comment">2 6 4 3 6</span></span><br><span class="line"><span class="comment">Q 3 5 4 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>可持久化系列</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集求联通块</title>
    <url>/posts/823c4696.html</url>
    <content><![CDATA[<h2 id="P1197-JSOI2008-星球大战"><a href="#P1197-JSOI2008-星球大战" class="headerlink" title="P1197 [JSOI2008]星球大战"></a>P1197 [JSOI2008]星球大战</h2><p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/20210226153916.png" alt="image-20210226153906812" style="zoom:67%;" /></p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>n个星球，m条边，k此摧毁，每次都会摧毁一个星球，摧毁一次求一次联通块，没摧毁时也要输出一次</p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>求联通块有两种方法</p>
<ol>
<li>利用dfs或者bfs从每一个点出发，把能到达的点都标记，每一个点都走一次，时间复杂度为O(n)，</li>
<li>使用并查集，单独n个点联通块就是n个，当两个点连接起来并且这两个点分别属于两个不同的联通块时，把他们合并成一个集合，联通块数量-1，时间复杂度差不多等于边的数量，&gt;O(m)</li>
</ol>
<p>如果只是求一次联通块的数量显然第一种方法更优，但是这道题每少一个点就要求一次联通块，如果用第一种方法时复O(kn)，这道题会超时，这时如果用并查集正着来做，时复O(mk)，也会超时，但是换一种思路，这道题要摧毁星球，我们倒着来，修建星球，每修建一个求一次联通块，而这时并查集时复就是常数级别O(max(m,k))，每修建一个多了一个点，联通块+1，看看和这个点相连的点是否属于一个集合，属于就-1，一个pair存点，再用链式前向星存一下图</p>
<h2 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SUB=<span class="number">-0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> eps=<span class="number">1e-4</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> to,next;</span><br><span class="line">&#125;e[MAXN];</span><br><span class="line"><span class="type">int</span> fa[MAXN],ans[MAXN],head[MAXN],dead[MAXN];</span><br><span class="line"><span class="type">bool</span> vis[MAXN];</span><br><span class="line"><span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; b[MAXN];</span><br><span class="line"><span class="type">int</span> tot,n,m,k;</span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span>&#123;</span><br><span class="line">	e[tot]=&#123;v,head[u]&#125;;</span><br><span class="line">	head[u]=tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==fa[x]) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">return</span> fa[x]=find(fa[x]);</span><br><span class="line">&#125; </span><br><span class="line"><span class="type">void</span> <span class="title function_">remerge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">	<span class="type">int</span> fx=find(x),fy=find(y);</span><br><span class="line">	<span class="keyword">if</span>(fx!=fy) fa[fx]=fy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++) fa[i]=i;</span><br><span class="line">	<span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span> head);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="type">int</span> u,v;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">		b[i]=&#123;u,v&#125;;</span><br><span class="line">		add(u,v);</span><br><span class="line">		add(v,u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;dead[i];</span><br><span class="line">		vis[dead[i]]=<span class="number">1</span>;  <span class="comment">//标记这个点被摧毁了</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> num=n-k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="comment">//如果条边连接的两个点都没有被摧毁且两者不在同一个集合</span></span><br><span class="line">		<span class="keyword">if</span>(!vis[b[i].first] &amp;&amp; !vis[b[i].second] &amp;&amp; find(b[i].first)!=find(b[i].second))&#123;</span><br><span class="line">			remerge(b[i].first,b[i].second);</span><br><span class="line">			num--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//此时就是所有星球被摧毁的联通块</span></span><br><span class="line">	ans[<span class="number">0</span>]=num;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=k;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">		num++; <span class="comment">//加一个点联通块+1</span></span><br><span class="line">		vis[dead[i]]=<span class="number">0</span>;  <span class="comment">//清除这个点的标记</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=head[dead[i]];~j;j=e[j].next)&#123;  <span class="comment">//遍历这个点相连的点</span></span><br><span class="line">			<span class="type">int</span> v=e[j].to;</span><br><span class="line">			<span class="keyword">if</span>(!vis[v] &amp;&amp; find(v)!=find(dead[i]))&#123;  <span class="comment">//相连点存活且不在一个集合联通块-1</span></span><br><span class="line">				num--;</span><br><span class="line">				remerge(v,dead[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		ans[k-i+<span class="number">1</span>]=num;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//倒着输出</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=k;i&gt;=<span class="number">0</span>;i--) <span class="built_in">cout</span>&lt;&lt;ans[i]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用dfs求：</p>
<p>20分，其中一个地方爆栈了，可以换成bfs来求</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">400010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SUB=<span class="number">-0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> eps=<span class="number">1e-4</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> to,next;</span><br><span class="line">&#125;e[<span class="number">200010</span>];</span><br><span class="line"><span class="type">int</span> n,m,tot,k,x,y,js;</span><br><span class="line"><span class="type">int</span> head[MAXN];</span><br><span class="line"><span class="type">bool</span> vis[MAXN],used[MAXN],book[MAXN];</span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span>&#123;</span><br><span class="line">	e[tot]=&#123;v,head[u]&#125;;</span><br><span class="line">	head[u]=tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">	vis[x]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[x];~i;i=e[i].next)&#123;</span><br><span class="line">		<span class="type">int</span> v=e[i].to;</span><br><span class="line">		<span class="keyword">if</span>(vis[v] || used[v]) <span class="keyword">continue</span>;</span><br><span class="line">		dfs(v);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span> head);</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">		add(x,y);</span><br><span class="line">		add(y,x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(vis[i] || used[i]) <span class="keyword">continue</span>;</span><br><span class="line">		js++;</span><br><span class="line">		dfs(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;js&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">while</span>(k--)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">		js=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">		used[x]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(vis[i] || used[i]) <span class="keyword">continue</span>;</span><br><span class="line">			js++;</span><br><span class="line">			dfs(i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;js&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>并查集求联通块</tag>
      </tags>
  </entry>
  <entry>
    <title>整数分块</title>
    <url>/posts/f7996318.html</url>
    <content><![CDATA[<blockquote>
<p>整数分块可以以log(n)的时间复杂度内求出${\sum_{i=1}^n\lfloor n/i \rfloor}$</p>
</blockquote>
<h2 id="小G的约数"><a href="#小G的约数" class="headerlink" title="小G的约数"></a>小G的约数</h2><p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/20210227160808.png" alt="image-20210227160754599" style="zoom:67%;" /></p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>单纯求F(n)O(n)求出，现在求$\sum<em>{i=1}^nF_i$，可以换种思路，从个体对整体的贡献下手，对于每一个约数求有这个约数的所有数数量，显然是n/i个，然后乘上i，那么问题就转化为了${\sum</em>{i=1}^n\lfloor n/i \rfloor*i}$，很明显的整数分块模板，什么是整数分块，考虑n=10的时候n/i的表</p>
<p>i:   1  2 3 4 5 6 7 8 9 10</p>
<p>n/i: 10 5 3 2 2 1 1 1 1 1</p>
<p>发现数字呈从大到小块状分布，只要知道了一个块的左端和右端就能直接算出这个块的n/i的和，这里有一个结论：$N/i==N/i’时，i’的最大值：N/(N/i)$,i’也就是右端点，因此可以枚举每一段区间，n/i的所有数字中不同数字的数量不会超过2*sqrt(n)个，因此时复就是sqrt(n)</p>
<h2 id="整数分块函数"><a href="#整数分块函数" class="headerlink" title="整数分块函数"></a>整数分块函数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ll <span class="title function_">get</span><span class="params">(ll x)</span>&#123;</span><br><span class="line">	ll ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=x;i++)&#123;</span><br><span class="line">        ll r=x/(x/i);</span><br><span class="line">        ret+=x/i*(r-i+<span class="number">1</span>);</span><br><span class="line">	    i=r;  <span class="comment">//把指针移到右端点的下一个位置，这里移到右端点是因为i++</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ACCODE"><a href="#ACCODE" class="headerlink" title="ACCODE"></a>ACCODE</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SUB=<span class="number">-0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> eps=<span class="number">1e-4</span>;</span><br><span class="line">ll <span class="title function_">get</span><span class="params">(ll x)</span>&#123;</span><br><span class="line">	ll ret=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=x;i++)&#123;</span><br><span class="line">		ll r=x/(x/i);</span><br><span class="line">		ret+=(r-i+<span class="number">1</span>)*(x/i)*(i+r)/<span class="number">2</span>;  <span class="comment">//这里要乘以等差数组前缀和</span></span><br><span class="line">		i=r;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	ios;</span><br><span class="line">	ll n;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;get(get(n))&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>整数分块</tag>
      </tags>
  </entry>
  <entry>
    <title>扩展KMP</title>
    <url>/posts/82a15c1d.html</url>
    <content><![CDATA[<h1 id="扩展KMP"><a href="#扩展KMP" class="headerlink" title="扩展KMP"></a>扩展KMP</h1><blockquote>
<p>解决的问题： 求解母串以i位置开始的后缀子串与模式串的最大公共前缀</p>
<p>时复： O(母串长度+模式串长度)</p>
</blockquote>
<p>引入两个概念，extend[]数组表示以母串i位置开始的后缀子串与模式串的最大公共前缀，next[]数组表示模式串以i位置开始的后缀子串与模式串的最大公共前缀，一个是模式串与母串，一个是模式串与模式串</p>
<p>与KMP类似，都采用了利用之前已经得到的信息来优化当前的时间</p>
<h2 id="大致过程"><a href="#大致过程" class="headerlink" title="大致过程"></a>大致过程</h2><p>记一个po表示起始位置，求解extend数组需要先求出next数组，而求解next数组的过程和求extend过程一致，只不过是把模式串当作母串</p>
<p><img src="https://img-blog.csdn.net/2018052216265837?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMTYwNjA1/font/5a6L5L2T" alt="img"></p>
<p>(1) 第一步，我们先对原串S1和模式串S2进行逐一匹配，直到发生不配对的情况。我们可以看到，S1[0]=S2[0],S1[1]=S2[1],S1[2]=S2[2],S1[3] ≠S2[3],此时匹配失败，第一步结束，我们得到S1[0,2]=S2[0,2],即extend[0]=3;</p>
<p>(2) Extend[0]的计算如第一步所示，那么extend[1]的计算是否也要从原串S1的1位置，模式串的0位置开始进行逐一匹配呢？扩展KMP优化的便是这个过程。从extend[0]=3的结果中，我们可以知道，S1[0,2]=S2[0,2],那么S1[1.2]=S2[1,2]。因为next[1]=4,所以S2[1,4]=S2[0,3],即S2[1,2]=S[0,1],可以得出S1[1,2]=S2[1,2]=S2[0,1],然后我们继续匹配，S1[3] ≠S2[3],匹配失败，extend[1]=2;</p>
<p>(3) 因为extend[1]=2,则S1[1,2]=S2[0,1],所以S1[2,2]=S2[0,0],因为next[0]=5,所以S1[0,5]=S2[0,5],所以S2[0,0]=S2[0,0],又回到S1[2,2]=S2[0,0],继续匹配下一位，因为S1[3] ≠S2[1],所以下一位匹配失败，extend[2]=1;</p>
<p>(4) 到计算原串S1的3号位置（在之前的步骤中能匹配到的最远的位置+1,即发生匹配失败的位置），这种情况下，我们会回到步骤（1）的方式，从原串S1的3号位置开始和模式串的0号位置开始，进行逐一匹配，直到匹配失败，此时的extend[]值即为它的匹配长度。因为S1[3] ≠S2[0],匹配失败，匹配长度为0，即extend[3]=0;</p>
<p>(5) 计算S1的4号位置extend[]。由于原串S1的4号位置也是未匹配过的，我们也是回到步骤（1）的方式，从原串S1的4号位置开始和模式串S2的0号位置开始进行逐一匹配，可以看到，S1[4]=S2[0],S1[5]=S2[1],S1[6]=S2[2],S1[7]=S2[3],S1[8]=S2[4],S1[9] ≠S2[5],此时原串S1的9号位置发生匹配失败，最多能匹配到原串S1的8号位置，即S1[4,8]=S2[0,4],匹配长度为5，即extend[4]=5;</p>
<p>(6) 计算S1的5号位置extend[].由于原串S1的5号位置是匹配过的（在步骤（5）中匹配了），我们从extend[4]=5得出，S1[4,8]=S2[0,4],即S1[5,8]=S2[1,4],和步骤（2）的计算方式类似，我们从next[1]=4可知，S2[0,3]=S2[1,4],即S1[5,8]=S2[0,3],然后我们继续匹配原串S1的9号位置和S2的4号位置，S1[9]=S2[4],继续匹配，S1[10]=S2[5],此时原串S1的所有字符皆匹配完毕，皆大欢喜，则S1[5,10]=S2[0,5],extend[5]=6;</p>
<p>(7) 从原串S1的6号位置到10号位置的extend[]的计算，与原串S1的1号位置到3号位置的计算基本相同。S1[6,10]=S2[1,5],因为next[1]=4，所以S2[1,4]=S[0,3],所以S1[6,9]=S2[0,3],此时不在需要判断匹配下一位的字符了，直接extend[6]=4;(具体原因在后面的分析总结中有说明)</p>
<p>(8) S1[7,10]=S2[2,5],因为next[3]=2,所以S2[3,4]=S2[0,1],所以S1[8,9]=S2[0,1],匹配长度为2，即extend[7]=3;</p>
<p>(9) S1[8,10]=S2[3,5],因为next[3]=2,所以S2[3,4]=S2[0,1],所以S1[8,9]=S2[0,1],匹配长度为2，即extend[8]=2;</p>
<p>(10) S1[9,10]=S2[4,5],因为next[4]=1,所以S2[4,5]=S2[0,0],所以S1[9,9]=S2[0,0],匹配长度为1，即extend[9]=1;</p>
<p>(11) S1[10,10]=S2[5,5],因为next[5]=0,所以匹配长度为0，即extend[10]=0;</p>
<p>至此，所有的匹配已经结束，相信，如果你仔细的看了上述的例子，已经对扩展KMP有了一定的了解了，它的计算过程中，主要是步骤一和步骤二的计算过程。下面我们对这两个过程归纳一下：</p>
<p><img src="https://img-blog.csdn.net/20180522162729858?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMTYwNjA1/font/5a6L5L2T" alt="img"></p>
<p>我们可以得出，len=next[k+1-Po],S2[0,len-1]=S2[k+1-Po,k+Po+len],所以S1[k+1,k+len]=S2[k+1-Po,k+Po+len]=S2[0,len-1],即extend[k+1]=len;</p>
<p>那么会不会出现S1[k+len+1]=S2[len]的情况呢？答案是否定的</p>
<p>假如S1[k+len+1]=S2[len],则S1[k+1,k+len+1]=S2[0,len]</p>
<p>因为k+len&lt;P,所以k+len+1&lt;=P</p>
<p>所以S1[k+1,k+len+1]=S2[k+1-Po,k+Po+len+1]=S2[0,len]</p>
<p>此时，next[k+1-Po]=len+1与原假设不符合，所以此时S1[k+len+1]≠S2[len],不需要再次判断。</p>
<p>（2）当（k+1）+len-1=k+len&gt;=P时，即以下情况：</p>
<p><img src="https://img-blog.csdn.net/20180522162806418?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMTYwNjA1" alt="img"></p>
<p>我们可以看出，由S1[Po,P]=S2[0,P-Po]可得出S1[k+1,P]=S2[k+1-Po,P-po]，len=next[k+1-Po],所以S2[0,len-1]=S2[k+1-Po,k+len+Po]</p>
<p>所以S1[k+1,p]=S2[0,P-k-1]</p>
<p>由于大于P的位置我们还未进行匹配，所以从原串S1的P+1位置开始和模式串的P-k位置开始进行逐一匹配，直到匹配失败，并更新相应的Po位置和最远匹配位置P,此时extend[k+1]=P-k+后来逐一匹配的匹配长度。</p>
<p>其实，next[]数组的计算过程与extend[]的计算过程基本一致，可以看成是原串S2和模式串S2的扩展KMP进行计算，每次计算extend[k+1]时，next[i](0&lt;=i&lt;=k)已经算出来了，算出extend[k+1]的时候，意味着next[k+1]=extend[k+1]也计算出来了。</p>
<p>时间复杂度分析</p>
<p>通过上面的算法可知，我们原串S1的每一个字符串只会进行一次匹配，extend[k+1]的计算可以通过之前extend<a href="0&lt;=i&lt;=k">i\</a>的值得出，由于需要用相同的方法对模式串S2进行一次预处理，所以扩展KMP的时间复杂度为O(l1+l2),其中，l1为原串S1的长度，l2为模式串S2的长度。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">getnext</span><span class="params">(<span class="built_in">string</span> T)</span>&#123;</span><br><span class="line">	<span class="type">int</span> len=T.size();</span><br><span class="line">	nex[<span class="number">0</span>]=len;</span><br><span class="line">	<span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(p+<span class="number">1</span>&lt;len &amp;&amp; T[p]==T[p+<span class="number">1</span>]) p++;  <span class="comment">//这里注意把边界写在前面</span></span><br><span class="line">	nex[<span class="number">1</span>]=p;</span><br><span class="line">	<span class="type">int</span> po=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;len;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i+nex[i-po]&lt;po+nex[po]) nex[i]=nex[i-po];  <span class="comment">//第一种情况，直接得到答案</span></span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="type">int</span> j=po+nex[po]-i;  </span><br><span class="line">			<span class="keyword">if</span>(j&lt;<span class="number">0</span>) j=<span class="number">0</span>;  <span class="comment">//超出已匹配的字符串长度，需要重新匹配</span></span><br><span class="line">			<span class="keyword">while</span>(i+j&lt;len &amp;&amp; T[i+j]==T[j]) j++;</span><br><span class="line">			nex[i]=j;</span><br><span class="line">			po=i;  <span class="comment">//长度超出，更新起始位置</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">extmp</span><span class="params">(<span class="built_in">string</span> S,<span class="built_in">string</span> T)</span>&#123;</span><br><span class="line">	<span class="type">int</span> len1=S.size(), len2=T.size();</span><br><span class="line">	getnext(T);</span><br><span class="line">	<span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(p&lt;len1 &amp;&amp; p&lt;len2 &amp;&amp; S[p]==T[p]) p++;  <span class="comment">//边界写到前面</span></span><br><span class="line">	ext[<span class="number">0</span>]=p;</span><br><span class="line">	<span class="type">int</span> po=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len1;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i+nex[i-po]&lt;po+ext[po]) ext[i]=nex[i-po];</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="type">int</span> j=po+ext[po]-i;</span><br><span class="line">			<span class="keyword">if</span>(j&lt;<span class="number">0</span>) j=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span>(i+j&lt;len1 &amp;&amp; j&lt;len2 &amp;&amp; T[j]==S[i+j]) j++;</span><br><span class="line">			ext[i]=j;</span><br><span class="line">			po=i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="武辰延的字符串"><a href="#武辰延的字符串" class="headerlink" title="武辰延的字符串"></a>武辰延的字符串</h2><p><a href="https://ac.nowcoder.com/acm/contest/9984/B">题目</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/20210407203054.png" alt="image-20210407203042725" style="zoom:50%;" /></p>
<p>可以用扩展KMP来做，将s2当作母串，对于s1和s1的公共前缀子串，每一个位置的extend值累加起来就是答案</p>
<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">string</span> S,T;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ext[<span class="number">110000</span>],nex[<span class="number">110000</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">getnext</span><span class="params">(<span class="built_in">string</span> T)</span>&#123;</span><br><span class="line">	<span class="type">int</span> len=T.size();</span><br><span class="line">	nex[<span class="number">0</span>]=len;</span><br><span class="line">	<span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(p+<span class="number">1</span>&lt;len &amp;&amp; T[p]==T[p+<span class="number">1</span>]) p++;</span><br><span class="line">	nex[<span class="number">1</span>]=p;</span><br><span class="line">	<span class="type">int</span> po=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;len;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i+nex[i-po]&lt;po+nex[po]) nex[i]=nex[i-po];</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="type">int</span> j=po+nex[po]-i;</span><br><span class="line">			<span class="keyword">if</span>(j&lt;<span class="number">0</span>) j=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span>(i+j&lt;len &amp;&amp; T[i+j]==T[j]) j++;</span><br><span class="line">			nex[i]=j;</span><br><span class="line">			po=i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">extmp</span><span class="params">(<span class="built_in">string</span> S,<span class="built_in">string</span> T)</span>&#123;</span><br><span class="line">	<span class="type">int</span> len1=S.size(), len2=T.size();</span><br><span class="line">	getnext(T);</span><br><span class="line">	<span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(p&lt;len1 &amp;&amp; p&lt;len2 &amp;&amp; S[p]==T[p]) p++;</span><br><span class="line">	ext[<span class="number">0</span>]=p;</span><br><span class="line">	<span class="type">int</span> po=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len1;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i+nex[i-po]&lt;po+ext[po]) ext[i]=nex[i-po];</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="type">int</span> j=po+ext[po]-i;</span><br><span class="line">			<span class="keyword">if</span>(j&lt;<span class="number">0</span>) j=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span>(i+j&lt;len1 &amp;&amp; j&lt;len2 &amp;&amp; T[j]==S[i+j]) j++;</span><br><span class="line">			ext[i]=j;</span><br><span class="line">			po=i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;T&gt;&gt;S;</span><br><span class="line">	extmp(S,T);</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> len1=T.size(),len2=S.size(),ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len1;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i&gt;=len2) <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span>(T[i]!=S[i]) <span class="keyword">break</span>;</span><br><span class="line">		ans+=ext[i+<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>数学期望</title>
    <url>/posts/b9d78651.html</url>
    <content><![CDATA[<blockquote>
<p>期望: 结果乘以结果出现的概率</p>
<p>$E(X+Y)=E(X)+E(Y)$</p>
<p>$E(XY)=E(X)E(Y)——(X和Y相互独立)$</p>
</blockquote>
<h2 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>投硬币，连续出现K次正面的投掷次数期望值。</p>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>假设已经连续抛出$n-1$次正面，需要$T<em>{n−1}$次。想得到$n$次正面，则再进行一次投掷$Tn=T</em>{n−1}+1+?$</p>
<p>若硬币为正面则游戏结束，还需要抛0次$Tn=T_{n−1}+1+0.5∗0+?$）</p>
<p>如果硬币为反面，则游戏重来，还需要投掷$0.5∗Tn$次，递推公式如下所示：</p>
<p>$Tn=T_{n−1}+1+0.5∗0+0.5∗Tn$</p>
<p>求出通项公式:</p>
<p>$Tn=2^{n+1}+2$</p>
<h2 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h2><p><a href="https://ac.nowcoder.com/acm/problem/25193">题目链接</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/image-20211119093700596.png" alt="image-20211119093700596"></p>
<p>设dp[i]表示i个座位最后坐满人的情况，那么对于n个座位而言，第一个人上车就有n个选择，坐在第一个位置，剩下的就是dp[n-2]，坐在第二个位置，剩下的就是$dp[0]+dp[n-3]$，坐在第三个位置，剩下的就是$dp[1]+dp[n-4]$，以此类推…</p>
<p>求个和，就是$2*sum[n-2]$，sum[n-2]表示前n-2项的前缀和(dp[0]=0)</p>
<p>还要把第一个人加上，因为有n个选择，所以加n，每一个选择有$1/n$的概率，所以最后除以n</p>
<p>$dp[i]=(i+2*cnt)/n$</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1000002</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1000000007</span>;</span><br><span class="line">ll dp[N];</span><br><span class="line">ll <span class="title function_">ksm</span><span class="params">(ll a,ll b)</span>&#123;</span><br><span class="line">	ll res=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(b)&#123;</span><br><span class="line">		<span class="keyword">if</span>(b&amp;<span class="number">1</span>) res=res*a%mod;</span><br><span class="line">		a=a*a%mod;</span><br><span class="line">		b&gt;&gt;=<span class="number">1</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">ll <span class="title function_">inv</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ksm(x,mod<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	dp[<span class="number">1</span>]=<span class="number">1</span>; dp[<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">	ll cnt=<span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		dp[i]=(<span class="number">2</span>*cnt%mod+i)*inv(i)%mod;</span><br><span class="line">		cnt=(cnt+dp[i<span class="number">-1</span>])%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;dp[n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="问题三"><a href="#问题三" class="headerlink" title="问题三"></a>问题三</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>三个骰子，给出每个骰子的面数，求随机摇出的三个数字和出现次数最多的是什么？如果有多个和出现次数一样，输出最小的。</p>
<h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><p><a href="https://p31prshut.blog.luogu.org/ti-xie-p2911-usaco08oct-niu-gu-tou-bovine-bones">大犇题解</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> a[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>;i++) <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">	sort(a+<span class="number">1</span>,a+<span class="number">1</span>+<span class="number">3</span>);</span><br><span class="line">	<span class="keyword">if</span>(a[<span class="number">2</span>]&lt;=(a[<span class="number">3</span>]-a[<span class="number">1</span>]+<span class="number">1</span>)) <span class="built_in">cout</span>&lt;&lt;<span class="number">1</span>+a[<span class="number">1</span>]+a[<span class="number">2</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="number">1</span>+a[<span class="number">3</span>]+(a[<span class="number">2</span>]-(a[<span class="number">3</span>]-a[<span class="number">1</span>]+<span class="number">1</span>))/<span class="number">2</span>+<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>期望</tag>
      </tags>
  </entry>
  <entry>
    <title>最大回文子串</title>
    <url>/posts/8eeb6466.html</url>
    <content><![CDATA[<h1 id="马拉车算法-Manacher"><a href="#马拉车算法-Manacher" class="headerlink" title="马拉车算法(Manacher)"></a>马拉车算法(Manacher)</h1><p>:::success</p>
<p>解决的问题：</p>
<p>以O(n)时间求出一个字符串的最长回文子串长度</p>
<p>:::</p>
<h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><p>如果求最大回文子串，暴力做法是从一个点开始，每次向左和右同时延伸一个单位，比较是否相同，但是这种方式比较难受的是如果字符串长度是偶数，那么可能对称中心不在字符上，而在两个字符之间，如果还想使用上面的方法就必须让指针在字符之间停留一下，所以考虑在每一个字符之间以及开头结尾（开头结尾添加是要让添加字符后的答案和未添加时的答案有一个对应关系）都添加相同的未出现的字符，这里用”#”表示，这样一来aba就变成了#a#b#a#，这样一来无论原串的长度为奇或偶转化后的字符串长度永远是奇数(2*l+1)，这时会发现添加后的字符串找出来的最长回文子串长度永远等于原串的最长回文子串长度+1（无论原串长度为奇数或偶数），所以对改变后的字符串求解的答案-1就是答案。</p>
<p>引入Len数组表示一个字符向左或向右可延伸的最长回文长度，比如aba，那么Len[1]=2（ab）</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/20210409161413.png" alt="image-20210409161400175" style="zoom:50%;" /></p>
<p>当求Len[i]时Len[i_mirror]是已知的，又因为黑色区域都是回文的，所以Len[i]=min(Len[i_mirror],mx-i)，之所以要和mx-i取一个较小的是因为可能左边的Len比较大，而对于当前位置的i+Len[i]超过了mx就会造成答案错误，因为mx右面的都还没有匹配过</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> <span class="title function_">process</span><span class="params">(<span class="built_in">string</span> s)</span>&#123;</span><br><span class="line">	<span class="type">int</span> len=s.size();</span><br><span class="line">	<span class="built_in">string</span> ret;</span><br><span class="line">	ret+=<span class="string">&quot;^&quot;</span>;  <span class="comment">//开头加上当前字符中没有的字符，而且开头的字符不能和结尾的字符相同，这是因为不能增加可匹配的回文长度（会改变答案） </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">		ret+=<span class="string">&quot;#&quot;</span>;</span><br><span class="line">		ret+=s[i];</span><br><span class="line">	&#125;</span><br><span class="line">	ret+=<span class="string">&quot;#$&quot;</span>;  <span class="comment">//结尾加上和开头不一样的字符 </span></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">manacher</span><span class="params">(<span class="built_in">string</span> s)</span>&#123;</span><br><span class="line">	s=process(s);  <span class="comment">//加上特殊字符，使得字符数量变成奇数 </span></span><br><span class="line">	<span class="type">int</span> c=<span class="number">0</span>,mx=<span class="number">0</span>,len=s.size(),sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i&lt;mx) Len[i]=min(mx-i,Len[<span class="number">2</span>*c-i]);  <span class="comment">//2*c-i就是关于c的对称点 ，之所以取min是因为可能左边的Leni比较大，</span></span><br><span class="line">											  <span class="comment">//这个点如果向右延伸这么长就超出mx了，而mx右面的位置都是没有匹配的，不确定是否可以组成回文 </span></span><br><span class="line">		<span class="keyword">else</span> Len[i]=<span class="number">1</span>;  <span class="comment">//如果当前位置已经超出最大的匹配范围了，就设置为1（当前字符就算一个回文） </span></span><br><span class="line">		<span class="keyword">while</span>(s[i+Len[i]]==s[i-Len[i]]) Len[i]++;  <span class="comment">//从当前点进行暴力匹配查看当前点可以延伸的最大长度 </span></span><br><span class="line">		<span class="keyword">if</span>(i+Len[i]&gt;mx)&#123;  <span class="comment">//如果超出了最大可延伸长度则更新 </span></span><br><span class="line">			c=i;  <span class="comment">//更新对称中心 </span></span><br><span class="line">			mx=i+Len[i];  <span class="comment">//更新最大延伸长度 </span></span><br><span class="line">			sum=max(sum,Len[i]);  <span class="comment">//更新答案 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum<span class="number">-1</span>;  <span class="comment">//答案要减1，无论奇偶转换后的字符串求得的最大回文长度都是答案减1，可以手推一下，很简单的 </span></span><br><span class="line">	<span class="comment">//aba (#a#b#a#)</span></span><br><span class="line">	<span class="comment">//abba (#a#b#b#a#)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="延伸求最大回文子串长什么样"><a href="#延伸求最大回文子串长什么样" class="headerlink" title="延伸求最大回文子串长什么样"></a>延伸求最大回文子串长什么样</h2><p>既然有了最大回文子串的长度，也可以计算出匹配到最大长度时的对称中心下标，那么只要找到原串和处理过的字符串的下标对应关系就可以求出max回文子串长啥样了，经过模拟发现j=2(i+1)(j:处理过的下标)，i-Len[i]+2是匹配到的最长回文子串的开头字符的下标，所以可以求得最大回文子串</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改此处即可</span></span><br><span class="line"><span class="keyword">if</span>(Len[i]&gt;sum)&#123;</span><br><span class="line">    sum=Len[i];</span><br><span class="line">    st=(i-Len[i]+<span class="number">2</span>)/<span class="number">2</span><span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> bk.substr(st,sum<span class="number">-1</span>);  <span class="comment">//答案要减1，无论奇偶转换后的字符串求得的最大回文长度都是答案减1，可以手推一下，很简单的 </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Manacher</tag>
      </tags>
  </entry>
  <entry>
    <title>数位DP</title>
    <url>/posts/a3781d1f.html</url>
    <content><![CDATA[<blockquote>
<p>数位DP</p>
<p>解决的是求一段区间中满足一定条件的数的数量，形式固定</p>
</blockquote>
<h2 id="数位DP模板"><a href="#数位DP模板" class="headerlink" title="数位DP模板"></a>数位DP模板</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num[<span class="number">100</span>],dp[<span class="number">100</span>][...];</span><br><span class="line"><span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> ...,<span class="type">bool</span> limit)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(pos==<span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">	<span class="keyword">if</span>(!limit &amp;&amp; dp[pos][...]!=<span class="number">-1</span>) <span class="keyword">return</span> dp[pos][...];</span><br><span class="line">	<span class="type">int</span> up=limit?num[pos]:<span class="number">9</span>;</span><br><span class="line">	<span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=up; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(...) sum+=dfs(pos<span class="number">-1</span>,...,limit &amp;&amp; (i==up));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!limit) dp[pos][...]=sum;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ps 如果有前导0就可以加一个 lead,一开始传1，然后后面就传lead&amp;&amp;(i==0)就可以了</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">work</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">	<span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(x) &#123;</span><br><span class="line">		num[++len]=x%<span class="number">10</span>;</span><br><span class="line">		x=x/<span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dfs(len,...,<span class="number">1</span>); <span class="comment">//第一位直接上限位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以一道例题讲解算法</p>
<h2 id="不要62"><a href="#不要62" class="headerlink" title="不要62"></a><a href="https://acm.hdu.edu.cn/showproblem.php?pid=2089">不要62</a></h2><p>求[L,R]内所有没出现4、62的数字数量，比如662、458这些都不满足条件。</p>
<p>首先转化为算1~R满足条件数字的问题，然后用fun(R)-fun(L-1)就是答案，数位DP就是对数位进行记忆化搜索，保存可以利用的信息，从而进行剪枝优化时间。核心在于dp[][]数组去保存信息，第一维表示当前的位数，第二维表示前一位的状态，记录的是这一维没有限制时符合条件的数量，也就是当前这一位是0~9时的数量，因为这个状态重复的最多且计算量大</p>
<p>这就是这道题目的代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当前的数位，前一位是否为6，前一位是否有限制</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> pos,<span class="type">bool</span> state,<span class="type">bool</span> limit)</span>&#123;</span><br><span class="line">    <span class="comment">//到最后一位返回1，表示有一个数满足要求</span></span><br><span class="line">	<span class="keyword">if</span>(pos==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//前一位没有限制表示当前可以取得数字是0~9，看一下是否可以记忆化剪枝</span></span><br><span class="line">    <span class="comment">//注意这里dp为0也可以返回，因为dp记录的是这种状态的答案数量，可能为0</span></span><br><span class="line">	<span class="keyword">if</span>(!limit &amp;&amp; dp[pos][state]!=<span class="number">-1</span>) <span class="keyword">return</span> dp[pos][state];</span><br><span class="line">    <span class="comment">//当前最高计算到多少位</span></span><br><span class="line">	<span class="type">int</span> up=limit?num[pos]:<span class="number">9</span>;</span><br><span class="line">    <span class="comment">//计算这个状态的答案sum</span></span><br><span class="line">	<span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=up;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(state &amp;&amp; i==<span class="number">2</span>) <span class="keyword">continue</span>;	<span class="comment">//62跳过</span></span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">4</span>) <span class="keyword">continue</span>;	<span class="comment">//4跳过</span></span><br><span class="line">		sum+=dfs(pos<span class="number">-1</span>,i==<span class="number">6</span>,limit&amp;&amp;num[pos]==i); <span class="comment">//深搜累加答案</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!limit) dp[pos][state]=sum; <span class="comment">//保存状态</span></span><br><span class="line">	<span class="keyword">return</span> sum;	<span class="comment">//记得返回答案</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">work</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">	cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(x)&#123;</span><br><span class="line">		num[++cnt]=x%<span class="number">10</span>;	<span class="comment">//保存数位</span></span><br><span class="line">		x/=<span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dfs(cnt,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Round-Numbers"><a href="#Round-Numbers" class="headerlink" title="Round Numbers"></a><a href="http://poj.org/problem?id=3252">Round Numbers</a></h2><p>统计区间中二进制0的个数不小于1的个数的所有数字。</p>
<p>这里比不要62多了一个参数，表示是否有前导零。</p>
<p>写法1：</p>
<p>三维dp，第三维表示总位数，这个地方我刚开始写错了，没考虑到这个，只记录了0的数量，其实1的数量也要考虑进去，否则1个0，1个1和1个0，2个1就会被记录成一个状态，导致答案错误，这里我这么写主要为了使用ksm剪枝，更快求出答案。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> js,<span class="type">bool</span> limit,<span class="type">bool</span> lead)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(pos==<span class="number">0</span>) <span class="keyword">return</span> js&gt;=(res-js);</span><br><span class="line">	<span class="keyword">if</span>(!limit &amp;&amp; !lead &amp;&amp; js&gt;=(res-js)) dp[pos][js][res]=ksm(<span class="number">2</span>,pos);</span><br><span class="line">	<span class="keyword">if</span>(!limit &amp;&amp; !lead &amp;&amp; dp[pos][js][res]!=<span class="number">-1</span>) <span class="keyword">return</span> dp[pos][js][res];</span><br><span class="line">	<span class="type">int</span> up=limit?num[pos]:<span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=up;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">0</span> &amp;&amp; lead)&#123;</span><br><span class="line">			res--;</span><br><span class="line">			sum+=dfs(pos<span class="number">-1</span>,js,limit&amp;&amp;num[pos]==i,<span class="number">1</span>);</span><br><span class="line">			res++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> sum+=dfs(pos<span class="number">-1</span>,i==<span class="number">0</span>?js+<span class="number">1</span>:js,limit&amp;&amp;num[pos]==i,<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!limit &amp;&amp; !lead) dp[pos][js][res]=sum;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">work</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">	cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(x)&#123;</span><br><span class="line">		num[++cnt]=x%<span class="number">2</span>;</span><br><span class="line">		x/=<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	res=cnt;</span><br><span class="line">	<span class="keyword">return</span> dfs(cnt,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写法2：</p>
<p>当前位是0就加，是1就减，直接包含了所有状态，省空间且写法简单，需要学习，初始值为32因为不能减到负数，因为还要作为数组下标存储状态</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> js,<span class="type">bool</span> limit,<span class="type">bool</span> lead)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(pos==<span class="number">0</span>) <span class="keyword">return</span> js&gt;=<span class="number">32</span>;</span><br><span class="line">	<span class="keyword">if</span>(!limit &amp;&amp; !lead &amp;&amp; dp[pos][js]!=<span class="number">-1</span>) <span class="keyword">return</span> dp[pos][js];</span><br><span class="line">	<span class="type">int</span> up=limit?num[pos]:<span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=up;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">0</span> &amp;&amp; lead) sum+=dfs(pos<span class="number">-1</span>,js,limit&amp;&amp;num[pos]==i,<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">else</span> sum+=dfs(pos<span class="number">-1</span>,i==<span class="number">0</span>?js+<span class="number">1</span>:js<span class="number">-1</span>,limit&amp;&amp;num[pos]==i,<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!limit &amp;&amp; !lead) dp[pos][js]=sum;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">work</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">	cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(x)&#123;</span><br><span class="line">		num[++cnt]=x%<span class="number">2</span>;</span><br><span class="line">		x/=<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	res=cnt;</span><br><span class="line">	<span class="keyword">return</span> dfs(cnt,<span class="number">32</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数位DP</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/posts/0.html</url>
    <content><![CDATA[<h1 id="树链剖分"><a href="#树链剖分" class="headerlink" title="树链剖分"></a>树链剖分</h1><blockquote>
<p>求解问题：在树上进行区间修改区间查询问题，求lca问题，维护路径信息</p>
<p>主要思想：将树上的点分割成一条一条的链，每一条链的第一个点是链头(父亲)，利用dfs序按照链优先的思想加上序号，这样每一条链上面的序号都是连续的，就把树上的点映射到了一条数轴上</p>
<p>时复：找到父亲，重子节点，子树大小（dfs1）O(N)，进行一次dfs序(dfs2 O(N))，每一条路径都能被分割成最多log2n条链，因此链头数量不超过log2n，每次求lca时复logn</p>
</blockquote>
<h2 id="重链剖分"><a href="#重链剖分" class="headerlink" title="重链剖分"></a>重链剖分</h2><blockquote>
<p>dfn数组: 每一个点映射到链上的标号</p>
<p>rnk数组: 每一个标号对应点的编号 (rnk[dfn[x]]=x)</p>
<p>dep数组: 每一个节点的深度</p>
<p>fa数组: 节点父亲</p>
<p>siz数组: 子树大小</p>
<p>son数组: 重孩子</p>
<p>top数组: 节点在链上链头的编号</p>
<p>以上7个数组是树链剖分的几个必要数组，根据题目不同会使用上面的某几个数组</p>
</blockquote>
<p>定义：</p>
<ol>
<li>重子节点是子树节点最多的那棵树的根节点，如果有多个随意取出一个即可</li>
<li>剩下的非重子节点的点都是轻子节点</li>
<li>从当前节点到重子节点的边是重边</li>
<li>从当前节点到轻子节点的边是轻边</li>
<li>若干条首尾相连的重边称为重链，所有落单的点也当作重链</li>
</ol>
<p><img src="https://oi-wiki.org/graph/images/hld.png" alt="HLD" style="zoom:50%;" /></p>
<p>利用以上定义可以将一棵树分成若干条链，这些链上的dfs序号是连续的</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">dfs1</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">	siz[x]=<span class="number">1</span>;  <span class="comment">//当前子树大小为1</span></span><br><span class="line">    son[x]=<span class="number">-1</span>;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];~i;i=e[i].next)&#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(v==fa[x]) <span class="keyword">continue</span>;</span><br><span class="line">        fa[v]=x;  <span class="comment">//深搜之前一定要更新父亲</span></span><br><span class="line">        dep[v]=dep[x]+<span class="number">1</span>;  <span class="comment">//往下深搜之前一定要先把深度给更新了</span></span><br><span class="line">        dfs1(v);</span><br><span class="line">        siz[x]=siz[v]+<span class="number">1</span>;  <span class="comment">//深搜过后才能更新子树大小</span></span><br><span class="line">        <span class="keyword">if</span>(son[x]==<span class="number">-1</span> || siz[son[x]]&lt;siz[v]) son[x]=v;  <span class="comment">//找到重子节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> t)</span>&#123;</span><br><span class="line">	top[x]=t;  <span class="comment">//这条链的链头</span></span><br><span class="line">    cnt++;  <span class="comment">//dfs序加一</span></span><br><span class="line">    dfn[x]=cnt;  <span class="comment">//给节点标上dfs序</span></span><br><span class="line">    rnk[cnt]=x;  <span class="comment">//返回dfs序对应的节点</span></span><br><span class="line">    <span class="keyword">if</span>(son[x]==<span class="number">-1</span>) <span class="keyword">return</span> ;</span><br><span class="line">    dfs2(son[x],t);  <span class="comment">//优先遍历重子节点，到重子节点的边都是重链，所以链头不变</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];~i;i=e[i].next)&#123;</span><br><span class="line">		<span class="type">int</span> v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(v==fa[x] || v==son[x]) <span class="keyword">continue</span>;</span><br><span class="line">        dfs2(v,v);  <span class="comment">//到轻子节点，链头要变化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="树上单点修改区间查询"><a href="#树上单点修改区间查询" class="headerlink" title="树上单点修改区间查询"></a>树上单点修改区间查询</h2><p>求两个点的区间值时，在找lca的过程中保存信息，最后输出答案即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#pragma G++ optimize(2)</span></span><br><span class="line"><span class="comment">//#pragma G++ optimize(3,&quot;Ofast&quot;,&quot;inline&quot;)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SUB=<span class="number">-0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-4</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> E=<span class="built_in">exp</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> to,next;</span><br><span class="line">&#125;e[MAXN];</span><br><span class="line"><span class="type">int</span> head[MAXN],w[MAXN];</span><br><span class="line"><span class="type">int</span> tot;</span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span>&#123;</span><br><span class="line">	e[tot]=&#123;v,head[u]&#125;;</span><br><span class="line">	head[u]=tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,a,b,q;</span><br><span class="line"><span class="type">int</span> dfn[MAXN],siz[MAXN],dep[MAXN],fa[MAXN];</span><br><span class="line"><span class="type">int</span> son[MAXN],top[MAXN],rnk[MAXN];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> las)</span>&#123; <span class="comment">//求出dep、son、siz、fa</span></span><br><span class="line">	son[x]=<span class="number">-1</span>;</span><br><span class="line">	siz[x]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[x];~i;i=e[i].next)&#123;</span><br><span class="line">		<span class="type">int</span> v=e[i].to;</span><br><span class="line">		<span class="keyword">if</span>(v==las) <span class="keyword">continue</span>;</span><br><span class="line">		fa[v]=x;</span><br><span class="line">		dep[v]=dep[x]+<span class="number">1</span>;</span><br><span class="line">		dfs(v,x);</span><br><span class="line">		siz[x]+=siz[v];</span><br><span class="line">		<span class="keyword">if</span>(son[x]==<span class="number">-1</span> || siz[v]&gt;siz[son[x]]) son[x]=v;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> t)</span>&#123; <span class="comment">//求出dfn、rnk、top</span></span><br><span class="line">	++cnt;</span><br><span class="line">	dfn[x]=cnt;</span><br><span class="line">	rnk[cnt]=x;</span><br><span class="line">	top[x]=t;</span><br><span class="line">	<span class="keyword">if</span>(son[x]!=<span class="number">-1</span>) dfs2(son[x],t);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[x];~i;i=e[i].next)&#123;</span><br><span class="line">		<span class="type">int</span> v=e[i].to;</span><br><span class="line">		<span class="keyword">if</span>(v==fa[x] || v==son[x]) <span class="keyword">continue</span>;</span><br><span class="line">		dfs2(v,v);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lson (u&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rson (u&lt;&lt;1|1)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> l,r,mx,sum;</span><br><span class="line">&#125;tr[MAXN&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">pushup</span><span class="params">(<span class="type">int</span> u)</span>&#123;</span><br><span class="line">	tr[u].mx=max(tr[lson].mx,tr[rson].mx);</span><br><span class="line">	tr[u].sum=tr[lson].sum+tr[rson].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">		tr[u]=&#123;l,r,w[rnk[l]],w[rnk[l]]&#125;;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	tr[u]=&#123;l,r&#125;;</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	build(lson,l,mid);</span><br><span class="line">	build(rson,mid+<span class="number">1</span>,r);</span><br><span class="line">	pushup(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pos,<span class="type">int</span> val)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(tr[u].l==tr[u].r)&#123;</span><br><span class="line">		tr[u].mx=val;</span><br><span class="line">		tr[u].sum=val;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid=tr[u].l+tr[u].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(pos&lt;=mid) update(lson,pos,val);</span><br><span class="line">	<span class="keyword">else</span> update(rson,pos,val);</span><br><span class="line">	pushup(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">qmax</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> ql,<span class="type">int</span> qr)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(tr[u].l&gt;=ql &amp;&amp; tr[u].r&lt;=qr) <span class="keyword">return</span> tr[u].mx;</span><br><span class="line">	<span class="type">int</span> ret=-INF;</span><br><span class="line">	<span class="type">int</span> mid=tr[u].l+tr[u].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(ql&lt;=mid) ret=max(ret,qmax(lson,ql,qr));</span><br><span class="line">	<span class="keyword">if</span>(mid+<span class="number">1</span>&lt;=qr) ret=max(ret,qmax(rson,ql,qr));</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">query_mx</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">	<span class="type">int</span> l=x,r=y;</span><br><span class="line">	<span class="type">int</span> ret=-INF;</span><br><span class="line">	<span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">		<span class="keyword">if</span>(dep[top[x]]&gt;dep[top[y]])&#123;</span><br><span class="line">			ret=max(ret,qmax(<span class="number">1</span>,dfn[top[x]],dfn[x]));</span><br><span class="line">			x=fa[top[x]];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			ret=max(ret,qmax(<span class="number">1</span>,dfn[top[y]],dfn[y]));</span><br><span class="line">			y=fa[top[y]];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(dfn[x]&gt;dfn[y]) ret=max(ret,qmax(<span class="number">1</span>,dfn[y],dfn[x]));</span><br><span class="line">	<span class="keyword">else</span> ret=max(ret,qmax(<span class="number">1</span>,dfn[x],dfn[y]));</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">qsum</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> ql,<span class="type">int</span> qr)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(tr[u].l&gt;=ql &amp;&amp; tr[u].r&lt;=qr) <span class="keyword">return</span> tr[u].sum;</span><br><span class="line">	<span class="type">int</span> ret=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> mid=tr[u].l+tr[u].r&gt;&gt;<span class="number">1</span>; </span><br><span class="line">	<span class="keyword">if</span>(ql&lt;=mid) ret+=qsum(lson,ql,qr);</span><br><span class="line">	<span class="keyword">if</span>(qr&gt;=mid+<span class="number">1</span>) ret+=qsum(rson,ql,qr);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">query_sum</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">	<span class="type">int</span> ret=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">		<span class="keyword">if</span>(dep[top[x]]&gt;dep[top[y]])&#123;</span><br><span class="line">			ret+=qsum(<span class="number">1</span>,dfn[top[x]],dfn[x]);</span><br><span class="line">			x=fa[top[x]];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			ret+=qsum(<span class="number">1</span>,dfn[top[y]],dfn[y]);</span><br><span class="line">			y=fa[top[y]];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(dfn[x]&gt;dfn[y]) ret+=qsum(<span class="number">1</span>,dfn[y],dfn[x]);</span><br><span class="line">	<span class="keyword">else</span> ret+=qsum(<span class="number">1</span>,dfn[x],dfn[y]);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="comment">// debug;</span></span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span> head);</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">		add(a,b);</span><br><span class="line">		add(b,a);</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">	dfs2(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;w[i];</span><br><span class="line">	build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">	<span class="comment">// cout&lt;&lt;tr[1].mx&lt;&lt;endl;</span></span><br><span class="line">	<span class="comment">// cout&lt;&lt;qmax(1,1,4)&lt;&lt;endl;</span></span><br><span class="line">	<span class="comment">// for(int i=1;i&lt;=n;i++) cout&lt;&lt;dfn[i]&lt;&lt;&quot; &quot;;</span></span><br><span class="line">	<span class="comment">// cout&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line">	<span class="comment">// for(int i=1;i&lt;=n;i++) cout&lt;&lt;son[i]&lt;&lt;&quot; &quot;;</span></span><br><span class="line">	<span class="comment">// cout&lt;&lt;endl;</span></span><br><span class="line">	<span class="comment">// for(int i=1;i&lt;=n;i++) cout&lt;&lt;dep[i]&lt;&lt;&quot; &quot;;</span></span><br><span class="line">	<span class="comment">// cout&lt;&lt;endl;</span></span><br><span class="line">	<span class="comment">// for(int i=1;i&lt;=n;i++) cout&lt;&lt;rnk[i]&lt;&lt;&quot; &quot;;</span></span><br><span class="line">	<span class="comment">// cout&lt;&lt;endl;</span></span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;q;</span><br><span class="line">	<span class="keyword">while</span>(q--)&#123;</span><br><span class="line">		<span class="built_in">string</span> s;</span><br><span class="line">		<span class="type">int</span> u,v;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;s&gt;&gt;u&gt;&gt;v;</span><br><span class="line">		<span class="keyword">if</span>(s==<span class="string">&quot;CHANGE&quot;</span>) update(<span class="number">1</span>,dfn[u],v);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(s==<span class="string">&quot;QMAX&quot;</span>) <span class="built_in">cout</span>&lt;&lt;query_mx(<span class="number">1</span>,u,v)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;query_sum(<span class="number">1</span>,u,v)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="comment">// if(u==3 &amp;&amp; v==6) cout&lt;&lt;qmax(1,3,4)&lt;&lt;&quot;ss&quot;&lt;&lt;endl;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P1069-细胞分裂</title>
    <url>/posts/4ac79732.html</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1069">题目链接</a></p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/20210225153205.png" alt="image-20210225153142932" style="zoom:67%;" /></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>有n种不同数量的细胞，每一个细胞每一秒都会分裂出一个新的，现在要把某一种细胞平均分到m1^m2^个容器里面，问选一种细胞，使得等待的时间最短，如果无法均分到容器中，就输出-1</p>
<h2 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h2><p>要均分就表示Si^t^%m1^m2^==0求t的最小值，看一下数据范围发现m1比较小，而Si很大，分别对Si和m1分解质因子，只要m1中的每一个质因子Si中都有，那么Si就可以通过分裂均分到m1^m2^中，因此不需要把Si的所有质因子都找到，只需要找到小于等于m1的所有质因子即可，因此时间复杂度就是n*3e3就是3e7，对于m1和Si共有的质因子需要满足pi*t&gt;=pm1*m2，要让满足条件的t最小就是取所有共有质因子的最大比值，然后所有比值中取最小</p>
<h2 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SUB=<span class="number">-0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> eps=<span class="number">1e-4</span>;</span><br><span class="line"><span class="type">int</span> tail,pr[MAXN/<span class="number">10</span>];</span><br><span class="line"><span class="type">bool</span> np[MAXN];</span><br><span class="line"><span class="type">void</span> <span class="title function_">ol</span><span class="params">()</span>&#123;</span><br><span class="line">	np[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">1000000</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!np[i]) pr[++tail]=i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=tail &amp;&amp; pr[j]&lt;=<span class="number">1000000</span>/i;j++)&#123;</span><br><span class="line">			np[i*pr[j]]=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(i%pr[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span> n,m1,m2;</span><br><span class="line"><span class="type">int</span> S[MAXN],z1[MAXN],z2[MAXN];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	ios;</span><br><span class="line">	ol();</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m1&gt;&gt;m2;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;S[i];</span><br><span class="line">	<span class="keyword">if</span>(m1==<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tail &amp;&amp; pr[i]&lt;=m1/pr[i];i++)&#123;</span><br><span class="line">		<span class="keyword">while</span>(m1%pr[i]==<span class="number">0</span>)&#123;</span><br><span class="line">			z1[pr[i]]+=m2;</span><br><span class="line">			m1/=pr[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(m1&gt;<span class="number">1</span>) z1[m1]+=m2;</span><br><span class="line">	<span class="type">int</span> ans=INF;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(z2,<span class="number">0</span>,<span class="keyword">sizeof</span> z2);</span><br><span class="line">		<span class="type">int</span> bk=S[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=tail &amp;&amp; pr[j]&lt;=S[i]/pr[j];j++)&#123;</span><br><span class="line">			<span class="keyword">while</span>(S[i]%pr[j]==<span class="number">0</span>)&#123;</span><br><span class="line">				z2[pr[j]]++;</span><br><span class="line">				S[i]/=pr[j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(S[i]&gt;<span class="number">1</span> &amp;&amp; S[i]&lt;=<span class="number">30000</span>) z2[S[i]]++;</span><br><span class="line">		<span class="type">int</span> flag=<span class="number">0</span>,mx=<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=tail;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(z1[pr[j]] &amp;&amp; !z2[pr[j]])&#123;</span><br><span class="line">				flag=<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(z1[pr[j]] &amp;&amp; z2[pr[j]]) mx=max(mx,(z1[pr[j]]<span class="number">-1</span>)/z2[pr[j]]+<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!flag) ans=min(ans,mx);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(ans!=INF) <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>质因子分解</tag>
      </tags>
  </entry>
  <entry>
    <title>爬取唯美图片</title>
    <url>/posts/add36e4f.html</url>
    <content><![CDATA[<blockquote>
<p>通过Beautiful定位标签，获取图片链接，仅限于图片直接内嵌于网页源代码中，有的网站图片链接藏在js文件，无法爬取</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#爬取umei.cc中的图片</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">domain = <span class="string">&quot;https://umei.cc/katongdongman/dongmantupian/&quot;</span> <span class="comment">#网站地址</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.45 Safari/537.36&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">res = requests.get(domain, headers=headers)</span><br><span class="line">res.encoding = <span class="string">&#x27;utf-8&#x27;</span>  <span class="comment">#防止中文乱码</span></span><br><span class="line">content = res.text  <span class="comment">#获取源代码</span></span><br><span class="line"></span><br><span class="line">mainPage = BeautifulSoup(content, <span class="string">&quot;html.parser&quot;</span>)    <span class="comment">#创建Beautiful对象，说明其使用的语言</span></span><br><span class="line">img_list = mainPage.find(<span class="string">&quot;div&quot;</span>, class_=<span class="string">&quot;TypeList&quot;</span>).find_all(<span class="string">&quot;img&quot;</span>)  <span class="comment">#找到class=&quot;TypeList&quot;的div标签包裹的所有img标签</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> img <span class="keyword">in</span> img_list:    <span class="comment">#遍历这些img标签</span></span><br><span class="line">    img_scr = img.get(<span class="string">&quot;src&quot;</span>)    <span class="comment">#获取其中的src属性值</span></span><br><span class="line">    <span class="comment"># print(img_name)</span></span><br><span class="line">    imgName = <span class="string">&quot;img/&#123;&#125;&quot;</span>.<span class="built_in">format</span>(img_scr.split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">1</span>])   <span class="comment">#获取图片名称</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(imgName, mode=<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:  <span class="comment">#打开文件</span></span><br><span class="line">        f.write(requests.get(img_scr).content)  <span class="comment">#写入二进制码</span></span><br><span class="line">    f.close()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;over&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;all over!&quot;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>爬取豆瓣Top250电影信息</title>
    <url>/posts/e15caf4c.html</url>
    <content><![CDATA[<blockquote>
<p>使用了request、re(正则)、csv模块</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#爬取豆瓣Top250的电影名称，评分，导演与演员</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;https://movie.douban.com/top250&quot;</span> <span class="comment">#豆瓣链接</span></span><br><span class="line">headers = &#123;     <span class="comment"># headers，伪装浏览器访问</span></span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>:<span class="string">&quot;: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.45 Safari/537.36&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">obj = re.<span class="built_in">compile</span>(<span class="string">r&#x27;&lt;li&gt;.*?&lt;span class=&quot;title&quot;&gt;(?P&lt;name&gt;.*?)&lt;/span&gt;.*?&#x27;</span>  <span class="comment"># 正则预编译查找模式</span></span><br><span class="line">                 <span class="string">r&#x27;&lt;p class=&quot;&quot;&gt;(?P&lt;actors&gt;.*?)&lt;/p&gt;.*?&#x27;</span></span><br><span class="line">                 <span class="string">r&#x27;&lt;span class=&quot;rating_num&quot; property=&quot;v:average&quot;&gt;(?P&lt;score&gt;.*?)&lt;/span&gt;.*?&#x27;</span>, re.S)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;peaTop250.csv&quot;</span>, mode=<span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:    <span class="comment"># 以utf-8编码打开csv文件</span></span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>(num&lt;<span class="number">250</span>):     <span class="comment"># 爬取每一个页面的信息</span></span><br><span class="line">        URL = url + <span class="string">&quot;?start=&#123;&#125;&amp;filter=&quot;</span>.<span class="built_in">format</span>(num)     <span class="comment">#更改页面地址</span></span><br><span class="line">        <span class="built_in">print</span>(URL)</span><br><span class="line">        content = requests.get(url=URL, headers=headers).text   <span class="comment">#得到页面源代码</span></span><br><span class="line">        res = obj.finditer(content)     <span class="comment">#按照预编译好的规则查找响应的值，并储存到一个迭代器中，存储类型为字典</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> res:</span><br><span class="line">            f.write(<span class="string">&quot;作者:&quot;</span> + i.group(<span class="string">&quot;name&quot;</span>) + <span class="string">&quot;\n&quot;</span>) <span class="comment">#写到csv中</span></span><br><span class="line">            f.write(i.group(<span class="string">&quot;actors&quot;</span>).replace(<span class="string">&quot; &quot;</span>,<span class="string">&#x27;&#x27;</span>).replace(<span class="string">&#x27;\n&#x27;</span>,<span class="string">&#x27;&#x27;</span>).replace(<span class="string">&quot;&amp;nbsp&quot;</span>,<span class="string">&#x27; &#x27;</span>) + <span class="string">&quot;\n&quot;</span>) <span class="comment">#把字符串中的空格回车消除和&amp;nbsp转化为空格</span></span><br><span class="line">            f.write(<span class="string">&quot;评分:&quot;</span> + i.group(<span class="string">&quot;score&quot;</span>) + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        num+=<span class="number">25</span></span><br><span class="line"></span><br><span class="line">f.close()   <span class="comment">#关闭文件</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;over&quot;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客小白月赛29</title>
    <url>/posts/f1b375ae.html</url>
    <content><![CDATA[<h2 id="B-二进制"><a href="#B-二进制" class="headerlink" title="B 二进制"></a>B 二进制</h2><p>题目链接: <a href="https://ac.nowcoder.com/acm/contest/8564/B">https://ac.nowcoder.com/acm/contest/8564/B</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/20210221185349.png" alt="image-20210221185340310" style="zoom: 50%;" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/20210221185433.png" alt="image-20210221185431834" style="zoom:50%;" /></p>
<p>单纯与或者单纯或单纯异或都支持交换律，但是他们放在一起就不支持交换律了，比如1先和0与再和1或结果是1，但是1先和1或再和0与结果就不一样，可以设两个数，一个所有位都是0，一个所有位都是1，把这两个分别进行上述操作，最后得出来的结果按位对比，如果0变成了1且1变成了0则这个位肯定是异或1，如果0变成0且1变成0则这一位是与0，如果0变成1且1变成1这一位肯定是或1，按照这个规律可以求出这个数，任何一个数与1或0异或0都不变，所以可以设置三个数，一个全设为1，另外两个全设为0，当这个位是与0时，就用全为1的变量减去(1&lt;&lt;i)这一位上的数，另外两个同理</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SUB=<span class="number">-0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> eps=<span class="number">1e-4</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a=<span class="number">0</span>,b=(<span class="number">1</span>&lt;&lt;<span class="number">20</span>)<span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="type">int</span> op,v;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;op&gt;&gt;v;</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">			a&amp;=v;</span><br><span class="line">			b&amp;=v;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>)&#123;</span><br><span class="line">			a|=v;</span><br><span class="line">			b|=v;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			a^=v;</span><br><span class="line">			b^=v;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> yu=(<span class="number">1</span>&lt;&lt;<span class="number">20</span>)<span class="number">-1</span>,huo=<span class="number">0</span>,yihuo=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>( (a&gt;&gt;i)&amp;<span class="number">1</span> )&#123;</span><br><span class="line">			<span class="keyword">if</span>((b&gt;&gt;i)&amp;<span class="number">1</span>) huo+=(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">			<span class="keyword">else</span> yihuo+=(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(!((b&gt;&gt;i)&amp;<span class="number">1</span>)) yu-=(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="number">3</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;yu&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="number">2</span>&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;huo&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="number">3</span>&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;yihuo&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>默认</category>
      </categories>
      <tags>
        <tag>默认</tag>
      </tags>
  </entry>
  <entry>
    <title>种类并查集</title>
    <url>/posts/7bf7b6ec.html</url>
    <content><![CDATA[<p>种类并查集可以解决多种关系的问题，比如两个人不是朋友的关系，其思想是多开几倍的空间，假如有n种关系，就开n倍的空间，然后用+n来表示两个不同集合的关系</p>
<h2 id="食物链P2024"><a href="#食物链P2024" class="headerlink" title="食物链P2024"></a>食物链P2024</h2><p>链接：<a href="https://www.luogu.com.cn/problem/P2024">https://www.luogu.com.cn/problem/P2024</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/20210225222508212.png" alt="20210225222508212"></p>
<p>开3倍空间维护3个集合，分别表示A、B、C，例如1和2是朋友，那就把3个集合中的1和2合并，1吃2，就把A集合中1和B集合中的2合并，B集合中的1和C集合的2合并，C集合的1和A集合的2合并，再来一个2吃3，这样一来C中的3和A中的1也在一个集合里了，维护了C吃A的关系，也就是如果Ai和Bj的祖先相同就表示Ai吃Bj，另外两个同理</p>
<h2 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">20010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SUB=<span class="number">-0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> eps=<span class="number">1e-4</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> u,v,w;</span><br><span class="line">&#125;arr[MAXN];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> fa[MAXN*<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==fa[x]) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> fa[x]=find(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">remerge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">	<span class="type">int</span> fx=find(x),fy=find(y);</span><br><span class="line">	<span class="keyword">if</span>(fx!=fy) fa[fx]=fy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">cmp</span><span class="params">(node a,node b)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.w&gt;b.w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">cin</span>&gt;&gt;arr[i].u&gt;&gt;arr[i].v&gt;&gt;arr[i].w;</span><br><span class="line">	sort(arr+<span class="number">1</span>,arr+<span class="number">1</span>+m,cmp);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++) fa[i]=i;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="type">int</span> x=arr[i].u,y=arr[i].v;</span><br><span class="line">		<span class="keyword">if</span>(find(x)==find(y) || find(x+n)==find(y+n))&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;arr[i].w&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		remerge(x+n,y);</span><br><span class="line">        remerge(x,y+n);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>种类并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>考研这一年</title>
    <url>/posts/6d71acfd.html</url>
    <content><![CDATA[<blockquote>
<p>2020年，我考研的一年</p>
</blockquote>
<h2 id="1月1日，我正式开始考研"><a href="#1月1日，我正式开始考研" class="headerlink" title="1月1日，我正式开始考研"></a>1月1日，我正式开始考研</h2><p>我开始准备英语长难句，跟刘晓燕老师的语法课，每天跟群里面发的每日一句，坚持背单词，当时用app+实体书结合的方法进行背诵，A4纸的方法尤其有效，记得由于当时还是寒假在家，动力不足，每天有效学习时长可能只有6个小时左右，所以会花很多时间来背诵单词，当时我非常想考一所985院校，但也不清楚自己的实力，不了解考研流程，所以定了重庆大学这个984.5，有了目标，就有了动力，我从没有断过每日单词打卡，这个习惯我一直保持到10月3日，连续打卡301天，这是我考研路上引以为傲的一项战绩。我深知高数的重要性，所以很早就开始跟汤家凤的基础课，买了他的1800，每天下午都会听一会，做点题，但不多，整个寒假也只是过完了前3章（几乎没咋学）</p>
<h2 id="3月初，开学考研步入正轨"><a href="#3月初，开学考研步入正轨" class="headerlink" title="3月初，开学考研步入正轨"></a>3月初，开学考研步入正轨</h2><p>我开始提高每日学习时长，能翘的课都翘了，还发现了一个学习圣地，不需要预约，贼适合考研，强过图书馆一万倍，我把考研书籍搬到教室占位，当时的书籍很少，竟然都不需要书立，当时上午学习英语，其余时间留给数学，记得刚开始英语真题时，感觉题目贼难，文章单词都认识，放在一起就不会，题目也是很坑，当时每道阅读题几乎都要错个两三个，但当时的数学给我感觉很好（因为题目很简单），最喜欢刷那些水题了，流畅无阻，但好景不长，我碰到了660，做660我一度怀疑这本习题集真的是打基础的？<del>事实证明真的不是</del>，刷完660我就开始刷880了，880给我的感觉很不错，题目很多都是思路很常规，但里面有很多细节的题，当然也有很多难题怪题，毕竟属于基础和强化之间的习题集，快做完880时，我们也快放假了，由于疫情原因暑假无法留校，真的搞心态，在家里真的没办法学习，室友们也都不打算租房，我只好到处寻找研友，最后还是和一位高中同学一起租了个寄宿自习室，开始了我的暑期学习。</p>
<h2 id="6月7日，暑期学习开始"><a href="#6月7日，暑期学习开始" class="headerlink" title="6月7日，暑期学习开始"></a>6月7日，暑期学习开始</h2><p>在家里待了一星期，整个人都不好了，开始几天还能投入学习，但是越到后面越不想学，到后面干脆摆烂，原定10天的家庭生活压缩到了6天，第七天一早我就和同学出发前往自习室了，自习室比我想象的要好的多，真的吹爆，焦作六七八自习室，考研二战暑期必选，三个月总费用2100，包含住宿费和自习室费用，宿舍和自习室只隔了一个楼，可以午休真不错，下面就是小吃街，每天吃饭睡觉学习无缝衔接，这种感觉比在学校都好，自习室餐厅饭也很好吃，只有一个缺点就是太贵！开始我还很喜欢在自习室吃，后面价格越来越贵，只好出去外面吃，自习室里面大多数都是本校的，我也看到了很多熟人，每天出去吃饭都能遇到熟人，记得当时最讨厌的就是每周的核酸，因为离核酸点很远，而且人还特多，记得第一次做核酸排了40分钟的队，暑期我完成了高数强化和专业课408的一轮复习，英语阅读也完成了2刷，记得差不多8月的时候，感觉高数和英语都形成了质变，做题感觉明显强于之前，英语阅读已经偶尔错两道道，经常性全对或者错一道，做题时间也压缩在15分钟左右，简单的甚至10分钟即可完成，高数一些难题也可以比较顺畅地做出来，武忠祥的每日一题几乎每次都可以做对，当然强化阶段难题还是更多的，尤其是辅导讲义上，几乎每一道题都不会做，因为太难太偏了，专业课由于打过acm，数据结构毫无压力，因为操作系统之前好好学过，进程那一部分也学的不错，但文件管理之后内容，记得当时一窍不通，由于知识点太多太杂，我当时还买了一盒记号笔，用来画知识点，一盒记号笔到考研结束用完了5支。三个月没从来没有歇过完整的一天，除非当天特别厌学，我会抽出一个下午或者晚上早点回去来给自己放松一下，由于这种高强度的学习，我当时的心情一度很压抑，尤其是下午的时候，焦作还是个火炉城市，夏天异常热，虽然自习室空调不停，但是人的情绪还是特别容易焦躁，到8月份的时候，我有连续一个多星期都没办法静下心来，为了克制这种焦躁的情绪，我尝试了各种方法，比如晚上提前一点结束，去外面跑步，或者约朋友打会乒乓球，不过最有效的方法还是换座位，我属于是那种在一个环境待久了容易腻的人，当进入一个新环境我往往可以提高效率，当时最开心的时光就属于是晚上和朋友在楼顶打乒乓球的时间了，为了让同学们有锻炼身体的机会，自习室机构在楼顶设置了一个健身房，上面搭了一个大棚，对于这点，我真的吹爆，每天40分钟的乒乓球时间足以吹走我一天的疲惫，打完球再去楼底买个小吃，现在想想都觉得爽。这样的生活一直只持续到8.22，由于朋友要开学了，所以我们宿舍4个人出去聚了一餐，又去看了《独行月球》，第二天，朋友走了，我也在9.2返回了学校。进入考研第四阶段。</p>
<h2 id="9月2日，回归校园生活"><a href="#9月2日，回归校园生活" class="headerlink" title="9月2日，回归校园生活"></a>9月2日，回归校园生活</h2><p>告别了暑期学习，但学习不能停，依旧是日复一日的高强度学习，只不过这个时期，我的学习重心也由数学转到了408的学习，我会把一下午的时间都分配给专业课，每天盯着408一道道现在看来如同天书般的题目，我是真的头大，408的学习，我过了至少4轮，真的没有那一门课有408那样五花八门的术语以及错综复杂的知识点，这样的学习持续到10月初，当时的我已经开始由408转向自命题了，这种感觉就是一个天上一个地下，突然看917，那些题就好像是智障一般，出的异常简单，也怪不得往年大量考生可以拿130+，而且当时我的数学也基本成型，各种曾经的难题已经难不倒我，我开始估分，保守估计当时的我做往年真题已经可以拿到380+的分数，因此我开始向往更好的学校，我盯上了四川大学，因为我一直比较喜欢四川，可能是因为电视剧上面的川音很上头吧，但是四川大学去年均分390，我非常害怕，害怕最后发挥不好考不上，尤其是知乎上各种劝退贴，380+被刷一半，更重要的是我本科学校很拉，双非一本，周围没有人敢报考985，我报的学校已经是我已知最好的了，特别慌，就是那种从理性上来看，只要最后正常发挥可以考上，从感性上看考不上的那种难受，这种挣扎持续了一个多星期，那个时候我没事就拿手机去搜四川大学的相关消息，“重大末流985”当初是我看到最多的词条，从开始想上一所985到现在想上一所好的985，无数个夜晚我都想把志愿改了，可惜最后我还是没能战胜心理压力，依旧选择了重大<del>从结果来看报川大是更好的选择</del>。时间来到10月底，我开始给政治投入更多时间，虽然暑假就已经过了一轮政治，但是由于没咋做题，对于知识点的掌握情况不容乐观，肖1000题没几道会的，一度很崩溃。坚持听了一个月的腿姐强化课，政治才有些好转。</p>
<h2 id="12月最后冲刺"><a href="#12月最后冲刺" class="headerlink" title="12月最后冲刺"></a>12月最后冲刺</h2><p>由于疫情影响，河南高校要提前放假，所以舍友都在12月初离校了，只有我和研友独守空巢，这对我们来说是个好消息，我们休息地环境更好了，但是好景不长，由于河南疫情加重，要求所有考生离校，在最后的冲刺时期，一旦没有调整好状态很可能意味着浪费掉一年的时光，我深知此事事关重大，也知道家中环境绝不适合学习，一时间不知所措，<del>当时心中不知道骂了学校多少遍</del>，不过好在考生齐心，向学校提出留校学习，学校最后妥协，允许考生留校，但是需要封控，起初大家都以为一个星期后便可恢复如常，大家也都习惯了，但是每当距离解封还有1天时，总有寝室楼莫名出现感染者，喜提一星期，原定1星期的封闭延长至16天，连续10来天，顿顿大米，看到大米就恶心，吃过的饭盒也不能扔，只能丢在阳台，到后面阳台的垃圾已经堆积成山，难以想象在这种环境下我还要保持每天10个小时的学习。距离考试只剩7天，大家的备战也都如火如荼的进行着，偏偏这个时候，我们宿舍楼出现感染者了，大家都非常慌，不敢与别人有任何接触，一天晚上，邻宿舍的一个同学叫我辅导他一些代码题，我当时犹豫要不要去，心想应该不会那么巧，他现在也没啥症状，应该问题不大，所以晚上我去了，给他讲了1个多小时的题，第二题下午，我收到通知，他，，他发烧了，当时我心里一万个草泥马奔腾而过，我和我室友那几天胆战心惊，害怕自己会中招，不过那几天倒也没事，身体没有任何异样，距离考试仅剩一天，我室友发烧了，38度多，绝了，就挑要考试的时候发烧，考试第一天我倒是没事，上午政治，今年出的题比较难，感觉做的不太好，选择有好几道都不确定，大题也没压中几道，大多数还是抄材料+胡编乱造，下午考英语，题目异常简单，我从来没有做哪一年的英语真题做的如此之顺，我可以肯定阅读全对，最后做完还有半个小时时间，英语考完，我信心大增，第二天醒来，头好晕，完蛋，中招了，不过因为刚刚发烧，头虽然晕，但是不太影响做题，上午数学，做的非常顺利，除了一道选择题不确定以外，其余题目都做出来了，而且做完所有题目还有20分钟，考完我头巨晕，趴下就能睡着的那种，摸了摸头，滚烫滚烫的，拖着疲惫的身体回到了宿舍，吃了几口饭就睡了，最后一门专业课，我其实是不担心的，因为根据往年的题目来看，一般来说917是很简单的，所以我考试的时候并没有绷紧心弦去做题（也有很大一部分原因是头真的很晕），但是做完几道选择题发现不对劲，怎么这么多不会，选择题竟然花了1个小时10分钟，天呐，我当时就慌了，赶紧加快速度，后面大题也很难，没几道会的，最后甚至题目都没做完，后面才知道，我还漏了一道非常简单的8分题目，因为没看到！考完专业课我是真崩溃，估分100分，要知道往年都是135+的，今年的题给我干废了。不过由于其他科目发挥都很好，所以我不担心总分会很低。</p>
<h2 id="出分"><a href="#出分" class="headerlink" title="出分"></a>出分</h2><p>2023.3.21日，怀揣着忐忑地心情，我点开了查分链接，403分。看到这个分数，说实话我并没有多么激动，意料之中的分数，一整年的辛苦，才换来了最后的辉煌，一切都是顺理成章，一切都是理所应当。</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>考研</tag>
      </tags>
  </entry>
  <entry>
    <title>计算几何</title>
    <url>/posts/6ce32202.html</url>
    <content><![CDATA[<h1 id="计算几何"><a href="#计算几何" class="headerlink" title="计算几何"></a>计算几何</h1><p><code>皮克定理</code>： 2S=2a+b-2 (S:三角形面积，a三角形内部点的个数，b三角形边上点的个数)，求三角形内点的个数</p>
<p><code>求线段上整数点的个数</code>：gcd(abs(x2-x1),abs(y2-y1))+1</p>
<p><code>判断一个点是否在多变形内部</code>：以这个点向多边形顶点做向量，相邻两两做叉积(左乘右)，若得出的所有结果符号都一样，则在内部</p>
<p><code>计算多边形面积</code>：从原点向多边形顶点做向量，相邻向量做叉积（右乘左）累加求和除以2</p>
<p><code>判断一个点是否在两条直线中间</code>：从两个直线上随便找两个点，从当前点向交点和直线上一点做向量，两向量做叉乘，另外一条直线也是如此，叉乘的两个结果如果符号不同就在中间，否则不在</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title>纪念我逝去的ACM</title>
    <url>/posts/c4e80fbc.html</url>
    <content><![CDATA[<blockquote>
<p>2021.12.04下午4点，第46届ACM/ICPC南京站圆满结束，同时这也寓意着我的ACM生涯到此也正式画上了句号。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/image-20220102200127985.png" alt="image-20220102200127985"></p>
<h2 id="生涯战绩"><a href="#生涯战绩" class="headerlink" title="生涯战绩"></a>生涯战绩</h2><ul>
<li>2020-河南省CCPC-银牌</li>
<li>2020-天梯赛-国三</li>
<li>2021-蓝桥杯-国二</li>
<li>2021-河南省ICPC-银牌</li>
<li>2021-天梯赛-国二</li>
<li>2021-河南省CCPC-银牌</li>
<li>2021-ICPC南京站-铜牌</li>
</ul>
<h2 id="相遇"><a href="#相遇" class="headerlink" title="相遇"></a>相遇</h2><p>&emsp;&emsp;我与ACM的接触纯属偶然，甚至对于计算机专业的选择我也并不自信，19年高考失利，伴随着不再复读的决心进入了我的分数可以达到的最好专业，刚入学时，因为对新事物的好奇，我奔走于各个社团之间，希望能丰富自己的大学生活。十月份学校举行百团大战活动，我在许多社团都填了报名表，但不幸的是，没有一个社团愿意收我<del>咱也不知道他们收人的标准是什么咱也不敢问</del>，当时我一直在参与微控科创协会的C语言培训，一周大概有3次，每次2个小时左右，当时我真的是一个纯小白，但经过了一段时间的C语言学习，我慢慢地爱上了这门语言，还记得当时在控制台打印出杨辉三角时，我内心不可言喻的欣喜。</p>
<p>&emsp;&emsp;某天晚上，班群里发来了算法协会的一个招新公告，我当时对于这个协会是一点概念都没有的，只是听说它是一个编程型的协会，而且使用C语言，反正我也没有协会可去就报了名，周六是招新日子，记得是上午10点在机房招新，当天早晨7点我还去参加了学校的乒乓球协会选拔赛\笑哭，由于有一定的C语言基础，对于学长们的提问，我也一一回答了上来，最后我还记得学长们问我的最后一个问题是“如果将来你组队，你给自己起的队名是什么？”现在想想，可能学长只是单纯不知道起啥队名，想从我这提取点灵感吧，hhh。</p>
<p>&emsp;&emsp;之后我也顺利成章地进入了协会，进入协会后我发现，这个协会的学长们个个都是大佬，一些在我看来非常困难的问题在他们眼里好像就是计算1+1等于几，不过虽然他们很强，但不得不吐槽的是，讲课讲地确实不咋滴，记得当时我连cin都还不会用的时候，就已经开始讲STL了…每次去机房敲代码都好像看天书，不过也正是因为有了这样“薄弱”的基础，为我后来“毫不费力”地进入协会埋下伏笔。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/1641130309864.jpg" alt="机房敲代码" style="zoom:25%;" /></p>
<h2 id="招新"><a href="#招新" class="headerlink" title="招新"></a>招新</h2><p>&emsp;&emsp;具体校赛日期我记不得了，甚至校赛和招新赛的先后顺序我也忘了，印象中应该是校赛在前，当时是17届学长们出题组织的比赛，早上9点到下午2点，当时看到这个比赛时间都晕了，这是什么牛马时间？<del>后来的我：才5个小时怎么够用呢？这个BUG再给我几分钟我就调出来了</del>，当时的题目还是半英半中，我直接看的头晕，还好签到是中文，我也只写了两道签到，然后就溜了，没错跑去吃饭了，后来看了榜单，好家伙，焦作一中榜一，当时的我都震惊了，被屠榜了！现在看来，太正常不过了，和这么多OI爷同台竞技，能把第二保住学长们就已经很厉害了orz，最后排到60多名开外的我还混了个三等奖\手动狗头。</p>
<p>&emsp;&emsp;招新赛其实是我真正意义上的第一场比赛，因为这场比赛才符合我当时的水平，当时大概有几十号人参加，蒟蒻的我还是用C语言去写的题目，甚至连一些缩进都没调，现在的我再去看当时提交的代码，真不敢相信世界上真的有写出这样代码的人，不过比较幸运的是，最后我还取得了第三名的好成绩，虽然排在我后面的那些人到后面都超过了我\卑微，比较遗憾的是，后来我才知道当时季军是有奖品的，一个耳机，而由于我的提前离场，奖品只好颁发给下一名了<img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/017AE03F.gif" alt="img" style="zoom:25%;" />，也是在这一场我第一次见到了乔佬的威力，也认识了老牛。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/1641130327003.jpg" alt="训练赛第一次AK" style="zoom:25%;" /></p>
<h2 id="寒假-疫情"><a href="#寒假-疫情" class="headerlink" title="寒假+疫情"></a>寒假+疫情</h2><p>&emsp;&emsp;之后进入协会后我们就被放养了，之后再训练就是在寒假时了，但是由于网络的不便，并没有什么强制手段，所以大部分人也都在摸鱼，including me，当时只有一周一次的训练赛，还记得当时是下午2点半开始，每次都搞得我紧张兮兮，当然监管手段不严，当时很多人都直接从网上搜到题解，改一下就直接交了。</p>
<p>&emsp;&emsp;2020的寒假我收获最大的并不是算法知识，而是剪辑。</p>
<p>&emsp;&emsp;当时的我刷到学校抖音上自制的一个爱情公寓片头，完完全全吸引到我了，当时的我也对新事物充满了好奇，便开始搜索各种剪辑教程，每天从早到晚都在琢磨怎么做出这样的特效，功夫不负有心人，我也确实最后做出来了，虽然是个低配版的，后来因为恢复系统，没有备份也丢失了，现在那些剪辑技巧我也全忘光了。</p>
<p>&emsp;&emsp;之后因为疫情，一整个学期我都在家里度过，天天盼望开学，到最后还是寒假暑假连着放，不过因为在家，我也有了更多属于自己的时间，这段时间里我接触到了贯穿我整个ACM生涯乃至未来职业生涯的Hexo博客。</p>
<p>&emsp;&emsp;因为记录算法的需要，我需要一个可以记录知识的博客，当时我还在用CSDN，但无奈颜控的我实在接受不了它的丑陋，把目光盯向了Hexo博客，剪辑的技巧我忘光了，但是Hexo博客却从始至终都在陪伴着我，第一次接触Hexo博客是打开龙佬的Sakura，当时就觉得这个网页好漂亮，好想拥有，后来才知道原来龙佬讲过一次课，就是关于怎么去搭建一个自己的Hexo博客，而我竟然没有看到这个消息！苦逼的我只能自己搜索各种教程，但当时的我实在是太小白了，当时的我还在使用360，可想而知，当时我的技术知识有多么薄弱，配置一个ssh秘钥死活弄不好，最后还是在闲鱼上下单了，30rmb，离谱的是，接单的那个人竟然也没给我弄好…他没有把仓库名后缀改成.github.io，导致页面死活访问不了，就这个小错误他鼓弄了一下午加一个晚上，后来实在弄不好，就不了了之了，不过他人确实挺好最后还说不收钱，不过我还是给他打了钱，这个问题最后还是请教龙佬才解决的，还记得当时搭建成功后那高兴劲啊，当时就发了一条说说。</p>
<p>&emsp;&emsp;后来就入了Hexo的坑，之后的整整一个月都在学习怎么美化博客，尝试了各种各样的主题，因为Sakura主题需要cdn，当时我不会，死活配置不好，就转向Matery，用了这个主题一段时间后还是喜欢Sakura，又开始推翻重来，就这样摸着石头慢慢过了河，还真配置好了，弄好以后就开始各种花里胡哨的美化，加一个板娘啊，加一个点击特效啊等等，后来全被我删了，美化的尽头就是默认，这句话真的深有体会，前前后后折腾了一个多月，期末考试就到了，之后就忙着复习，值得一提的是当时的我不知道慕课脚本，竟然还在手算高数题\大哭。</p>
<h2 id="第一次暑期集训"><a href="#第一次暑期集训" class="headerlink" title="第一次暑期集训"></a>第一次暑期集训</h2><p>&emsp;&emsp;之后就迎来了我ACM生涯中最重要的一段时期，2020暑期培训，从这个培训开始我才是真正意义上地开启了ACM生涯，还记得当时强哥说的一句话，“如果说暑期培训之前你们是一点一点提升的话，那么暑期培训就是一段一段提升的”，这句话现在的我深有体会，当时每天上午9点学长们准时开始讲课，讲完课后给我拉题让我们去做，每天都是10道左右，就是这样每天不间断地训练写题，我的编程能力和算法知识提升速度飞快，也是在这样的环境下，我认识了潘姥爷，还记得和潘姥爷讨论的第一题是一道CF的题目，每组样例时限1s，潘姥爷看成了这道题时限1s，时复感人。</p>
<p>&emsp;&emsp;当时每周六都会有一次积分赛，积分赛的平台是龙佬搭建的Domjudge，我是一个测试恐惧者，每次考试前我总会睡不着觉，紧张兮兮，积分赛也不例外，不过幸运的是，第一次积分赛题目比较友好，而我呢也比较幸运，竟然成为了第一个AK的人<del>虽然算上罚时我就掉到第3了</del>，当时吃的那顿午饭贼香。后面的积分赛难度就慢慢上去了，而且还邀请了河工业的人一起来打，我们也次次被屠榜，到后面已经被打麻了，不过最后我还是以总集训第二名的成绩留在了协会并且抱上了潘姥爷这个大腿。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/image-20220102215847102.png" alt="积分赛榜单" style="zoom: 50%;" /></p>
<h2 id="三只菜鸟齐力下厨"><a href="#三只菜鸟齐力下厨" class="headerlink" title="三只菜鸟齐力下厨"></a>三只菜鸟齐力下厨</h2><p>&emsp;&emsp;开学后的生活开始单调起来，没有课的时候就到机房训练，当时已经开始组队赛，我也是见识到了潘姥爷的厉害，当时的我也算比较强，可能也是和潘姥爷实力最接近的时候了吧。之后就是各种训练赛，各种自闭时刻…</p>
<p>&emsp;&emsp;10月份，我们正式组了队，同时也迎来了新成员，老牛，我更加自闭，这货思维这么敏捷吗？后面的训练赛我只管躺平，他俩去C就行了。</p>
<p>&emsp;&emsp;因为比赛需要队名，我们没有什么好的灵感，于是就让潘姥爷决定了，于是“三只菜鸟齐力下厨”便诞生了。</p>
<p>&emsp;&emsp;之后就是两场真正意义上的正式赛。</p>
<p>&emsp;&emsp;10月中旬，河南省CCPC省赛，银牌。（差几发罚时就金牌的我们无比自信，没想到出道即巅峰）</p>
<p>&emsp;&emsp;10月末，CCPC秦皇岛站，打铁。</p>
<p>&emsp;&emsp;11月，天梯赛，国三。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/1641130450908.jpg" alt="秦皇岛打铁" style="zoom: 20%;" /></p>
<h2 id="寒假"><a href="#寒假" class="headerlink" title="寒假"></a>寒假</h2><p>&emsp;&emsp;之后就迎来了大二寒假，经过了几个月的磨合，我们仨已经正式踏入了ACM的大门，并把ICPC区域赛的牌子定为我们的目标，我们在校外租了房子，打算训练一个寒假，而这个寒假也成为了我大学生涯里意义非凡的一页。</p>
<p>&emsp;&emsp;放假后并没有回家，<del>学校当然不允许，所以我们是黑户</del>，我们自己买了锅碗瓢盆，每天去菜市场买菜自己做饭吃，当时的环境不能说差，只能说将就着死不掉，一天我们受邀去了学长们租的房子，就好像是穷人家的孩子进了王思聪的大门一样，装修豪华，有暖气，有冰箱，有天然气，有几个大床，天呐，他们是来训练的吗？他们真的不是来享福的吗？我们酸了。环境是差了点，但确实不影响我们训练，有暖气就够了，我们仨每天就挤在一个房间里整天对着各种变态题目掉头发，那个时候是我CF上分最快的时候，毕竟三个臭皮匠顶个诸葛亮。寒假末期，我们的心逐渐野了，开始下馆子，晚上也会开黑到深夜，想一想，那个时候的生活确实够惬意的。</p>
<p>&emsp;&emsp;然而我们却不知道，痛苦的时光正逐渐逼近。因为疫情延期开学，同学们都在庆祝，而我们就悲催了，我们的房子到期了，我们无家可归了，幸运的是学校部分学生已经返校，寝室已经可以住人了，不幸的是我们没有返校证明，不能进入宿舍，无奈，我们只能睡在机房，几个椅子拼在一起，几件衣服往上一铺，就是一张床，然而那一晚我永远不会忘记，一夜我醒了6次，早上起来浑身酸痛。</p>
<p>&emsp;&emsp;这样下去不是办法，还是要想办法混进宿舍，经过观察，阿姨晚上11点后一般就回屋休息了，我们就趁宿舍阿姨晚上不在的时候偷偷溜进去，我们甚至不敢开灯，害怕被抓，早上天微亮就要起床，因为这个时候阿姨不在，也是因为这，我吃到了学校“新鲜出炉”的饭菜。</p>
<p>&emsp;&emsp;白天就在机房训练，晚上就偷鸡摸狗，这样的生活持续了2个多星期终于开学了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/sucai_2/1641130541089.jpg" alt="寒假租的房子" style="zoom: 10%;" /></p>
<h2 id="焦煤生产-打铁-大队"><a href="#焦煤生产-打铁-大队" class="headerlink" title="焦煤生产(打铁)大队"></a>焦煤生产(打铁)大队</h2><p>&emsp;&emsp;开学后不就我们就迎来了第一场ICPC区域赛，昆明站，赛前觉得我们的队名不吉利（上次省赛差点拿金），于是决定更换队名，想了想，要能体现地方特色，高端上档次，要不就叫“焦煤生产大队”吧，老牛说，我们点头，于是焦煤打铁大队横空出世。</p>
<p>&emsp;&emsp;周日，赛前我们热血沸腾，赛中我们备受打击，赛后我们直接抑郁，1个小时半才签了到（第一题不算），然后就没有了然后，我写的那道计算几何最后也没做出来，赛后我浑浑噩噩地回到宿舍，盯着我写的代码，突然发现起点可能在右边，改了一下，A了，我直接自闭，第一场ICPC区域赛就这样草草收场。</p>
<p>&emsp;&emsp;经过了一个月的训练，我们迎来了第二场区域赛银川站，这时我们信心满满，我们模拟了前几年的各种赛站，基本上都是可以拿到铜牌，这一站我们无比自信，而且异常兴奋，因为这是我们第一次公费旅游，出去参加ICPC区域赛，银川，大西北，因为郑州到银川的车票没有了，我们选择了从太原倒车，太原风景针不戳，那一下午是我公费旅游最开心的一下午，凌晨我们坐上了去往银川的火车，十个小时的卧铺是真的难受，下车后，我就见到了传说中的西北风光，着实壮丽，西北的空气都要清新许多，但西北也着实荒凉，路边全都是荒地，坐在车上向外望，还能看到山顶的白雪，景色着实优美。</p>
<p>&emsp;&emsp;到旅馆收拾好行李，我们便去品尝了银川特色羊肉泡馍，确实美味，简单睡了一觉后，我们便乘车去往ICPC现场，宁夏理工学院，四面环河，着实牛皮，这确实不用担心学生们溜出去了，进入现场，场面确实够壮观的，各种学校的牌子摆的是整整齐齐，一眼望去，全是名校，几百个队伍挤在这么一个体育场里，声音嘈杂，我们也是格外兴奋，我们的旁边是一支清华队伍，压力陡增。</p>
<p>&emsp;&emsp;第二天现场赛，我们踌躇满志，准备大展宏图，拿到题后，开始翻译，emm？这是这个意思吗？我作为队伍翻译官直接懵逼，这句话啥意思啊？再读一遍，草，这么简单，秒了，OK，下一题，嗯？这又是啥意思，再读一遍，草，傻逼题，秒了，下一题，靠！这又是啥意思啊！再读一遍，哦，原来是这个意思，傻逼题，WA了，嗯？怎么会，再读一遍，靠，傻逼吧，什么鬼题目啊，A了，然后，然后就没有然后了，死活读不懂第四题，我们两个小时A了3道题，排名170+，最后结束，我们207，发205块牌子，靠！最后才知道第四题也是一道傻逼题，就是一个字典树的小应用，就这样，我们在火车里抑郁了十几个小时，比赛前一天灵笼特别篇正好上映，我都忍住没有去看，最后竟然是这样的结局，不过白老板确实帅！</p>
<p>&emsp;&emsp;不过银川一行也不是没有收获，毕竟是亲眼见证了ACM/ICPC名场面。</p>
<p>&emsp;&emsp;之后就是蓝桥杯和河南省ICPC省赛了，哪一个比赛我们都没有顺过，蓝桥国二，省赛银牌，总是遇到各种问题。</p>
<p>&emsp;&emsp;但值得一提的是省赛又一次公费旅游，挺爽的，农大真真真TM漂亮！</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/73820b9e01f1453cba0dcd81c7874deb.jpg" alt="" title="农大校门"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/0ec1800dcc764628b3f4165a0d82d645.jpg" alt="" title="打卡网红餐厅"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/3fd614f61f0a406fb241657ce00f6e5d.jpg" alt="" title="打卡太原"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/7bdbd85a276a457b8baa6eb536ff0008.jpg" alt="" title="银川现场赛"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/8fcc0b7dc089403ea89fbedfd1a01d1a.jpg" alt="" title="比赛当前头上的云"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/0a95736f2eca4a1eb91bbdf68993713d.jpg" alt="夜晚的郑州" title="夜晚的郑州"></p>
<h2 id="第二次暑期集训"><a href="#第二次暑期集训" class="headerlink" title="第二次暑期集训"></a>第二次暑期集训</h2><p>&emsp;&emsp;之后就放假了，于是我又迎来了2021年的暑期培训，七月初我们放假，在家待了将近两个星期，便又回到了学校机房。</p>
<p>&emsp;&emsp;这次集训与上次集训的最大不同就在于，我们从被组织者变成了组织者，因为ACM的知识我们已经基本覆盖完全，所以这个假期我们没有再去学习新算法，每天就是不停地打比赛，打比赛，记得当时一周有不下4次的比赛，有时甚至能达到每日一场，但高频率的比赛必定会伴随着补题不充分的问题，所以后来我们渐渐地也放掉了一些比赛。</p>
<p>&emsp;&emsp;值得一提的是，集训末期，我还自己摸索着搭建出了Domjudge博客，给学弟们出了最后一场集训赛。</p>
<p>&emsp;&emsp;集训里我见证了被淹没的理工大。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/0e9692d54db948a2b8571d62076d445f.jpg" alt="" title="等待CF开始"></p>
<h2 id="比赛末期"><a href="#比赛末期" class="headerlink" title="比赛末期"></a>比赛末期</h2><p>&emsp;&emsp;2021年的ICPC日程公布了，令我们感到十分抓狂的是，CCPC和ICPC完全重合，而且没有一场线下赛，得知这个消息，我们的大脑嗡嗡的，要知道，<code>线上铜牌，线下银牌啊</code>，没办法，只能接受现实，经过缜密思考，我们决定，参加济南站、南京站以及威海站。</p>
<p>&emsp;&emsp;济南赛前，我们摩拳擦掌，准备大展拳脚，看到题后，疯狂思考，于是1个小时过去了，我们样例还没推出来，心态裂开，最后还是潘姥爷猜了个结论，我们俩去验证，发现是对的，于是写了一个超级简单的dfs，就过了…后来去开高斯消元，因为没有做过这种取模题目，完全没有往这方面去想，一直在想怎么去防止丢精度以及爆ll，到最后也没有调出来。</p>
<p>&emsp;&emsp;打完以后，我们心态崩盘，看着这个一题手快有牌的场子，我们心里不知道骂了出题人多少遍。</p>
<p>&emsp;&emsp;威海，大佬云集，不说了，4题手慢无牌。</p>
<p>&emsp;&emsp;威海比赛过后，听说学弟沈阳拿牌了，心里咯噔一下，那种说不出的难受，训练了这么长时间，到最后竟然是输在了选赛站上，沈阳伤我两次（2020沈阳也比较简单）</p>
<p>&emsp;&emsp;南京之前，我们已经抱着无牌退役的心情去了，心想反正最后一场了，放手一搏吧。</p>
<p>&emsp;&emsp;感谢南京出题组，原来还有良心出题组会去照顾弱校，对比之前济南的数论场，银川的翻译场，南京的题目质量和比赛体验直接拉满，最后拿下106（真就差一名），遗憾铜首（退役了也不忘让我再遗憾一次）。</p>
<h2 id="最后的晚餐"><a href="#最后的晚餐" class="headerlink" title="最后的晚餐"></a>最后的晚餐</h2><p>&emsp;&emsp;2021.12.04晚，算协余孽共聚一桌，享用了退役前最后的晚餐，这次酒席，我一杯酒也没挡。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncleacc/website_materials_img/5d5dd9eaf9da41ddb6b69fe3eedb41fd.jpg" alt="" title="最后的晚餐"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;回过头来看看我的ACM生涯，可谓曲曲折折，遗憾满满，省赛没有拿过金牌，区域赛只出去过一次，只拿到了一个铜牌，还是铜首，蓝桥也没有拿到国一，银川也只差3名，好像每次比赛总会出现一些问题，总是差一点点。但是既然已经结束了，回忆总是美好的，从2019年11月接触ACM，到2021年12月退役，整整两年，虽然期间经常摸鱼，但这两年我收获颇丰，第一次参加竞赛，第一次接触白酒，第一次喝吐，第一次合租房子，第一次没有自己的假期，第一次熬夜CF，第一次深夜KTV，第一次翻墙回学校，第一次结交如此多的能人异士，可以说，圆满了。</p>
<p>&emsp;&emsp;祝愿潘姥爷能早日找到自己的初恋，老牛能顺利通过大厂面试获得心仪offer，也祝愿我们都能拥有美好的人生。</p>
<p>&emsp;&emsp;最后感谢王老师，给了我们进入ACM大门的机会并且给我们提供了601这样一方净土。</p>
<p>&emsp;&emsp;感谢所有助攻人员，respect。</p>
<p>​    </p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>纪念我的ACM史</tag>
      </tags>
  </entry>
  <entry>
    <title>线段树区间修改</title>
    <url>/posts/54d18d14.html</url>
    <content><![CDATA[<p>朴素版的线段树只能实现单点修改区间查询，修改和查询的时间复杂度都是O(logn)</p>
<h2 id="懒标记问题"><a href="#懒标记问题" class="headerlink" title="懒标记问题"></a>懒标记问题</h2><p>加上懒标记后的线段树就可以实现区间修改了，比如我要把[a,b]的值加上k，肯定不会傻到n次单点修改，是个人都会想到假如递归到一个包含在[a,b]的区间时就不用继续往下递归了，直接告诉这个区间的管理员，把这个区间的和直接给修改了，但是假如你上面第一次增加时增加区间为[c,d]，并且区间[c,d]是包含在[a,b]中间的，现在又要在[e,d]增加k，e&gt;c的，这个时候你就会发现[e,d]这个区间增加了两次，因为第一次增加时你根本没有递归到[e,d]，而是递归到这个区间的上一层就直接返回了，现在你再在[e,d]区间增加值就会出错，因为少加了第一次的增值，所以应该找一个东西记录下来第一次增值，并且把他带到下面去，这时懒标记就出来了，新开一个数组lazy[i]，表示编号为i的区间的累计增值，那么第一次修改[c,d]时，lazy<a href="u表示区间[c,d]的编号">u\</a>就会记录下来增值，lazy[u]+=c，第二次修改经过这个已经修改过的区间时，就要顺带着把这个区间的修改值一起带过去，正所谓父亲欠下的债儿子去偿还，当修改[e,d]时，经过[c,d]区间时，就会把lazy值给带到下面的儿子区间里面</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pushdown</span><span class="params">(u)</span>&#123;</span><br><span class="line">	tr[u&lt;&lt;<span class="number">1</span>].val+=lazy[u];  <span class="comment">//儿子区间加上父亲区间的增值</span></span><br><span class="line">	tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].val+=lazy[u];</span><br><span class="line">	lazy[u&lt;&lt;<span class="number">1</span>]=lazy[u];  <span class="comment">//儿子区间也要加上标记，当以后再经过儿子区间时也要顺带增值去修改</span></span><br><span class="line">	lazy[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].val+=lazy[u];</span><br><span class="line">    lazy[u]=<span class="number">0</span>;  <span class="comment">//既然父亲的债给儿子了，父亲也就没有债了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是区间查询的灵魂了，朴素版和plus只差了几行代码而已，首先修改时判断区间条件变了，只要当前区间处于修改区间内就可以直接修改，修改时把区间值增加区间长度*增值，并把加法标记lazy累加即可</p>
<h2 id="线段树1"><a href="#线段树1" class="headerlink" title="线段树1"></a>线段树1</h2><p>一道模板题<a href="https://www.luogu.com.cn/problem/P3372">线段树1</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll SUP=<span class="number">0x800000</span>;</span><br><span class="line"><span class="type">const</span> ll MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-4</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	ll l,r,val;</span><br><span class="line">&#125;tr[MAXN&lt;&lt;<span class="number">2</span>];</span><br><span class="line">ll lazy[MAXN&lt;&lt;<span class="number">2</span>],arr[MAXN];</span><br><span class="line"><span class="type">void</span> <span class="title function_">pushup</span><span class="params">(ll u)</span>&#123;</span><br><span class="line">	tr[u].val=tr[u&lt;&lt;<span class="number">1</span>].val+tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">pushdown</span><span class="params">(ll u)</span>&#123;  <span class="comment">//区间修改灵魂代码</span></span><br><span class="line">	<span class="keyword">if</span>(lazy[u])&#123;</span><br><span class="line">		tr[u&lt;&lt;<span class="number">1</span>].val+=(tr[u&lt;&lt;<span class="number">1</span>].r-tr[u&lt;&lt;<span class="number">1</span>].l+<span class="number">1</span>)*lazy[u];</span><br><span class="line">		lazy[u&lt;&lt;<span class="number">1</span>]+=lazy[u];</span><br><span class="line">		tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].val+=(tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].r-tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].l+<span class="number">1</span>)*lazy[u];</span><br><span class="line">		lazy[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+=lazy[u];</span><br><span class="line">		lazy[u]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">build</span><span class="params">(ll u,ll l,ll r)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r) tr[u]=&#123;l,r,arr[l]&#125;;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		tr[u]=&#123;l,r&#125;;</span><br><span class="line">		ll mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		build(u&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">		build(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">		pushup(u); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(ll u,ll l,ll r,ll c)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(tr[u].l&gt;=l &amp;&amp; tr[u].r&lt;=r)&#123;</span><br><span class="line">		tr[u].val+=(tr[u].r-tr[u].l+<span class="number">1</span>)*c;  <span class="comment">//值加上区间长度*增值</span></span><br><span class="line">		lazy[u]+=c; <span class="comment">//标记累加</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		pushdown(u);  <span class="comment">//往下传时要顺带着把增值带过去</span></span><br><span class="line">		ll mid=(tr[u].l+tr[u].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(r&lt;=mid) add(u&lt;&lt;<span class="number">1</span>,l,r,c);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(l&gt;mid) add(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,c);</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			add(u&lt;&lt;<span class="number">1</span>,l,r,c);</span><br><span class="line">			add(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,c);</span><br><span class="line">		&#125;</span><br><span class="line">		pushup(u);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">ll <span class="title function_">query</span><span class="params">(ll u,ll l,ll r)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(tr[u].l&gt;=l &amp;&amp; tr[u].r&lt;=r) <span class="keyword">return</span> tr[u].val;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		pushdown(u);  <span class="comment">//记得查询函数也要往下传，只要往区间下面递归的都要pushdown!</span></span><br><span class="line">		ll mid=(tr[u].r+tr[u].l)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(r&lt;=mid) <span class="keyword">return</span> query(u&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(l&gt;mid) <span class="keyword">return</span> query(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			ll ret1=query(u&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">			ll ret2=query(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">			<span class="keyword">return</span> ret1+ret2;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	ll n,m;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;arr[i];</span><br><span class="line">	build(<span class="number">1</span>,<span class="number">1</span>,n); </span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		ll op;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;op;</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">			ll x,y,k;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;k;</span><br><span class="line">			add(<span class="number">1</span>,x,y,k);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			ll x,y;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;query(<span class="number">1</span>,x,y)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="线段树2"><a href="#线段树2" class="headerlink" title="线段树2"></a>线段树2</h2><p>接下来看一道比较难的升级版本<a href="https://www.luogu.com.cn/problem/P3373">线段树2</a></p>
<p><strong><img src="https://cdn.jsdelivr.net/gh/uncleacc/Sucai/20210119174515.png" alt="image-20210119174455193" style="zoom:50%;" /></strong></p>
<p>这道题只是增加了一个操作，不只可以给一段区间增加值，也可以乘上一个值，假如两种运算分开考的话那么这道题就是一道模板题，但难就难在他一起考了，你一定会想到这就会涉及到优先级问题，因为假如给一段区间增加了一个值，又给这段区间乘上一个值，之后递归时经过这个区间时，你就弄不清楚应该先加还是先乘，而这两种结果显然是不同的，假设儿子区间的值为a，父亲区间已经有了加法标记b和乘法标记c，那么两种不同的运算顺序会得到不同结果</p>
<p>$(a+b)<em>c!=a</em>c+b$</p>
<p>那么有没有办法规定一种固定的运算顺序，使得无论是先给父亲区间加上加法标记还是乘法标记最终得到相同的结果呢？</p>
<p>答案是有的，观察上面不等式两边的式子发现只要在右面的b后面乘上一个c两个式子就相等了，因此我们就可以规定一种运算，永远先乘再加，当添加标记的顺序就是先乘再加时肯定没问题，但是若先添加的加法标记然后添加的乘法标记时怎么办？这时候计算儿子的值时就是<code>儿子的值*乘值+儿子区间长度*增值</code>，假如先加后乘那么儿子的值应该是<code>(儿子的值+儿子区间长度*增值)*乘值</code>，发现了吗？实际和理想只差了一个乘法标记，所以当先添加加法标记再添加乘法标记时，把已经添加的加法标记乘上乘值即可使得两种不同的顺序得到相同的结果，儿子的加法标记更新时就要先乘以父亲乘法标记再加上父亲加法标记，你可能会问为什么有这种情况，向下传递时父亲标记不是被传递给儿子了吗？但传递后还可以再给啊！传递后我再让父亲区间加上或者乘上一个值，这也是合法的，所以当再次经过父亲区间时儿子区间的加法标记还没有乘上父亲的增值，就需要补充上去，而乘法标记只需要乘以父亲乘法标记即可</p>
<h2 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void pushdown(ll u)&#123;</span><br><span class="line">	ll l=u&lt;&lt;1,r=u&lt;&lt;1|1;</span><br><span class="line">	// 儿子的值=儿子的值*父亲的乘法标记+儿子区间*父亲加法标记 </span><br><span class="line">	tr[l].val=(tr[l].val*lazy2[u]%p+(tr[l].r-tr[l].l+1)*lazy1[u]%p)%p;</span><br><span class="line">	tr[r].val=(tr[r].val*lazy2[u]%p+(tr[r].r-tr[r].l+1)*lazy1[u]%p)%p;</span><br><span class="line">	// 儿子加法标记更新，儿子加法标记=儿子加法标记*父亲乘法标记+父亲加法标记 </span><br><span class="line">	lazy1[l]=(lazy1[l]*lazy2[u]%p+lazy1[u])%p;</span><br><span class="line">	lazy1[r]=(lazy1[r]*lazy2[u]%p+lazy1[u])%p;</span><br><span class="line">	//  儿子乘法标记=儿子乘法标记*父亲乘法标记</span><br><span class="line">	lazy2[l]=lazy2[l]*lazy2[u]%p;</span><br><span class="line">	lazy2[r]=lazy2[r]*lazy2[u]%p;</span><br><span class="line">	</span><br><span class="line">	lazy1[u]=0;</span><br><span class="line">	lazy2[u]=1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么不先加后乘呢？因为这样就涉及到了除法运算，就出现了精度问题，会出错。</p>
<h2 id="ACCODE"><a href="#ACCODE" class="headerlink" title="ACCODE"></a>ACCODE</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll SUP=<span class="number">0x800000</span>;</span><br><span class="line"><span class="type">const</span> ll MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-4</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	ll l,r,val;</span><br><span class="line">&#125;tr[MAXN&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="comment">//lazy1加法标记 lazy2乘法标记 </span></span><br><span class="line">ll lazy1[MAXN&lt;&lt;<span class="number">2</span>],lazy2[MAXN&lt;&lt;<span class="number">2</span>],arr[MAXN];</span><br><span class="line">ll n,m,p;</span><br><span class="line"><span class="type">void</span> <span class="title function_">pushup</span><span class="params">(ll u)</span>&#123;</span><br><span class="line">	tr[u].val=(tr[u&lt;&lt;<span class="number">1</span>].val+tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].val)%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">pushdown</span><span class="params">(ll u)</span>&#123;</span><br><span class="line">	ll l=u&lt;&lt;<span class="number">1</span>,r=u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>;</span><br><span class="line">	<span class="comment">// 儿子的值=儿子的值*父亲的乘法标记+儿子区间*父亲加法标记 </span></span><br><span class="line">	tr[l].val=(tr[l].val*lazy2[u]%p+(tr[l].r-tr[l].l+<span class="number">1</span>)*lazy1[u]%p)%p;</span><br><span class="line">	tr[r].val=(tr[r].val*lazy2[u]%p+(tr[r].r-tr[r].l+<span class="number">1</span>)*lazy1[u]%p)%p;</span><br><span class="line">	<span class="comment">// 儿子加法标记更新，儿子加法标记=儿子加法标记*父亲乘法标记+父亲加法标记 </span></span><br><span class="line">	lazy1[l]=(lazy1[l]*lazy2[u]%p+lazy1[u])%p;</span><br><span class="line">	lazy1[r]=(lazy1[r]*lazy2[u]%p+lazy1[u])%p;</span><br><span class="line">	<span class="comment">//  儿子乘法标记=儿子乘法标记*父亲乘法标记</span></span><br><span class="line">	lazy2[l]=lazy2[l]*lazy2[u]%p;</span><br><span class="line">	lazy2[r]=lazy2[r]*lazy2[u]%p;</span><br><span class="line">	</span><br><span class="line">	lazy1[u]=<span class="number">0</span>;</span><br><span class="line">	lazy2[u]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">build</span><span class="params">(ll u,ll l,ll r)</span>&#123;</span><br><span class="line">	lazy1[u]=<span class="number">0</span>;  <span class="comment">//初始化标记 </span></span><br><span class="line">	lazy2[u]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(l==r) tr[u]=&#123;l,r,arr[l]&#125;;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		tr[u]=&#123;l,r&#125;;</span><br><span class="line">		ll mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		build(u&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">		build(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">		pushup(u); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(ll u,ll l,ll r,ll c)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(tr[u].l&gt;=l &amp;&amp; tr[u].r&lt;=r)&#123;</span><br><span class="line">		tr[u].val=(tr[u].val+(tr[u].r-tr[u].l+<span class="number">1</span>)*c%p)%p;  <span class="comment">//区间值加上c </span></span><br><span class="line">		lazy1[u]=(c+lazy1[u])%p;  <span class="comment">//更新加法标记 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		pushdown(u);</span><br><span class="line">		ll mid=(tr[u].l+tr[u].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(l&lt;=mid) add(u&lt;&lt;<span class="number">1</span>,l,r,c);</span><br><span class="line">		<span class="keyword">if</span>(r&gt;mid) add(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,c);</span><br><span class="line">		pushup(u);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">mul</span><span class="params">(ll u,ll l,ll r,ll c)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(tr[u].l&gt;=l &amp;&amp; tr[u].r&lt;=r)&#123;</span><br><span class="line">		tr[u].val=tr[u].val*c%p;  <span class="comment">//区间的值乘上c </span></span><br><span class="line">		lazy1[u]=(lazy1[u]*c)%p;  <span class="comment">//每次更新乘法标记时要顺带着把加法标记也更新了，目的是确定优先级 </span></span><br><span class="line">		lazy2[u]=(lazy2[u]*c)%p;  <span class="comment">//更新乘法标记 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		pushdown(u);</span><br><span class="line">		ll mid=(tr[u].l+tr[u].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(l&lt;=mid) mul(u&lt;&lt;<span class="number">1</span>,l,r,c);</span><br><span class="line">		<span class="keyword">if</span>(r&gt;mid) mul(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,c);</span><br><span class="line">		pushup(u);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">ll <span class="title function_">query</span><span class="params">(ll u,ll l,ll r)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(tr[u].l&gt;=l &amp;&amp; tr[u].r&lt;=r) <span class="keyword">return</span> tr[u].val;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		pushdown(u);</span><br><span class="line">		ll mid=(tr[u].r+tr[u].l)&gt;&gt;<span class="number">1</span>,ret=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(l&lt;=mid) ret=(ret+query(u&lt;&lt;<span class="number">1</span>,l,r))%p;</span><br><span class="line">		<span class="keyword">if</span>(r&gt;mid) ret=(ret+query(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r))%p;</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ios;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;p;</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;arr[i];</span><br><span class="line">	build(<span class="number">1</span>,<span class="number">1</span>,n); </span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		ll op,x,y,k;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;op;</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;k;</span><br><span class="line">			mul(<span class="number">1</span>,x,y,k);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>)&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;k;</span><br><span class="line">			add(<span class="number">1</span>,x,y,k);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;query(<span class="number">1</span>,x,y)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
</search>
